=begin
#NSX API

#VMware NSX REST API

OpenAPI spec version: 1.0.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.3.1

=end

require "uri"

module NSXT
  class TroubleshootingAndMonitoringApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end

    # Create a mirror session
    # Create a mirror session
    # @param port_mirroring_session 
    # @param [Hash] opts the optional parameters
    # @return [PortMirroringSession]
    def create_port_mirroring_sessions(port_mirroring_session, opts = {})
      data, _status_code, _headers = create_port_mirroring_sessions_with_http_info(port_mirroring_session, opts)
      return data
    end

    # Create a mirror session
    # Create a mirror session
    # @param port_mirroring_session 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortMirroringSession, Fixnum, Hash)>] PortMirroringSession data, response status code and response headers
    def create_port_mirroring_sessions_with_http_info(port_mirroring_session, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.create_port_mirroring_sessions ..."
      end
      # verify the required parameter 'port_mirroring_session' is set
      if @api_client.config.client_side_validation && port_mirroring_session.nil?
        fail ArgumentError, "Missing the required parameter 'port_mirroring_session' when calling TroubleshootingAndMonitoringApi.create_port_mirroring_sessions"
      end
      # resource path
      local_var_path = "/mirror-sessions"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_mirroring_session)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortMirroringSession')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#create_port_mirroring_sessions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Initiate a Traceflow Operation on the Specified Port
    # Initiate a Traceflow Operation on the Specified Port
    # @param traceflow_request 
    # @param [Hash] opts the optional parameters
    # @return [Traceflow]
    def create_traceflow(traceflow_request, opts = {})
      data, _status_code, _headers = create_traceflow_with_http_info(traceflow_request, opts)
      return data
    end

    # Initiate a Traceflow Operation on the Specified Port
    # Initiate a Traceflow Operation on the Specified Port
    # @param traceflow_request 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Traceflow, Fixnum, Hash)>] Traceflow data, response status code and response headers
    def create_traceflow_with_http_info(traceflow_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.create_traceflow ..."
      end
      # verify the required parameter 'traceflow_request' is set
      if @api_client.config.client_side_validation && traceflow_request.nil?
        fail ArgumentError, "Missing the required parameter 'traceflow_request' when calling TroubleshootingAndMonitoringApi.create_traceflow"
      end
      # resource path
      local_var_path = "/traceflows"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(traceflow_request)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Traceflow')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#create_traceflow\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete the mirror session
    # Delete the mirror session
    # @param mirror_session_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_port_mirroring_session(mirror_session_id, opts = {})
      delete_port_mirroring_session_with_http_info(mirror_session_id, opts)
      return nil
    end

    # Delete the mirror session
    # Delete the mirror session
    # @param mirror_session_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_port_mirroring_session_with_http_info(mirror_session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.delete_port_mirroring_session ..."
      end
      # verify the required parameter 'mirror_session_id' is set
      if @api_client.config.client_side_validation && mirror_session_id.nil?
        fail ArgumentError, "Missing the required parameter 'mirror_session_id' when calling TroubleshootingAndMonitoringApi.delete_port_mirroring_session"
      end
      # resource path
      local_var_path = "/mirror-sessions/{mirror-session-id}".sub('{' + 'mirror-session-id' + '}', mirror_session_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#delete_port_mirroring_session\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete the Traceflow round
    # Delete the Traceflow round
    # @param traceflow_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_traceflow(traceflow_id, opts = {})
      delete_traceflow_with_http_info(traceflow_id, opts)
      return nil
    end

    # Delete the Traceflow round
    # Delete the Traceflow round
    # @param traceflow_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_traceflow_with_http_info(traceflow_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.delete_traceflow ..."
      end
      # verify the required parameter 'traceflow_id' is set
      if @api_client.config.client_side_validation && traceflow_id.nil?
        fail ArgumentError, "Missing the required parameter 'traceflow_id' when calling TroubleshootingAndMonitoringApi.delete_traceflow"
      end
      # resource path
      local_var_path = "/traceflows/{traceflow-id}".sub('{' + 'traceflow-id' + '}', traceflow_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#delete_traceflow\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get high-level summary of all transport nodes. The service layer does not support source = realtime or cached.
    # Get high-level summary of all transport nodes. The service layer does not support source = realtime or cached.
    # @param [Hash] opts the optional parameters
    # @return [HeatMapTransportZoneStatus]
    def get_all_transport_nodes_status(opts = {})
      data, _status_code, _headers = get_all_transport_nodes_status_with_http_info(opts)
      return data
    end

    # Get high-level summary of all transport nodes. The service layer does not support source &#x3D; realtime or cached.
    # Get high-level summary of all transport nodes. The service layer does not support source &#x3D; realtime or cached.
    # @param [Hash] opts the optional parameters
    # @return [Array<(HeatMapTransportZoneStatus, Fixnum, Hash)>] HeatMapTransportZoneStatus data, response status code and response headers
    def get_all_transport_nodes_status_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.get_all_transport_nodes_status ..."
      end
      # resource path
      local_var_path = "/transport-nodes/status"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'HeatMapTransportZoneStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#get_all_transport_nodes_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get high-level summary of a transport zone. The service layer does not support source = realtime or cached.
    # Get high-level summary of a transport zone. The service layer does not support source = realtime or cached.
    # @param [Hash] opts the optional parameters
    # @return [HeatMapTransportNodesAggregateStatus]
    def get_all_transport_zone_status(opts = {})
      data, _status_code, _headers = get_all_transport_zone_status_with_http_info(opts)
      return data
    end

    # Get high-level summary of a transport zone. The service layer does not support source &#x3D; realtime or cached.
    # Get high-level summary of a transport zone. The service layer does not support source &#x3D; realtime or cached.
    # @param [Hash] opts the optional parameters
    # @return [Array<(HeatMapTransportNodesAggregateStatus, Fixnum, Hash)>] HeatMapTransportNodesAggregateStatus data, response status code and response headers
    def get_all_transport_zone_status_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.get_all_transport_zone_status ..."
      end
      # resource path
      local_var_path = "/transport-zones/status"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'HeatMapTransportNodesAggregateStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#get_all_transport_zone_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get networking entities between two logical ports with VIF attachment
    # Get networking entities between two logical ports with VIF attachment
    # @param lport_id ID of source port
    # @param peer_port_id ID of peer port
    # @param [Hash] opts the optional parameters
    # @return [PortConnectionEntities]
    def get_forwarding_path(lport_id, peer_port_id, opts = {})
      data, _status_code, _headers = get_forwarding_path_with_http_info(lport_id, peer_port_id, opts)
      return data
    end

    # Get networking entities between two logical ports with VIF attachment
    # Get networking entities between two logical ports with VIF attachment
    # @param lport_id ID of source port
    # @param peer_port_id ID of peer port
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortConnectionEntities, Fixnum, Hash)>] PortConnectionEntities data, response status code and response headers
    def get_forwarding_path_with_http_info(lport_id, peer_port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.get_forwarding_path ..."
      end
      # verify the required parameter 'lport_id' is set
      if @api_client.config.client_side_validation && lport_id.nil?
        fail ArgumentError, "Missing the required parameter 'lport_id' when calling TroubleshootingAndMonitoringApi.get_forwarding_path"
      end
      # verify the required parameter 'peer_port_id' is set
      if @api_client.config.client_side_validation && peer_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'peer_port_id' when calling TroubleshootingAndMonitoringApi.get_forwarding_path"
      end
      # resource path
      local_var_path = "/logical-ports/{lport-id}/forwarding-path".sub('{' + 'lport-id' + '}', lport_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'peer_port_id'] = peer_port_id

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortConnectionEntities')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#get_forwarding_path\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get high-level summary of a transport zone
    # Get high-level summary of a transport zone
    # @param zone_id ID of transport zone
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [HeatMapTransportZoneStatus]
    def get_heatmap_transport_zone_status(zone_id, opts = {})
      data, _status_code, _headers = get_heatmap_transport_zone_status_with_http_info(zone_id, opts)
      return data
    end

    # Get high-level summary of a transport zone
    # Get high-level summary of a transport zone
    # @param zone_id ID of transport zone
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(HeatMapTransportZoneStatus, Fixnum, Hash)>] HeatMapTransportZoneStatus data, response status code and response headers
    def get_heatmap_transport_zone_status_with_http_info(zone_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.get_heatmap_transport_zone_status ..."
      end
      # verify the required parameter 'zone_id' is set
      if @api_client.config.client_side_validation && zone_id.nil?
        fail ArgumentError, "Missing the required parameter 'zone_id' when calling TroubleshootingAndMonitoringApi.get_heatmap_transport_zone_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/transport-zones/{zone-id}/status".sub('{' + 'zone-id' + '}', zone_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'HeatMapTransportZoneStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#get_heatmap_transport_zone_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the list of IPFIX observation points
    # Get the list of IPFIX observation points
    # @param [Hash] opts the optional parameters
    # @return [IpfixObsPointsListResult]
    def get_ipfix_obs_points(opts = {})
      data, _status_code, _headers = get_ipfix_obs_points_with_http_info(opts)
      return data
    end

    # Get the list of IPFIX observation points
    # Get the list of IPFIX observation points
    # @param [Hash] opts the optional parameters
    # @return [Array<(IpfixObsPointsListResult, Fixnum, Hash)>] IpfixObsPointsListResult data, response status code and response headers
    def get_ipfix_obs_points_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.get_ipfix_obs_points ..."
      end
      # resource path
      local_var_path = "/ipfix-obs-points"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'IpfixObsPointsListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#get_ipfix_obs_points\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get high-level summary of a transport node
    # Get high-level summary of a transport node
    # @param node_id ID of transport node
    # @param [Hash] opts the optional parameters
    # @return [PnicBondStatusListResult]
    def get_pnic_statuses_for_transport_node(node_id, opts = {})
      data, _status_code, _headers = get_pnic_statuses_for_transport_node_with_http_info(node_id, opts)
      return data
    end

    # Get high-level summary of a transport node
    # Get high-level summary of a transport node
    # @param node_id ID of transport node
    # @param [Hash] opts the optional parameters
    # @return [Array<(PnicBondStatusListResult, Fixnum, Hash)>] PnicBondStatusListResult data, response status code and response headers
    def get_pnic_statuses_for_transport_node_with_http_info(node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.get_pnic_statuses_for_transport_node ..."
      end
      # verify the required parameter 'node_id' is set
      if @api_client.config.client_side_validation && node_id.nil?
        fail ArgumentError, "Missing the required parameter 'node_id' when calling TroubleshootingAndMonitoringApi.get_pnic_statuses_for_transport_node"
      end
      # resource path
      local_var_path = "/transport-nodes/{node-id}/pnic-bond-status".sub('{' + 'node-id' + '}', node_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PnicBondStatusListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#get_pnic_statuses_for_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the mirror session
    # Get the mirror session
    # @param mirror_session_id 
    # @param [Hash] opts the optional parameters
    # @return [PortMirroringSession]
    def get_port_mirroring_session(mirror_session_id, opts = {})
      data, _status_code, _headers = get_port_mirroring_session_with_http_info(mirror_session_id, opts)
      return data
    end

    # Get the mirror session
    # Get the mirror session
    # @param mirror_session_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortMirroringSession, Fixnum, Hash)>] PortMirroringSession data, response status code and response headers
    def get_port_mirroring_session_with_http_info(mirror_session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.get_port_mirroring_session ..."
      end
      # verify the required parameter 'mirror_session_id' is set
      if @api_client.config.client_side_validation && mirror_session_id.nil?
        fail ArgumentError, "Missing the required parameter 'mirror_session_id' when calling TroubleshootingAndMonitoringApi.get_port_mirroring_session"
      end
      # resource path
      local_var_path = "/mirror-sessions/{mirror-session-id}".sub('{' + 'mirror-session-id' + '}', mirror_session_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortMirroringSession')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#get_port_mirroring_session\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Read global switch IPFIX export configuration
    # Read global switch IPFIX export configuration
    # @param [Hash] opts the optional parameters
    # @return [IpfixObsPointConfig]
    def get_switch_ipfix_config(opts = {})
      data, _status_code, _headers = get_switch_ipfix_config_with_http_info(opts)
      return data
    end

    # Read global switch IPFIX export configuration
    # Read global switch IPFIX export configuration
    # @param [Hash] opts the optional parameters
    # @return [Array<(IpfixObsPointConfig, Fixnum, Hash)>] IpfixObsPointConfig data, response status code and response headers
    def get_switch_ipfix_config_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.get_switch_ipfix_config ..."
      end
      # resource path
      local_var_path = "/ipfix-obs-points/switch-global"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'IpfixObsPointConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#get_switch_ipfix_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the Traceflow round status and result summary
    # Get the Traceflow round status and result summary
    # @param traceflow_id 
    # @param [Hash] opts the optional parameters
    # @return [Traceflow]
    def get_traceflow(traceflow_id, opts = {})
      data, _status_code, _headers = get_traceflow_with_http_info(traceflow_id, opts)
      return data
    end

    # Get the Traceflow round status and result summary
    # Get the Traceflow round status and result summary
    # @param traceflow_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Traceflow, Fixnum, Hash)>] Traceflow data, response status code and response headers
    def get_traceflow_with_http_info(traceflow_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.get_traceflow ..."
      end
      # verify the required parameter 'traceflow_id' is set
      if @api_client.config.client_side_validation && traceflow_id.nil?
        fail ArgumentError, "Missing the required parameter 'traceflow_id' when calling TroubleshootingAndMonitoringApi.get_traceflow"
      end
      # resource path
      local_var_path = "/traceflows/{traceflow-id}".sub('{' + 'traceflow-id' + '}', traceflow_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Traceflow')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#get_traceflow\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get observations for the Traceflow round
    # Get observations for the Traceflow round
    # @param traceflow_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_name Observations having the given component name will be listed.
    # @option opts [String] :component_type Observations having the given component type will be listed.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included to result of query
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :resource_type The type of observations that will be listed.
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :transport_node_name Observations having the given transport node name will be listed.
    # @return [TraceflowObservationListResult]
    def get_traceflow_observations(traceflow_id, opts = {})
      data, _status_code, _headers = get_traceflow_observations_with_http_info(traceflow_id, opts)
      return data
    end

    # Get observations for the Traceflow round
    # Get observations for the Traceflow round
    # @param traceflow_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_name Observations having the given component name will be listed.
    # @option opts [String] :component_type Observations having the given component type will be listed.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included to result of query
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :resource_type The type of observations that will be listed.
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :transport_node_name Observations having the given transport node name will be listed.
    # @return [Array<(TraceflowObservationListResult, Fixnum, Hash)>] TraceflowObservationListResult data, response status code and response headers
    def get_traceflow_observations_with_http_info(traceflow_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.get_traceflow_observations ..."
      end
      # verify the required parameter 'traceflow_id' is set
      if @api_client.config.client_side_validation && traceflow_id.nil?
        fail ArgumentError, "Missing the required parameter 'traceflow_id' when calling TroubleshootingAndMonitoringApi.get_traceflow_observations"
      end
      if @api_client.config.client_side_validation && opts[:'component_type'] && !['PHYSICAL', 'LR', 'LS', 'DFW', 'BRIDGE', 'EDGE_TUNNEL', 'EDGE_HOSTSWITCH', 'UNKNOWN'].include?(opts[:'component_type'])
        fail ArgumentError, 'invalid value for "component_type", must be one of PHYSICAL, LR, LS, DFW, BRIDGE, EDGE_TUNNEL, EDGE_HOSTSWITCH, UNKNOWN'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling TroubleshootingAndMonitoringApi.get_traceflow_observations, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling TroubleshootingAndMonitoringApi.get_traceflow_observations, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'resource_type'] && !['TraceflowObservationForwarded', 'TraceflowObservationDropped', 'TraceflowObservationDelivered', 'TraceflowObservationReceived', 'TraceflowObservationForwardedLogical', 'TraceflowObservationDroppedLogical', 'TraceflowObservationReceivedLogical'].include?(opts[:'resource_type'])
        fail ArgumentError, 'invalid value for "resource_type", must be one of TraceflowObservationForwarded, TraceflowObservationDropped, TraceflowObservationDelivered, TraceflowObservationReceived, TraceflowObservationForwardedLogical, TraceflowObservationDroppedLogical, TraceflowObservationReceivedLogical'
      end
      # resource path
      local_var_path = "/traceflows/{traceflow-id}/observations".sub('{' + 'traceflow-id' + '}', traceflow_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'component_name'] = opts[:'component_name'] if !opts[:'component_name'].nil?
      query_params[:'component_type'] = opts[:'component_type'] if !opts[:'component_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'resource_type'] = opts[:'resource_type'] if !opts[:'resource_type'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'transport_node_name'] = opts[:'transport_node_name'] if !opts[:'transport_node_name'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TraceflowObservationListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#get_traceflow_observations\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Creates a status report of transport nodes of all the transport zones
    # Creates a status report of transport nodes of all the transport zones
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @option opts [String] :status Transport node
    # @return [nil]
    def get_transport_node_report(opts = {})
      get_transport_node_report_with_http_info(opts)
      return nil
    end

    # Creates a status report of transport nodes of all the transport zones
    # Creates a status report of transport nodes of all the transport zones
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @option opts [String] :status Transport node
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def get_transport_node_report_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.get_transport_node_report ..."
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'status'] && !['UP', 'DOWN', 'DEGRADED'].include?(opts[:'status'])
        fail ArgumentError, 'invalid value for "status", must be one of UP, DOWN, DEGRADED'
      end
      # resource path
      local_var_path = "/transport-zones/transport-node-status-report"

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'status'] = opts[:'status'] if !opts[:'status'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/octet-stream'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#get_transport_node_report\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Creates a status report of transport nodes in a transport zone
    # Creates a status report of transport nodes in a transport zone
    # @param zone_id ID of transport zone
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @option opts [String] :status Transport node
    # @return [nil]
    def get_transport_node_report_for_a_transport_zone(zone_id, opts = {})
      get_transport_node_report_for_a_transport_zone_with_http_info(zone_id, opts)
      return nil
    end

    # Creates a status report of transport nodes in a transport zone
    # Creates a status report of transport nodes in a transport zone
    # @param zone_id ID of transport zone
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @option opts [String] :status Transport node
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def get_transport_node_report_for_a_transport_zone_with_http_info(zone_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.get_transport_node_report_for_a_transport_zone ..."
      end
      # verify the required parameter 'zone_id' is set
      if @api_client.config.client_side_validation && zone_id.nil?
        fail ArgumentError, "Missing the required parameter 'zone_id' when calling TroubleshootingAndMonitoringApi.get_transport_node_report_for_a_transport_zone"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'status'] && !['UP', 'DOWN', 'DEGRADED'].include?(opts[:'status'])
        fail ArgumentError, 'invalid value for "status", must be one of UP, DOWN, DEGRADED'
      end
      # resource path
      local_var_path = "/transport-zones/{zone-id}/transport-node-status-report".sub('{' + 'zone-id' + '}', zone_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'status'] = opts[:'status'] if !opts[:'status'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/octet-stream'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#get_transport_node_report_for_a_transport_zone\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Read status of a transport node
    # Read status of a transport node
    # @param node_id ID of transport node
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [TransportNodeStatus]
    def get_transport_node_status(node_id, opts = {})
      data, _status_code, _headers = get_transport_node_status_with_http_info(node_id, opts)
      return data
    end

    # Read status of a transport node
    # Read status of a transport node
    # @param node_id ID of transport node
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(TransportNodeStatus, Fixnum, Hash)>] TransportNodeStatus data, response status code and response headers
    def get_transport_node_status_with_http_info(node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.get_transport_node_status ..."
      end
      # verify the required parameter 'node_id' is set
      if @api_client.config.client_side_validation && node_id.nil?
        fail ArgumentError, "Missing the required parameter 'node_id' when calling TroubleshootingAndMonitoringApi.get_transport_node_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/transport-nodes/{node-id}/status".sub('{' + 'node-id' + '}', node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNodeStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#get_transport_node_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List available node logs
    # Returns the number of log files and lists the log files that reside on the NSX virtual appliance. The list includes the filename, file size, and last-modified time in milliseconds since epoch (1 January 1970) for each log file. Knowing the last-modified time with millisecond accuracy since epoch is helpful when you are comparing two times, such as the time of a POST request and the end time on a server. 
    # @param [Hash] opts the optional parameters
    # @return [NodeLogPropertiesListResult]
    def list_node_logs(opts = {})
      data, _status_code, _headers = list_node_logs_with_http_info(opts)
      return data
    end

    # List available node logs
    # Returns the number of log files and lists the log files that reside on the NSX virtual appliance. The list includes the filename, file size, and last-modified time in milliseconds since epoch (1 January 1970) for each log file. Knowing the last-modified time with millisecond accuracy since epoch is helpful when you are comparing two times, such as the time of a POST request and the end time on a server. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(NodeLogPropertiesListResult, Fixnum, Hash)>] NodeLogPropertiesListResult data, response status code and response headers
    def list_node_logs_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.list_node_logs ..."
      end
      # resource path
      local_var_path = "/node/logs"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'NodeLogPropertiesListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#list_node_logs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List all mirror sessions
    # List all mirror sessions
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included to result of query
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortMirroringSessionListResult]
    def list_port_mirroring_session(opts = {})
      data, _status_code, _headers = list_port_mirroring_session_with_http_info(opts)
      return data
    end

    # List all mirror sessions
    # List all mirror sessions
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included to result of query
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortMirroringSessionListResult, Fixnum, Hash)>] PortMirroringSessionListResult data, response status code and response headers
    def list_port_mirroring_session_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.list_port_mirroring_session ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling TroubleshootingAndMonitoringApi.list_port_mirroring_session, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling TroubleshootingAndMonitoringApi.list_port_mirroring_session, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/mirror-sessions"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortMirroringSessionListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#list_port_mirroring_session\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Read status of all transport nodes with tunnel connections to transport node 
    # Read status of all transport nodes with tunnel connections to transport node 
    # @param node_id ID of transport node
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bfd_diagnostic_code BFD diagnostic code of Tunnel as defined in RFC 5880
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included to result of query
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :tunnel_status Tunnel Status
    # @return [TransportNodeStatusListResult]
    def list_remote_transport_node_status(node_id, opts = {})
      data, _status_code, _headers = list_remote_transport_node_status_with_http_info(node_id, opts)
      return data
    end

    # Read status of all transport nodes with tunnel connections to transport node 
    # Read status of all transport nodes with tunnel connections to transport node 
    # @param node_id ID of transport node
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bfd_diagnostic_code BFD diagnostic code of Tunnel as defined in RFC 5880
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included to result of query
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :tunnel_status Tunnel Status
    # @return [Array<(TransportNodeStatusListResult, Fixnum, Hash)>] TransportNodeStatusListResult data, response status code and response headers
    def list_remote_transport_node_status_with_http_info(node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.list_remote_transport_node_status ..."
      end
      # verify the required parameter 'node_id' is set
      if @api_client.config.client_side_validation && node_id.nil?
        fail ArgumentError, "Missing the required parameter 'node_id' when calling TroubleshootingAndMonitoringApi.list_remote_transport_node_status"
      end
      if @api_client.config.client_side_validation && opts[:'bfd_diagnostic_code'] && !['0', 'NO_DIAGNOSTIC', '1', 'CONTROL_DETECTION_TIME_EXPIRED', '2', 'ECHO_FUNCTION_FAILED', '3', 'NEIGHBOR_SIGNALED_SESSION_DOWN', '4', 'FORWARDING_PLANE_RESET', '5', 'PATH_DOWN', '6', 'CONCATENATED_PATH_DOWN', '7', 'ADMINISTRATIVELY_DOWN', '8', 'REVERSE_CONCATENATED_PATH_DOWN'].include?(opts[:'bfd_diagnostic_code'])
        fail ArgumentError, 'invalid value for "bfd_diagnostic_code", must be one of 0, NO_DIAGNOSTIC, 1, CONTROL_DETECTION_TIME_EXPIRED, 2, ECHO_FUNCTION_FAILED, 3, NEIGHBOR_SIGNALED_SESSION_DOWN, 4, FORWARDING_PLANE_RESET, 5, PATH_DOWN, 6, CONCATENATED_PATH_DOWN, 7, ADMINISTRATIVELY_DOWN, 8, REVERSE_CONCATENATED_PATH_DOWN'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling TroubleshootingAndMonitoringApi.list_remote_transport_node_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling TroubleshootingAndMonitoringApi.list_remote_transport_node_status, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'tunnel_status'] && !['UP', 'DOWN'].include?(opts[:'tunnel_status'])
        fail ArgumentError, 'invalid value for "tunnel_status", must be one of UP, DOWN'
      end
      # resource path
      local_var_path = "/transport-nodes/{node-id}/remote-transport-node-status".sub('{' + 'node-id' + '}', node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bfd_diagnostic_code'] = opts[:'bfd_diagnostic_code'] if !opts[:'bfd_diagnostic_code'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'tunnel_status'] = opts[:'tunnel_status'] if !opts[:'tunnel_status'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNodeStatusListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#list_remote_transport_node_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List all Traceflow rounds
    # List all Traceflow rounds; if a logical port id is given as a query parameter, only those originated from the logical port are returned. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included to result of query
    # @option opts [String] :lport_id id of the source logical port where the trace flows originated
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [TraceflowListResult]
    def list_traceflows(opts = {})
      data, _status_code, _headers = list_traceflows_with_http_info(opts)
      return data
    end

    # List all Traceflow rounds
    # List all Traceflow rounds; if a logical port id is given as a query parameter, only those originated from the logical port are returned. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included to result of query
    # @option opts [String] :lport_id id of the source logical port where the trace flows originated
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(TraceflowListResult, Fixnum, Hash)>] TraceflowListResult data, response status code and response headers
    def list_traceflows_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.list_traceflows ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling TroubleshootingAndMonitoringApi.list_traceflows, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling TroubleshootingAndMonitoringApi.list_traceflows, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/traceflows"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'lport_id'] = opts[:'lport_id'] if !opts[:'lport_id'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TraceflowListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#list_traceflows\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Read status of all the transport nodes
    # Read status of all the transport nodes
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included to result of query
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :status Transport node
    # @return [TransportNodeStatusListResult]
    def list_transport_node_status(opts = {})
      data, _status_code, _headers = list_transport_node_status_with_http_info(opts)
      return data
    end

    # Read status of all the transport nodes
    # Read status of all the transport nodes
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included to result of query
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :status Transport node
    # @return [Array<(TransportNodeStatusListResult, Fixnum, Hash)>] TransportNodeStatusListResult data, response status code and response headers
    def list_transport_node_status_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.list_transport_node_status ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling TroubleshootingAndMonitoringApi.list_transport_node_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling TroubleshootingAndMonitoringApi.list_transport_node_status, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'status'] && !['UP', 'DOWN', 'DEGRADED', 'UNKNOWN'].include?(opts[:'status'])
        fail ArgumentError, 'invalid value for "status", must be one of UP, DOWN, DEGRADED, UNKNOWN'
      end
      # resource path
      local_var_path = "/transport-zones/transport-node-status"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'status'] = opts[:'status'] if !opts[:'status'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNodeStatusListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#list_transport_node_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Read status of transport nodes in a transport zone
    # Read status of transport nodes in a transport zone
    # @param zone_id ID of transport zone
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included to result of query
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :status Transport node
    # @return [TransportNodeStatusListResult]
    def list_transport_node_status_for_transport_zone(zone_id, opts = {})
      data, _status_code, _headers = list_transport_node_status_for_transport_zone_with_http_info(zone_id, opts)
      return data
    end

    # Read status of transport nodes in a transport zone
    # Read status of transport nodes in a transport zone
    # @param zone_id ID of transport zone
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included to result of query
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :status Transport node
    # @return [Array<(TransportNodeStatusListResult, Fixnum, Hash)>] TransportNodeStatusListResult data, response status code and response headers
    def list_transport_node_status_for_transport_zone_with_http_info(zone_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.list_transport_node_status_for_transport_zone ..."
      end
      # verify the required parameter 'zone_id' is set
      if @api_client.config.client_side_validation && zone_id.nil?
        fail ArgumentError, "Missing the required parameter 'zone_id' when calling TroubleshootingAndMonitoringApi.list_transport_node_status_for_transport_zone"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling TroubleshootingAndMonitoringApi.list_transport_node_status_for_transport_zone, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling TroubleshootingAndMonitoringApi.list_transport_node_status_for_transport_zone, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'status'] && !['UP', 'DOWN', 'DEGRADED', 'UNKNOWN'].include?(opts[:'status'])
        fail ArgumentError, 'invalid value for "status", must be one of UP, DOWN, DEGRADED, UNKNOWN'
      end
      # resource path
      local_var_path = "/transport-zones/{zone-id}/transport-node-status".sub('{' + 'zone-id' + '}', zone_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'status'] = opts[:'status'] if !opts[:'status'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNodeStatusListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#list_transport_node_status_for_transport_zone\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Read node log properties
    # For a single specified log file, lists the filename, file size, and last-modified time. 
    # @param log_name Name of log file to read properties
    # @param [Hash] opts the optional parameters
    # @return [NodeLogProperties]
    def read_node_log(log_name, opts = {})
      data, _status_code, _headers = read_node_log_with_http_info(log_name, opts)
      return data
    end

    # Read node log properties
    # For a single specified log file, lists the filename, file size, and last-modified time. 
    # @param log_name Name of log file to read properties
    # @param [Hash] opts the optional parameters
    # @return [Array<(NodeLogProperties, Fixnum, Hash)>] NodeLogProperties data, response status code and response headers
    def read_node_log_with_http_info(log_name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.read_node_log ..."
      end
      # verify the required parameter 'log_name' is set
      if @api_client.config.client_side_validation && log_name.nil?
        fail ArgumentError, "Missing the required parameter 'log_name' when calling TroubleshootingAndMonitoringApi.read_node_log"
      end
      # resource path
      local_var_path = "/node/logs/{log-name}".sub('{' + 'log-name' + '}', log_name.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/octet-stream'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'NodeLogProperties')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#read_node_log\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Read node log contents
    # For a single specified log file, returns the content of the log file. This method supports byte-range requests. To request just a portion of a log file, supply an HTTP Range header, e.g. \"Range: bytes=<start>-<end>\". <end> is optional, and, if omitted, the file contents from start to the end of the file are returned.' 
    # @param log_name Name of log to read
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def read_node_log_data(log_name, opts = {})
      read_node_log_data_with_http_info(log_name, opts)
      return nil
    end

    # Read node log contents
    # For a single specified log file, returns the content of the log file. This method supports byte-range requests. To request just a portion of a log file, supply an HTTP Range header, e.g. \&quot;Range: bytes&#x3D;&lt;start&gt;-&lt;end&gt;\&quot;. &lt;end&gt; is optional, and, if omitted, the file contents from start to the end of the file are returned.&#39; 
    # @param log_name Name of log to read
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def read_node_log_data_with_http_info(log_name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.read_node_log_data ..."
      end
      # verify the required parameter 'log_name' is set
      if @api_client.config.client_side_validation && log_name.nil?
        fail ArgumentError, "Missing the required parameter 'log_name' when calling TroubleshootingAndMonitoringApi.read_node_log_data"
      end
      # resource path
      local_var_path = "/node/logs/{log-name}/data".sub('{' + 'log-name' + '}', log_name.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/octet-stream'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#read_node_log_data\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update the mirror session
    # Update the mirror session
    # @param mirror_session_id 
    # @param port_mirroring_session 
    # @param [Hash] opts the optional parameters
    # @return [PortMirroringSession]
    def update_port_mirroring_session(mirror_session_id, port_mirroring_session, opts = {})
      data, _status_code, _headers = update_port_mirroring_session_with_http_info(mirror_session_id, port_mirroring_session, opts)
      return data
    end

    # Update the mirror session
    # Update the mirror session
    # @param mirror_session_id 
    # @param port_mirroring_session 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortMirroringSession, Fixnum, Hash)>] PortMirroringSession data, response status code and response headers
    def update_port_mirroring_session_with_http_info(mirror_session_id, port_mirroring_session, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.update_port_mirroring_session ..."
      end
      # verify the required parameter 'mirror_session_id' is set
      if @api_client.config.client_side_validation && mirror_session_id.nil?
        fail ArgumentError, "Missing the required parameter 'mirror_session_id' when calling TroubleshootingAndMonitoringApi.update_port_mirroring_session"
      end
      # verify the required parameter 'port_mirroring_session' is set
      if @api_client.config.client_side_validation && port_mirroring_session.nil?
        fail ArgumentError, "Missing the required parameter 'port_mirroring_session' when calling TroubleshootingAndMonitoringApi.update_port_mirroring_session"
      end
      # resource path
      local_var_path = "/mirror-sessions/{mirror-session-id}".sub('{' + 'mirror-session-id' + '}', mirror_session_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_mirroring_session)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortMirroringSession')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#update_port_mirroring_session\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update global switch IPFIX export configuration
    # Update global switch IPFIX export configuration
    # @param ipfix_obs_point_config 
    # @param [Hash] opts the optional parameters
    # @return [IpfixObsPointConfig]
    def update_switch_ipfix_config(ipfix_obs_point_config, opts = {})
      data, _status_code, _headers = update_switch_ipfix_config_with_http_info(ipfix_obs_point_config, opts)
      return data
    end

    # Update global switch IPFIX export configuration
    # Update global switch IPFIX export configuration
    # @param ipfix_obs_point_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(IpfixObsPointConfig, Fixnum, Hash)>] IpfixObsPointConfig data, response status code and response headers
    def update_switch_ipfix_config_with_http_info(ipfix_obs_point_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.update_switch_ipfix_config ..."
      end
      # verify the required parameter 'ipfix_obs_point_config' is set
      if @api_client.config.client_side_validation && ipfix_obs_point_config.nil?
        fail ArgumentError, "Missing the required parameter 'ipfix_obs_point_config' when calling TroubleshootingAndMonitoringApi.update_switch_ipfix_config"
      end
      # resource path
      local_var_path = "/ipfix-obs-points/switch-global"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(ipfix_obs_point_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'IpfixObsPointConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#update_switch_ipfix_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Verify whether the mirror session is still valid
    # Verify whether all participants are on the same transport node
    # @param mirror_session_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def verify_port_mirroring_session_verify(mirror_session_id, opts = {})
      verify_port_mirroring_session_verify_with_http_info(mirror_session_id, opts)
      return nil
    end

    # Verify whether the mirror session is still valid
    # Verify whether all participants are on the same transport node
    # @param mirror_session_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def verify_port_mirroring_session_verify_with_http_info(mirror_session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: TroubleshootingAndMonitoringApi.verify_port_mirroring_session_verify ..."
      end
      # verify the required parameter 'mirror_session_id' is set
      if @api_client.config.client_side_validation && mirror_session_id.nil?
        fail ArgumentError, "Missing the required parameter 'mirror_session_id' when calling TroubleshootingAndMonitoringApi.verify_port_mirroring_session_verify"
      end
      # resource path
      local_var_path = "/mirror-sessions/{mirror-session-id}?action=verify".sub('{' + 'mirror-session-id' + '}', mirror_session_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TroubleshootingAndMonitoringApi#verify_port_mirroring_session_verify\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
