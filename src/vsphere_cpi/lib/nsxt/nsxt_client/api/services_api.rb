=begin
#NSX-T Manager API

#VMware NSX-T Manager REST API

OpenAPI spec version: 2.3.0.0.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.3.1

=end

require "uri"

module NSXT
  class ServicesApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end

    # Add an InstanceEndpoint for a Service Instance
    # Adds a new instance endpoint. It belongs to one service instance and is attached to one service attachment. It represents a redirection target for a Rule. 
    # @param service_id 
    # @param service_instance_id 
    # @param instance_endpoint 
    # @param [Hash] opts the optional parameters
    # @return [InstanceEndpoint]
    def add_instance_endpoint(service_id, service_instance_id, instance_endpoint, opts = {})
      data, _status_code, _headers = add_instance_endpoint_with_http_info(service_id, service_instance_id, instance_endpoint, opts)
      return data
    end

    # Add an InstanceEndpoint for a Service Instance
    # Adds a new instance endpoint. It belongs to one service instance and is attached to one service attachment. It represents a redirection target for a Rule. 
    # @param service_id 
    # @param service_instance_id 
    # @param instance_endpoint 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InstanceEndpoint, Fixnum, Hash)>] InstanceEndpoint data, response status code and response headers
    def add_instance_endpoint_with_http_info(service_id, service_instance_id, instance_endpoint, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.add_instance_endpoint ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.add_instance_endpoint"
      end
      # verify the required parameter 'service_instance_id' is set
      if @api_client.config.client_side_validation && service_instance_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_instance_id' when calling ServicesApi.add_instance_endpoint"
      end
      # verify the required parameter 'instance_endpoint' is set
      if @api_client.config.client_side_validation && instance_endpoint.nil?
        fail ArgumentError, "Missing the required parameter 'instance_endpoint' when calling ServicesApi.add_instance_endpoint"
      end
      # resource path
      local_var_path = "/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/instance-endpoints".sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'service-instance-id' + '}', service_instance_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(instance_endpoint)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'InstanceEndpoint')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#add_instance_endpoint\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add a new object in the exclude list
    # Add a new object in the exclude list
    # @param resource_reference 
    # @param [Hash] opts the optional parameters
    # @return [ResourceReference]
    def add_member_add_member(resource_reference, opts = {})
      data, _status_code, _headers = add_member_add_member_with_http_info(resource_reference, opts)
      return data
    end

    # Add a new object in the exclude list
    # Add a new object in the exclude list
    # @param resource_reference 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ResourceReference, Fixnum, Hash)>] ResourceReference data, response status code and response headers
    def add_member_add_member_with_http_info(resource_reference, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.add_member_add_member ..."
      end
      # verify the required parameter 'resource_reference' is set
      if @api_client.config.client_side_validation && resource_reference.nil?
        fail ArgumentError, "Missing the required parameter 'resource_reference' when calling ServicesApi.add_member_add_member"
      end
      # resource path
      local_var_path = "/firewall/excludelist?action=add_member"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(resource_reference)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ResourceReference')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#add_member_add_member\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add a Single Rule in a Section
    # Adds a new firewall rule in existing firewall section. Adding firewall rule to a section modifies parent section entity and simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale content to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update. 
    # @param section_id 
    # @param firewall_rule 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation (default to insert_top)
    # @return [FirewallRule]
    def add_rule_in_section(section_id, firewall_rule, opts = {})
      data, _status_code, _headers = add_rule_in_section_with_http_info(section_id, firewall_rule, opts)
      return data
    end

    # Add a Single Rule in a Section
    # Adds a new firewall rule in existing firewall section. Adding firewall rule to a section modifies parent section entity and simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale content to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update. 
    # @param section_id 
    # @param firewall_rule 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation
    # @return [Array<(FirewallRule, Fixnum, Hash)>] FirewallRule data, response status code and response headers
    def add_rule_in_section_with_http_info(section_id, firewall_rule, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.add_rule_in_section ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.add_rule_in_section"
      end
      # verify the required parameter 'firewall_rule' is set
      if @api_client.config.client_side_validation && firewall_rule.nil?
        fail ArgumentError, "Missing the required parameter 'firewall_rule' when calling ServicesApi.add_rule_in_section"
      end
      if @api_client.config.client_side_validation && !opts[:'id'].nil? && opts[:'id'].to_s.length > 64
        fail ArgumentError, 'invalid value for "opts[:"id"]" when calling ServicesApi.add_rule_in_section, the character length must be smaller than or equal to 64.'
      end

      if @api_client.config.client_side_validation && opts[:'operation'] && !['insert_top', 'insert_bottom', 'insert_after', 'insert_before'].include?(opts[:'operation'])
        fail ArgumentError, 'invalid value for "operation", must be one of insert_top, insert_bottom, insert_after, insert_before'
      end
      # resource path
      local_var_path = "/firewall/sections/{section-id}/rules".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'id'] = opts[:'id'] if !opts[:'id'].nil?
      query_params[:'operation'] = opts[:'operation'] if !opts[:'operation'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(firewall_rule)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallRule')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#add_rule_in_section\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add Multiple Rules in a Section
    # Create multiple firewall rules in existing firewall section bounded by limit of 1000 firewall rules per section. Adding multiple firewall rules in a section modifies parent section entity and simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update. 
    # @param section_id 
    # @param firewall_rule_list 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation (default to insert_top)
    # @return [FirewallRuleList]
    def add_rules_in_section_create_multiple(section_id, firewall_rule_list, opts = {})
      data, _status_code, _headers = add_rules_in_section_create_multiple_with_http_info(section_id, firewall_rule_list, opts)
      return data
    end

    # Add Multiple Rules in a Section
    # Create multiple firewall rules in existing firewall section bounded by limit of 1000 firewall rules per section. Adding multiple firewall rules in a section modifies parent section entity and simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update. 
    # @param section_id 
    # @param firewall_rule_list 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation
    # @return [Array<(FirewallRuleList, Fixnum, Hash)>] FirewallRuleList data, response status code and response headers
    def add_rules_in_section_create_multiple_with_http_info(section_id, firewall_rule_list, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.add_rules_in_section_create_multiple ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.add_rules_in_section_create_multiple"
      end
      # verify the required parameter 'firewall_rule_list' is set
      if @api_client.config.client_side_validation && firewall_rule_list.nil?
        fail ArgumentError, "Missing the required parameter 'firewall_rule_list' when calling ServicesApi.add_rules_in_section_create_multiple"
      end
      if @api_client.config.client_side_validation && !opts[:'id'].nil? && opts[:'id'].to_s.length > 64
        fail ArgumentError, 'invalid value for "opts[:"id"]" when calling ServicesApi.add_rules_in_section_create_multiple, the character length must be smaller than or equal to 64.'
      end

      if @api_client.config.client_side_validation && opts[:'operation'] && !['insert_top', 'insert_bottom', 'insert_after', 'insert_before'].include?(opts[:'operation'])
        fail ArgumentError, 'invalid value for "operation", must be one of insert_top, insert_bottom, insert_after, insert_before'
      end
      # resource path
      local_var_path = "/firewall/sections/{section-id}/rules?action=create_multiple".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'id'] = opts[:'id'] if !opts[:'id'].nil?
      query_params[:'operation'] = opts[:'operation'] if !opts[:'operation'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(firewall_rule_list)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallRuleList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#add_rules_in_section_create_multiple\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a New Empty Section
    # Creates new empty firewall section in the system. 
    # @param firewall_section 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation (default to insert_top)
    # @return [FirewallSection]
    def add_section(firewall_section, opts = {})
      data, _status_code, _headers = add_section_with_http_info(firewall_section, opts)
      return data
    end

    # Create a New Empty Section
    # Creates new empty firewall section in the system. 
    # @param firewall_section 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation
    # @return [Array<(FirewallSection, Fixnum, Hash)>] FirewallSection data, response status code and response headers
    def add_section_with_http_info(firewall_section, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.add_section ..."
      end
      # verify the required parameter 'firewall_section' is set
      if @api_client.config.client_side_validation && firewall_section.nil?
        fail ArgumentError, "Missing the required parameter 'firewall_section' when calling ServicesApi.add_section"
      end
      if @api_client.config.client_side_validation && !opts[:'id'].nil? && opts[:'id'].to_s.length > 64
        fail ArgumentError, 'invalid value for "opts[:"id"]" when calling ServicesApi.add_section, the character length must be smaller than or equal to 64.'
      end

      if @api_client.config.client_side_validation && opts[:'operation'] && !['insert_top', 'insert_bottom', 'insert_after', 'insert_before'].include?(opts[:'operation'])
        fail ArgumentError, 'invalid value for "operation", must be one of insert_top, insert_bottom, insert_after, insert_before'
      end
      # resource path
      local_var_path = "/firewall/sections"

      # query parameters
      query_params = {}
      query_params[:'id'] = opts[:'id'] if !opts[:'id'].nil?
      query_params[:'operation'] = opts[:'operation'] if !opts[:'operation'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(firewall_section)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallSection')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#add_section\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a Section with Rules
    # Creates a new firewall section with rules. The limit on the number of rules is defined by maxItems in collection types for FirewallRule (FirewallRuleXXXList types). When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules with a large number of rule references is not supported.  Instead, to create sections, use: POST /api/v1/firewall/sections  To create rules, use: POST /api/v1/firewall/sections/&lt;section-id&gt;/rules 
    # @param firewall_section_rule_list 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation (default to insert_top)
    # @return [FirewallSectionRuleList]
    def add_section_with_rules_create_with_rules(firewall_section_rule_list, opts = {})
      data, _status_code, _headers = add_section_with_rules_create_with_rules_with_http_info(firewall_section_rule_list, opts)
      return data
    end

    # Create a Section with Rules
    # Creates a new firewall section with rules. The limit on the number of rules is defined by maxItems in collection types for FirewallRule (FirewallRuleXXXList types). When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules with a large number of rule references is not supported.  Instead, to create sections, use: POST /api/v1/firewall/sections  To create rules, use: POST /api/v1/firewall/sections/&amp;lt;section-id&amp;gt;/rules 
    # @param firewall_section_rule_list 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation
    # @return [Array<(FirewallSectionRuleList, Fixnum, Hash)>] FirewallSectionRuleList data, response status code and response headers
    def add_section_with_rules_create_with_rules_with_http_info(firewall_section_rule_list, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.add_section_with_rules_create_with_rules ..."
      end
      # verify the required parameter 'firewall_section_rule_list' is set
      if @api_client.config.client_side_validation && firewall_section_rule_list.nil?
        fail ArgumentError, "Missing the required parameter 'firewall_section_rule_list' when calling ServicesApi.add_section_with_rules_create_with_rules"
      end
      if @api_client.config.client_side_validation && !opts[:'id'].nil? && opts[:'id'].to_s.length > 64
        fail ArgumentError, 'invalid value for "opts[:"id"]" when calling ServicesApi.add_section_with_rules_create_with_rules, the character length must be smaller than or equal to 64.'
      end

      if @api_client.config.client_side_validation && opts[:'operation'] && !['insert_top', 'insert_bottom', 'insert_after', 'insert_before'].include?(opts[:'operation'])
        fail ArgumentError, 'invalid value for "operation", must be one of insert_top, insert_bottom, insert_after, insert_before'
      end
      # resource path
      local_var_path = "/firewall/sections?action=create_with_rules"

      # query parameters
      query_params = {}
      query_params[:'id'] = opts[:'id'] if !opts[:'id'].nil?
      query_params[:'operation'] = opts[:'operation'] if !opts[:'operation'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(firewall_section_rule_list)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallSectionRuleList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#add_section_with_rules_create_with_rules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add a Service Attachment.
    # Adds a new Service attachment. A service attachment represents a point on NSX entity (Example: Logical Router) to which service instance can be connected through an InstanceEndpoint. 
    # @param service_attachment 
    # @param [Hash] opts the optional parameters
    # @return [ServiceAttachment]
    def add_service_attachment(service_attachment, opts = {})
      data, _status_code, _headers = add_service_attachment_with_http_info(service_attachment, opts)
      return data
    end

    # Add a Service Attachment.
    # Adds a new Service attachment. A service attachment represents a point on NSX entity (Example: Logical Router) to which service instance can be connected through an InstanceEndpoint. 
    # @param service_attachment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ServiceAttachment, Fixnum, Hash)>] ServiceAttachment data, response status code and response headers
    def add_service_attachment_with_http_info(service_attachment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.add_service_attachment ..."
      end
      # verify the required parameter 'service_attachment' is set
      if @api_client.config.client_side_validation && service_attachment.nil?
        fail ArgumentError, "Missing the required parameter 'service_attachment' when calling ServicesApi.add_service_attachment"
      end
      # resource path
      local_var_path = "/serviceinsertion/service-attachments"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(service_attachment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceAttachment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#add_service_attachment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add a Single Rule in a Section
    # Adds a new serviceinsertion rule in existing serviceinsertion section. 
    # @param section_id 
    # @param service_insertion_rule 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation (default to insert_top)
    # @return [ServiceInsertionRule]
    def add_service_insertion_rule_in_section(section_id, service_insertion_rule, opts = {})
      data, _status_code, _headers = add_service_insertion_rule_in_section_with_http_info(section_id, service_insertion_rule, opts)
      return data
    end

    # Add a Single Rule in a Section
    # Adds a new serviceinsertion rule in existing serviceinsertion section. 
    # @param section_id 
    # @param service_insertion_rule 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation
    # @return [Array<(ServiceInsertionRule, Fixnum, Hash)>] ServiceInsertionRule data, response status code and response headers
    def add_service_insertion_rule_in_section_with_http_info(section_id, service_insertion_rule, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.add_service_insertion_rule_in_section ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.add_service_insertion_rule_in_section"
      end
      # verify the required parameter 'service_insertion_rule' is set
      if @api_client.config.client_side_validation && service_insertion_rule.nil?
        fail ArgumentError, "Missing the required parameter 'service_insertion_rule' when calling ServicesApi.add_service_insertion_rule_in_section"
      end
      if @api_client.config.client_side_validation && !opts[:'id'].nil? && opts[:'id'].to_s.length > 64
        fail ArgumentError, 'invalid value for "opts[:"id"]" when calling ServicesApi.add_service_insertion_rule_in_section, the character length must be smaller than or equal to 64.'
      end

      if @api_client.config.client_side_validation && opts[:'operation'] && !['insert_top', 'insert_bottom', 'insert_after', 'insert_before'].include?(opts[:'operation'])
        fail ArgumentError, 'invalid value for "operation", must be one of insert_top, insert_bottom, insert_after, insert_before'
      end
      # resource path
      local_var_path = "/serviceinsertion/sections/{section-id}/rules".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'id'] = opts[:'id'] if !opts[:'id'].nil?
      query_params[:'operation'] = opts[:'operation'] if !opts[:'operation'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(service_insertion_rule)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceInsertionRule')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#add_service_insertion_rule_in_section\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add Multiple Rules in a Section
    # Create multiple serviceinsertion rules in existing serviceinsertion section bounded by limit of 1000 serviceinsertion rules per section. 
    # @param section_id 
    # @param service_insertion_rule_list 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation (default to insert_top)
    # @return [ServiceInsertionRuleList]
    def add_service_insertion_rules_in_section_create_multiple(section_id, service_insertion_rule_list, opts = {})
      data, _status_code, _headers = add_service_insertion_rules_in_section_create_multiple_with_http_info(section_id, service_insertion_rule_list, opts)
      return data
    end

    # Add Multiple Rules in a Section
    # Create multiple serviceinsertion rules in existing serviceinsertion section bounded by limit of 1000 serviceinsertion rules per section. 
    # @param section_id 
    # @param service_insertion_rule_list 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation
    # @return [Array<(ServiceInsertionRuleList, Fixnum, Hash)>] ServiceInsertionRuleList data, response status code and response headers
    def add_service_insertion_rules_in_section_create_multiple_with_http_info(section_id, service_insertion_rule_list, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.add_service_insertion_rules_in_section_create_multiple ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.add_service_insertion_rules_in_section_create_multiple"
      end
      # verify the required parameter 'service_insertion_rule_list' is set
      if @api_client.config.client_side_validation && service_insertion_rule_list.nil?
        fail ArgumentError, "Missing the required parameter 'service_insertion_rule_list' when calling ServicesApi.add_service_insertion_rules_in_section_create_multiple"
      end
      if @api_client.config.client_side_validation && !opts[:'id'].nil? && opts[:'id'].to_s.length > 64
        fail ArgumentError, 'invalid value for "opts[:"id"]" when calling ServicesApi.add_service_insertion_rules_in_section_create_multiple, the character length must be smaller than or equal to 64.'
      end

      if @api_client.config.client_side_validation && opts[:'operation'] && !['insert_top', 'insert_bottom', 'insert_after', 'insert_before'].include?(opts[:'operation'])
        fail ArgumentError, 'invalid value for "operation", must be one of insert_top, insert_bottom, insert_after, insert_before'
      end
      # resource path
      local_var_path = "/serviceinsertion/sections/{section-id}/rules?action=create_multiple".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'id'] = opts[:'id'] if !opts[:'id'].nil?
      query_params[:'operation'] = opts[:'operation'] if !opts[:'operation'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(service_insertion_rule_list)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceInsertionRuleList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#add_service_insertion_rules_in_section_create_multiple\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a New Empty Section
    # Creates new empty Service Insertion section in the system. 
    # @param service_insertion_section 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation (default to insert_top)
    # @return [ServiceInsertionSection]
    def add_service_insertion_section(service_insertion_section, opts = {})
      data, _status_code, _headers = add_service_insertion_section_with_http_info(service_insertion_section, opts)
      return data
    end

    # Create a New Empty Section
    # Creates new empty Service Insertion section in the system. 
    # @param service_insertion_section 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation
    # @return [Array<(ServiceInsertionSection, Fixnum, Hash)>] ServiceInsertionSection data, response status code and response headers
    def add_service_insertion_section_with_http_info(service_insertion_section, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.add_service_insertion_section ..."
      end
      # verify the required parameter 'service_insertion_section' is set
      if @api_client.config.client_side_validation && service_insertion_section.nil?
        fail ArgumentError, "Missing the required parameter 'service_insertion_section' when calling ServicesApi.add_service_insertion_section"
      end
      if @api_client.config.client_side_validation && !opts[:'id'].nil? && opts[:'id'].to_s.length > 64
        fail ArgumentError, 'invalid value for "opts[:"id"]" when calling ServicesApi.add_service_insertion_section, the character length must be smaller than or equal to 64.'
      end

      if @api_client.config.client_side_validation && opts[:'operation'] && !['insert_top', 'insert_bottom', 'insert_after', 'insert_before'].include?(opts[:'operation'])
        fail ArgumentError, 'invalid value for "operation", must be one of insert_top, insert_bottom, insert_after, insert_before'
      end
      # resource path
      local_var_path = "/serviceinsertion/sections"

      # query parameters
      query_params = {}
      query_params[:'id'] = opts[:'id'] if !opts[:'id'].nil?
      query_params[:'operation'] = opts[:'operation'] if !opts[:'operation'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(service_insertion_section)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceInsertionSection')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#add_service_insertion_section\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a Section with Rules
    # Creates a new serviceinsertion section with rules. The limit on the number of rules is defined by maxItems in collection types for ServiceInsertionRule (ServiceInsertionRuleXXXList types). When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules are not supported.  Instead, to create sections, use: POST /api/v1/serviceinsertion/sections  To create rules, use: POST /api/v1/serviceinsertion/sections/&lt;section-id&gt;/rules 
    # @param service_insertion_section_rule_list 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation (default to insert_top)
    # @return [ServiceInsertionSectionRuleList]
    def add_service_insertion_section_with_rules_create_with_rules(service_insertion_section_rule_list, opts = {})
      data, _status_code, _headers = add_service_insertion_section_with_rules_create_with_rules_with_http_info(service_insertion_section_rule_list, opts)
      return data
    end

    # Create a Section with Rules
    # Creates a new serviceinsertion section with rules. The limit on the number of rules is defined by maxItems in collection types for ServiceInsertionRule (ServiceInsertionRuleXXXList types). When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules are not supported.  Instead, to create sections, use: POST /api/v1/serviceinsertion/sections  To create rules, use: POST /api/v1/serviceinsertion/sections/&amp;lt;section-id&amp;gt;/rules 
    # @param service_insertion_section_rule_list 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation
    # @return [Array<(ServiceInsertionSectionRuleList, Fixnum, Hash)>] ServiceInsertionSectionRuleList data, response status code and response headers
    def add_service_insertion_section_with_rules_create_with_rules_with_http_info(service_insertion_section_rule_list, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.add_service_insertion_section_with_rules_create_with_rules ..."
      end
      # verify the required parameter 'service_insertion_section_rule_list' is set
      if @api_client.config.client_side_validation && service_insertion_section_rule_list.nil?
        fail ArgumentError, "Missing the required parameter 'service_insertion_section_rule_list' when calling ServicesApi.add_service_insertion_section_with_rules_create_with_rules"
      end
      if @api_client.config.client_side_validation && !opts[:'id'].nil? && opts[:'id'].to_s.length > 64
        fail ArgumentError, 'invalid value for "opts[:"id"]" when calling ServicesApi.add_service_insertion_section_with_rules_create_with_rules, the character length must be smaller than or equal to 64.'
      end

      if @api_client.config.client_side_validation && opts[:'operation'] && !['insert_top', 'insert_bottom', 'insert_after', 'insert_before'].include?(opts[:'operation'])
        fail ArgumentError, 'invalid value for "operation", must be one of insert_top, insert_bottom, insert_after, insert_before'
      end
      # resource path
      local_var_path = "/serviceinsertion/sections?action=create_with_rules"

      # query parameters
      query_params = {}
      query_params[:'id'] = opts[:'id'] if !opts[:'id'].nil?
      query_params[:'operation'] = opts[:'operation'] if !opts[:'operation'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(service_insertion_section_rule_list)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceInsertionSectionRuleList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#add_service_insertion_section_with_rules_create_with_rules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a Service-Insertion Service
    # Creates new Service-Insertion Service in the system. 
    # @param service_definition 
    # @param [Hash] opts the optional parameters
    # @return [ServiceDefinition]
    def add_service_insertion_service(service_definition, opts = {})
      data, _status_code, _headers = add_service_insertion_service_with_http_info(service_definition, opts)
      return data
    end

    # Create a Service-Insertion Service
    # Creates new Service-Insertion Service in the system. 
    # @param service_definition 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ServiceDefinition, Fixnum, Hash)>] ServiceDefinition data, response status code and response headers
    def add_service_insertion_service_with_http_info(service_definition, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.add_service_insertion_service ..."
      end
      # verify the required parameter 'service_definition' is set
      if @api_client.config.client_side_validation && service_definition.nil?
        fail ArgumentError, "Missing the required parameter 'service_definition' when calling ServicesApi.add_service_insertion_service"
      end
      # resource path
      local_var_path = "/serviceinsertion/services"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(service_definition)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceDefinition')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#add_service_insertion_service\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add a Service Instance for a specified Service.
    # Adds a new Service-Instance under the specified Service. 
    # @param service_id 
    # @param base_service_instance 
    # @param [Hash] opts the optional parameters
    # @return [BaseServiceInstance]
    def add_service_instance(service_id, base_service_instance, opts = {})
      data, _status_code, _headers = add_service_instance_with_http_info(service_id, base_service_instance, opts)
      return data
    end

    # Add a Service Instance for a specified Service.
    # Adds a new Service-Instance under the specified Service. 
    # @param service_id 
    # @param base_service_instance 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BaseServiceInstance, Fixnum, Hash)>] BaseServiceInstance data, response status code and response headers
    def add_service_instance_with_http_info(service_id, base_service_instance, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.add_service_instance ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.add_service_instance"
      end
      # verify the required parameter 'base_service_instance' is set
      if @api_client.config.client_side_validation && base_service_instance.nil?
        fail ArgumentError, "Missing the required parameter 'base_service_instance' when calling ServicesApi.add_service_instance"
      end
      # resource path
      local_var_path = "/serviceinsertion/services/{service-id}/service-instances".sub('{' + 'service-id' + '}', service_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(base_service_instance)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BaseServiceInstance')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#add_service_instance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Check if the object a member of the exclude list
    # Check if the object a member of the exclude list
    # @param object_id identifier of the object
    # @param [Hash] opts the optional parameters
    # @return [ResourceReference]
    def check_member_if_exists_check_if_exists(object_id, opts = {})
      data, _status_code, _headers = check_member_if_exists_check_if_exists_with_http_info(object_id, opts)
      return data
    end

    # Check if the object a member of the exclude list
    # Check if the object a member of the exclude list
    # @param object_id identifier of the object
    # @param [Hash] opts the optional parameters
    # @return [Array<(ResourceReference, Fixnum, Hash)>] ResourceReference data, response status code and response headers
    def check_member_if_exists_check_if_exists_with_http_info(object_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.check_member_if_exists_check_if_exists ..."
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        fail ArgumentError, "Missing the required parameter 'object_id' when calling ServicesApi.check_member_if_exists_check_if_exists"
      end
      if @api_client.config.client_side_validation && object_id.to_s.length > 64
        fail ArgumentError, 'invalid value for "object_id" when calling ServicesApi.check_member_if_exists_check_if_exists, the character length must be smaller than or equal to 64.'
      end

      # resource path
      local_var_path = "/firewall/excludelist?action=check_if_exists"

      # query parameters
      query_params = {}
      query_params[:'object_id'] = object_id

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ResourceReference')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#check_member_if_exists_check_if_exists\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Clear the current cache of the dns forwarder.
    # Clear the current cache of the dns forwarder. 
    # @param forwarder_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def clear_dns_forwarder_cache_clear_cache(forwarder_id, opts = {})
      clear_dns_forwarder_cache_clear_cache_with_http_info(forwarder_id, opts)
      return nil
    end

    # Clear the current cache of the dns forwarder.
    # Clear the current cache of the dns forwarder. 
    # @param forwarder_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def clear_dns_forwarder_cache_clear_cache_with_http_info(forwarder_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.clear_dns_forwarder_cache_clear_cache ..."
      end
      # verify the required parameter 'forwarder_id' is set
      if @api_client.config.client_side_validation && forwarder_id.nil?
        fail ArgumentError, "Missing the required parameter 'forwarder_id' when calling ServicesApi.clear_dns_forwarder_cache_clear_cache"
      end
      # resource path
      local_var_path = "/dns/forwarders/{forwarder-id}?action=clear_cache".sub('{' + 'forwarder-id' + '}', forwarder_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#clear_dns_forwarder_cache_clear_cache\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create an IP pool for a DHCP server
    # Create an IP pool for a DHCP server
    # @param server_id 
    # @param dhcp_ip_pool 
    # @param [Hash] opts the optional parameters
    # @return [DhcpIpPool]
    def create_dhcp_ip_pool(server_id, dhcp_ip_pool, opts = {})
      data, _status_code, _headers = create_dhcp_ip_pool_with_http_info(server_id, dhcp_ip_pool, opts)
      return data
    end

    # Create an IP pool for a DHCP server
    # Create an IP pool for a DHCP server
    # @param server_id 
    # @param dhcp_ip_pool 
    # @param [Hash] opts the optional parameters
    # @return [Array<(DhcpIpPool, Fixnum, Hash)>] DhcpIpPool data, response status code and response headers
    def create_dhcp_ip_pool_with_http_info(server_id, dhcp_ip_pool, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.create_dhcp_ip_pool ..."
      end
      # verify the required parameter 'server_id' is set
      if @api_client.config.client_side_validation && server_id.nil?
        fail ArgumentError, "Missing the required parameter 'server_id' when calling ServicesApi.create_dhcp_ip_pool"
      end
      # verify the required parameter 'dhcp_ip_pool' is set
      if @api_client.config.client_side_validation && dhcp_ip_pool.nil?
        fail ArgumentError, "Missing the required parameter 'dhcp_ip_pool' when calling ServicesApi.create_dhcp_ip_pool"
      end
      # resource path
      local_var_path = "/dhcp/servers/{server-id}/ip-pools".sub('{' + 'server-id' + '}', server_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(dhcp_ip_pool)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DhcpIpPool')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#create_dhcp_ip_pool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a DHCP server profile
    # Create a DHCP server profile
    # @param dhcp_profile 
    # @param [Hash] opts the optional parameters
    # @return [DhcpProfile]
    def create_dhcp_profile(dhcp_profile, opts = {})
      data, _status_code, _headers = create_dhcp_profile_with_http_info(dhcp_profile, opts)
      return data
    end

    # Create a DHCP server profile
    # Create a DHCP server profile
    # @param dhcp_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(DhcpProfile, Fixnum, Hash)>] DhcpProfile data, response status code and response headers
    def create_dhcp_profile_with_http_info(dhcp_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.create_dhcp_profile ..."
      end
      # verify the required parameter 'dhcp_profile' is set
      if @api_client.config.client_side_validation && dhcp_profile.nil?
        fail ArgumentError, "Missing the required parameter 'dhcp_profile' when calling ServicesApi.create_dhcp_profile"
      end
      # resource path
      local_var_path = "/dhcp/server-profiles"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(dhcp_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DhcpProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#create_dhcp_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a DHCP server
    # Create a DHCP server
    # @param logical_dhcp_server 
    # @param [Hash] opts the optional parameters
    # @return [LogicalDhcpServer]
    def create_dhcp_server(logical_dhcp_server, opts = {})
      data, _status_code, _headers = create_dhcp_server_with_http_info(logical_dhcp_server, opts)
      return data
    end

    # Create a DHCP server
    # Create a DHCP server
    # @param logical_dhcp_server 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LogicalDhcpServer, Fixnum, Hash)>] LogicalDhcpServer data, response status code and response headers
    def create_dhcp_server_with_http_info(logical_dhcp_server, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.create_dhcp_server ..."
      end
      # verify the required parameter 'logical_dhcp_server' is set
      if @api_client.config.client_side_validation && logical_dhcp_server.nil?
        fail ArgumentError, "Missing the required parameter 'logical_dhcp_server' when calling ServicesApi.create_dhcp_server"
      end
      # resource path
      local_var_path = "/dhcp/servers"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(logical_dhcp_server)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LogicalDhcpServer')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#create_dhcp_server\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a static binding for a DHCP server
    # Create a static binding for a DHCP server
    # @param server_id 
    # @param dhcp_static_binding 
    # @param [Hash] opts the optional parameters
    # @return [DhcpStaticBinding]
    def create_dhcp_static_binding(server_id, dhcp_static_binding, opts = {})
      data, _status_code, _headers = create_dhcp_static_binding_with_http_info(server_id, dhcp_static_binding, opts)
      return data
    end

    # Create a static binding for a DHCP server
    # Create a static binding for a DHCP server
    # @param server_id 
    # @param dhcp_static_binding 
    # @param [Hash] opts the optional parameters
    # @return [Array<(DhcpStaticBinding, Fixnum, Hash)>] DhcpStaticBinding data, response status code and response headers
    def create_dhcp_static_binding_with_http_info(server_id, dhcp_static_binding, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.create_dhcp_static_binding ..."
      end
      # verify the required parameter 'server_id' is set
      if @api_client.config.client_side_validation && server_id.nil?
        fail ArgumentError, "Missing the required parameter 'server_id' when calling ServicesApi.create_dhcp_static_binding"
      end
      # verify the required parameter 'dhcp_static_binding' is set
      if @api_client.config.client_side_validation && dhcp_static_binding.nil?
        fail ArgumentError, "Missing the required parameter 'dhcp_static_binding' when calling ServicesApi.create_dhcp_static_binding"
      end
      # resource path
      local_var_path = "/dhcp/servers/{server-id}/static-bindings".sub('{' + 'server-id' + '}', server_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(dhcp_static_binding)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DhcpStaticBinding')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#create_dhcp_static_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a dns forwader
    # Create a dns forwader upon a logical router. There is only one dns forwarder can be created upon a given logical router. 
    # @param dns_forwarder 
    # @param [Hash] opts the optional parameters
    # @return [DnsForwarder]
    def create_dns_forwader(dns_forwarder, opts = {})
      data, _status_code, _headers = create_dns_forwader_with_http_info(dns_forwarder, opts)
      return data
    end

    # Create a dns forwader
    # Create a dns forwader upon a logical router. There is only one dns forwarder can be created upon a given logical router. 
    # @param dns_forwarder 
    # @param [Hash] opts the optional parameters
    # @return [Array<(DnsForwarder, Fixnum, Hash)>] DnsForwarder data, response status code and response headers
    def create_dns_forwader_with_http_info(dns_forwarder, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.create_dns_forwader ..."
      end
      # verify the required parameter 'dns_forwarder' is set
      if @api_client.config.client_side_validation && dns_forwarder.nil?
        fail ArgumentError, "Missing the required parameter 'dns_forwarder' when calling ServicesApi.create_dns_forwader"
      end
      # resource path
      local_var_path = "/dns/forwarders"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(dns_forwarder)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DnsForwarder')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#create_dns_forwader\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a load balancer application profile
    # Create a load balancer application profile. 
    # @param lb_app_profile 
    # @param [Hash] opts the optional parameters
    # @return [LbAppProfile]
    def create_load_balancer_application_profile(lb_app_profile, opts = {})
      data, _status_code, _headers = create_load_balancer_application_profile_with_http_info(lb_app_profile, opts)
      return data
    end

    # Create a load balancer application profile
    # Create a load balancer application profile. 
    # @param lb_app_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbAppProfile, Fixnum, Hash)>] LbAppProfile data, response status code and response headers
    def create_load_balancer_application_profile_with_http_info(lb_app_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.create_load_balancer_application_profile ..."
      end
      # verify the required parameter 'lb_app_profile' is set
      if @api_client.config.client_side_validation && lb_app_profile.nil?
        fail ArgumentError, "Missing the required parameter 'lb_app_profile' when calling ServicesApi.create_load_balancer_application_profile"
      end
      # resource path
      local_var_path = "/loadbalancer/application-profiles"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_app_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbAppProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#create_load_balancer_application_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a load balancer client-ssl profile
    # Create a load balancer client-ssl profile. 
    # @param lb_client_ssl_profile 
    # @param [Hash] opts the optional parameters
    # @return [LbClientSslProfile]
    def create_load_balancer_client_ssl_profile(lb_client_ssl_profile, opts = {})
      data, _status_code, _headers = create_load_balancer_client_ssl_profile_with_http_info(lb_client_ssl_profile, opts)
      return data
    end

    # Create a load balancer client-ssl profile
    # Create a load balancer client-ssl profile. 
    # @param lb_client_ssl_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbClientSslProfile, Fixnum, Hash)>] LbClientSslProfile data, response status code and response headers
    def create_load_balancer_client_ssl_profile_with_http_info(lb_client_ssl_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.create_load_balancer_client_ssl_profile ..."
      end
      # verify the required parameter 'lb_client_ssl_profile' is set
      if @api_client.config.client_side_validation && lb_client_ssl_profile.nil?
        fail ArgumentError, "Missing the required parameter 'lb_client_ssl_profile' when calling ServicesApi.create_load_balancer_client_ssl_profile"
      end
      # resource path
      local_var_path = "/loadbalancer/client-ssl-profiles"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_client_ssl_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbClientSslProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#create_load_balancer_client_ssl_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a load balancer monitor
    # Create a load balancer monitor. 
    # @param lb_monitor 
    # @param [Hash] opts the optional parameters
    # @return [LbMonitor]
    def create_load_balancer_monitor(lb_monitor, opts = {})
      data, _status_code, _headers = create_load_balancer_monitor_with_http_info(lb_monitor, opts)
      return data
    end

    # Create a load balancer monitor
    # Create a load balancer monitor. 
    # @param lb_monitor 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbMonitor, Fixnum, Hash)>] LbMonitor data, response status code and response headers
    def create_load_balancer_monitor_with_http_info(lb_monitor, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.create_load_balancer_monitor ..."
      end
      # verify the required parameter 'lb_monitor' is set
      if @api_client.config.client_side_validation && lb_monitor.nil?
        fail ArgumentError, "Missing the required parameter 'lb_monitor' when calling ServicesApi.create_load_balancer_monitor"
      end
      # resource path
      local_var_path = "/loadbalancer/monitors"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_monitor)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbMonitor')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#create_load_balancer_monitor\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a load balancer persistence profile
    # Create a load balancer persistence profile. 
    # @param lb_persistence_profile 
    # @param [Hash] opts the optional parameters
    # @return [LbPersistenceProfile]
    def create_load_balancer_persistence_profile(lb_persistence_profile, opts = {})
      data, _status_code, _headers = create_load_balancer_persistence_profile_with_http_info(lb_persistence_profile, opts)
      return data
    end

    # Create a load balancer persistence profile
    # Create a load balancer persistence profile. 
    # @param lb_persistence_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbPersistenceProfile, Fixnum, Hash)>] LbPersistenceProfile data, response status code and response headers
    def create_load_balancer_persistence_profile_with_http_info(lb_persistence_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.create_load_balancer_persistence_profile ..."
      end
      # verify the required parameter 'lb_persistence_profile' is set
      if @api_client.config.client_side_validation && lb_persistence_profile.nil?
        fail ArgumentError, "Missing the required parameter 'lb_persistence_profile' when calling ServicesApi.create_load_balancer_persistence_profile"
      end
      # resource path
      local_var_path = "/loadbalancer/persistence-profiles"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_persistence_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbPersistenceProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#create_load_balancer_persistence_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a load balancer pool
    # Create a load balancer pool. 
    # @param lb_pool 
    # @param [Hash] opts the optional parameters
    # @return [LbPool]
    def create_load_balancer_pool(lb_pool, opts = {})
      data, _status_code, _headers = create_load_balancer_pool_with_http_info(lb_pool, opts)
      return data
    end

    # Create a load balancer pool
    # Create a load balancer pool. 
    # @param lb_pool 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbPool, Fixnum, Hash)>] LbPool data, response status code and response headers
    def create_load_balancer_pool_with_http_info(lb_pool, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.create_load_balancer_pool ..."
      end
      # verify the required parameter 'lb_pool' is set
      if @api_client.config.client_side_validation && lb_pool.nil?
        fail ArgumentError, "Missing the required parameter 'lb_pool' when calling ServicesApi.create_load_balancer_pool"
      end
      # resource path
      local_var_path = "/loadbalancer/pools"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_pool)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbPool')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#create_load_balancer_pool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a load balancer rule
    # Create a load balancer rule. 
    # @param lb_rule 
    # @param [Hash] opts the optional parameters
    # @return [LbRule]
    def create_load_balancer_rule(lb_rule, opts = {})
      data, _status_code, _headers = create_load_balancer_rule_with_http_info(lb_rule, opts)
      return data
    end

    # Create a load balancer rule
    # Create a load balancer rule. 
    # @param lb_rule 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbRule, Fixnum, Hash)>] LbRule data, response status code and response headers
    def create_load_balancer_rule_with_http_info(lb_rule, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.create_load_balancer_rule ..."
      end
      # verify the required parameter 'lb_rule' is set
      if @api_client.config.client_side_validation && lb_rule.nil?
        fail ArgumentError, "Missing the required parameter 'lb_rule' when calling ServicesApi.create_load_balancer_rule"
      end
      # resource path
      local_var_path = "/loadbalancer/rules"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_rule)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbRule')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#create_load_balancer_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a load balancer server-ssl profile
    # Create a load balancer server-ssl profile. 
    # @param lb_server_ssl_profile 
    # @param [Hash] opts the optional parameters
    # @return [LbServerSslProfile]
    def create_load_balancer_server_ssl_profile(lb_server_ssl_profile, opts = {})
      data, _status_code, _headers = create_load_balancer_server_ssl_profile_with_http_info(lb_server_ssl_profile, opts)
      return data
    end

    # Create a load balancer server-ssl profile
    # Create a load balancer server-ssl profile. 
    # @param lb_server_ssl_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbServerSslProfile, Fixnum, Hash)>] LbServerSslProfile data, response status code and response headers
    def create_load_balancer_server_ssl_profile_with_http_info(lb_server_ssl_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.create_load_balancer_server_ssl_profile ..."
      end
      # verify the required parameter 'lb_server_ssl_profile' is set
      if @api_client.config.client_side_validation && lb_server_ssl_profile.nil?
        fail ArgumentError, "Missing the required parameter 'lb_server_ssl_profile' when calling ServicesApi.create_load_balancer_server_ssl_profile"
      end
      # resource path
      local_var_path = "/loadbalancer/server-ssl-profiles"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_server_ssl_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbServerSslProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#create_load_balancer_server_ssl_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a load balancer service
    # Create a load balancer service. 
    # @param lb_service 
    # @param [Hash] opts the optional parameters
    # @return [LbService]
    def create_load_balancer_service(lb_service, opts = {})
      data, _status_code, _headers = create_load_balancer_service_with_http_info(lb_service, opts)
      return data
    end

    # Create a load balancer service
    # Create a load balancer service. 
    # @param lb_service 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbService, Fixnum, Hash)>] LbService data, response status code and response headers
    def create_load_balancer_service_with_http_info(lb_service, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.create_load_balancer_service ..."
      end
      # verify the required parameter 'lb_service' is set
      if @api_client.config.client_side_validation && lb_service.nil?
        fail ArgumentError, "Missing the required parameter 'lb_service' when calling ServicesApi.create_load_balancer_service"
      end
      # resource path
      local_var_path = "/loadbalancer/services"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_service)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbService')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#create_load_balancer_service\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a load balancer TCP profile
    # Create a load balancer TCP profile. 
    # @param lb_tcp_profile 
    # @param [Hash] opts the optional parameters
    # @return [LbTcpProfile]
    def create_load_balancer_tcp_profile(lb_tcp_profile, opts = {})
      data, _status_code, _headers = create_load_balancer_tcp_profile_with_http_info(lb_tcp_profile, opts)
      return data
    end

    # Create a load balancer TCP profile
    # Create a load balancer TCP profile. 
    # @param lb_tcp_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbTcpProfile, Fixnum, Hash)>] LbTcpProfile data, response status code and response headers
    def create_load_balancer_tcp_profile_with_http_info(lb_tcp_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.create_load_balancer_tcp_profile ..."
      end
      # verify the required parameter 'lb_tcp_profile' is set
      if @api_client.config.client_side_validation && lb_tcp_profile.nil?
        fail ArgumentError, "Missing the required parameter 'lb_tcp_profile' when calling ServicesApi.create_load_balancer_tcp_profile"
      end
      # resource path
      local_var_path = "/loadbalancer/tcp-profiles"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_tcp_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbTcpProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#create_load_balancer_tcp_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a load balancer virtual server
    # Create a load balancer virtual server. 
    # @param lb_virtual_server 
    # @param [Hash] opts the optional parameters
    # @return [LbVirtualServer]
    def create_load_balancer_virtual_server(lb_virtual_server, opts = {})
      data, _status_code, _headers = create_load_balancer_virtual_server_with_http_info(lb_virtual_server, opts)
      return data
    end

    # Create a load balancer virtual server
    # Create a load balancer virtual server. 
    # @param lb_virtual_server 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbVirtualServer, Fixnum, Hash)>] LbVirtualServer data, response status code and response headers
    def create_load_balancer_virtual_server_with_http_info(lb_virtual_server, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.create_load_balancer_virtual_server ..."
      end
      # verify the required parameter 'lb_virtual_server' is set
      if @api_client.config.client_side_validation && lb_virtual_server.nil?
        fail ArgumentError, "Missing the required parameter 'lb_virtual_server' when calling ServicesApi.create_load_balancer_virtual_server"
      end
      # resource path
      local_var_path = "/loadbalancer/virtual-servers"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_virtual_server)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbVirtualServer')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#create_load_balancer_virtual_server\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a load balancer virtual server with rules
    # It is used to create virtual servers, the associated rules and bind the rules to the virtual server. To add new rules, make sure the rules which have no identifier specified, the new rules are automatically generated and associated to the virtual server. If the virtual server need to consume some existed rules without change, those rules should not be specified in this array, otherwise, the rules are updated. 
    # @param lb_virtual_server_with_rule 
    # @param [Hash] opts the optional parameters
    # @return [LbVirtualServerWithRule]
    def create_load_balancer_virtual_server_with_rules_create_with_rules(lb_virtual_server_with_rule, opts = {})
      data, _status_code, _headers = create_load_balancer_virtual_server_with_rules_create_with_rules_with_http_info(lb_virtual_server_with_rule, opts)
      return data
    end

    # Create a load balancer virtual server with rules
    # It is used to create virtual servers, the associated rules and bind the rules to the virtual server. To add new rules, make sure the rules which have no identifier specified, the new rules are automatically generated and associated to the virtual server. If the virtual server need to consume some existed rules without change, those rules should not be specified in this array, otherwise, the rules are updated. 
    # @param lb_virtual_server_with_rule 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbVirtualServerWithRule, Fixnum, Hash)>] LbVirtualServerWithRule data, response status code and response headers
    def create_load_balancer_virtual_server_with_rules_create_with_rules_with_http_info(lb_virtual_server_with_rule, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.create_load_balancer_virtual_server_with_rules_create_with_rules ..."
      end
      # verify the required parameter 'lb_virtual_server_with_rule' is set
      if @api_client.config.client_side_validation && lb_virtual_server_with_rule.nil?
        fail ArgumentError, "Missing the required parameter 'lb_virtual_server_with_rule' when calling ServicesApi.create_load_balancer_virtual_server_with_rules_create_with_rules"
      end
      # resource path
      local_var_path = "/loadbalancer/virtual-servers?action=create_with_rules"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_virtual_server_with_rule)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbVirtualServerWithRule')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#create_load_balancer_virtual_server_with_rules_create_with_rules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a metadata proxy
    # Create a metadata proxy
    # @param metadata_proxy 
    # @param [Hash] opts the optional parameters
    # @return [MetadataProxy]
    def create_metadata_proxy(metadata_proxy, opts = {})
      data, _status_code, _headers = create_metadata_proxy_with_http_info(metadata_proxy, opts)
      return data
    end

    # Create a metadata proxy
    # Create a metadata proxy
    # @param metadata_proxy 
    # @param [Hash] opts the optional parameters
    # @return [Array<(MetadataProxy, Fixnum, Hash)>] MetadataProxy data, response status code and response headers
    def create_metadata_proxy_with_http_info(metadata_proxy, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.create_metadata_proxy ..."
      end
      # verify the required parameter 'metadata_proxy' is set
      if @api_client.config.client_side_validation && metadata_proxy.nil?
        fail ArgumentError, "Missing the required parameter 'metadata_proxy' when calling ServicesApi.create_metadata_proxy"
      end
      # resource path
      local_var_path = "/md-proxies"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(metadata_proxy)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MetadataProxy')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#create_metadata_proxy\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a DHCP server's IP pool
    # Delete a DHCP server's IP pool
    # @param server_id 
    # @param pool_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_dhcp_ip_pool(server_id, pool_id, opts = {})
      delete_dhcp_ip_pool_with_http_info(server_id, pool_id, opts)
      return nil
    end

    # Delete a DHCP server&#39;s IP pool
    # Delete a DHCP server&#39;s IP pool
    # @param server_id 
    # @param pool_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_dhcp_ip_pool_with_http_info(server_id, pool_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_dhcp_ip_pool ..."
      end
      # verify the required parameter 'server_id' is set
      if @api_client.config.client_side_validation && server_id.nil?
        fail ArgumentError, "Missing the required parameter 'server_id' when calling ServicesApi.delete_dhcp_ip_pool"
      end
      # verify the required parameter 'pool_id' is set
      if @api_client.config.client_side_validation && pool_id.nil?
        fail ArgumentError, "Missing the required parameter 'pool_id' when calling ServicesApi.delete_dhcp_ip_pool"
      end
      # resource path
      local_var_path = "/dhcp/servers/{server-id}/ip-pools/{pool-id}".sub('{' + 'server-id' + '}', server_id.to_s).sub('{' + 'pool-id' + '}', pool_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_dhcp_ip_pool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a DHCP server profile
    # Delete a DHCP server profile
    # @param profile_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_dhcp_profile(profile_id, opts = {})
      delete_dhcp_profile_with_http_info(profile_id, opts)
      return nil
    end

    # Delete a DHCP server profile
    # Delete a DHCP server profile
    # @param profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_dhcp_profile_with_http_info(profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_dhcp_profile ..."
      end
      # verify the required parameter 'profile_id' is set
      if @api_client.config.client_side_validation && profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'profile_id' when calling ServicesApi.delete_dhcp_profile"
      end
      # resource path
      local_var_path = "/dhcp/server-profiles/{profile-id}".sub('{' + 'profile-id' + '}', profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_dhcp_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a DHCP server
    # Delete a DHCP server
    # @param server_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_dhcp_server(server_id, opts = {})
      delete_dhcp_server_with_http_info(server_id, opts)
      return nil
    end

    # Delete a DHCP server
    # Delete a DHCP server
    # @param server_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_dhcp_server_with_http_info(server_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_dhcp_server ..."
      end
      # verify the required parameter 'server_id' is set
      if @api_client.config.client_side_validation && server_id.nil?
        fail ArgumentError, "Missing the required parameter 'server_id' when calling ServicesApi.delete_dhcp_server"
      end
      # resource path
      local_var_path = "/dhcp/servers/{server-id}".sub('{' + 'server-id' + '}', server_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_dhcp_server\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a static binding
    # Delete a static binding
    # @param server_id 
    # @param binding_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_dhcp_static_binding(server_id, binding_id, opts = {})
      delete_dhcp_static_binding_with_http_info(server_id, binding_id, opts)
      return nil
    end

    # Delete a static binding
    # Delete a static binding
    # @param server_id 
    # @param binding_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_dhcp_static_binding_with_http_info(server_id, binding_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_dhcp_static_binding ..."
      end
      # verify the required parameter 'server_id' is set
      if @api_client.config.client_side_validation && server_id.nil?
        fail ArgumentError, "Missing the required parameter 'server_id' when calling ServicesApi.delete_dhcp_static_binding"
      end
      # verify the required parameter 'binding_id' is set
      if @api_client.config.client_side_validation && binding_id.nil?
        fail ArgumentError, "Missing the required parameter 'binding_id' when calling ServicesApi.delete_dhcp_static_binding"
      end
      # resource path
      local_var_path = "/dhcp/servers/{server-id}/static-bindings/{binding-id}".sub('{' + 'server-id' + '}', server_id.to_s).sub('{' + 'binding-id' + '}', binding_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_dhcp_static_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a specific dns forwarder
    # Delete a specific dns forwarder. 
    # @param forwarder_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_dns_forwarder(forwarder_id, opts = {})
      delete_dns_forwarder_with_http_info(forwarder_id, opts)
      return nil
    end

    # Delete a specific dns forwarder
    # Delete a specific dns forwarder. 
    # @param forwarder_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_dns_forwarder_with_http_info(forwarder_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_dns_forwarder ..."
      end
      # verify the required parameter 'forwarder_id' is set
      if @api_client.config.client_side_validation && forwarder_id.nil?
        fail ArgumentError, "Missing the required parameter 'forwarder_id' when calling ServicesApi.delete_dns_forwarder"
      end
      # resource path
      local_var_path = "/dns/forwarders/{forwarder-id}".sub('{' + 'forwarder-id' + '}', forwarder_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_dns_forwarder\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a particular InstanceEndpoint.
    # Delete instance endpoint information for a given instace endpoint. Please make sure to delete all the Service Insertion Rules, which refer to this Endpoint as 'redirect_tos' target. 
    # @param service_id 
    # @param service_instance_id 
    # @param instance_endpoint 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_instance_endpoint(service_id, service_instance_id, instance_endpoint, opts = {})
      delete_instance_endpoint_with_http_info(service_id, service_instance_id, instance_endpoint, opts)
      return nil
    end

    # Delete a particular InstanceEndpoint.
    # Delete instance endpoint information for a given instace endpoint. Please make sure to delete all the Service Insertion Rules, which refer to this Endpoint as &#39;redirect_tos&#39; target. 
    # @param service_id 
    # @param service_instance_id 
    # @param instance_endpoint 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_instance_endpoint_with_http_info(service_id, service_instance_id, instance_endpoint, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_instance_endpoint ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.delete_instance_endpoint"
      end
      # verify the required parameter 'service_instance_id' is set
      if @api_client.config.client_side_validation && service_instance_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_instance_id' when calling ServicesApi.delete_instance_endpoint"
      end
      # verify the required parameter 'instance_endpoint' is set
      if @api_client.config.client_side_validation && instance_endpoint.nil?
        fail ArgumentError, "Missing the required parameter 'instance_endpoint' when calling ServicesApi.delete_instance_endpoint"
      end
      # resource path
      local_var_path = "/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/instance-endpoints/{instance-endpoint}".sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'service-instance-id' + '}', service_instance_id.to_s).sub('{' + 'instance-endpoint' + '}', instance_endpoint.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_instance_endpoint\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a load balancer application profile
    # Delete a load balancer application profile. 
    # @param application_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_load_balancer_application_profile(application_profile_id, opts = {})
      delete_load_balancer_application_profile_with_http_info(application_profile_id, opts)
      return nil
    end

    # Delete a load balancer application profile
    # Delete a load balancer application profile. 
    # @param application_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_load_balancer_application_profile_with_http_info(application_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_load_balancer_application_profile ..."
      end
      # verify the required parameter 'application_profile_id' is set
      if @api_client.config.client_side_validation && application_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'application_profile_id' when calling ServicesApi.delete_load_balancer_application_profile"
      end
      # resource path
      local_var_path = "/loadbalancer/application-profiles/{application-profile-id}".sub('{' + 'application-profile-id' + '}', application_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_load_balancer_application_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a load balancer client-ssl profile
    # Delete a load balancer client-ssl profile. 
    # @param client_ssl_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_load_balancer_client_ssl_profile(client_ssl_profile_id, opts = {})
      delete_load_balancer_client_ssl_profile_with_http_info(client_ssl_profile_id, opts)
      return nil
    end

    # Delete a load balancer client-ssl profile
    # Delete a load balancer client-ssl profile. 
    # @param client_ssl_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_load_balancer_client_ssl_profile_with_http_info(client_ssl_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_load_balancer_client_ssl_profile ..."
      end
      # verify the required parameter 'client_ssl_profile_id' is set
      if @api_client.config.client_side_validation && client_ssl_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'client_ssl_profile_id' when calling ServicesApi.delete_load_balancer_client_ssl_profile"
      end
      # resource path
      local_var_path = "/loadbalancer/client-ssl-profiles/{client-ssl-profile-id}".sub('{' + 'client-ssl-profile-id' + '}', client_ssl_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_load_balancer_client_ssl_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a load balancer monitor
    # Delete a load balancer monitor. 
    # @param monitor_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_load_balancer_monitor(monitor_id, opts = {})
      delete_load_balancer_monitor_with_http_info(monitor_id, opts)
      return nil
    end

    # Delete a load balancer monitor
    # Delete a load balancer monitor. 
    # @param monitor_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_load_balancer_monitor_with_http_info(monitor_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_load_balancer_monitor ..."
      end
      # verify the required parameter 'monitor_id' is set
      if @api_client.config.client_side_validation && monitor_id.nil?
        fail ArgumentError, "Missing the required parameter 'monitor_id' when calling ServicesApi.delete_load_balancer_monitor"
      end
      # resource path
      local_var_path = "/loadbalancer/monitors/{monitor-id}".sub('{' + 'monitor-id' + '}', monitor_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_load_balancer_monitor\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a load balancer persistence profile
    # Delete a load balancer persistence profile. 
    # @param persistence_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_load_balancer_persistence_profile(persistence_profile_id, opts = {})
      delete_load_balancer_persistence_profile_with_http_info(persistence_profile_id, opts)
      return nil
    end

    # Delete a load balancer persistence profile
    # Delete a load balancer persistence profile. 
    # @param persistence_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_load_balancer_persistence_profile_with_http_info(persistence_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_load_balancer_persistence_profile ..."
      end
      # verify the required parameter 'persistence_profile_id' is set
      if @api_client.config.client_side_validation && persistence_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'persistence_profile_id' when calling ServicesApi.delete_load_balancer_persistence_profile"
      end
      # resource path
      local_var_path = "/loadbalancer/persistence-profiles/{persistence-profile-id}".sub('{' + 'persistence-profile-id' + '}', persistence_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_load_balancer_persistence_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a load balancer pool
    # Delete a load balancer pool. 
    # @param pool_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_load_balancer_pool(pool_id, opts = {})
      delete_load_balancer_pool_with_http_info(pool_id, opts)
      return nil
    end

    # Delete a load balancer pool
    # Delete a load balancer pool. 
    # @param pool_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_load_balancer_pool_with_http_info(pool_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_load_balancer_pool ..."
      end
      # verify the required parameter 'pool_id' is set
      if @api_client.config.client_side_validation && pool_id.nil?
        fail ArgumentError, "Missing the required parameter 'pool_id' when calling ServicesApi.delete_load_balancer_pool"
      end
      # resource path
      local_var_path = "/loadbalancer/pools/{pool-id}".sub('{' + 'pool-id' + '}', pool_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_load_balancer_pool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a load balancer rule
    # Delete a load balancer rule. 
    # @param rule_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_load_balancer_rule(rule_id, opts = {})
      delete_load_balancer_rule_with_http_info(rule_id, opts)
      return nil
    end

    # Delete a load balancer rule
    # Delete a load balancer rule. 
    # @param rule_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_load_balancer_rule_with_http_info(rule_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_load_balancer_rule ..."
      end
      # verify the required parameter 'rule_id' is set
      if @api_client.config.client_side_validation && rule_id.nil?
        fail ArgumentError, "Missing the required parameter 'rule_id' when calling ServicesApi.delete_load_balancer_rule"
      end
      # resource path
      local_var_path = "/loadbalancer/rules/{rule-id}".sub('{' + 'rule-id' + '}', rule_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_load_balancer_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a load balancer server-ssl profile
    # Delete a load balancer server-ssl profile. 
    # @param server_ssl_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_load_balancer_server_ssl_profile(server_ssl_profile_id, opts = {})
      delete_load_balancer_server_ssl_profile_with_http_info(server_ssl_profile_id, opts)
      return nil
    end

    # Delete a load balancer server-ssl profile
    # Delete a load balancer server-ssl profile. 
    # @param server_ssl_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_load_balancer_server_ssl_profile_with_http_info(server_ssl_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_load_balancer_server_ssl_profile ..."
      end
      # verify the required parameter 'server_ssl_profile_id' is set
      if @api_client.config.client_side_validation && server_ssl_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'server_ssl_profile_id' when calling ServicesApi.delete_load_balancer_server_ssl_profile"
      end
      # resource path
      local_var_path = "/loadbalancer/server-ssl-profiles/{server-ssl-profile-id}".sub('{' + 'server-ssl-profile-id' + '}', server_ssl_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_load_balancer_server_ssl_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a load balancer service
    # Delete a load balancer service. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_load_balancer_service(service_id, opts = {})
      delete_load_balancer_service_with_http_info(service_id, opts)
      return nil
    end

    # Delete a load balancer service
    # Delete a load balancer service. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_load_balancer_service_with_http_info(service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_load_balancer_service ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.delete_load_balancer_service"
      end
      # resource path
      local_var_path = "/loadbalancer/services/{service-id}".sub('{' + 'service-id' + '}', service_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_load_balancer_service\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a load balancer TCP profile
    # Delete a load balancer TCP profile. 
    # @param tcp_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_load_balancer_tcp_profile(tcp_profile_id, opts = {})
      delete_load_balancer_tcp_profile_with_http_info(tcp_profile_id, opts)
      return nil
    end

    # Delete a load balancer TCP profile
    # Delete a load balancer TCP profile. 
    # @param tcp_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_load_balancer_tcp_profile_with_http_info(tcp_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_load_balancer_tcp_profile ..."
      end
      # verify the required parameter 'tcp_profile_id' is set
      if @api_client.config.client_side_validation && tcp_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'tcp_profile_id' when calling ServicesApi.delete_load_balancer_tcp_profile"
      end
      # resource path
      local_var_path = "/loadbalancer/tcp-profiles/{tcp-profile-id}".sub('{' + 'tcp-profile-id' + '}', tcp_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_load_balancer_tcp_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a load balancer virtual server
    # Delete a load balancer virtual server. 
    # @param virtual_server_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :delete_associated_rules Delete associated rules (default to false)
    # @return [nil]
    def delete_load_balancer_virtual_server(virtual_server_id, opts = {})
      delete_load_balancer_virtual_server_with_http_info(virtual_server_id, opts)
      return nil
    end

    # Delete a load balancer virtual server
    # Delete a load balancer virtual server. 
    # @param virtual_server_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :delete_associated_rules Delete associated rules
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_load_balancer_virtual_server_with_http_info(virtual_server_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_load_balancer_virtual_server ..."
      end
      # verify the required parameter 'virtual_server_id' is set
      if @api_client.config.client_side_validation && virtual_server_id.nil?
        fail ArgumentError, "Missing the required parameter 'virtual_server_id' when calling ServicesApi.delete_load_balancer_virtual_server"
      end
      # resource path
      local_var_path = "/loadbalancer/virtual-servers/{virtual-server-id}".sub('{' + 'virtual-server-id' + '}', virtual_server_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'delete_associated_rules'] = opts[:'delete_associated_rules'] if !opts[:'delete_associated_rules'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_load_balancer_virtual_server\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a metadata proxy
    # Delete a metadata proxy
    # @param proxy_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_metadata_proxy(proxy_id, opts = {})
      delete_metadata_proxy_with_http_info(proxy_id, opts)
      return nil
    end

    # Delete a metadata proxy
    # Delete a metadata proxy
    # @param proxy_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_metadata_proxy_with_http_info(proxy_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_metadata_proxy ..."
      end
      # verify the required parameter 'proxy_id' is set
      if @api_client.config.client_side_validation && proxy_id.nil?
        fail ArgumentError, "Missing the required parameter 'proxy_id' when calling ServicesApi.delete_metadata_proxy"
      end
      # resource path
      local_var_path = "/md-proxies/{proxy-id}".sub('{' + 'proxy-id' + '}', proxy_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_metadata_proxy\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete an Existing Rule
    # Delete existing firewall rule in a firewall section. Deleting firewall rule in a section modifies parent section and simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update. 
    # @param section_id 
    # @param rule_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_rule(section_id, rule_id, opts = {})
      delete_rule_with_http_info(section_id, rule_id, opts)
      return nil
    end

    # Delete an Existing Rule
    # Delete existing firewall rule in a firewall section. Deleting firewall rule in a section modifies parent section and simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update. 
    # @param section_id 
    # @param rule_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_rule_with_http_info(section_id, rule_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_rule ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.delete_rule"
      end
      # verify the required parameter 'rule_id' is set
      if @api_client.config.client_side_validation && rule_id.nil?
        fail ArgumentError, "Missing the required parameter 'rule_id' when calling ServicesApi.delete_rule"
      end
      # resource path
      local_var_path = "/firewall/sections/{section-id}/rules/{rule-id}".sub('{' + 'section-id' + '}', section_id.to_s).sub('{' + 'rule-id' + '}', rule_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete an Existing Section and Its Associated Rules
    # Removes firewall section from the system. Firewall section with rules can only be deleted by passing \"cascade=true\" parameter. 
    # @param section_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :cascade Flag to cascade delete of this object to all it&#39;s child objects. (default to false)
    # @return [nil]
    def delete_section(section_id, opts = {})
      delete_section_with_http_info(section_id, opts)
      return nil
    end

    # Delete an Existing Section and Its Associated Rules
    # Removes firewall section from the system. Firewall section with rules can only be deleted by passing \&quot;cascade&#x3D;true\&quot; parameter. 
    # @param section_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :cascade Flag to cascade delete of this object to all it&#39;s child objects.
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_section_with_http_info(section_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_section ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.delete_section"
      end
      # resource path
      local_var_path = "/firewall/sections/{section-id}".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cascade'] = opts[:'cascade'] if !opts[:'cascade'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_section\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete an existing service attachment
    # Delete existing service attachment from system. Before deletion, please make sure that, no instance endpoints are connected to this attachment. In turn no appliance should be connected to this attachment. 
    # @param service_attachment_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_service_attachment(service_attachment_id, opts = {})
      delete_service_attachment_with_http_info(service_attachment_id, opts)
      return nil
    end

    # Delete an existing service attachment
    # Delete existing service attachment from system. Before deletion, please make sure that, no instance endpoints are connected to this attachment. In turn no appliance should be connected to this attachment. 
    # @param service_attachment_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_service_attachment_with_http_info(service_attachment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_service_attachment ..."
      end
      # verify the required parameter 'service_attachment_id' is set
      if @api_client.config.client_side_validation && service_attachment_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_attachment_id' when calling ServicesApi.delete_service_attachment"
      end
      # resource path
      local_var_path = "/serviceinsertion/service-attachments/{service-attachment-id}".sub('{' + 'service-attachment-id' + '}', service_attachment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_service_attachment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete an Existing Rule
    # Delete existing serviceinsertion rule in a serviceinsertion section. 
    # @param section_id 
    # @param rule_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_service_insertion_rule(section_id, rule_id, opts = {})
      delete_service_insertion_rule_with_http_info(section_id, rule_id, opts)
      return nil
    end

    # Delete an Existing Rule
    # Delete existing serviceinsertion rule in a serviceinsertion section. 
    # @param section_id 
    # @param rule_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_service_insertion_rule_with_http_info(section_id, rule_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_service_insertion_rule ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.delete_service_insertion_rule"
      end
      # verify the required parameter 'rule_id' is set
      if @api_client.config.client_side_validation && rule_id.nil?
        fail ArgumentError, "Missing the required parameter 'rule_id' when calling ServicesApi.delete_service_insertion_rule"
      end
      # resource path
      local_var_path = "/serviceinsertion/sections/{section-id}/rules/{rule-id}".sub('{' + 'section-id' + '}', section_id.to_s).sub('{' + 'rule-id' + '}', rule_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_service_insertion_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete an Existing Section and Its Associated Rules
    # Removes serviceinsertion section from the system. ServiceInsertion section with rules can only be deleted by passing \"cascade=true\" parameter. 
    # @param section_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :cascade Flag to cascade delete of this object to all it&#39;s child objects. (default to false)
    # @return [nil]
    def delete_service_insertion_section(section_id, opts = {})
      delete_service_insertion_section_with_http_info(section_id, opts)
      return nil
    end

    # Delete an Existing Section and Its Associated Rules
    # Removes serviceinsertion section from the system. ServiceInsertion section with rules can only be deleted by passing \&quot;cascade&#x3D;true\&quot; parameter. 
    # @param section_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :cascade Flag to cascade delete of this object to all it&#39;s child objects.
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_service_insertion_section_with_http_info(section_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_service_insertion_section ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.delete_service_insertion_section"
      end
      # resource path
      local_var_path = "/serviceinsertion/sections/{section-id}".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cascade'] = opts[:'cascade'] if !opts[:'cascade'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_service_insertion_section\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete an existing Service and the Service-Instance associated with it.
    # Removes Service-Insertion Service from the system. A Service with Service-Instances can only be deleted by passing \"cascade=true\" parameter. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :cascade Flag to cascade delete all the child objects, associated with it. (default to false)
    # @return [nil]
    def delete_service_insertion_service(service_id, opts = {})
      delete_service_insertion_service_with_http_info(service_id, opts)
      return nil
    end

    # Delete an existing Service and the Service-Instance associated with it.
    # Removes Service-Insertion Service from the system. A Service with Service-Instances can only be deleted by passing \&quot;cascade&#x3D;true\&quot; parameter. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :cascade Flag to cascade delete all the child objects, associated with it.
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_service_insertion_service_with_http_info(service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_service_insertion_service ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.delete_service_insertion_service"
      end
      # resource path
      local_var_path = "/serviceinsertion/services/{service-id}".sub('{' + 'service-id' + '}', service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cascade'] = opts[:'cascade'] if !opts[:'cascade'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_service_insertion_service\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete an existing Service-Instance
    # Delete existing Service-Instance for a given Service-Insertion Service. 
    # @param service_id 
    # @param service_instance_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_service_instance(service_id, service_instance_id, opts = {})
      delete_service_instance_with_http_info(service_id, service_instance_id, opts)
      return nil
    end

    # Delete an existing Service-Instance
    # Delete existing Service-Instance for a given Service-Insertion Service. 
    # @param service_id 
    # @param service_instance_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_service_instance_with_http_info(service_id, service_instance_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_service_instance ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.delete_service_instance"
      end
      # verify the required parameter 'service_instance_id' is set
      if @api_client.config.client_side_validation && service_instance_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_instance_id' when calling ServicesApi.delete_service_instance"
      end
      # resource path
      local_var_path = "/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}".sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'service-instance-id' + '}', service_instance_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_service_instance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Remove service VMs either as standalone or HA
    # Undeploy one service VM as standalone or two service VMs as HA. Associated deployment information and instance runtime will also be deleted once service VMs have been un-deployed successfully. 
    # @param service_id 
    # @param service_instance_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_service_v_ms_delete(service_id, service_instance_id, opts = {})
      delete_service_v_ms_delete_with_http_info(service_id, service_instance_id, opts)
      return nil
    end

    # Remove service VMs either as standalone or HA
    # Undeploy one service VM as standalone or two service VMs as HA. Associated deployment information and instance runtime will also be deleted once service VMs have been un-deployed successfully. 
    # @param service_id 
    # @param service_instance_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_service_v_ms_delete_with_http_info(service_id, service_instance_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.delete_service_v_ms_delete ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.delete_service_v_ms_delete"
      end
      # verify the required parameter 'service_instance_id' is set
      if @api_client.config.client_side_validation && service_instance_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_instance_id' when calling ServicesApi.delete_service_v_ms_delete"
      end
      # resource path
      local_var_path = "/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/instance-runtimes?action=delete".sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'service-instance-id' + '}', service_instance_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#delete_service_v_ms_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Deploy and set up service VMs either as standalone or HA
    # Deploys one service VM as standalone, or two service VMs as HA where one VM is active and another one is standby.  During the deployment of service VMs, service will be set up based on deployment events using callbacks. 
    # @param service_id 
    # @param service_instance_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def deploy_service_v_ms_deploy(service_id, service_instance_id, opts = {})
      deploy_service_v_ms_deploy_with_http_info(service_id, service_instance_id, opts)
      return nil
    end

    # Deploy and set up service VMs either as standalone or HA
    # Deploys one service VM as standalone, or two service VMs as HA where one VM is active and another one is standby.  During the deployment of service VMs, service will be set up based on deployment events using callbacks. 
    # @param service_id 
    # @param service_instance_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def deploy_service_v_ms_deploy_with_http_info(service_id, service_instance_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.deploy_service_v_ms_deploy ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.deploy_service_v_ms_deploy"
      end
      # verify the required parameter 'service_instance_id' is set
      if @api_client.config.client_side_validation && service_instance_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_instance_id' when calling ServicesApi.deploy_service_v_ms_deploy"
      end
      # resource path
      local_var_path = "/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/instance-runtimes?action=deploy".sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'service-instance-id' + '}', service_instance_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#deploy_service_v_ms_deploy\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Disable firewall on target resource in dfw context
    # Disable firewall on target resource in dfw context
    # @param context_type 
    # @param id 
    # @param [Hash] opts the optional parameters
    # @return [TargetResourceStatus]
    def disable_firewall_on_target_resource_disable_firewall(context_type, id, opts = {})
      data, _status_code, _headers = disable_firewall_on_target_resource_disable_firewall_with_http_info(context_type, id, opts)
      return data
    end

    # Disable firewall on target resource in dfw context
    # Disable firewall on target resource in dfw context
    # @param context_type 
    # @param id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TargetResourceStatus, Fixnum, Hash)>] TargetResourceStatus data, response status code and response headers
    def disable_firewall_on_target_resource_disable_firewall_with_http_info(context_type, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.disable_firewall_on_target_resource_disable_firewall ..."
      end
      # verify the required parameter 'context_type' is set
      if @api_client.config.client_side_validation && context_type.nil?
        fail ArgumentError, "Missing the required parameter 'context_type' when calling ServicesApi.disable_firewall_on_target_resource_disable_firewall"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling ServicesApi.disable_firewall_on_target_resource_disable_firewall"
      end
      # resource path
      local_var_path = "/firewall/status/{context-type}/{id}?action=disable_firewall".sub('{' + 'context-type' + '}', context_type.to_s).sub('{' + 'id' + '}', id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TargetResourceStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#disable_firewall_on_target_resource_disable_firewall\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Enable firewall on target resource in dfw context
    # Enable firewall on target resource in dfw context
    # @param context_type 
    # @param id 
    # @param [Hash] opts the optional parameters
    # @return [TargetResourceStatus]
    def enable_firewall_on_target_resource_enable_firewall(context_type, id, opts = {})
      data, _status_code, _headers = enable_firewall_on_target_resource_enable_firewall_with_http_info(context_type, id, opts)
      return data
    end

    # Enable firewall on target resource in dfw context
    # Enable firewall on target resource in dfw context
    # @param context_type 
    # @param id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TargetResourceStatus, Fixnum, Hash)>] TargetResourceStatus data, response status code and response headers
    def enable_firewall_on_target_resource_enable_firewall_with_http_info(context_type, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.enable_firewall_on_target_resource_enable_firewall ..."
      end
      # verify the required parameter 'context_type' is set
      if @api_client.config.client_side_validation && context_type.nil?
        fail ArgumentError, "Missing the required parameter 'context_type' when calling ServicesApi.enable_firewall_on_target_resource_enable_firewall"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling ServicesApi.enable_firewall_on_target_resource_enable_firewall"
      end
      # resource path
      local_var_path = "/firewall/status/{context-type}/{id}?action=enable_firewall".sub('{' + 'context-type' + '}', context_type.to_s).sub('{' + 'id' + '}', id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TargetResourceStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#enable_firewall_on_target_resource_enable_firewall\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get lease info of a given dhcp server id
    # Get lease info of a given dhcp server id. If a \"pool_id\" is specified, the lease info of the pool are returned. If an \"address\" is specified, only the lease info the this address is returned. The \"address\" can be a single IP, an ip-range, or a mac address. \"pool_id\" and \"address\" are mutually excluded. Either a \"pool_id\" or an \"address\" can be provided, but not both. 
    # @param server_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :address can be an ip address, or an ip range, or a mac address
    # @option opts [String] :pool_id The uuid of dhcp ip pool
    # @option opts [String] :source Data source type.
    # @return [DhcpLeases]
    def get_dhcp_lease_info(server_id, opts = {})
      data, _status_code, _headers = get_dhcp_lease_info_with_http_info(server_id, opts)
      return data
    end

    # Get lease info of a given dhcp server id
    # Get lease info of a given dhcp server id. If a \&quot;pool_id\&quot; is specified, the lease info of the pool are returned. If an \&quot;address\&quot; is specified, only the lease info the this address is returned. The \&quot;address\&quot; can be a single IP, an ip-range, or a mac address. \&quot;pool_id\&quot; and \&quot;address\&quot; are mutually excluded. Either a \&quot;pool_id\&quot; or an \&quot;address\&quot; can be provided, but not both. 
    # @param server_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :address can be an ip address, or an ip range, or a mac address
    # @option opts [String] :pool_id The uuid of dhcp ip pool
    # @option opts [String] :source Data source type.
    # @return [Array<(DhcpLeases, Fixnum, Hash)>] DhcpLeases data, response status code and response headers
    def get_dhcp_lease_info_with_http_info(server_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_dhcp_lease_info ..."
      end
      # verify the required parameter 'server_id' is set
      if @api_client.config.client_side_validation && server_id.nil?
        fail ArgumentError, "Missing the required parameter 'server_id' when calling ServicesApi.get_dhcp_lease_info"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/dhcp/servers/{server-id}/leases".sub('{' + 'server-id' + '}', server_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'address'] = opts[:'address'] if !opts[:'address'].nil?
      query_params[:'pool_id'] = opts[:'pool_id'] if !opts[:'pool_id'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DhcpLeases')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_dhcp_lease_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get DHCP statistics with given dhcp server id
    # Returns the statistics of the given dhcp server. 
    # @param server_id 
    # @param [Hash] opts the optional parameters
    # @return [DhcpStatistics]
    def get_dhcp_statistics(server_id, opts = {})
      data, _status_code, _headers = get_dhcp_statistics_with_http_info(server_id, opts)
      return data
    end

    # Get DHCP statistics with given dhcp server id
    # Returns the statistics of the given dhcp server. 
    # @param server_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(DhcpStatistics, Fixnum, Hash)>] DhcpStatistics data, response status code and response headers
    def get_dhcp_statistics_with_http_info(server_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_dhcp_statistics ..."
      end
      # verify the required parameter 'server_id' is set
      if @api_client.config.client_side_validation && server_id.nil?
        fail ArgumentError, "Missing the required parameter 'server_id' when calling ServicesApi.get_dhcp_statistics"
      end
      # resource path
      local_var_path = "/dhcp/servers/{server-id}/statistics".sub('{' + 'server-id' + '}', server_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DhcpStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_dhcp_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get DHCP service status with given dhcp server id
    # Returns the service status of the given dhcp server. 
    # @param server_id 
    # @param [Hash] opts the optional parameters
    # @return [DhcpServerStatus]
    def get_dhcp_status(server_id, opts = {})
      data, _status_code, _headers = get_dhcp_status_with_http_info(server_id, opts)
      return data
    end

    # Get DHCP service status with given dhcp server id
    # Returns the service status of the given dhcp server. 
    # @param server_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(DhcpServerStatus, Fixnum, Hash)>] DhcpServerStatus data, response status code and response headers
    def get_dhcp_status_with_http_info(server_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_dhcp_status ..."
      end
      # verify the required parameter 'server_id' is set
      if @api_client.config.client_side_validation && server_id.nil?
        fail ArgumentError, "Missing the required parameter 'server_id' when calling ServicesApi.get_dhcp_status"
      end
      # resource path
      local_var_path = "/dhcp/servers/{server-id}/status".sub('{' + 'server-id' + '}', server_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DhcpServerStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_dhcp_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get list of entities in exclude list
    # Get list of entities in exclude list
    # @param [Hash] opts the optional parameters
    # @return [ExcludeList]
    def get_exclude_list(opts = {})
      data, _status_code, _headers = get_exclude_list_with_http_info(opts)
      return data
    end

    # Get list of entities in exclude list
    # Get list of entities in exclude list
    # @param [Hash] opts the optional parameters
    # @return [Array<(ExcludeList, Fixnum, Hash)>] ExcludeList data, response status code and response headers
    def get_exclude_list_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_exclude_list ..."
      end
      # resource path
      local_var_path = "/firewall/excludelist"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ExcludeList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_exclude_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Firewall section level statistics section
    # Get aggregated statistics for all rules for a given firewall section. The API only supports access to cached (source=cached) statistical data collected offline in the system. Data includes total number of packets, bytes, sessions counters and popularity index for a firewall rule and overall session count, max session count and max popularity index for all firewall rules on transport nodes or edge nodes. Aggregated statistics like maximum popularity index, maximum session count and total session count are computed with lower frequency compared to individual generic rule statistics, hence they may have a computation delay up to 15 minutes to reflect in response to this API. 
    # @param section_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [FirewallStatsList]
    def get_firewall_section_stats(section_id, opts = {})
      data, _status_code, _headers = get_firewall_section_stats_with_http_info(section_id, opts)
      return data
    end

    # Get Firewall section level statistics section
    # Get aggregated statistics for all rules for a given firewall section. The API only supports access to cached (source&#x3D;cached) statistical data collected offline in the system. Data includes total number of packets, bytes, sessions counters and popularity index for a firewall rule and overall session count, max session count and max popularity index for all firewall rules on transport nodes or edge nodes. Aggregated statistics like maximum popularity index, maximum session count and total session count are computed with lower frequency compared to individual generic rule statistics, hence they may have a computation delay up to 15 minutes to reflect in response to this API. 
    # @param section_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(FirewallStatsList, Fixnum, Hash)>] FirewallStatsList data, response status code and response headers
    def get_firewall_section_stats_with_http_info(section_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_firewall_section_stats ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.get_firewall_section_stats"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/firewall/sections/{section-id}/rules/stats".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallStatsList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_firewall_section_stats\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Firewall rule level statistics
    # Get aggregated statistics for a rule for given firewall section. The API only supports access to cached (source=cached) statistical data collected offline in the system. Data includes total number of packets, bytes, sessions counters and popularity index for a firewall rule and overall session count, max session count and max popularity index for all firewall rules on transport nodes or edge nodes. Aggregated statistics like maximum popularity index, maximum session count and total session count are computed with lower frequency compared to individual generic rule statistics, hence they may have a computation delay up to 15 minutes to reflect in response to this API. 
    # @param section_id 
    # @param rule_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [FirewallStats]
    def get_firewall_stats(section_id, rule_id, opts = {})
      data, _status_code, _headers = get_firewall_stats_with_http_info(section_id, rule_id, opts)
      return data
    end

    # Get Firewall rule level statistics
    # Get aggregated statistics for a rule for given firewall section. The API only supports access to cached (source&#x3D;cached) statistical data collected offline in the system. Data includes total number of packets, bytes, sessions counters and popularity index for a firewall rule and overall session count, max session count and max popularity index for all firewall rules on transport nodes or edge nodes. Aggregated statistics like maximum popularity index, maximum session count and total session count are computed with lower frequency compared to individual generic rule statistics, hence they may have a computation delay up to 15 minutes to reflect in response to this API. 
    # @param section_id 
    # @param rule_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(FirewallStats, Fixnum, Hash)>] FirewallStats data, response status code and response headers
    def get_firewall_stats_with_http_info(section_id, rule_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_firewall_stats ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.get_firewall_stats"
      end
      # verify the required parameter 'rule_id' is set
      if @api_client.config.client_side_validation && rule_id.nil?
        fail ArgumentError, "Missing the required parameter 'rule_id' when calling ServicesApi.get_firewall_stats"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/firewall/sections/{section-id}/rules/{rule-id}/stats".sub('{' + 'section-id' + '}', section_id.to_s).sub('{' + 'rule-id' + '}', rule_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallStats')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_firewall_stats\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get firewall global status for dfw context
    # Get firewall global status for dfw context
    # @param context_type 
    # @param [Hash] opts the optional parameters
    # @return [FirewallStatus]
    def get_firewall_status(context_type, opts = {})
      data, _status_code, _headers = get_firewall_status_with_http_info(context_type, opts)
      return data
    end

    # Get firewall global status for dfw context
    # Get firewall global status for dfw context
    # @param context_type 
    # @param [Hash] opts the optional parameters
    # @return [Array<(FirewallStatus, Fixnum, Hash)>] FirewallStatus data, response status code and response headers
    def get_firewall_status_with_http_info(context_type, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_firewall_status ..."
      end
      # verify the required parameter 'context_type' is set
      if @api_client.config.client_side_validation && context_type.nil?
        fail ArgumentError, "Missing the required parameter 'context_type' when calling ServicesApi.get_firewall_status"
      end
      # resource path
      local_var_path = "/firewall/status/{context-type}".sub('{' + 'context-type' + '}', context_type.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_firewall_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get firewall status for target resource in dfw context
    # Get firewall status for target resource in dfw context
    # @param context_type 
    # @param id 
    # @param [Hash] opts the optional parameters
    # @return [TargetResourceStatus]
    def get_firewall_status_on_target_resource(context_type, id, opts = {})
      data, _status_code, _headers = get_firewall_status_on_target_resource_with_http_info(context_type, id, opts)
      return data
    end

    # Get firewall status for target resource in dfw context
    # Get firewall status for target resource in dfw context
    # @param context_type 
    # @param id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TargetResourceStatus, Fixnum, Hash)>] TargetResourceStatus data, response status code and response headers
    def get_firewall_status_on_target_resource_with_http_info(context_type, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_firewall_status_on_target_resource ..."
      end
      # verify the required parameter 'context_type' is set
      if @api_client.config.client_side_validation && context_type.nil?
        fail ArgumentError, "Missing the required parameter 'context_type' when calling ServicesApi.get_firewall_status_on_target_resource"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling ServicesApi.get_firewall_status_on_target_resource"
      end
      # resource path
      local_var_path = "/firewall/status/{context-type}/{id}".sub('{' + 'context-type' + '}', context_type.to_s).sub('{' + 'id' + '}', id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TargetResourceStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_firewall_status_on_target_resource\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a particular instance endpoint for a service instance.
    # Returns detailed Endpoint information for a given InstanceEndpoint. 
    # @param service_id 
    # @param service_instance_id 
    # @param instance_endpoint 
    # @param [Hash] opts the optional parameters
    # @return [InstanceEndpoint]
    def get_instance_endpoint(service_id, service_instance_id, instance_endpoint, opts = {})
      data, _status_code, _headers = get_instance_endpoint_with_http_info(service_id, service_instance_id, instance_endpoint, opts)
      return data
    end

    # Get a particular instance endpoint for a service instance.
    # Returns detailed Endpoint information for a given InstanceEndpoint. 
    # @param service_id 
    # @param service_instance_id 
    # @param instance_endpoint 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InstanceEndpoint, Fixnum, Hash)>] InstanceEndpoint data, response status code and response headers
    def get_instance_endpoint_with_http_info(service_id, service_instance_id, instance_endpoint, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_instance_endpoint ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.get_instance_endpoint"
      end
      # verify the required parameter 'service_instance_id' is set
      if @api_client.config.client_side_validation && service_instance_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_instance_id' when calling ServicesApi.get_instance_endpoint"
      end
      # verify the required parameter 'instance_endpoint' is set
      if @api_client.config.client_side_validation && instance_endpoint.nil?
        fail ArgumentError, "Missing the required parameter 'instance_endpoint' when calling ServicesApi.get_instance_endpoint"
      end
      # resource path
      local_var_path = "/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/instance-endpoints/{instance-endpoint}".sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'service-instance-id' + '}', service_instance_id.to_s).sub('{' + 'instance-endpoint' + '}', instance_endpoint.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'InstanceEndpoint')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_instance_endpoint\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the statistics of load balancer pool
    # Returns the statistics of the given load balancer pool by given load balancer serives id and load balancer pool id. 
    # @param service_id 
    # @param pool_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [LbPoolStatistics]
    def get_load_balancer_pool_statistics(service_id, pool_id, opts = {})
      data, _status_code, _headers = get_load_balancer_pool_statistics_with_http_info(service_id, pool_id, opts)
      return data
    end

    # Get the statistics of load balancer pool
    # Returns the statistics of the given load balancer pool by given load balancer serives id and load balancer pool id. 
    # @param service_id 
    # @param pool_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(LbPoolStatistics, Fixnum, Hash)>] LbPoolStatistics data, response status code and response headers
    def get_load_balancer_pool_statistics_with_http_info(service_id, pool_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_load_balancer_pool_statistics ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.get_load_balancer_pool_statistics"
      end
      # verify the required parameter 'pool_id' is set
      if @api_client.config.client_side_validation && pool_id.nil?
        fail ArgumentError, "Missing the required parameter 'pool_id' when calling ServicesApi.get_load_balancer_pool_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/loadbalancer/services/{service-id}/pools/{pool-id}/statistics".sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'pool-id' + '}', pool_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbPoolStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_load_balancer_pool_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the status of load balancer pool
    # Returns the status of the given load balancer pool by given load balancer serives id and load balancer pool id. 
    # @param service_id 
    # @param pool_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [LbPoolStatus]
    def get_load_balancer_pool_status(service_id, pool_id, opts = {})
      data, _status_code, _headers = get_load_balancer_pool_status_with_http_info(service_id, pool_id, opts)
      return data
    end

    # Get the status of load balancer pool
    # Returns the status of the given load balancer pool by given load balancer serives id and load balancer pool id. 
    # @param service_id 
    # @param pool_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(LbPoolStatus, Fixnum, Hash)>] LbPoolStatus data, response status code and response headers
    def get_load_balancer_pool_status_with_http_info(service_id, pool_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_load_balancer_pool_status ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.get_load_balancer_pool_status"
      end
      # verify the required parameter 'pool_id' is set
      if @api_client.config.client_side_validation && pool_id.nil?
        fail ArgumentError, "Missing the required parameter 'pool_id' when calling ServicesApi.get_load_balancer_pool_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/loadbalancer/services/{service-id}/pools/{pool-id}/status".sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'pool-id' + '}', pool_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbPoolStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_load_balancer_pool_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the statistics of load balancer service
    # Returns the statistics of the given load balancer service. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [LbServiceStatistics]
    def get_load_balancer_service_statistics(service_id, opts = {})
      data, _status_code, _headers = get_load_balancer_service_statistics_with_http_info(service_id, opts)
      return data
    end

    # Get the statistics of load balancer service
    # Returns the statistics of the given load balancer service. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(LbServiceStatistics, Fixnum, Hash)>] LbServiceStatistics data, response status code and response headers
    def get_load_balancer_service_statistics_with_http_info(service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_load_balancer_service_statistics ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.get_load_balancer_service_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/loadbalancer/services/{service-id}/statistics".sub('{' + 'service-id' + '}', service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbServiceStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_load_balancer_service_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the status of the given load balancer service
    # Returns the status of the given load balancer service. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [LbServiceStatus]
    def get_load_balancer_service_status(service_id, opts = {})
      data, _status_code, _headers = get_load_balancer_service_status_with_http_info(service_id, opts)
      return data
    end

    # Get the status of the given load balancer service
    # Returns the status of the given load balancer service. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(LbServiceStatus, Fixnum, Hash)>] LbServiceStatus data, response status code and response headers
    def get_load_balancer_service_status_with_http_info(service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_load_balancer_service_status ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.get_load_balancer_service_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/loadbalancer/services/{service-id}/status".sub('{' + 'service-id' + '}', service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbServiceStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_load_balancer_service_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the statistics of the given load balancer virtual server
    # Returns the statistics of the load balancer virtual server by given load  balancer serives id and load balancer virtual server id. 
    # @param service_id 
    # @param virtual_server_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [LbVirtualServerStatistics]
    def get_load_balancer_virtual_server_statistics(service_id, virtual_server_id, opts = {})
      data, _status_code, _headers = get_load_balancer_virtual_server_statistics_with_http_info(service_id, virtual_server_id, opts)
      return data
    end

    # Get the statistics of the given load balancer virtual server
    # Returns the statistics of the load balancer virtual server by given load  balancer serives id and load balancer virtual server id. 
    # @param service_id 
    # @param virtual_server_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(LbVirtualServerStatistics, Fixnum, Hash)>] LbVirtualServerStatistics data, response status code and response headers
    def get_load_balancer_virtual_server_statistics_with_http_info(service_id, virtual_server_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_load_balancer_virtual_server_statistics ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.get_load_balancer_virtual_server_statistics"
      end
      # verify the required parameter 'virtual_server_id' is set
      if @api_client.config.client_side_validation && virtual_server_id.nil?
        fail ArgumentError, "Missing the required parameter 'virtual_server_id' when calling ServicesApi.get_load_balancer_virtual_server_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/loadbalancer/services/{service-id}/virtual-servers/{virtual-server-id}/statistics".sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'virtual-server-id' + '}', virtual_server_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbVirtualServerStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_load_balancer_virtual_server_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the status of the load balancer virtual server
    # Returns the status of the virtual server by given load balancer serives id and load balancer virtual server id. 
    # @param service_id 
    # @param virtual_server_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [LbVirtualServerStatus]
    def get_load_balancer_virtual_server_status(service_id, virtual_server_id, opts = {})
      data, _status_code, _headers = get_load_balancer_virtual_server_status_with_http_info(service_id, virtual_server_id, opts)
      return data
    end

    # Get the status of the load balancer virtual server
    # Returns the status of the virtual server by given load balancer serives id and load balancer virtual server id. 
    # @param service_id 
    # @param virtual_server_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(LbVirtualServerStatus, Fixnum, Hash)>] LbVirtualServerStatus data, response status code and response headers
    def get_load_balancer_virtual_server_status_with_http_info(service_id, virtual_server_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_load_balancer_virtual_server_status ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.get_load_balancer_virtual_server_status"
      end
      # verify the required parameter 'virtual_server_id' is set
      if @api_client.config.client_side_validation && virtual_server_id.nil?
        fail ArgumentError, "Missing the required parameter 'virtual_server_id' when calling ServicesApi.get_load_balancer_virtual_server_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/loadbalancer/services/{service-id}/virtual-servers/{virtual-server-id}/status".sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'virtual-server-id' + '}', virtual_server_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbVirtualServerStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_load_balancer_virtual_server_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Metadata Proxy statistics with given proxy id
    # Returns the statistics of the given metatada proxy. If no logical switch is provided, all staticstics of all the logical switches the proxy was attached will be returned. 
    # @param proxy_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :logical_switch_id The uuid of logical switch
    # @option opts [String] :source Data source type.
    # @return [MetadataProxyStatistics]
    def get_metadata_proxy_statistics(proxy_id, opts = {})
      data, _status_code, _headers = get_metadata_proxy_statistics_with_http_info(proxy_id, opts)
      return data
    end

    # Get Metadata Proxy statistics with given proxy id
    # Returns the statistics of the given metatada proxy. If no logical switch is provided, all staticstics of all the logical switches the proxy was attached will be returned. 
    # @param proxy_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :logical_switch_id The uuid of logical switch
    # @option opts [String] :source Data source type.
    # @return [Array<(MetadataProxyStatistics, Fixnum, Hash)>] MetadataProxyStatistics data, response status code and response headers
    def get_metadata_proxy_statistics_with_http_info(proxy_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_metadata_proxy_statistics ..."
      end
      # verify the required parameter 'proxy_id' is set
      if @api_client.config.client_side_validation && proxy_id.nil?
        fail ArgumentError, "Missing the required parameter 'proxy_id' when calling ServicesApi.get_metadata_proxy_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/md-proxies/{proxy-id}/statistics".sub('{' + 'proxy-id' + '}', proxy_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'logical_switch_id'] = opts[:'logical_switch_id'] if !opts[:'logical_switch_id'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MetadataProxyStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_metadata_proxy_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Metadata Proxy status with given proxy id and attached logical switch.
    # Returns the status of the given metadata proxy and attached logical switch. 
    # @param proxy_id 
    # @param logical_switch_id 
    # @param [Hash] opts the optional parameters
    # @return [MetadataProxyStatus]
    def get_metadata_proxy_status(proxy_id, logical_switch_id, opts = {})
      data, _status_code, _headers = get_metadata_proxy_status_with_http_info(proxy_id, logical_switch_id, opts)
      return data
    end

    # Get Metadata Proxy status with given proxy id and attached logical switch.
    # Returns the status of the given metadata proxy and attached logical switch. 
    # @param proxy_id 
    # @param logical_switch_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(MetadataProxyStatus, Fixnum, Hash)>] MetadataProxyStatus data, response status code and response headers
    def get_metadata_proxy_status_with_http_info(proxy_id, logical_switch_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_metadata_proxy_status ..."
      end
      # verify the required parameter 'proxy_id' is set
      if @api_client.config.client_side_validation && proxy_id.nil?
        fail ArgumentError, "Missing the required parameter 'proxy_id' when calling ServicesApi.get_metadata_proxy_status"
      end
      # verify the required parameter 'logical_switch_id' is set
      if @api_client.config.client_side_validation && logical_switch_id.nil?
        fail ArgumentError, "Missing the required parameter 'logical_switch_id' when calling ServicesApi.get_metadata_proxy_status"
      end
      # resource path
      local_var_path = "/md-proxies/{proxy-id}/{logical-switch-id}/status".sub('{' + 'proxy-id' + '}', proxy_id.to_s).sub('{' + 'logical-switch-id' + '}', logical_switch_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MetadataProxyStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_metadata_proxy_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Read an Existing Rule
    # Return existing firewall rule information in a firewall section. 
    # @param section_id 
    # @param rule_id 
    # @param [Hash] opts the optional parameters
    # @return [FirewallRule]
    def get_rule(section_id, rule_id, opts = {})
      data, _status_code, _headers = get_rule_with_http_info(section_id, rule_id, opts)
      return data
    end

    # Read an Existing Rule
    # Return existing firewall rule information in a firewall section. 
    # @param section_id 
    # @param rule_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(FirewallRule, Fixnum, Hash)>] FirewallRule data, response status code and response headers
    def get_rule_with_http_info(section_id, rule_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_rule ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.get_rule"
      end
      # verify the required parameter 'rule_id' is set
      if @api_client.config.client_side_validation && rule_id.nil?
        fail ArgumentError, "Missing the required parameter 'rule_id' when calling ServicesApi.get_rule"
      end
      # resource path
      local_var_path = "/firewall/sections/{section-id}/rules/{rule-id}".sub('{' + 'section-id' + '}', section_id.to_s).sub('{' + 'rule-id' + '}', rule_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallRule')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the Realized State of a Firewall Rule
    # Return realized state information of a firewall rule. 
    # @param rule_id 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :barrier_id 
    # @option opts [String] :request_id Realization request ID
    # @return [RuleState]
    def get_rule_state(rule_id, opts = {})
      data, _status_code, _headers = get_rule_state_with_http_info(rule_id, opts)
      return data
    end

    # Get the Realized State of a Firewall Rule
    # Return realized state information of a firewall rule. 
    # @param rule_id 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :barrier_id 
    # @option opts [String] :request_id Realization request ID
    # @return [Array<(RuleState, Fixnum, Hash)>] RuleState data, response status code and response headers
    def get_rule_state_with_http_info(rule_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_rule_state ..."
      end
      # verify the required parameter 'rule_id' is set
      if @api_client.config.client_side_validation && rule_id.nil?
        fail ArgumentError, "Missing the required parameter 'rule_id' when calling ServicesApi.get_rule_state"
      end
      if @api_client.config.client_side_validation && !opts[:'barrier_id'].nil? && opts[:'barrier_id'] < 0
        fail ArgumentError, 'invalid value for "opts[:"barrier_id"]" when calling ServicesApi.get_rule_state, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/firewall/rules/{rule-id}/state".sub('{' + 'rule-id' + '}', rule_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'barrier_id'] = opts[:'barrier_id'] if !opts[:'barrier_id'].nil?
      query_params[:'request_id'] = opts[:'request_id'] if !opts[:'request_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RuleState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_rule_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get All the Rules for a Section
    # Return all firewall rule(s) information for a given firewall section. 
    # @param section_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :applied_tos AppliedTo&#39;s referenced by this section or section&#39;s Distributed Service Rules .
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :destinations Destinations referenced by this section&#39;s Distributed Service Rules .
    # @option opts [String] :filter_type Filter type (default to FILTER)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :search_invalid_references Return invalid references in results. (default to false)
    # @option opts [String] :services NSService referenced by this section&#39;s Distributed Service Rules .
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :sources Sources referenced by this section&#39;s Distributed Service Rules .
    # @return [FirewallRuleListResult]
    def get_rules(section_id, opts = {})
      data, _status_code, _headers = get_rules_with_http_info(section_id, opts)
      return data
    end

    # Get All the Rules for a Section
    # Return all firewall rule(s) information for a given firewall section. 
    # @param section_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :applied_tos AppliedTo&#39;s referenced by this section or section&#39;s Distributed Service Rules .
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :destinations Destinations referenced by this section&#39;s Distributed Service Rules .
    # @option opts [String] :filter_type Filter type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :search_invalid_references Return invalid references in results.
    # @option opts [String] :services NSService referenced by this section&#39;s Distributed Service Rules .
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :sources Sources referenced by this section&#39;s Distributed Service Rules .
    # @return [Array<(FirewallRuleListResult, Fixnum, Hash)>] FirewallRuleListResult data, response status code and response headers
    def get_rules_with_http_info(section_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_rules ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.get_rules"
      end
      if @api_client.config.client_side_validation && opts[:'filter_type'] && !['FILTER', 'SEARCH'].include?(opts[:'filter_type'])
        fail ArgumentError, 'invalid value for "filter_type", must be one of FILTER, SEARCH'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.get_rules, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.get_rules, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/firewall/sections/{section-id}/rules".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'applied_tos'] = opts[:'applied_tos'] if !opts[:'applied_tos'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'destinations'] = opts[:'destinations'] if !opts[:'destinations'].nil?
      query_params[:'filter_type'] = opts[:'filter_type'] if !opts[:'filter_type'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'search_invalid_references'] = opts[:'search_invalid_references'] if !opts[:'search_invalid_references'].nil?
      query_params[:'services'] = opts[:'services'] if !opts[:'services'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'sources'] = opts[:'sources'] if !opts[:'sources'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallRuleListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_rules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get operational status for an interface
    # Returns operational status of a specified interface
    # @param service_id 
    # @param service_instance_id 
    # @param instance_runtime_id 
    # @param interface_index 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [RuntimeInterfaceOperationalStatus]
    def get_runtime_interface_operational_status(service_id, service_instance_id, instance_runtime_id, interface_index, opts = {})
      data, _status_code, _headers = get_runtime_interface_operational_status_with_http_info(service_id, service_instance_id, instance_runtime_id, interface_index, opts)
      return data
    end

    # Get operational status for an interface
    # Returns operational status of a specified interface
    # @param service_id 
    # @param service_instance_id 
    # @param instance_runtime_id 
    # @param interface_index 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(RuntimeInterfaceOperationalStatus, Fixnum, Hash)>] RuntimeInterfaceOperationalStatus data, response status code and response headers
    def get_runtime_interface_operational_status_with_http_info(service_id, service_instance_id, instance_runtime_id, interface_index, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_runtime_interface_operational_status ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.get_runtime_interface_operational_status"
      end
      # verify the required parameter 'service_instance_id' is set
      if @api_client.config.client_side_validation && service_instance_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_instance_id' when calling ServicesApi.get_runtime_interface_operational_status"
      end
      # verify the required parameter 'instance_runtime_id' is set
      if @api_client.config.client_side_validation && instance_runtime_id.nil?
        fail ArgumentError, "Missing the required parameter 'instance_runtime_id' when calling ServicesApi.get_runtime_interface_operational_status"
      end
      # verify the required parameter 'interface_index' is set
      if @api_client.config.client_side_validation && interface_index.nil?
        fail ArgumentError, "Missing the required parameter 'interface_index' when calling ServicesApi.get_runtime_interface_operational_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/instance-runtimes/{instance-runtime-id}/interfaces/{interface_index}/status".sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'service-instance-id' + '}', service_instance_id.to_s).sub('{' + 'instance-runtime-id' + '}', instance_runtime_id.to_s).sub('{' + 'interface_index' + '}', interface_index.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RuntimeInterfaceOperationalStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_runtime_interface_operational_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get statistics for a given interface identified by the interface index
    # Returns statistics of a specified interface via associated logical port. If the logical port is attached to a logical router port, query parameter \"source=realtime\" is not supported. 
    # @param service_id 
    # @param service_instance_id 
    # @param instance_runtime_id 
    # @param interface_index 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [RuntimeInterfaceStatistics]
    def get_runtime_interface_statistics(service_id, service_instance_id, instance_runtime_id, interface_index, opts = {})
      data, _status_code, _headers = get_runtime_interface_statistics_with_http_info(service_id, service_instance_id, instance_runtime_id, interface_index, opts)
      return data
    end

    # Get statistics for a given interface identified by the interface index
    # Returns statistics of a specified interface via associated logical port. If the logical port is attached to a logical router port, query parameter \&quot;source&#x3D;realtime\&quot; is not supported. 
    # @param service_id 
    # @param service_instance_id 
    # @param instance_runtime_id 
    # @param interface_index 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(RuntimeInterfaceStatistics, Fixnum, Hash)>] RuntimeInterfaceStatistics data, response status code and response headers
    def get_runtime_interface_statistics_with_http_info(service_id, service_instance_id, instance_runtime_id, interface_index, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_runtime_interface_statistics ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.get_runtime_interface_statistics"
      end
      # verify the required parameter 'service_instance_id' is set
      if @api_client.config.client_side_validation && service_instance_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_instance_id' when calling ServicesApi.get_runtime_interface_statistics"
      end
      # verify the required parameter 'instance_runtime_id' is set
      if @api_client.config.client_side_validation && instance_runtime_id.nil?
        fail ArgumentError, "Missing the required parameter 'instance_runtime_id' when calling ServicesApi.get_runtime_interface_statistics"
      end
      # verify the required parameter 'interface_index' is set
      if @api_client.config.client_side_validation && interface_index.nil?
        fail ArgumentError, "Missing the required parameter 'interface_index' when calling ServicesApi.get_runtime_interface_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/instance-runtimes/{instance-runtime-id}/interfaces/{interface_index}/statistics".sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'service-instance-id' + '}', service_instance_id.to_s).sub('{' + 'instance-runtime-id' + '}', instance_runtime_id.to_s).sub('{' + 'interface_index' + '}', interface_index.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RuntimeInterfaceStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_runtime_interface_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get an Existing Section
    # Returns information about firewall section for the identifier. 
    # @param section_id 
    # @param [Hash] opts the optional parameters
    # @return [FirewallSection]
    def get_section(section_id, opts = {})
      data, _status_code, _headers = get_section_with_http_info(section_id, opts)
      return data
    end

    # Get an Existing Section
    # Returns information about firewall section for the identifier. 
    # @param section_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(FirewallSection, Fixnum, Hash)>] FirewallSection data, response status code and response headers
    def get_section_with_http_info(section_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_section ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.get_section"
      end
      # resource path
      local_var_path = "/firewall/sections/{section-id}".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallSection')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_section\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the Realized State of a Firewall Section
    # Return realized state information of a firewall section. 
    # @param section_id 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :barrier_id 
    # @option opts [String] :request_id Realization request ID
    # @return [FirewallSectionState]
    def get_section_state(section_id, opts = {})
      data, _status_code, _headers = get_section_state_with_http_info(section_id, opts)
      return data
    end

    # Get the Realized State of a Firewall Section
    # Return realized state information of a firewall section. 
    # @param section_id 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :barrier_id 
    # @option opts [String] :request_id Realization request ID
    # @return [Array<(FirewallSectionState, Fixnum, Hash)>] FirewallSectionState data, response status code and response headers
    def get_section_state_with_http_info(section_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_section_state ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.get_section_state"
      end
      if @api_client.config.client_side_validation && !opts[:'barrier_id'].nil? && opts[:'barrier_id'] < 0
        fail ArgumentError, 'invalid value for "opts[:"barrier_id"]" when calling ServicesApi.get_section_state, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/firewall/sections/{section-id}/state".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'barrier_id'] = opts[:'barrier_id'] if !opts[:'barrier_id'].nil?
      query_params[:'request_id'] = opts[:'request_id'] if !opts[:'request_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallSectionState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_section_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get an Existing Section, Including Rules
    # Returns firewall section information with rules for a section identifier. When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules with a large number rule references is not supported.  Instead, to read firewall rules, use: GET /api/v1/firewall/sections/&lt;section-id&gt;/rules with the appropriate page_size. 
    # @param section_id 
    # @param [Hash] opts the optional parameters
    # @return [FirewallSectionRuleList]
    def get_section_with_rules_list_with_rules(section_id, opts = {})
      data, _status_code, _headers = get_section_with_rules_list_with_rules_with_http_info(section_id, opts)
      return data
    end

    # Get an Existing Section, Including Rules
    # Returns firewall section information with rules for a section identifier. When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules with a large number rule references is not supported.  Instead, to read firewall rules, use: GET /api/v1/firewall/sections/&amp;lt;section-id&amp;gt;/rules with the appropriate page_size. 
    # @param section_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(FirewallSectionRuleList, Fixnum, Hash)>] FirewallSectionRuleList data, response status code and response headers
    def get_section_with_rules_list_with_rules_with_http_info(section_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_section_with_rules_list_with_rules ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.get_section_with_rules_list_with_rules"
      end
      # resource path
      local_var_path = "/firewall/sections/{section-id}?action=list_with_rules".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallSectionRuleList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_section_with_rules_list_with_rules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the summary of sections in the firewall configuration.
    # List the summary of number of sections and number of rules for each firewall category (L2DFW, L3DFW). 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [FirewallSectionsSummaryList]
    def get_sections_summary(opts = {})
      data, _status_code, _headers = get_sections_summary_with_http_info(opts)
      return data
    end

    # Get the summary of sections in the firewall configuration.
    # List the summary of number of sections and number of rules for each firewall category (L2DFW, L3DFW). 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(FirewallSectionsSummaryList, Fixnum, Hash)>] FirewallSectionsSummaryList data, response status code and response headers
    def get_sections_summary_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_sections_summary ..."
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/firewall/sections/summary"

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallSectionsSummaryList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_sections_summary\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a particular service attachment.
    # Returns detailed Attachment information for a given service attachment. 
    # @param service_attachment_id 
    # @param [Hash] opts the optional parameters
    # @return [ServiceAttachment]
    def get_service_attachment(service_attachment_id, opts = {})
      data, _status_code, _headers = get_service_attachment_with_http_info(service_attachment_id, opts)
      return data
    end

    # Get a particular service attachment.
    # Returns detailed Attachment information for a given service attachment. 
    # @param service_attachment_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ServiceAttachment, Fixnum, Hash)>] ServiceAttachment data, response status code and response headers
    def get_service_attachment_with_http_info(service_attachment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_service_attachment ..."
      end
      # verify the required parameter 'service_attachment_id' is set
      if @api_client.config.client_side_validation && service_attachment_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_attachment_id' when calling ServicesApi.get_service_attachment"
      end
      # resource path
      local_var_path = "/serviceinsertion/service-attachments/{service-attachment-id}".sub('{' + 'service-attachment-id' + '}', service_attachment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceAttachment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_service_attachment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Read an Existing Rule
    # Return existing serviceinsertion rule information in a serviceinsertion section. 
    # @param section_id 
    # @param rule_id 
    # @param [Hash] opts the optional parameters
    # @return [ServiceInsertionRule]
    def get_service_insertion_rule(section_id, rule_id, opts = {})
      data, _status_code, _headers = get_service_insertion_rule_with_http_info(section_id, rule_id, opts)
      return data
    end

    # Read an Existing Rule
    # Return existing serviceinsertion rule information in a serviceinsertion section. 
    # @param section_id 
    # @param rule_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ServiceInsertionRule, Fixnum, Hash)>] ServiceInsertionRule data, response status code and response headers
    def get_service_insertion_rule_with_http_info(section_id, rule_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_service_insertion_rule ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.get_service_insertion_rule"
      end
      # verify the required parameter 'rule_id' is set
      if @api_client.config.client_side_validation && rule_id.nil?
        fail ArgumentError, "Missing the required parameter 'rule_id' when calling ServicesApi.get_service_insertion_rule"
      end
      # resource path
      local_var_path = "/serviceinsertion/sections/{section-id}/rules/{rule-id}".sub('{' + 'section-id' + '}', section_id.to_s).sub('{' + 'rule-id' + '}', rule_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceInsertionRule')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_service_insertion_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get All the Rules for a Section
    # Return all serviceinsertion rule(s) information for a given serviceinsertion section. 
    # @param section_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :applied_tos AppliedTo&#39;s referenced by this section or section&#39;s Distributed Service Rules .
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :destinations Destinations referenced by this section&#39;s Distributed Service Rules .
    # @option opts [String] :filter_type Filter type (default to FILTER)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :services NSService referenced by this section&#39;s Distributed Service Rules .
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :sources Sources referenced by this section&#39;s Distributed Service Rules .
    # @return [ServiceInsertionRuleListResult]
    def get_service_insertion_rules(section_id, opts = {})
      data, _status_code, _headers = get_service_insertion_rules_with_http_info(section_id, opts)
      return data
    end

    # Get All the Rules for a Section
    # Return all serviceinsertion rule(s) information for a given serviceinsertion section. 
    # @param section_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :applied_tos AppliedTo&#39;s referenced by this section or section&#39;s Distributed Service Rules .
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :destinations Destinations referenced by this section&#39;s Distributed Service Rules .
    # @option opts [String] :filter_type Filter type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :services NSService referenced by this section&#39;s Distributed Service Rules .
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :sources Sources referenced by this section&#39;s Distributed Service Rules .
    # @return [Array<(ServiceInsertionRuleListResult, Fixnum, Hash)>] ServiceInsertionRuleListResult data, response status code and response headers
    def get_service_insertion_rules_with_http_info(section_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_service_insertion_rules ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.get_service_insertion_rules"
      end
      if @api_client.config.client_side_validation && opts[:'filter_type'] && !['FILTER', 'SEARCH'].include?(opts[:'filter_type'])
        fail ArgumentError, 'invalid value for "filter_type", must be one of FILTER, SEARCH'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.get_service_insertion_rules, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.get_service_insertion_rules, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/serviceinsertion/sections/{section-id}/rules".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'applied_tos'] = opts[:'applied_tos'] if !opts[:'applied_tos'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'destinations'] = opts[:'destinations'] if !opts[:'destinations'].nil?
      query_params[:'filter_type'] = opts[:'filter_type'] if !opts[:'filter_type'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'services'] = opts[:'services'] if !opts[:'services'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'sources'] = opts[:'sources'] if !opts[:'sources'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceInsertionRuleListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_service_insertion_rules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get an Existing Section
    # Returns information about serviceinsertion section for the identifier. 
    # @param section_id 
    # @param [Hash] opts the optional parameters
    # @return [ServiceInsertionSection]
    def get_service_insertion_section(section_id, opts = {})
      data, _status_code, _headers = get_service_insertion_section_with_http_info(section_id, opts)
      return data
    end

    # Get an Existing Section
    # Returns information about serviceinsertion section for the identifier. 
    # @param section_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ServiceInsertionSection, Fixnum, Hash)>] ServiceInsertionSection data, response status code and response headers
    def get_service_insertion_section_with_http_info(section_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_service_insertion_section ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.get_service_insertion_section"
      end
      # resource path
      local_var_path = "/serviceinsertion/sections/{section-id}".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceInsertionSection')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_service_insertion_section\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get an Existing Section, Including Rules
    # Returns serviceinsertion section information with rules for a section identifier. When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules are not supported.  Instead, to read serviceinsertion rules, use: GET /api/v1/serviceinsertion/sections/&lt;section-id&gt;/rules with the appropriate page_size. 
    # @param section_id 
    # @param [Hash] opts the optional parameters
    # @return [ServiceInsertionSectionRuleList]
    def get_service_insertion_section_with_rules_list_with_rules(section_id, opts = {})
      data, _status_code, _headers = get_service_insertion_section_with_rules_list_with_rules_with_http_info(section_id, opts)
      return data
    end

    # Get an Existing Section, Including Rules
    # Returns serviceinsertion section information with rules for a section identifier. When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules are not supported.  Instead, to read serviceinsertion rules, use: GET /api/v1/serviceinsertion/sections/&amp;lt;section-id&amp;gt;/rules with the appropriate page_size. 
    # @param section_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ServiceInsertionSectionRuleList, Fixnum, Hash)>] ServiceInsertionSectionRuleList data, response status code and response headers
    def get_service_insertion_section_with_rules_list_with_rules_with_http_info(section_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_service_insertion_section_with_rules_list_with_rules ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.get_service_insertion_section_with_rules_list_with_rules"
      end
      # resource path
      local_var_path = "/serviceinsertion/sections/{section-id}?action=list_with_rules".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceInsertionSectionRuleList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_service_insertion_section_with_rules_list_with_rules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get an existing Service
    # Returns information about Service-Insertion Service with the given identifier. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @return [ServiceDefinition]
    def get_service_insertion_service(service_id, opts = {})
      data, _status_code, _headers = get_service_insertion_service_with_http_info(service_id, opts)
      return data
    end

    # Get an existing Service
    # Returns information about Service-Insertion Service with the given identifier. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ServiceDefinition, Fixnum, Hash)>] ServiceDefinition data, response status code and response headers
    def get_service_insertion_service_with_http_info(service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_service_insertion_service ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.get_service_insertion_service"
      end
      # resource path
      local_var_path = "/serviceinsertion/services/{service-id}".sub('{' + 'service-id' + '}', service_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceDefinition')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_service_insertion_service\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Service-Instance for Service.
    # Returns Service-Instance information for a given Service-Insertion Service. 
    # @param service_id 
    # @param service_instance_id 
    # @param [Hash] opts the optional parameters
    # @return [BaseServiceInstance]
    def get_service_instance(service_id, service_instance_id, opts = {})
      data, _status_code, _headers = get_service_instance_with_http_info(service_id, service_instance_id, opts)
      return data
    end

    # Get Service-Instance for Service.
    # Returns Service-Instance information for a given Service-Insertion Service. 
    # @param service_id 
    # @param service_instance_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BaseServiceInstance, Fixnum, Hash)>] BaseServiceInstance data, response status code and response headers
    def get_service_instance_with_http_info(service_id, service_instance_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.get_service_instance ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.get_service_instance"
      end
      # verify the required parameter 'service_instance_id' is set
      if @api_client.config.client_side_validation && service_instance_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_instance_id' when calling ServicesApi.get_service_instance"
      end
      # resource path
      local_var_path = "/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}".sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'service-instance-id' + '}', service_instance_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BaseServiceInstance')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#get_service_instance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a paginated list of a DHCP server's IP pools
    # Get a paginated list of a DHCP server's IP pools
    # @param server_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [DhcpIpPoolListResult]
    def list_dhcp_ip_pools(server_id, opts = {})
      data, _status_code, _headers = list_dhcp_ip_pools_with_http_info(server_id, opts)
      return data
    end

    # Get a paginated list of a DHCP server&#39;s IP pools
    # Get a paginated list of a DHCP server&#39;s IP pools
    # @param server_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(DhcpIpPoolListResult, Fixnum, Hash)>] DhcpIpPoolListResult data, response status code and response headers
    def list_dhcp_ip_pools_with_http_info(server_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_dhcp_ip_pools ..."
      end
      # verify the required parameter 'server_id' is set
      if @api_client.config.client_side_validation && server_id.nil?
        fail ArgumentError, "Missing the required parameter 'server_id' when calling ServicesApi.list_dhcp_ip_pools"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_dhcp_ip_pools, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_dhcp_ip_pools, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/dhcp/servers/{server-id}/ip-pools".sub('{' + 'server-id' + '}', server_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DhcpIpPoolListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_dhcp_ip_pools\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a paginated list of DHCP server profiles
    # Get a paginated list of DHCP server profiles
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [DhcpProfileListResult]
    def list_dhcp_profiles(opts = {})
      data, _status_code, _headers = list_dhcp_profiles_with_http_info(opts)
      return data
    end

    # Get a paginated list of DHCP server profiles
    # Get a paginated list of DHCP server profiles
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(DhcpProfileListResult, Fixnum, Hash)>] DhcpProfileListResult data, response status code and response headers
    def list_dhcp_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_dhcp_profiles ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_dhcp_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_dhcp_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/dhcp/server-profiles"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DhcpProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_dhcp_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a paginated list of DHCP servers
    # Get a paginated list of DHCP servers
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [LogicalDhcpServerListResult]
    def list_dhcp_servers(opts = {})
      data, _status_code, _headers = list_dhcp_servers_with_http_info(opts)
      return data
    end

    # Get a paginated list of DHCP servers
    # Get a paginated list of DHCP servers
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(LogicalDhcpServerListResult, Fixnum, Hash)>] LogicalDhcpServerListResult data, response status code and response headers
    def list_dhcp_servers_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_dhcp_servers ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_dhcp_servers, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_dhcp_servers, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/dhcp/servers"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LogicalDhcpServerListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_dhcp_servers\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a paginated list of a DHCP server's static bindings
    # Get a paginated list of a DHCP server's static bindings
    # @param server_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [DhcpStaticBindingListResult]
    def list_dhcp_static_bindings(server_id, opts = {})
      data, _status_code, _headers = list_dhcp_static_bindings_with_http_info(server_id, opts)
      return data
    end

    # Get a paginated list of a DHCP server&#39;s static bindings
    # Get a paginated list of a DHCP server&#39;s static bindings
    # @param server_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(DhcpStaticBindingListResult, Fixnum, Hash)>] DhcpStaticBindingListResult data, response status code and response headers
    def list_dhcp_static_bindings_with_http_info(server_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_dhcp_static_bindings ..."
      end
      # verify the required parameter 'server_id' is set
      if @api_client.config.client_side_validation && server_id.nil?
        fail ArgumentError, "Missing the required parameter 'server_id' when calling ServicesApi.list_dhcp_static_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_dhcp_static_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_dhcp_static_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/dhcp/servers/{server-id}/static-bindings".sub('{' + 'server-id' + '}', server_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DhcpStaticBindingListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_dhcp_static_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a paginated list of dns forwarders
    # Get a paginated list of dns forwarders. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [DnsForwarderListResult]
    def list_dns_forwaders(opts = {})
      data, _status_code, _headers = list_dns_forwaders_with_http_info(opts)
      return data
    end

    # Get a paginated list of dns forwarders
    # Get a paginated list of dns forwarders. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(DnsForwarderListResult, Fixnum, Hash)>] DnsForwarderListResult data, response status code and response headers
    def list_dns_forwaders_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_dns_forwaders ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_dns_forwaders, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_dns_forwaders, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/dns/forwarders"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DnsForwarderListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_dns_forwaders\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List all firewall status for supported contexts
    # List all firewall status for supported contexts
    # @param [Hash] opts the optional parameters
    # @return [FirewallStatusListResult]
    def list_firewall_status(opts = {})
      data, _status_code, _headers = list_firewall_status_with_http_info(opts)
      return data
    end

    # List all firewall status for supported contexts
    # List all firewall status for supported contexts
    # @param [Hash] opts the optional parameters
    # @return [Array<(FirewallStatusListResult, Fixnum, Hash)>] FirewallStatusListResult data, response status code and response headers
    def list_firewall_status_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_firewall_status ..."
      end
      # resource path
      local_var_path = "/firewall/status"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallStatusListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_firewall_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List all InstanceEndpoints of a Service Instance.
    # List all InstanceEndpoints of a service instance. 
    # @param service_id 
    # @param service_instance_id 
    # @param [Hash] opts the optional parameters
    # @return [InstanceEndpointListResult]
    def list_instance_endpoints(service_id, service_instance_id, opts = {})
      data, _status_code, _headers = list_instance_endpoints_with_http_info(service_id, service_instance_id, opts)
      return data
    end

    # List all InstanceEndpoints of a Service Instance.
    # List all InstanceEndpoints of a service instance. 
    # @param service_id 
    # @param service_instance_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InstanceEndpointListResult, Fixnum, Hash)>] InstanceEndpointListResult data, response status code and response headers
    def list_instance_endpoints_with_http_info(service_id, service_instance_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_instance_endpoints ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.list_instance_endpoints"
      end
      # verify the required parameter 'service_instance_id' is set
      if @api_client.config.client_side_validation && service_instance_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_instance_id' when calling ServicesApi.list_instance_endpoints"
      end
      # resource path
      local_var_path = "/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/instance-endpoints".sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'service-instance-id' + '}', service_instance_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'InstanceEndpointListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_instance_endpoints\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Returns list of instance runtimes of service VM being deployed
    # Returns list of instance runtimes of service VMs being deployed for a given service instance id 
    # @param service_id 
    # @param service_instance_id 
    # @param [Hash] opts the optional parameters
    # @return [InstanceRuntimeListResult]
    def list_instance_runtimes(service_id, service_instance_id, opts = {})
      data, _status_code, _headers = list_instance_runtimes_with_http_info(service_id, service_instance_id, opts)
      return data
    end

    # Returns list of instance runtimes of service VM being deployed
    # Returns list of instance runtimes of service VMs being deployed for a given service instance id 
    # @param service_id 
    # @param service_instance_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InstanceRuntimeListResult, Fixnum, Hash)>] InstanceRuntimeListResult data, response status code and response headers
    def list_instance_runtimes_with_http_info(service_id, service_instance_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_instance_runtimes ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.list_instance_runtimes"
      end
      # verify the required parameter 'service_instance_id' is set
      if @api_client.config.client_side_validation && service_instance_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_instance_id' when calling ServicesApi.list_instance_runtimes"
      end
      # resource path
      local_var_path = "/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/instance-runtimes".sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'service-instance-id' + '}', service_instance_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'InstanceRuntimeListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_instance_runtimes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a paginated list of load balancer application profiles
    # Retrieve a paginated list of load balancer application profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type application profile type
    # @return [LbAppProfileListResult]
    def list_load_balancer_application_profiles(opts = {})
      data, _status_code, _headers = list_load_balancer_application_profiles_with_http_info(opts)
      return data
    end

    # Retrieve a paginated list of load balancer application profiles
    # Retrieve a paginated list of load balancer application profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type application profile type
    # @return [Array<(LbAppProfileListResult, Fixnum, Hash)>] LbAppProfileListResult data, response status code and response headers
    def list_load_balancer_application_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_load_balancer_application_profiles ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_application_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_application_profiles, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['LbHttpProfile', 'LbFastTcpProfile', 'LbFastUdpProfile'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of LbHttpProfile, LbFastTcpProfile, LbFastUdpProfile'
      end
      # resource path
      local_var_path = "/loadbalancer/application-profiles"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbAppProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_load_balancer_application_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a paginated list of load balancer client-ssl profiles
    # Retrieve a paginated list of load balancer client-ssl profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [LbClientSslProfileListResult]
    def list_load_balancer_client_ssl_profiles(opts = {})
      data, _status_code, _headers = list_load_balancer_client_ssl_profiles_with_http_info(opts)
      return data
    end

    # Retrieve a paginated list of load balancer client-ssl profiles
    # Retrieve a paginated list of load balancer client-ssl profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(LbClientSslProfileListResult, Fixnum, Hash)>] LbClientSslProfileListResult data, response status code and response headers
    def list_load_balancer_client_ssl_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_load_balancer_client_ssl_profiles ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_client_ssl_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_client_ssl_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/loadbalancer/client-ssl-profiles"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbClientSslProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_load_balancer_client_ssl_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a paginated list of load balancer monitors
    # Retrieve a paginated list of load balancer monitors. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type monitor query type
    # @return [LbMonitorListResult]
    def list_load_balancer_monitors(opts = {})
      data, _status_code, _headers = list_load_balancer_monitors_with_http_info(opts)
      return data
    end

    # Retrieve a paginated list of load balancer monitors
    # Retrieve a paginated list of load balancer monitors. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type monitor query type
    # @return [Array<(LbMonitorListResult, Fixnum, Hash)>] LbMonitorListResult data, response status code and response headers
    def list_load_balancer_monitors_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_load_balancer_monitors ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_monitors, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_monitors, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['LbHttpMonitor', 'LbHttpsMonitor', 'LbIcmpMonitor', 'LbTcpMonitor', 'LbUdpMonitor', 'LbPassiveMonitor', 'LbActiveMonitor'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of LbHttpMonitor, LbHttpsMonitor, LbIcmpMonitor, LbTcpMonitor, LbUdpMonitor, LbPassiveMonitor, LbActiveMonitor'
      end
      # resource path
      local_var_path = "/loadbalancer/monitors"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbMonitorListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_load_balancer_monitors\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a paginated list of load balancer persistence profiles
    # Retrieve a paginated list of load balancer persistence profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type persistence profile type
    # @return [LbPersistenceProfileListResult]
    def list_load_balancer_persistence_profiles(opts = {})
      data, _status_code, _headers = list_load_balancer_persistence_profiles_with_http_info(opts)
      return data
    end

    # Retrieve a paginated list of load balancer persistence profiles
    # Retrieve a paginated list of load balancer persistence profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type persistence profile type
    # @return [Array<(LbPersistenceProfileListResult, Fixnum, Hash)>] LbPersistenceProfileListResult data, response status code and response headers
    def list_load_balancer_persistence_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_load_balancer_persistence_profiles ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_persistence_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_persistence_profiles, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['LbCookiePersistenceProfile', 'LbSourceIpPersistenceProfile'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of LbCookiePersistenceProfile, LbSourceIpPersistenceProfile'
      end
      # resource path
      local_var_path = "/loadbalancer/persistence-profiles"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbPersistenceProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_load_balancer_persistence_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the statistics list of load balancer pools
    # Returns the statistics list of load balancer pools in given load balancer service. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [LbPoolStatisticsListResult]
    def list_load_balancer_pool_statistics(service_id, opts = {})
      data, _status_code, _headers = list_load_balancer_pool_statistics_with_http_info(service_id, opts)
      return data
    end

    # Get the statistics list of load balancer pools
    # Returns the statistics list of load balancer pools in given load balancer service. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(LbPoolStatisticsListResult, Fixnum, Hash)>] LbPoolStatisticsListResult data, response status code and response headers
    def list_load_balancer_pool_statistics_with_http_info(service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_load_balancer_pool_statistics ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.list_load_balancer_pool_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/loadbalancer/services/{service-id}/pools/statistics".sub('{' + 'service-id' + '}', service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbPoolStatisticsListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_load_balancer_pool_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the status list of load balancer pools
    # Returns the status list of load balancer pools in given load balancer service. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [LbPoolStatusListResult]
    def list_load_balancer_pool_statuses(service_id, opts = {})
      data, _status_code, _headers = list_load_balancer_pool_statuses_with_http_info(service_id, opts)
      return data
    end

    # Get the status list of load balancer pools
    # Returns the status list of load balancer pools in given load balancer service. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(LbPoolStatusListResult, Fixnum, Hash)>] LbPoolStatusListResult data, response status code and response headers
    def list_load_balancer_pool_statuses_with_http_info(service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_load_balancer_pool_statuses ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.list_load_balancer_pool_statuses"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/loadbalancer/services/{service-id}/pools/status".sub('{' + 'service-id' + '}', service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbPoolStatusListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_load_balancer_pool_statuses\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a paginated list of load balancer pools
    # Retrieve a paginated list of load balancer pools. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [LbPoolListResult]
    def list_load_balancer_pools(opts = {})
      data, _status_code, _headers = list_load_balancer_pools_with_http_info(opts)
      return data
    end

    # Retrieve a paginated list of load balancer pools
    # Retrieve a paginated list of load balancer pools. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(LbPoolListResult, Fixnum, Hash)>] LbPoolListResult data, response status code and response headers
    def list_load_balancer_pools_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_load_balancer_pools ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_pools, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_pools, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/loadbalancer/pools"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbPoolListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_load_balancer_pools\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a paginated list of load balancer rules
    # Retrieve a paginated list of load balancer rules. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [LbRuleListResult]
    def list_load_balancer_rules(opts = {})
      data, _status_code, _headers = list_load_balancer_rules_with_http_info(opts)
      return data
    end

    # Retrieve a paginated list of load balancer rules
    # Retrieve a paginated list of load balancer rules. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(LbRuleListResult, Fixnum, Hash)>] LbRuleListResult data, response status code and response headers
    def list_load_balancer_rules_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_load_balancer_rules ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_rules, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_rules, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/loadbalancer/rules"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbRuleListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_load_balancer_rules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a paginated list of load balancer server-ssl profiles
    # Retrieve a paginated list of load balancer server-ssl profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [LbServerSslProfileListResult]
    def list_load_balancer_server_ssl_profiles(opts = {})
      data, _status_code, _headers = list_load_balancer_server_ssl_profiles_with_http_info(opts)
      return data
    end

    # Retrieve a paginated list of load balancer server-ssl profiles
    # Retrieve a paginated list of load balancer server-ssl profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(LbServerSslProfileListResult, Fixnum, Hash)>] LbServerSslProfileListResult data, response status code and response headers
    def list_load_balancer_server_ssl_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_load_balancer_server_ssl_profiles ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_server_ssl_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_server_ssl_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/loadbalancer/server-ssl-profiles"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbServerSslProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_load_balancer_server_ssl_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a paginated list of load balancer services
    # Retrieve a paginated list of load balancer services. When logical_router_id is specified in request parameters, the associated load balancer services which are related to the given logical router returned. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :logical_router_id Logical router identifier
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [LbServiceListResult]
    def list_load_balancer_services(opts = {})
      data, _status_code, _headers = list_load_balancer_services_with_http_info(opts)
      return data
    end

    # Retrieve a paginated list of load balancer services
    # Retrieve a paginated list of load balancer services. When logical_router_id is specified in request parameters, the associated load balancer services which are related to the given logical router returned. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :logical_router_id Logical router identifier
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(LbServiceListResult, Fixnum, Hash)>] LbServiceListResult data, response status code and response headers
    def list_load_balancer_services_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_load_balancer_services ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_services, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_services, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/loadbalancer/services"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'logical_router_id'] = opts[:'logical_router_id'] if !opts[:'logical_router_id'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbServiceListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_load_balancer_services\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a list of supported SSL ciphers and protocols
    # Retrieve a list of supported SSL ciphers and protocols. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [LbSslCipherAndProtocolListResult]
    def list_load_balancer_ssl_ciphers_and_protocols(opts = {})
      data, _status_code, _headers = list_load_balancer_ssl_ciphers_and_protocols_with_http_info(opts)
      return data
    end

    # Retrieve a list of supported SSL ciphers and protocols
    # Retrieve a list of supported SSL ciphers and protocols. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(LbSslCipherAndProtocolListResult, Fixnum, Hash)>] LbSslCipherAndProtocolListResult data, response status code and response headers
    def list_load_balancer_ssl_ciphers_and_protocols_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_load_balancer_ssl_ciphers_and_protocols ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_ssl_ciphers_and_protocols, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_ssl_ciphers_and_protocols, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/loadbalancer/ssl/ciphers-and-protocols"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbSslCipherAndProtocolListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_load_balancer_ssl_ciphers_and_protocols\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a paginated list of load balancer TCP profiles
    # Retrieve a paginated list of load balancer TCP profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [LbTcpProfileListResult]
    def list_load_balancer_tcp_profiles(opts = {})
      data, _status_code, _headers = list_load_balancer_tcp_profiles_with_http_info(opts)
      return data
    end

    # Retrieve a paginated list of load balancer TCP profiles
    # Retrieve a paginated list of load balancer TCP profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(LbTcpProfileListResult, Fixnum, Hash)>] LbTcpProfileListResult data, response status code and response headers
    def list_load_balancer_tcp_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_load_balancer_tcp_profiles ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_tcp_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_tcp_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/loadbalancer/tcp-profiles"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbTcpProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_load_balancer_tcp_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the status list of virtual servers in given load balancer service
    # Returns the status list of virtual servers in given load balancer service. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [LbVirtualServerStatusListResult]
    def list_load_balancer_virtual_server_statuses(service_id, opts = {})
      data, _status_code, _headers = list_load_balancer_virtual_server_statuses_with_http_info(service_id, opts)
      return data
    end

    # Get the status list of virtual servers in given load balancer service
    # Returns the status list of virtual servers in given load balancer service. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(LbVirtualServerStatusListResult, Fixnum, Hash)>] LbVirtualServerStatusListResult data, response status code and response headers
    def list_load_balancer_virtual_server_statuses_with_http_info(service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_load_balancer_virtual_server_statuses ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.list_load_balancer_virtual_server_statuses"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/loadbalancer/services/{service-id}/virtual-servers/status".sub('{' + 'service-id' + '}', service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbVirtualServerStatusListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_load_balancer_virtual_server_statuses\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a paginated list of load balancer virtual servers
    # Retrieve a paginated list of load balancer virtual servers. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [LbVirtualServerListResult]
    def list_load_balancer_virtual_servers(opts = {})
      data, _status_code, _headers = list_load_balancer_virtual_servers_with_http_info(opts)
      return data
    end

    # Retrieve a paginated list of load balancer virtual servers
    # Retrieve a paginated list of load balancer virtual servers. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(LbVirtualServerListResult, Fixnum, Hash)>] LbVirtualServerListResult data, response status code and response headers
    def list_load_balancer_virtual_servers_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_load_balancer_virtual_servers ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_virtual_servers, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_load_balancer_virtual_servers, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/loadbalancer/virtual-servers"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbVirtualServerListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_load_balancer_virtual_servers\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the statistics list of virtual servers
    # Returns the statistics list of virtual servers in given load balancer service. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [LbVirtualServerStatisticsListResult]
    def list_load_balancer_virtual_servers_statistics(service_id, opts = {})
      data, _status_code, _headers = list_load_balancer_virtual_servers_statistics_with_http_info(service_id, opts)
      return data
    end

    # Get the statistics list of virtual servers
    # Returns the statistics list of virtual servers in given load balancer service. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(LbVirtualServerStatisticsListResult, Fixnum, Hash)>] LbVirtualServerStatisticsListResult data, response status code and response headers
    def list_load_balancer_virtual_servers_statistics_with_http_info(service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_load_balancer_virtual_servers_statistics ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.list_load_balancer_virtual_servers_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/loadbalancer/services/{service-id}/virtual-servers/statistics".sub('{' + 'service-id' + '}', service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbVirtualServerStatisticsListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_load_balancer_virtual_servers_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a paginated list of metadata proxies
    # Get a paginated list of metadata proxies
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [MetadataProxyListResult]
    def list_metadata_proxy(opts = {})
      data, _status_code, _headers = list_metadata_proxy_with_http_info(opts)
      return data
    end

    # Get a paginated list of metadata proxies
    # Get a paginated list of metadata proxies
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(MetadataProxyListResult, Fixnum, Hash)>] MetadataProxyListResult data, response status code and response headers
    def list_metadata_proxy_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_metadata_proxy ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_metadata_proxy, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_metadata_proxy, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/md-proxies"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MetadataProxyListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_metadata_proxy\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List All Firewall Sections
    # List all firewall section in paginated form. A default page size is limited to 1000 firewall sections. By default list of section is filtered by LAYER3 type. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :applied_tos AppliedTo&#39;s referenced by this section or section&#39;s Distributed Service Rules .
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :destinations Destinations referenced by this section&#39;s Distributed Service Rules .
    # @option opts [String] :enforced_on Type of attachment for logical port; for query only.
    # @option opts [String] :exclude_applied_to_type Resource type valid for use as AppliedTo filter in section API
    # @option opts [String] :filter_type Filter type (default to FILTER)
    # @option opts [String] :include_applied_to_type Resource type valid for use as AppliedTo filter in section API
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [BOOLEAN] :locked Limit results to sections which are locked/unlocked
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :search_invalid_references Return invalid references in results. (default to false)
    # @option opts [String] :search_scope Limit result to sections of a specific enforcement point
    # @option opts [String] :services NSService referenced by this section&#39;s Distributed Service Rules .
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :sources Sources referenced by this section&#39;s Distributed Service Rules .
    # @option opts [String] :type Section Type (default to LAYER3)
    # @return [FirewallSectionListResult]
    def list_sections(opts = {})
      data, _status_code, _headers = list_sections_with_http_info(opts)
      return data
    end

    # List All Firewall Sections
    # List all firewall section in paginated form. A default page size is limited to 1000 firewall sections. By default list of section is filtered by LAYER3 type. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :applied_tos AppliedTo&#39;s referenced by this section or section&#39;s Distributed Service Rules .
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :destinations Destinations referenced by this section&#39;s Distributed Service Rules .
    # @option opts [String] :enforced_on Type of attachment for logical port; for query only.
    # @option opts [String] :exclude_applied_to_type Resource type valid for use as AppliedTo filter in section API
    # @option opts [String] :filter_type Filter type
    # @option opts [String] :include_applied_to_type Resource type valid for use as AppliedTo filter in section API
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [BOOLEAN] :locked Limit results to sections which are locked/unlocked
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :search_invalid_references Return invalid references in results.
    # @option opts [String] :search_scope Limit result to sections of a specific enforcement point
    # @option opts [String] :services NSService referenced by this section&#39;s Distributed Service Rules .
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :sources Sources referenced by this section&#39;s Distributed Service Rules .
    # @option opts [String] :type Section Type
    # @return [Array<(FirewallSectionListResult, Fixnum, Hash)>] FirewallSectionListResult data, response status code and response headers
    def list_sections_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_sections ..."
      end
      if @api_client.config.client_side_validation && opts[:'enforced_on'] && !['VIF', 'LOGICALROUTER', 'BRIDGEENDPOINT', 'DHCP_SERVICE', 'METADATA_PROXY', 'L2VPN_SESSION', 'NONE'].include?(opts[:'enforced_on'])
        fail ArgumentError, 'invalid value for "enforced_on", must be one of VIF, LOGICALROUTER, BRIDGEENDPOINT, DHCP_SERVICE, METADATA_PROXY, L2VPN_SESSION, NONE'
      end
      if @api_client.config.client_side_validation && opts[:'exclude_applied_to_type'] && !['NSGroup', 'LogicalSwitch', 'LogicalRouter', 'LogicalPort'].include?(opts[:'exclude_applied_to_type'])
        fail ArgumentError, 'invalid value for "exclude_applied_to_type", must be one of NSGroup, LogicalSwitch, LogicalRouter, LogicalPort'
      end
      if @api_client.config.client_side_validation && opts[:'filter_type'] && !['FILTER', 'SEARCH'].include?(opts[:'filter_type'])
        fail ArgumentError, 'invalid value for "filter_type", must be one of FILTER, SEARCH'
      end
      if @api_client.config.client_side_validation && opts[:'include_applied_to_type'] && !['NSGroup', 'LogicalSwitch', 'LogicalRouter', 'LogicalPort'].include?(opts[:'include_applied_to_type'])
        fail ArgumentError, 'invalid value for "include_applied_to_type", must be one of NSGroup, LogicalSwitch, LogicalRouter, LogicalPort'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_sections, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_sections, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['LAYER2', 'LAYER3'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of LAYER2, LAYER3'
      end
      # resource path
      local_var_path = "/firewall/sections"

      # query parameters
      query_params = {}
      query_params[:'applied_tos'] = opts[:'applied_tos'] if !opts[:'applied_tos'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'destinations'] = opts[:'destinations'] if !opts[:'destinations'].nil?
      query_params[:'enforced_on'] = opts[:'enforced_on'] if !opts[:'enforced_on'].nil?
      query_params[:'exclude_applied_to_type'] = opts[:'exclude_applied_to_type'] if !opts[:'exclude_applied_to_type'].nil?
      query_params[:'filter_type'] = opts[:'filter_type'] if !opts[:'filter_type'].nil?
      query_params[:'include_applied_to_type'] = opts[:'include_applied_to_type'] if !opts[:'include_applied_to_type'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'locked'] = opts[:'locked'] if !opts[:'locked'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'search_invalid_references'] = opts[:'search_invalid_references'] if !opts[:'search_invalid_references'].nil?
      query_params[:'search_scope'] = opts[:'search_scope'] if !opts[:'search_scope'].nil?
      query_params[:'services'] = opts[:'services'] if !opts[:'services'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'sources'] = opts[:'sources'] if !opts[:'sources'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallSectionListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_sections\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get all service attachments.
    # Returns all Service-Attachement(s) present in the system. 
    # @param [Hash] opts the optional parameters
    # @return [ServiceAttachmentListResult]
    def list_service_attachments(opts = {})
      data, _status_code, _headers = list_service_attachments_with_http_info(opts)
      return data
    end

    # Get all service attachments.
    # Returns all Service-Attachement(s) present in the system. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ServiceAttachmentListResult, Fixnum, Hash)>] ServiceAttachmentListResult data, response status code and response headers
    def list_service_attachments_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_service_attachments ..."
      end
      # resource path
      local_var_path = "/serviceinsertion/service-attachments"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceAttachmentListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_service_attachments\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List All Service Insertion Sections
    # List all Service Insertion section in paginated form. A default page size is limited to 1000 sections. By default, the list of section is filtered by L3REDIRECT type. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :applied_tos AppliedTo&#39;s referenced by this section or section&#39;s Distributed Service Rules .
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :destinations Destinations referenced by this section&#39;s Distributed Service Rules .
    # @option opts [String] :exclude_applied_to_type Resource type valid for use as AppliedTo filter in section API
    # @option opts [String] :filter_type Filter type (default to FILTER)
    # @option opts [String] :include_applied_to_type Resource type valid for use as AppliedTo filter in section API
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :services NSService referenced by this section&#39;s Distributed Service Rules .
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :sources Sources referenced by this section&#39;s Distributed Service Rules .
    # @option opts [String] :type Section Type (default to L3REDIRECT)
    # @return [ServiceInsertionSectionListResult]
    def list_service_insertion_sections(opts = {})
      data, _status_code, _headers = list_service_insertion_sections_with_http_info(opts)
      return data
    end

    # List All Service Insertion Sections
    # List all Service Insertion section in paginated form. A default page size is limited to 1000 sections. By default, the list of section is filtered by L3REDIRECT type. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :applied_tos AppliedTo&#39;s referenced by this section or section&#39;s Distributed Service Rules .
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :destinations Destinations referenced by this section&#39;s Distributed Service Rules .
    # @option opts [String] :exclude_applied_to_type Resource type valid for use as AppliedTo filter in section API
    # @option opts [String] :filter_type Filter type
    # @option opts [String] :include_applied_to_type Resource type valid for use as AppliedTo filter in section API
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :services NSService referenced by this section&#39;s Distributed Service Rules .
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :sources Sources referenced by this section&#39;s Distributed Service Rules .
    # @option opts [String] :type Section Type
    # @return [Array<(ServiceInsertionSectionListResult, Fixnum, Hash)>] ServiceInsertionSectionListResult data, response status code and response headers
    def list_service_insertion_sections_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_service_insertion_sections ..."
      end
      if @api_client.config.client_side_validation && opts[:'exclude_applied_to_type'] && !['NSGroup', 'LogicalSwitch', 'LogicalRouter', 'LogicalPort'].include?(opts[:'exclude_applied_to_type'])
        fail ArgumentError, 'invalid value for "exclude_applied_to_type", must be one of NSGroup, LogicalSwitch, LogicalRouter, LogicalPort'
      end
      if @api_client.config.client_side_validation && opts[:'filter_type'] && !['FILTER', 'SEARCH'].include?(opts[:'filter_type'])
        fail ArgumentError, 'invalid value for "filter_type", must be one of FILTER, SEARCH'
      end
      if @api_client.config.client_side_validation && opts[:'include_applied_to_type'] && !['NSGroup', 'LogicalSwitch', 'LogicalRouter', 'LogicalPort'].include?(opts[:'include_applied_to_type'])
        fail ArgumentError, 'invalid value for "include_applied_to_type", must be one of NSGroup, LogicalSwitch, LogicalRouter, LogicalPort'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_service_insertion_sections, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ServicesApi.list_service_insertion_sections, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['L3REDIRECT'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of L3REDIRECT'
      end
      # resource path
      local_var_path = "/serviceinsertion/sections"

      # query parameters
      query_params = {}
      query_params[:'applied_tos'] = opts[:'applied_tos'] if !opts[:'applied_tos'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'destinations'] = opts[:'destinations'] if !opts[:'destinations'].nil?
      query_params[:'exclude_applied_to_type'] = opts[:'exclude_applied_to_type'] if !opts[:'exclude_applied_to_type'].nil?
      query_params[:'filter_type'] = opts[:'filter_type'] if !opts[:'filter_type'].nil?
      query_params[:'include_applied_to_type'] = opts[:'include_applied_to_type'] if !opts[:'include_applied_to_type'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'services'] = opts[:'services'] if !opts[:'services'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'sources'] = opts[:'sources'] if !opts[:'sources'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceInsertionSectionListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_service_insertion_sections\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List all Service-Insertion Services.
    # List all Service-Insertion Service Definitions. 
    # @param [Hash] opts the optional parameters
    # @return [ServiceInsertionServiceListResult]
    def list_service_insertion_services(opts = {})
      data, _status_code, _headers = list_service_insertion_services_with_http_info(opts)
      return data
    end

    # List all Service-Insertion Services.
    # List all Service-Insertion Service Definitions. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ServiceInsertionServiceListResult, Fixnum, Hash)>] ServiceInsertionServiceListResult data, response status code and response headers
    def list_service_insertion_services_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_service_insertion_services ..."
      end
      # resource path
      local_var_path = "/serviceinsertion/services"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceInsertionServiceListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_service_insertion_services\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get all Service-Instances for Service.
    # Returns all Service-Instance(s) for a given Service-Insertion Service. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @return [ServiceInstanceListResult]
    def list_service_instances_for_service(service_id, opts = {})
      data, _status_code, _headers = list_service_instances_for_service_with_http_info(service_id, opts)
      return data
    end

    # Get all Service-Instances for Service.
    # Returns all Service-Instance(s) for a given Service-Insertion Service. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ServiceInstanceListResult, Fixnum, Hash)>] ServiceInstanceListResult data, response status code and response headers
    def list_service_instances_for_service_with_http_info(service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.list_service_instances_for_service ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.list_service_instances_for_service"
      end
      # resource path
      local_var_path = "/serviceinsertion/services/{service-id}/service-instances".sub('{' + 'service-id' + '}', service_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceInstanceListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#list_service_instances_for_service\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Lock a section
    # Lock a section 
    # @param section_id 
    # @param firewall_section_lock 
    # @param [Hash] opts the optional parameters
    # @return [FirewallSection]
    def lock_section_lock(section_id, firewall_section_lock, opts = {})
      data, _status_code, _headers = lock_section_lock_with_http_info(section_id, firewall_section_lock, opts)
      return data
    end

    # Lock a section
    # Lock a section 
    # @param section_id 
    # @param firewall_section_lock 
    # @param [Hash] opts the optional parameters
    # @return [Array<(FirewallSection, Fixnum, Hash)>] FirewallSection data, response status code and response headers
    def lock_section_lock_with_http_info(section_id, firewall_section_lock, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.lock_section_lock ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.lock_section_lock"
      end
      # verify the required parameter 'firewall_section_lock' is set
      if @api_client.config.client_side_validation && firewall_section_lock.nil?
        fail ArgumentError, "Missing the required parameter 'firewall_section_lock' when calling ServicesApi.lock_section_lock"
      end
      # resource path
      local_var_path = "/firewall/sections/{section-id}?action=lock".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(firewall_section_lock)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallSection')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#lock_section_lock\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Resolve a given address via the dns forwarder
    # Query the nameserver for an ip-address or a FQDN of the given an address optionally using an specified DNS server. If the address is a fqdn, nslookup will resolve ip-address with it. If the address is an ip-address, do a reverse lookup and answer fqdn(s). 
    # @param forwarder_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :address IP address or FQDN for nslookup
    # @return [DnsAnswer]
    def lookup_address(forwarder_id, opts = {})
      data, _status_code, _headers = lookup_address_with_http_info(forwarder_id, opts)
      return data
    end

    # Resolve a given address via the dns forwarder
    # Query the nameserver for an ip-address or a FQDN of the given an address optionally using an specified DNS server. If the address is a fqdn, nslookup will resolve ip-address with it. If the address is an ip-address, do a reverse lookup and answer fqdn(s). 
    # @param forwarder_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :address IP address or FQDN for nslookup
    # @return [Array<(DnsAnswer, Fixnum, Hash)>] DnsAnswer data, response status code and response headers
    def lookup_address_with_http_info(forwarder_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.lookup_address ..."
      end
      # verify the required parameter 'forwarder_id' is set
      if @api_client.config.client_side_validation && forwarder_id.nil?
        fail ArgumentError, "Missing the required parameter 'forwarder_id' when calling ServicesApi.lookup_address"
      end
      # resource path
      local_var_path = "/dns/forwarders/{forwarder-id}/nslookup".sub('{' + 'forwarder-id' + '}', forwarder_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'address'] = opts[:'address'] if !opts[:'address'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DnsAnswer')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#lookup_address\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add, remove, or modify load balancer pool members
    # For ADD_MEMBERS, pool members will be created and added to load balancer pool. This action is only valid for static pool members. For REMOVE_MEMBERS, pool members will be removed from load balancer pool via IP and port in pool member settings. This action is only valid for static pool members. For UPDATE_MEMBERS, pool members admin state will be updated. This action is valid for both static pool members and dynamic pool members. For dynamic pool members, this update will be stored in customized_members field in load balancer pool member group. 
    # @param pool_id 
    # @param pool_member_setting_list 
    # @param action Specifies addition, removal and modification action
    # @param [Hash] opts the optional parameters
    # @return [LbPool]
    def perform_pool_member_action(pool_id, pool_member_setting_list, action, opts = {})
      data, _status_code, _headers = perform_pool_member_action_with_http_info(pool_id, pool_member_setting_list, action, opts)
      return data
    end

    # Add, remove, or modify load balancer pool members
    # For ADD_MEMBERS, pool members will be created and added to load balancer pool. This action is only valid for static pool members. For REMOVE_MEMBERS, pool members will be removed from load balancer pool via IP and port in pool member settings. This action is only valid for static pool members. For UPDATE_MEMBERS, pool members admin state will be updated. This action is valid for both static pool members and dynamic pool members. For dynamic pool members, this update will be stored in customized_members field in load balancer pool member group. 
    # @param pool_id 
    # @param pool_member_setting_list 
    # @param action Specifies addition, removal and modification action
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbPool, Fixnum, Hash)>] LbPool data, response status code and response headers
    def perform_pool_member_action_with_http_info(pool_id, pool_member_setting_list, action, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.perform_pool_member_action ..."
      end
      # verify the required parameter 'pool_id' is set
      if @api_client.config.client_side_validation && pool_id.nil?
        fail ArgumentError, "Missing the required parameter 'pool_id' when calling ServicesApi.perform_pool_member_action"
      end
      # verify the required parameter 'pool_member_setting_list' is set
      if @api_client.config.client_side_validation && pool_member_setting_list.nil?
        fail ArgumentError, "Missing the required parameter 'pool_member_setting_list' when calling ServicesApi.perform_pool_member_action"
      end
      # verify the required parameter 'action' is set
      if @api_client.config.client_side_validation && action.nil?
        fail ArgumentError, "Missing the required parameter 'action' when calling ServicesApi.perform_pool_member_action"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['ADD_MEMBERS', 'REMOVE_MEMBERS', 'UPDATE_MEMBERS'].include?(action)
        fail ArgumentError, "invalid value for 'action', must be one of ADD_MEMBERS, REMOVE_MEMBERS, UPDATE_MEMBERS"
      end
      # resource path
      local_var_path = "/loadbalancer/pools/{pool-id}".sub('{' + 'pool-id' + '}', pool_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'action'] = action

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(pool_member_setting_list)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbPool')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#perform_pool_member_action\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a DHCP server's IP pool with the specified pool ID
    # Get a DHCP server's IP pool with the specified pool ID
    # @param server_id 
    # @param pool_id 
    # @param [Hash] opts the optional parameters
    # @return [DhcpIpPool]
    def read_dhcp_ip_pool(server_id, pool_id, opts = {})
      data, _status_code, _headers = read_dhcp_ip_pool_with_http_info(server_id, pool_id, opts)
      return data
    end

    # Get a DHCP server&#39;s IP pool with the specified pool ID
    # Get a DHCP server&#39;s IP pool with the specified pool ID
    # @param server_id 
    # @param pool_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(DhcpIpPool, Fixnum, Hash)>] DhcpIpPool data, response status code and response headers
    def read_dhcp_ip_pool_with_http_info(server_id, pool_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.read_dhcp_ip_pool ..."
      end
      # verify the required parameter 'server_id' is set
      if @api_client.config.client_side_validation && server_id.nil?
        fail ArgumentError, "Missing the required parameter 'server_id' when calling ServicesApi.read_dhcp_ip_pool"
      end
      # verify the required parameter 'pool_id' is set
      if @api_client.config.client_side_validation && pool_id.nil?
        fail ArgumentError, "Missing the required parameter 'pool_id' when calling ServicesApi.read_dhcp_ip_pool"
      end
      # resource path
      local_var_path = "/dhcp/servers/{server-id}/ip-pools/{pool-id}".sub('{' + 'server-id' + '}', server_id.to_s).sub('{' + 'pool-id' + '}', pool_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DhcpIpPool')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#read_dhcp_ip_pool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a DHCP server profile
    # Get a DHCP server profile
    # @param profile_id 
    # @param [Hash] opts the optional parameters
    # @return [DhcpProfile]
    def read_dhcp_profile(profile_id, opts = {})
      data, _status_code, _headers = read_dhcp_profile_with_http_info(profile_id, opts)
      return data
    end

    # Get a DHCP server profile
    # Get a DHCP server profile
    # @param profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(DhcpProfile, Fixnum, Hash)>] DhcpProfile data, response status code and response headers
    def read_dhcp_profile_with_http_info(profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.read_dhcp_profile ..."
      end
      # verify the required parameter 'profile_id' is set
      if @api_client.config.client_side_validation && profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'profile_id' when calling ServicesApi.read_dhcp_profile"
      end
      # resource path
      local_var_path = "/dhcp/server-profiles/{profile-id}".sub('{' + 'profile-id' + '}', profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DhcpProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#read_dhcp_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a DHCP server
    # Get a DHCP server
    # @param server_id 
    # @param [Hash] opts the optional parameters
    # @return [LogicalDhcpServer]
    def read_dhcp_server(server_id, opts = {})
      data, _status_code, _headers = read_dhcp_server_with_http_info(server_id, opts)
      return data
    end

    # Get a DHCP server
    # Get a DHCP server
    # @param server_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LogicalDhcpServer, Fixnum, Hash)>] LogicalDhcpServer data, response status code and response headers
    def read_dhcp_server_with_http_info(server_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.read_dhcp_server ..."
      end
      # verify the required parameter 'server_id' is set
      if @api_client.config.client_side_validation && server_id.nil?
        fail ArgumentError, "Missing the required parameter 'server_id' when calling ServicesApi.read_dhcp_server"
      end
      # resource path
      local_var_path = "/dhcp/servers/{server-id}".sub('{' + 'server-id' + '}', server_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LogicalDhcpServer')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#read_dhcp_server\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a DHCP server's static binding with the specified binding ID
    # Get a DHCP server's static binding with the specified binding ID
    # @param server_id 
    # @param binding_id 
    # @param [Hash] opts the optional parameters
    # @return [DhcpStaticBinding]
    def read_dhcp_static_binding(server_id, binding_id, opts = {})
      data, _status_code, _headers = read_dhcp_static_binding_with_http_info(server_id, binding_id, opts)
      return data
    end

    # Get a DHCP server&#39;s static binding with the specified binding ID
    # Get a DHCP server&#39;s static binding with the specified binding ID
    # @param server_id 
    # @param binding_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(DhcpStaticBinding, Fixnum, Hash)>] DhcpStaticBinding data, response status code and response headers
    def read_dhcp_static_binding_with_http_info(server_id, binding_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.read_dhcp_static_binding ..."
      end
      # verify the required parameter 'server_id' is set
      if @api_client.config.client_side_validation && server_id.nil?
        fail ArgumentError, "Missing the required parameter 'server_id' when calling ServicesApi.read_dhcp_static_binding"
      end
      # verify the required parameter 'binding_id' is set
      if @api_client.config.client_side_validation && binding_id.nil?
        fail ArgumentError, "Missing the required parameter 'binding_id' when calling ServicesApi.read_dhcp_static_binding"
      end
      # resource path
      local_var_path = "/dhcp/servers/{server-id}/static-bindings/{binding-id}".sub('{' + 'server-id' + '}', server_id.to_s).sub('{' + 'binding-id' + '}', binding_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DhcpStaticBinding')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#read_dhcp_static_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a dns forwarder
    # Retrieve a dns forwarder. 
    # @param forwarder_id 
    # @param [Hash] opts the optional parameters
    # @return [DnsForwarder]
    def read_dns_forwader(forwarder_id, opts = {})
      data, _status_code, _headers = read_dns_forwader_with_http_info(forwarder_id, opts)
      return data
    end

    # Retrieve a dns forwarder
    # Retrieve a dns forwarder. 
    # @param forwarder_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(DnsForwarder, Fixnum, Hash)>] DnsForwarder data, response status code and response headers
    def read_dns_forwader_with_http_info(forwarder_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.read_dns_forwader ..."
      end
      # verify the required parameter 'forwarder_id' is set
      if @api_client.config.client_side_validation && forwarder_id.nil?
        fail ArgumentError, "Missing the required parameter 'forwarder_id' when calling ServicesApi.read_dns_forwader"
      end
      # resource path
      local_var_path = "/dns/forwarders/{forwarder-id}".sub('{' + 'forwarder-id' + '}', forwarder_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DnsForwarder')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#read_dns_forwader\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Read an Existing Rule
    # Return existing firewall rule information. 
    # @param rule_id 
    # @param [Hash] opts the optional parameters
    # @return [FirewallRule]
    def read_firewall_rule(rule_id, opts = {})
      data, _status_code, _headers = read_firewall_rule_with_http_info(rule_id, opts)
      return data
    end

    # Read an Existing Rule
    # Return existing firewall rule information. 
    # @param rule_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(FirewallRule, Fixnum, Hash)>] FirewallRule data, response status code and response headers
    def read_firewall_rule_with_http_info(rule_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.read_firewall_rule ..."
      end
      # verify the required parameter 'rule_id' is set
      if @api_client.config.client_side_validation && rule_id.nil?
        fail ArgumentError, "Missing the required parameter 'rule_id' when calling ServicesApi.read_firewall_rule"
      end
      # resource path
      local_var_path = "/firewall/rules/{rule-id}".sub('{' + 'rule-id' + '}', rule_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallRule')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#read_firewall_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a load balancer application profile
    # Retrieve a load balancer application profile. 
    # @param application_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [LbAppProfile]
    def read_load_balancer_application_profile(application_profile_id, opts = {})
      data, _status_code, _headers = read_load_balancer_application_profile_with_http_info(application_profile_id, opts)
      return data
    end

    # Retrieve a load balancer application profile
    # Retrieve a load balancer application profile. 
    # @param application_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbAppProfile, Fixnum, Hash)>] LbAppProfile data, response status code and response headers
    def read_load_balancer_application_profile_with_http_info(application_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.read_load_balancer_application_profile ..."
      end
      # verify the required parameter 'application_profile_id' is set
      if @api_client.config.client_side_validation && application_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'application_profile_id' when calling ServicesApi.read_load_balancer_application_profile"
      end
      # resource path
      local_var_path = "/loadbalancer/application-profiles/{application-profile-id}".sub('{' + 'application-profile-id' + '}', application_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbAppProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#read_load_balancer_application_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a load balancer client-ssl profile
    # Retrieve a load balancer client-ssl profile. 
    # @param client_ssl_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [LbClientSslProfile]
    def read_load_balancer_client_ssl_profile(client_ssl_profile_id, opts = {})
      data, _status_code, _headers = read_load_balancer_client_ssl_profile_with_http_info(client_ssl_profile_id, opts)
      return data
    end

    # Retrieve a load balancer client-ssl profile
    # Retrieve a load balancer client-ssl profile. 
    # @param client_ssl_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbClientSslProfile, Fixnum, Hash)>] LbClientSslProfile data, response status code and response headers
    def read_load_balancer_client_ssl_profile_with_http_info(client_ssl_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.read_load_balancer_client_ssl_profile ..."
      end
      # verify the required parameter 'client_ssl_profile_id' is set
      if @api_client.config.client_side_validation && client_ssl_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'client_ssl_profile_id' when calling ServicesApi.read_load_balancer_client_ssl_profile"
      end
      # resource path
      local_var_path = "/loadbalancer/client-ssl-profiles/{client-ssl-profile-id}".sub('{' + 'client-ssl-profile-id' + '}', client_ssl_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbClientSslProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#read_load_balancer_client_ssl_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a load balancer monitor
    # Retrieve a load balancer monitor. 
    # @param monitor_id 
    # @param [Hash] opts the optional parameters
    # @return [LbMonitor]
    def read_load_balancer_monitor(monitor_id, opts = {})
      data, _status_code, _headers = read_load_balancer_monitor_with_http_info(monitor_id, opts)
      return data
    end

    # Retrieve a load balancer monitor
    # Retrieve a load balancer monitor. 
    # @param monitor_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbMonitor, Fixnum, Hash)>] LbMonitor data, response status code and response headers
    def read_load_balancer_monitor_with_http_info(monitor_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.read_load_balancer_monitor ..."
      end
      # verify the required parameter 'monitor_id' is set
      if @api_client.config.client_side_validation && monitor_id.nil?
        fail ArgumentError, "Missing the required parameter 'monitor_id' when calling ServicesApi.read_load_balancer_monitor"
      end
      # resource path
      local_var_path = "/loadbalancer/monitors/{monitor-id}".sub('{' + 'monitor-id' + '}', monitor_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbMonitor')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#read_load_balancer_monitor\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a load balancer persistence profile
    # Retrieve a load balancer persistence profile. 
    # @param persistence_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [LbPersistenceProfile]
    def read_load_balancer_persistence_profile(persistence_profile_id, opts = {})
      data, _status_code, _headers = read_load_balancer_persistence_profile_with_http_info(persistence_profile_id, opts)
      return data
    end

    # Retrieve a load balancer persistence profile
    # Retrieve a load balancer persistence profile. 
    # @param persistence_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbPersistenceProfile, Fixnum, Hash)>] LbPersistenceProfile data, response status code and response headers
    def read_load_balancer_persistence_profile_with_http_info(persistence_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.read_load_balancer_persistence_profile ..."
      end
      # verify the required parameter 'persistence_profile_id' is set
      if @api_client.config.client_side_validation && persistence_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'persistence_profile_id' when calling ServicesApi.read_load_balancer_persistence_profile"
      end
      # resource path
      local_var_path = "/loadbalancer/persistence-profiles/{persistence-profile-id}".sub('{' + 'persistence-profile-id' + '}', persistence_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbPersistenceProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#read_load_balancer_persistence_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a load balancer pool
    # Retrieve a load balancer pool. 
    # @param pool_id 
    # @param [Hash] opts the optional parameters
    # @return [LbPool]
    def read_load_balancer_pool(pool_id, opts = {})
      data, _status_code, _headers = read_load_balancer_pool_with_http_info(pool_id, opts)
      return data
    end

    # Retrieve a load balancer pool
    # Retrieve a load balancer pool. 
    # @param pool_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbPool, Fixnum, Hash)>] LbPool data, response status code and response headers
    def read_load_balancer_pool_with_http_info(pool_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.read_load_balancer_pool ..."
      end
      # verify the required parameter 'pool_id' is set
      if @api_client.config.client_side_validation && pool_id.nil?
        fail ArgumentError, "Missing the required parameter 'pool_id' when calling ServicesApi.read_load_balancer_pool"
      end
      # resource path
      local_var_path = "/loadbalancer/pools/{pool-id}".sub('{' + 'pool-id' + '}', pool_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbPool')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#read_load_balancer_pool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a load balancer rule
    # Retrieve a load balancer rule. 
    # @param rule_id 
    # @param [Hash] opts the optional parameters
    # @return [LbRule]
    def read_load_balancer_rule(rule_id, opts = {})
      data, _status_code, _headers = read_load_balancer_rule_with_http_info(rule_id, opts)
      return data
    end

    # Retrieve a load balancer rule
    # Retrieve a load balancer rule. 
    # @param rule_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbRule, Fixnum, Hash)>] LbRule data, response status code and response headers
    def read_load_balancer_rule_with_http_info(rule_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.read_load_balancer_rule ..."
      end
      # verify the required parameter 'rule_id' is set
      if @api_client.config.client_side_validation && rule_id.nil?
        fail ArgumentError, "Missing the required parameter 'rule_id' when calling ServicesApi.read_load_balancer_rule"
      end
      # resource path
      local_var_path = "/loadbalancer/rules/{rule-id}".sub('{' + 'rule-id' + '}', rule_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbRule')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#read_load_balancer_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a load balancer server-ssl profile
    # Retrieve a load balancer server-ssl profile. 
    # @param server_ssl_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [LbServerSslProfile]
    def read_load_balancer_server_ssl_profile(server_ssl_profile_id, opts = {})
      data, _status_code, _headers = read_load_balancer_server_ssl_profile_with_http_info(server_ssl_profile_id, opts)
      return data
    end

    # Retrieve a load balancer server-ssl profile
    # Retrieve a load balancer server-ssl profile. 
    # @param server_ssl_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbServerSslProfile, Fixnum, Hash)>] LbServerSslProfile data, response status code and response headers
    def read_load_balancer_server_ssl_profile_with_http_info(server_ssl_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.read_load_balancer_server_ssl_profile ..."
      end
      # verify the required parameter 'server_ssl_profile_id' is set
      if @api_client.config.client_side_validation && server_ssl_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'server_ssl_profile_id' when calling ServicesApi.read_load_balancer_server_ssl_profile"
      end
      # resource path
      local_var_path = "/loadbalancer/server-ssl-profiles/{server-ssl-profile-id}".sub('{' + 'server-ssl-profile-id' + '}', server_ssl_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbServerSslProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#read_load_balancer_server_ssl_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a load balancer service
    # Retrieve a load balancer service. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @return [LbService]
    def read_load_balancer_service(service_id, opts = {})
      data, _status_code, _headers = read_load_balancer_service_with_http_info(service_id, opts)
      return data
    end

    # Retrieve a load balancer service
    # Retrieve a load balancer service. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbService, Fixnum, Hash)>] LbService data, response status code and response headers
    def read_load_balancer_service_with_http_info(service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.read_load_balancer_service ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.read_load_balancer_service"
      end
      # resource path
      local_var_path = "/loadbalancer/services/{service-id}".sub('{' + 'service-id' + '}', service_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbService')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#read_load_balancer_service\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Read the debug information of the load balancer service
    # API to download below information which will be used for debugging and troubleshooting. 1) Load balancer service 2) Load balancer associated virtual servers 3) Load balancer associated pools 4) Load balancer associated profiles such as persistence, SSL, application. 5) Load balancer associated monitors 6) Load balancer associated rules 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @return [LbServiceDebugInfo]
    def read_load_balancer_service_debug_info(service_id, opts = {})
      data, _status_code, _headers = read_load_balancer_service_debug_info_with_http_info(service_id, opts)
      return data
    end

    # Read the debug information of the load balancer service
    # API to download below information which will be used for debugging and troubleshooting. 1) Load balancer service 2) Load balancer associated virtual servers 3) Load balancer associated pools 4) Load balancer associated profiles such as persistence, SSL, application. 5) Load balancer associated monitors 6) Load balancer associated rules 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbServiceDebugInfo, Fixnum, Hash)>] LbServiceDebugInfo data, response status code and response headers
    def read_load_balancer_service_debug_info_with_http_info(service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.read_load_balancer_service_debug_info ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.read_load_balancer_service_debug_info"
      end
      # resource path
      local_var_path = "/loadbalancer/services/{service-id}/debug-info".sub('{' + 'service-id' + '}', service_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbServiceDebugInfo')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#read_load_balancer_service_debug_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Read the usage information of the given load balancer service
    # API to fetch the capacity and current usage of the given load balancer service. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @return [LbServiceUsage]
    def read_load_balancer_service_usage(service_id, opts = {})
      data, _status_code, _headers = read_load_balancer_service_usage_with_http_info(service_id, opts)
      return data
    end

    # Read the usage information of the given load balancer service
    # API to fetch the capacity and current usage of the given load balancer service. 
    # @param service_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbServiceUsage, Fixnum, Hash)>] LbServiceUsage data, response status code and response headers
    def read_load_balancer_service_usage_with_http_info(service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.read_load_balancer_service_usage ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.read_load_balancer_service_usage"
      end
      # resource path
      local_var_path = "/loadbalancer/services/{service-id}/usage".sub('{' + 'service-id' + '}', service_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbServiceUsage')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#read_load_balancer_service_usage\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a load balancer TCP profile
    # Retrieve a load balancer TCP profile. 
    # @param tcp_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [LbTcpProfile]
    def read_load_balancer_tcp_profile(tcp_profile_id, opts = {})
      data, _status_code, _headers = read_load_balancer_tcp_profile_with_http_info(tcp_profile_id, opts)
      return data
    end

    # Retrieve a load balancer TCP profile
    # Retrieve a load balancer TCP profile. 
    # @param tcp_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbTcpProfile, Fixnum, Hash)>] LbTcpProfile data, response status code and response headers
    def read_load_balancer_tcp_profile_with_http_info(tcp_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.read_load_balancer_tcp_profile ..."
      end
      # verify the required parameter 'tcp_profile_id' is set
      if @api_client.config.client_side_validation && tcp_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'tcp_profile_id' when calling ServicesApi.read_load_balancer_tcp_profile"
      end
      # resource path
      local_var_path = "/loadbalancer/tcp-profiles/{tcp-profile-id}".sub('{' + 'tcp-profile-id' + '}', tcp_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbTcpProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#read_load_balancer_tcp_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a load balancer virtual server
    # Retrieve a load balancer virtual server. 
    # @param virtual_server_id 
    # @param [Hash] opts the optional parameters
    # @return [LbVirtualServer]
    def read_load_balancer_virtual_server(virtual_server_id, opts = {})
      data, _status_code, _headers = read_load_balancer_virtual_server_with_http_info(virtual_server_id, opts)
      return data
    end

    # Retrieve a load balancer virtual server
    # Retrieve a load balancer virtual server. 
    # @param virtual_server_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbVirtualServer, Fixnum, Hash)>] LbVirtualServer data, response status code and response headers
    def read_load_balancer_virtual_server_with_http_info(virtual_server_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.read_load_balancer_virtual_server ..."
      end
      # verify the required parameter 'virtual_server_id' is set
      if @api_client.config.client_side_validation && virtual_server_id.nil?
        fail ArgumentError, "Missing the required parameter 'virtual_server_id' when calling ServicesApi.read_load_balancer_virtual_server"
      end
      # resource path
      local_var_path = "/loadbalancer/virtual-servers/{virtual-server-id}".sub('{' + 'virtual-server-id' + '}', virtual_server_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbVirtualServer')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#read_load_balancer_virtual_server\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a metadata proxy
    # Get a metadata proxy
    # @param proxy_id 
    # @param [Hash] opts the optional parameters
    # @return [MetadataProxy]
    def read_metadata_proxy(proxy_id, opts = {})
      data, _status_code, _headers = read_metadata_proxy_with_http_info(proxy_id, opts)
      return data
    end

    # Get a metadata proxy
    # Get a metadata proxy
    # @param proxy_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(MetadataProxy, Fixnum, Hash)>] MetadataProxy data, response status code and response headers
    def read_metadata_proxy_with_http_info(proxy_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.read_metadata_proxy ..."
      end
      # verify the required parameter 'proxy_id' is set
      if @api_client.config.client_side_validation && proxy_id.nil?
        fail ArgumentError, "Missing the required parameter 'proxy_id' when calling ServicesApi.read_metadata_proxy"
      end
      # resource path
      local_var_path = "/md-proxies/{proxy-id}".sub('{' + 'proxy-id' + '}', proxy_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MetadataProxy')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#read_metadata_proxy\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Remove an existing object from the exclude list
    # Remove an existing object from the exclude list
    # @param object_id identifier of the object
    # @param [Hash] opts the optional parameters
    # @return [ResourceReference]
    def remove_member_remove_member(object_id, opts = {})
      data, _status_code, _headers = remove_member_remove_member_with_http_info(object_id, opts)
      return data
    end

    # Remove an existing object from the exclude list
    # Remove an existing object from the exclude list
    # @param object_id identifier of the object
    # @param [Hash] opts the optional parameters
    # @return [Array<(ResourceReference, Fixnum, Hash)>] ResourceReference data, response status code and response headers
    def remove_member_remove_member_with_http_info(object_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.remove_member_remove_member ..."
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        fail ArgumentError, "Missing the required parameter 'object_id' when calling ServicesApi.remove_member_remove_member"
      end
      if @api_client.config.client_side_validation && object_id.to_s.length > 64
        fail ArgumentError, 'invalid value for "object_id" when calling ServicesApi.remove_member_remove_member, the character length must be smaller than or equal to 64.'
      end

      # resource path
      local_var_path = "/firewall/excludelist?action=remove_member"

      # query parameters
      query_params = {}
      query_params[:'object_id'] = object_id

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ResourceReference')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#remove_member_remove_member\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Reset firewall rule statistics
    # Sets firewall rule statistics counter to zero. This operation is supported for given category, for example: L3DFW i.e. for all layer3 firewall (transport nodes only) rules or L3EDGE i.e. for all layer3 edge firewall (edge nodes only) rules or L3BRIDGEPORT i.e. for all layer3 bridge port firewall (bridge ports only) rules. 
    # @param category Aggregation Statistic Category
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def reset_firewall_rule_stats_reset(category, opts = {})
      reset_firewall_rule_stats_reset_with_http_info(category, opts)
      return nil
    end

    # Reset firewall rule statistics
    # Sets firewall rule statistics counter to zero. This operation is supported for given category, for example: L3DFW i.e. for all layer3 firewall (transport nodes only) rules or L3EDGE i.e. for all layer3 edge firewall (edge nodes only) rules or L3BRIDGEPORT i.e. for all layer3 bridge port firewall (bridge ports only) rules. 
    # @param category Aggregation Statistic Category
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def reset_firewall_rule_stats_reset_with_http_info(category, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.reset_firewall_rule_stats_reset ..."
      end
      # verify the required parameter 'category' is set
      if @api_client.config.client_side_validation && category.nil?
        fail ArgumentError, "Missing the required parameter 'category' when calling ServicesApi.reset_firewall_rule_stats_reset"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['L3DFW', 'L3EDGE', 'L3BRIDGEPORT'].include?(category)
        fail ArgumentError, "invalid value for 'category', must be one of L3DFW, L3EDGE, L3BRIDGEPORT"
      end
      # resource path
      local_var_path = "/firewall/stats?action=reset"

      # query parameters
      query_params = {}
      query_params[:'category'] = category

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#reset_firewall_rule_stats_reset\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update an Existing Rule and Reorder the Rule
    # Modifies existing firewall rule along with relative position among other firewall rules inside a firewall section. Revising firewall rule in a section modifies parent section entity and simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update. 
    # @param section_id 
    # @param rule_id 
    # @param firewall_rule 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation (default to insert_top)
    # @return [FirewallRule]
    def revise_rule_revise(section_id, rule_id, firewall_rule, opts = {})
      data, _status_code, _headers = revise_rule_revise_with_http_info(section_id, rule_id, firewall_rule, opts)
      return data
    end

    # Update an Existing Rule and Reorder the Rule
    # Modifies existing firewall rule along with relative position among other firewall rules inside a firewall section. Revising firewall rule in a section modifies parent section entity and simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update. 
    # @param section_id 
    # @param rule_id 
    # @param firewall_rule 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation
    # @return [Array<(FirewallRule, Fixnum, Hash)>] FirewallRule data, response status code and response headers
    def revise_rule_revise_with_http_info(section_id, rule_id, firewall_rule, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.revise_rule_revise ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.revise_rule_revise"
      end
      # verify the required parameter 'rule_id' is set
      if @api_client.config.client_side_validation && rule_id.nil?
        fail ArgumentError, "Missing the required parameter 'rule_id' when calling ServicesApi.revise_rule_revise"
      end
      # verify the required parameter 'firewall_rule' is set
      if @api_client.config.client_side_validation && firewall_rule.nil?
        fail ArgumentError, "Missing the required parameter 'firewall_rule' when calling ServicesApi.revise_rule_revise"
      end
      if @api_client.config.client_side_validation && !opts[:'id'].nil? && opts[:'id'].to_s.length > 64
        fail ArgumentError, 'invalid value for "opts[:"id"]" when calling ServicesApi.revise_rule_revise, the character length must be smaller than or equal to 64.'
      end

      if @api_client.config.client_side_validation && opts[:'operation'] && !['insert_top', 'insert_bottom', 'insert_after', 'insert_before'].include?(opts[:'operation'])
        fail ArgumentError, 'invalid value for "operation", must be one of insert_top, insert_bottom, insert_after, insert_before'
      end
      # resource path
      local_var_path = "/firewall/sections/{section-id}/rules/{rule-id}?action=revise".sub('{' + 'section-id' + '}', section_id.to_s).sub('{' + 'rule-id' + '}', rule_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'id'] = opts[:'id'] if !opts[:'id'].nil?
      query_params[:'operation'] = opts[:'operation'] if !opts[:'operation'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(firewall_rule)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallRule')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#revise_rule_revise\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update an Existing Section, Including Its Position
    # Modifies an existing firewall section along with its relative position among other firewall sections in the system. Simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update. 
    # @param section_id 
    # @param firewall_section 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation (default to insert_top)
    # @return [FirewallSection]
    def revise_section_revise(section_id, firewall_section, opts = {})
      data, _status_code, _headers = revise_section_revise_with_http_info(section_id, firewall_section, opts)
      return data
    end

    # Update an Existing Section, Including Its Position
    # Modifies an existing firewall section along with its relative position among other firewall sections in the system. Simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update. 
    # @param section_id 
    # @param firewall_section 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation
    # @return [Array<(FirewallSection, Fixnum, Hash)>] FirewallSection data, response status code and response headers
    def revise_section_revise_with_http_info(section_id, firewall_section, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.revise_section_revise ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.revise_section_revise"
      end
      # verify the required parameter 'firewall_section' is set
      if @api_client.config.client_side_validation && firewall_section.nil?
        fail ArgumentError, "Missing the required parameter 'firewall_section' when calling ServicesApi.revise_section_revise"
      end
      if @api_client.config.client_side_validation && !opts[:'id'].nil? && opts[:'id'].to_s.length > 64
        fail ArgumentError, 'invalid value for "opts[:"id"]" when calling ServicesApi.revise_section_revise, the character length must be smaller than or equal to 64.'
      end

      if @api_client.config.client_side_validation && opts[:'operation'] && !['insert_top', 'insert_bottom', 'insert_after', 'insert_before'].include?(opts[:'operation'])
        fail ArgumentError, 'invalid value for "operation", must be one of insert_top, insert_bottom, insert_after, insert_before'
      end
      # resource path
      local_var_path = "/firewall/sections/{section-id}?action=revise".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'id'] = opts[:'id'] if !opts[:'id'].nil?
      query_params[:'operation'] = opts[:'operation'] if !opts[:'operation'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(firewall_section)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallSection')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#revise_section_revise\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update an Existing Section with Rules
    # Modifies an existing firewall section along with its relative position among other firewall sections with rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to move a section above or below another section, use: POST /api/v1/firewall/sections/&lt;section-id&gt;?action=revise  To modify rules, use: PUT /api/v1/firewall/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt;  Simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update. 
    # @param section_id 
    # @param firewall_section_rule_list 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation (default to insert_top)
    # @return [FirewallSectionRuleList]
    def revise_section_with_rules_revise_with_rules(section_id, firewall_section_rule_list, opts = {})
      data, _status_code, _headers = revise_section_with_rules_revise_with_rules_with_http_info(section_id, firewall_section_rule_list, opts)
      return data
    end

    # Update an Existing Section with Rules
    # Modifies an existing firewall section along with its relative position among other firewall sections with rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to move a section above or below another section, use: POST /api/v1/firewall/sections/&amp;lt;section-id&amp;gt;?action&#x3D;revise  To modify rules, use: PUT /api/v1/firewall/sections/&amp;lt;section-id&amp;gt;/rules/&amp;lt;rule-id&amp;gt;  Simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update. 
    # @param section_id 
    # @param firewall_section_rule_list 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation
    # @return [Array<(FirewallSectionRuleList, Fixnum, Hash)>] FirewallSectionRuleList data, response status code and response headers
    def revise_section_with_rules_revise_with_rules_with_http_info(section_id, firewall_section_rule_list, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.revise_section_with_rules_revise_with_rules ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.revise_section_with_rules_revise_with_rules"
      end
      # verify the required parameter 'firewall_section_rule_list' is set
      if @api_client.config.client_side_validation && firewall_section_rule_list.nil?
        fail ArgumentError, "Missing the required parameter 'firewall_section_rule_list' when calling ServicesApi.revise_section_with_rules_revise_with_rules"
      end
      if @api_client.config.client_side_validation && !opts[:'id'].nil? && opts[:'id'].to_s.length > 64
        fail ArgumentError, 'invalid value for "opts[:"id"]" when calling ServicesApi.revise_section_with_rules_revise_with_rules, the character length must be smaller than or equal to 64.'
      end

      if @api_client.config.client_side_validation && opts[:'operation'] && !['insert_top', 'insert_bottom', 'insert_after', 'insert_before'].include?(opts[:'operation'])
        fail ArgumentError, 'invalid value for "operation", must be one of insert_top, insert_bottom, insert_after, insert_before'
      end
      # resource path
      local_var_path = "/firewall/sections/{section-id}?action=revise_with_rules".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'id'] = opts[:'id'] if !opts[:'id'].nil?
      query_params[:'operation'] = opts[:'operation'] if !opts[:'operation'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(firewall_section_rule_list)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallSectionRuleList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#revise_section_with_rules_revise_with_rules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update an Existing Rule and Reorder the Rule
    # Modifies existing serviceinsertion rule along with relative position among other serviceinsertion rules inside a serviceinsertion section. 
    # @param section_id 
    # @param rule_id 
    # @param service_insertion_rule 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation (default to insert_top)
    # @return [ServiceInsertionRule]
    def revise_service_insertion_rule_revise(section_id, rule_id, service_insertion_rule, opts = {})
      data, _status_code, _headers = revise_service_insertion_rule_revise_with_http_info(section_id, rule_id, service_insertion_rule, opts)
      return data
    end

    # Update an Existing Rule and Reorder the Rule
    # Modifies existing serviceinsertion rule along with relative position among other serviceinsertion rules inside a serviceinsertion section. 
    # @param section_id 
    # @param rule_id 
    # @param service_insertion_rule 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation
    # @return [Array<(ServiceInsertionRule, Fixnum, Hash)>] ServiceInsertionRule data, response status code and response headers
    def revise_service_insertion_rule_revise_with_http_info(section_id, rule_id, service_insertion_rule, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.revise_service_insertion_rule_revise ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.revise_service_insertion_rule_revise"
      end
      # verify the required parameter 'rule_id' is set
      if @api_client.config.client_side_validation && rule_id.nil?
        fail ArgumentError, "Missing the required parameter 'rule_id' when calling ServicesApi.revise_service_insertion_rule_revise"
      end
      # verify the required parameter 'service_insertion_rule' is set
      if @api_client.config.client_side_validation && service_insertion_rule.nil?
        fail ArgumentError, "Missing the required parameter 'service_insertion_rule' when calling ServicesApi.revise_service_insertion_rule_revise"
      end
      if @api_client.config.client_side_validation && !opts[:'id'].nil? && opts[:'id'].to_s.length > 64
        fail ArgumentError, 'invalid value for "opts[:"id"]" when calling ServicesApi.revise_service_insertion_rule_revise, the character length must be smaller than or equal to 64.'
      end

      if @api_client.config.client_side_validation && opts[:'operation'] && !['insert_top', 'insert_bottom', 'insert_after', 'insert_before'].include?(opts[:'operation'])
        fail ArgumentError, 'invalid value for "operation", must be one of insert_top, insert_bottom, insert_after, insert_before'
      end
      # resource path
      local_var_path = "/serviceinsertion/sections/{section-id}/rules/{rule-id}?action=revise".sub('{' + 'section-id' + '}', section_id.to_s).sub('{' + 'rule-id' + '}', rule_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'id'] = opts[:'id'] if !opts[:'id'].nil?
      query_params[:'operation'] = opts[:'operation'] if !opts[:'operation'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(service_insertion_rule)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceInsertionRule')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#revise_service_insertion_rule_revise\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update an Existing Section, Including Its Position
    # Modifies an existing serviceinsertion section along with its relative position among other serviceinsertion sections in the system. 
    # @param section_id 
    # @param service_insertion_section 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation (default to insert_top)
    # @return [ServiceInsertionSection]
    def revise_service_insertion_section_revise(section_id, service_insertion_section, opts = {})
      data, _status_code, _headers = revise_service_insertion_section_revise_with_http_info(section_id, service_insertion_section, opts)
      return data
    end

    # Update an Existing Section, Including Its Position
    # Modifies an existing serviceinsertion section along with its relative position among other serviceinsertion sections in the system. 
    # @param section_id 
    # @param service_insertion_section 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation
    # @return [Array<(ServiceInsertionSection, Fixnum, Hash)>] ServiceInsertionSection data, response status code and response headers
    def revise_service_insertion_section_revise_with_http_info(section_id, service_insertion_section, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.revise_service_insertion_section_revise ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.revise_service_insertion_section_revise"
      end
      # verify the required parameter 'service_insertion_section' is set
      if @api_client.config.client_side_validation && service_insertion_section.nil?
        fail ArgumentError, "Missing the required parameter 'service_insertion_section' when calling ServicesApi.revise_service_insertion_section_revise"
      end
      if @api_client.config.client_side_validation && !opts[:'id'].nil? && opts[:'id'].to_s.length > 64
        fail ArgumentError, 'invalid value for "opts[:"id"]" when calling ServicesApi.revise_service_insertion_section_revise, the character length must be smaller than or equal to 64.'
      end

      if @api_client.config.client_side_validation && opts[:'operation'] && !['insert_top', 'insert_bottom', 'insert_after', 'insert_before'].include?(opts[:'operation'])
        fail ArgumentError, 'invalid value for "operation", must be one of insert_top, insert_bottom, insert_after, insert_before'
      end
      # resource path
      local_var_path = "/serviceinsertion/sections/{section-id}?action=revise".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'id'] = opts[:'id'] if !opts[:'id'].nil?
      query_params[:'operation'] = opts[:'operation'] if !opts[:'operation'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(service_insertion_section)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceInsertionSection')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#revise_service_insertion_section_revise\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update an Existing Section with Rules
    # Modifies an existing serviceinsertion section along with its relative position among other serviceinsertion sections with rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to move a section above or below another section, use: POST /api/v1/serviceinsertion/sections/&lt;section-id&gt;?action=revise  To modify rules, use: PUT /api/v1/serviceinsertion/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt; 
    # @param section_id 
    # @param service_insertion_section_rule_list 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation (default to insert_top)
    # @return [ServiceInsertionSectionRuleList]
    def revise_service_insertion_section_with_rules_revise_with_rules(section_id, service_insertion_section_rule_list, opts = {})
      data, _status_code, _headers = revise_service_insertion_section_with_rules_revise_with_rules_with_http_info(section_id, service_insertion_section_rule_list, opts)
      return data
    end

    # Update an Existing Section with Rules
    # Modifies an existing serviceinsertion section along with its relative position among other serviceinsertion sections with rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to move a section above or below another section, use: POST /api/v1/serviceinsertion/sections/&amp;lt;section-id&amp;gt;?action&#x3D;revise  To modify rules, use: PUT /api/v1/serviceinsertion/sections/&amp;lt;section-id&amp;gt;/rules/&amp;lt;rule-id&amp;gt; 
    # @param section_id 
    # @param service_insertion_section_rule_list 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :id Identifier of the anchor rule or section. This is a required field in case operation like &#39;insert_before&#39; and &#39;insert_after&#39;.
    # @option opts [String] :operation Operation
    # @return [Array<(ServiceInsertionSectionRuleList, Fixnum, Hash)>] ServiceInsertionSectionRuleList data, response status code and response headers
    def revise_service_insertion_section_with_rules_revise_with_rules_with_http_info(section_id, service_insertion_section_rule_list, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.revise_service_insertion_section_with_rules_revise_with_rules ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.revise_service_insertion_section_with_rules_revise_with_rules"
      end
      # verify the required parameter 'service_insertion_section_rule_list' is set
      if @api_client.config.client_side_validation && service_insertion_section_rule_list.nil?
        fail ArgumentError, "Missing the required parameter 'service_insertion_section_rule_list' when calling ServicesApi.revise_service_insertion_section_with_rules_revise_with_rules"
      end
      if @api_client.config.client_side_validation && !opts[:'id'].nil? && opts[:'id'].to_s.length > 64
        fail ArgumentError, 'invalid value for "opts[:"id"]" when calling ServicesApi.revise_service_insertion_section_with_rules_revise_with_rules, the character length must be smaller than or equal to 64.'
      end

      if @api_client.config.client_side_validation && opts[:'operation'] && !['insert_top', 'insert_bottom', 'insert_after', 'insert_before'].include?(opts[:'operation'])
        fail ArgumentError, 'invalid value for "operation", must be one of insert_top, insert_bottom, insert_after, insert_before'
      end
      # resource path
      local_var_path = "/serviceinsertion/sections/{section-id}?action=revise_with_rules".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'id'] = opts[:'id'] if !opts[:'id'].nil?
      query_params[:'operation'] = opts[:'operation'] if !opts[:'operation'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(service_insertion_section_rule_list)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceInsertionSectionRuleList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#revise_service_insertion_section_with_rules_revise_with_rules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Unlock a section
    # Unlock a section 
    # @param section_id 
    # @param firewall_section_lock 
    # @param [Hash] opts the optional parameters
    # @return [FirewallSection]
    def unlock_section_unlock(section_id, firewall_section_lock, opts = {})
      data, _status_code, _headers = unlock_section_unlock_with_http_info(section_id, firewall_section_lock, opts)
      return data
    end

    # Unlock a section
    # Unlock a section 
    # @param section_id 
    # @param firewall_section_lock 
    # @param [Hash] opts the optional parameters
    # @return [Array<(FirewallSection, Fixnum, Hash)>] FirewallSection data, response status code and response headers
    def unlock_section_unlock_with_http_info(section_id, firewall_section_lock, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.unlock_section_unlock ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.unlock_section_unlock"
      end
      # verify the required parameter 'firewall_section_lock' is set
      if @api_client.config.client_side_validation && firewall_section_lock.nil?
        fail ArgumentError, "Missing the required parameter 'firewall_section_lock' when calling ServicesApi.unlock_section_unlock"
      end
      # resource path
      local_var_path = "/firewall/sections/{section-id}?action=unlock".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(firewall_section_lock)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallSection')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#unlock_section_unlock\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a DHCP server's IP pool
    # Update a DHCP server's IP pool
    # @param server_id 
    # @param pool_id 
    # @param dhcp_ip_pool 
    # @param [Hash] opts the optional parameters
    # @return [DhcpIpPool]
    def update_dhcp_ip_pool(server_id, pool_id, dhcp_ip_pool, opts = {})
      data, _status_code, _headers = update_dhcp_ip_pool_with_http_info(server_id, pool_id, dhcp_ip_pool, opts)
      return data
    end

    # Update a DHCP server&#39;s IP pool
    # Update a DHCP server&#39;s IP pool
    # @param server_id 
    # @param pool_id 
    # @param dhcp_ip_pool 
    # @param [Hash] opts the optional parameters
    # @return [Array<(DhcpIpPool, Fixnum, Hash)>] DhcpIpPool data, response status code and response headers
    def update_dhcp_ip_pool_with_http_info(server_id, pool_id, dhcp_ip_pool, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_dhcp_ip_pool ..."
      end
      # verify the required parameter 'server_id' is set
      if @api_client.config.client_side_validation && server_id.nil?
        fail ArgumentError, "Missing the required parameter 'server_id' when calling ServicesApi.update_dhcp_ip_pool"
      end
      # verify the required parameter 'pool_id' is set
      if @api_client.config.client_side_validation && pool_id.nil?
        fail ArgumentError, "Missing the required parameter 'pool_id' when calling ServicesApi.update_dhcp_ip_pool"
      end
      # verify the required parameter 'dhcp_ip_pool' is set
      if @api_client.config.client_side_validation && dhcp_ip_pool.nil?
        fail ArgumentError, "Missing the required parameter 'dhcp_ip_pool' when calling ServicesApi.update_dhcp_ip_pool"
      end
      # resource path
      local_var_path = "/dhcp/servers/{server-id}/ip-pools/{pool-id}".sub('{' + 'server-id' + '}', server_id.to_s).sub('{' + 'pool-id' + '}', pool_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(dhcp_ip_pool)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DhcpIpPool')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_dhcp_ip_pool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a DHCP server profile
    # If both the edge_cluster_member_indexes are changed in a same PUT API, e.g. change from [a,b] to [x,y], the current dhcp server states will be lost, which could cause the network crash due to ip conflicts. Hence the suggestion is to change only one member index in one single update, e.g. from [a, b] to [a,y]. 
    # @param profile_id 
    # @param dhcp_profile 
    # @param [Hash] opts the optional parameters
    # @return [DhcpProfile]
    def update_dhcp_profile(profile_id, dhcp_profile, opts = {})
      data, _status_code, _headers = update_dhcp_profile_with_http_info(profile_id, dhcp_profile, opts)
      return data
    end

    # Update a DHCP server profile
    # If both the edge_cluster_member_indexes are changed in a same PUT API, e.g. change from [a,b] to [x,y], the current dhcp server states will be lost, which could cause the network crash due to ip conflicts. Hence the suggestion is to change only one member index in one single update, e.g. from [a, b] to [a,y]. 
    # @param profile_id 
    # @param dhcp_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(DhcpProfile, Fixnum, Hash)>] DhcpProfile data, response status code and response headers
    def update_dhcp_profile_with_http_info(profile_id, dhcp_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_dhcp_profile ..."
      end
      # verify the required parameter 'profile_id' is set
      if @api_client.config.client_side_validation && profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'profile_id' when calling ServicesApi.update_dhcp_profile"
      end
      # verify the required parameter 'dhcp_profile' is set
      if @api_client.config.client_side_validation && dhcp_profile.nil?
        fail ArgumentError, "Missing the required parameter 'dhcp_profile' when calling ServicesApi.update_dhcp_profile"
      end
      # resource path
      local_var_path = "/dhcp/server-profiles/{profile-id}".sub('{' + 'profile-id' + '}', profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(dhcp_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DhcpProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_dhcp_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a DHCP server
    # Update a DHCP server
    # @param server_id 
    # @param logical_dhcp_server 
    # @param [Hash] opts the optional parameters
    # @return [LogicalDhcpServer]
    def update_dhcp_server(server_id, logical_dhcp_server, opts = {})
      data, _status_code, _headers = update_dhcp_server_with_http_info(server_id, logical_dhcp_server, opts)
      return data
    end

    # Update a DHCP server
    # Update a DHCP server
    # @param server_id 
    # @param logical_dhcp_server 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LogicalDhcpServer, Fixnum, Hash)>] LogicalDhcpServer data, response status code and response headers
    def update_dhcp_server_with_http_info(server_id, logical_dhcp_server, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_dhcp_server ..."
      end
      # verify the required parameter 'server_id' is set
      if @api_client.config.client_side_validation && server_id.nil?
        fail ArgumentError, "Missing the required parameter 'server_id' when calling ServicesApi.update_dhcp_server"
      end
      # verify the required parameter 'logical_dhcp_server' is set
      if @api_client.config.client_side_validation && logical_dhcp_server.nil?
        fail ArgumentError, "Missing the required parameter 'logical_dhcp_server' when calling ServicesApi.update_dhcp_server"
      end
      # resource path
      local_var_path = "/dhcp/servers/{server-id}".sub('{' + 'server-id' + '}', server_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(logical_dhcp_server)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LogicalDhcpServer')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_dhcp_server\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a DHCP server's static binding
    # Update a DHCP server's static binding
    # @param server_id 
    # @param binding_id 
    # @param dhcp_static_binding 
    # @param [Hash] opts the optional parameters
    # @return [DhcpStaticBinding]
    def update_dhcp_static_binding(server_id, binding_id, dhcp_static_binding, opts = {})
      data, _status_code, _headers = update_dhcp_static_binding_with_http_info(server_id, binding_id, dhcp_static_binding, opts)
      return data
    end

    # Update a DHCP server&#39;s static binding
    # Update a DHCP server&#39;s static binding
    # @param server_id 
    # @param binding_id 
    # @param dhcp_static_binding 
    # @param [Hash] opts the optional parameters
    # @return [Array<(DhcpStaticBinding, Fixnum, Hash)>] DhcpStaticBinding data, response status code and response headers
    def update_dhcp_static_binding_with_http_info(server_id, binding_id, dhcp_static_binding, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_dhcp_static_binding ..."
      end
      # verify the required parameter 'server_id' is set
      if @api_client.config.client_side_validation && server_id.nil?
        fail ArgumentError, "Missing the required parameter 'server_id' when calling ServicesApi.update_dhcp_static_binding"
      end
      # verify the required parameter 'binding_id' is set
      if @api_client.config.client_side_validation && binding_id.nil?
        fail ArgumentError, "Missing the required parameter 'binding_id' when calling ServicesApi.update_dhcp_static_binding"
      end
      # verify the required parameter 'dhcp_static_binding' is set
      if @api_client.config.client_side_validation && dhcp_static_binding.nil?
        fail ArgumentError, "Missing the required parameter 'dhcp_static_binding' when calling ServicesApi.update_dhcp_static_binding"
      end
      # resource path
      local_var_path = "/dhcp/servers/{server-id}/static-bindings/{binding-id}".sub('{' + 'server-id' + '}', server_id.to_s).sub('{' + 'binding-id' + '}', binding_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(dhcp_static_binding)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DhcpStaticBinding')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_dhcp_static_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a specific dns forwarder
    # Update a specific dns forwarder. 
    # @param forwarder_id 
    # @param dns_forwarder 
    # @param [Hash] opts the optional parameters
    # @return [DnsForwarder]
    def update_dns_forwarder(forwarder_id, dns_forwarder, opts = {})
      data, _status_code, _headers = update_dns_forwarder_with_http_info(forwarder_id, dns_forwarder, opts)
      return data
    end

    # Update a specific dns forwarder
    # Update a specific dns forwarder. 
    # @param forwarder_id 
    # @param dns_forwarder 
    # @param [Hash] opts the optional parameters
    # @return [Array<(DnsForwarder, Fixnum, Hash)>] DnsForwarder data, response status code and response headers
    def update_dns_forwarder_with_http_info(forwarder_id, dns_forwarder, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_dns_forwarder ..."
      end
      # verify the required parameter 'forwarder_id' is set
      if @api_client.config.client_side_validation && forwarder_id.nil?
        fail ArgumentError, "Missing the required parameter 'forwarder_id' when calling ServicesApi.update_dns_forwarder"
      end
      # verify the required parameter 'dns_forwarder' is set
      if @api_client.config.client_side_validation && dns_forwarder.nil?
        fail ArgumentError, "Missing the required parameter 'dns_forwarder' when calling ServicesApi.update_dns_forwarder"
      end
      # resource path
      local_var_path = "/dns/forwarders/{forwarder-id}".sub('{' + 'forwarder-id' + '}', forwarder_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(dns_forwarder)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DnsForwarder')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_dns_forwarder\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Modify exclude list
    # Modify exclude list
    # @param exclude_list 
    # @param [Hash] opts the optional parameters
    # @return [ExcludeList]
    def update_exclude_list(exclude_list, opts = {})
      data, _status_code, _headers = update_exclude_list_with_http_info(exclude_list, opts)
      return data
    end

    # Modify exclude list
    # Modify exclude list
    # @param exclude_list 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ExcludeList, Fixnum, Hash)>] ExcludeList data, response status code and response headers
    def update_exclude_list_with_http_info(exclude_list, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_exclude_list ..."
      end
      # verify the required parameter 'exclude_list' is set
      if @api_client.config.client_side_validation && exclude_list.nil?
        fail ArgumentError, "Missing the required parameter 'exclude_list' when calling ServicesApi.update_exclude_list"
      end
      # resource path
      local_var_path = "/firewall/excludelist"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(exclude_list)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ExcludeList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_exclude_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update global firewall status for dfw context
    # Update global firewall status for dfw context
    # @param context_type 
    # @param firewall_status 
    # @param [Hash] opts the optional parameters
    # @return [FirewallStatus]
    def update_firewall_status(context_type, firewall_status, opts = {})
      data, _status_code, _headers = update_firewall_status_with_http_info(context_type, firewall_status, opts)
      return data
    end

    # Update global firewall status for dfw context
    # Update global firewall status for dfw context
    # @param context_type 
    # @param firewall_status 
    # @param [Hash] opts the optional parameters
    # @return [Array<(FirewallStatus, Fixnum, Hash)>] FirewallStatus data, response status code and response headers
    def update_firewall_status_with_http_info(context_type, firewall_status, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_firewall_status ..."
      end
      # verify the required parameter 'context_type' is set
      if @api_client.config.client_side_validation && context_type.nil?
        fail ArgumentError, "Missing the required parameter 'context_type' when calling ServicesApi.update_firewall_status"
      end
      # verify the required parameter 'firewall_status' is set
      if @api_client.config.client_side_validation && firewall_status.nil?
        fail ArgumentError, "Missing the required parameter 'firewall_status' when calling ServicesApi.update_firewall_status"
      end
      # resource path
      local_var_path = "/firewall/status/{context-type}".sub('{' + 'context-type' + '}', context_type.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(firewall_status)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_firewall_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a load balancer application profile
    # Update a load balancer application profile. 
    # @param application_profile_id 
    # @param lb_app_profile 
    # @param [Hash] opts the optional parameters
    # @return [LbAppProfile]
    def update_load_balancer_application_profile(application_profile_id, lb_app_profile, opts = {})
      data, _status_code, _headers = update_load_balancer_application_profile_with_http_info(application_profile_id, lb_app_profile, opts)
      return data
    end

    # Update a load balancer application profile
    # Update a load balancer application profile. 
    # @param application_profile_id 
    # @param lb_app_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbAppProfile, Fixnum, Hash)>] LbAppProfile data, response status code and response headers
    def update_load_balancer_application_profile_with_http_info(application_profile_id, lb_app_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_load_balancer_application_profile ..."
      end
      # verify the required parameter 'application_profile_id' is set
      if @api_client.config.client_side_validation && application_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'application_profile_id' when calling ServicesApi.update_load_balancer_application_profile"
      end
      # verify the required parameter 'lb_app_profile' is set
      if @api_client.config.client_side_validation && lb_app_profile.nil?
        fail ArgumentError, "Missing the required parameter 'lb_app_profile' when calling ServicesApi.update_load_balancer_application_profile"
      end
      # resource path
      local_var_path = "/loadbalancer/application-profiles/{application-profile-id}".sub('{' + 'application-profile-id' + '}', application_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_app_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbAppProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_load_balancer_application_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a load balancer client-ssl profile
    # Update a load balancer client-ssl profile. 
    # @param client_ssl_profile_id 
    # @param lb_client_ssl_profile 
    # @param [Hash] opts the optional parameters
    # @return [LbClientSslProfile]
    def update_load_balancer_client_ssl_profile(client_ssl_profile_id, lb_client_ssl_profile, opts = {})
      data, _status_code, _headers = update_load_balancer_client_ssl_profile_with_http_info(client_ssl_profile_id, lb_client_ssl_profile, opts)
      return data
    end

    # Update a load balancer client-ssl profile
    # Update a load balancer client-ssl profile. 
    # @param client_ssl_profile_id 
    # @param lb_client_ssl_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbClientSslProfile, Fixnum, Hash)>] LbClientSslProfile data, response status code and response headers
    def update_load_balancer_client_ssl_profile_with_http_info(client_ssl_profile_id, lb_client_ssl_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_load_balancer_client_ssl_profile ..."
      end
      # verify the required parameter 'client_ssl_profile_id' is set
      if @api_client.config.client_side_validation && client_ssl_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'client_ssl_profile_id' when calling ServicesApi.update_load_balancer_client_ssl_profile"
      end
      # verify the required parameter 'lb_client_ssl_profile' is set
      if @api_client.config.client_side_validation && lb_client_ssl_profile.nil?
        fail ArgumentError, "Missing the required parameter 'lb_client_ssl_profile' when calling ServicesApi.update_load_balancer_client_ssl_profile"
      end
      # resource path
      local_var_path = "/loadbalancer/client-ssl-profiles/{client-ssl-profile-id}".sub('{' + 'client-ssl-profile-id' + '}', client_ssl_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_client_ssl_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbClientSslProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_load_balancer_client_ssl_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a load balancer monitor
    # Update a load balancer monitor. 
    # @param monitor_id 
    # @param lb_monitor 
    # @param [Hash] opts the optional parameters
    # @return [LbMonitor]
    def update_load_balancer_monitor(monitor_id, lb_monitor, opts = {})
      data, _status_code, _headers = update_load_balancer_monitor_with_http_info(monitor_id, lb_monitor, opts)
      return data
    end

    # Update a load balancer monitor
    # Update a load balancer monitor. 
    # @param monitor_id 
    # @param lb_monitor 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbMonitor, Fixnum, Hash)>] LbMonitor data, response status code and response headers
    def update_load_balancer_monitor_with_http_info(monitor_id, lb_monitor, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_load_balancer_monitor ..."
      end
      # verify the required parameter 'monitor_id' is set
      if @api_client.config.client_side_validation && monitor_id.nil?
        fail ArgumentError, "Missing the required parameter 'monitor_id' when calling ServicesApi.update_load_balancer_monitor"
      end
      # verify the required parameter 'lb_monitor' is set
      if @api_client.config.client_side_validation && lb_monitor.nil?
        fail ArgumentError, "Missing the required parameter 'lb_monitor' when calling ServicesApi.update_load_balancer_monitor"
      end
      # resource path
      local_var_path = "/loadbalancer/monitors/{monitor-id}".sub('{' + 'monitor-id' + '}', monitor_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_monitor)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbMonitor')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_load_balancer_monitor\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a load balancer persistence profile
    # Update a load balancer persistence profile. 
    # @param persistence_profile_id 
    # @param lb_persistence_profile 
    # @param [Hash] opts the optional parameters
    # @return [LbPersistenceProfile]
    def update_load_balancer_persistence_profile(persistence_profile_id, lb_persistence_profile, opts = {})
      data, _status_code, _headers = update_load_balancer_persistence_profile_with_http_info(persistence_profile_id, lb_persistence_profile, opts)
      return data
    end

    # Update a load balancer persistence profile
    # Update a load balancer persistence profile. 
    # @param persistence_profile_id 
    # @param lb_persistence_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbPersistenceProfile, Fixnum, Hash)>] LbPersistenceProfile data, response status code and response headers
    def update_load_balancer_persistence_profile_with_http_info(persistence_profile_id, lb_persistence_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_load_balancer_persistence_profile ..."
      end
      # verify the required parameter 'persistence_profile_id' is set
      if @api_client.config.client_side_validation && persistence_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'persistence_profile_id' when calling ServicesApi.update_load_balancer_persistence_profile"
      end
      # verify the required parameter 'lb_persistence_profile' is set
      if @api_client.config.client_side_validation && lb_persistence_profile.nil?
        fail ArgumentError, "Missing the required parameter 'lb_persistence_profile' when calling ServicesApi.update_load_balancer_persistence_profile"
      end
      # resource path
      local_var_path = "/loadbalancer/persistence-profiles/{persistence-profile-id}".sub('{' + 'persistence-profile-id' + '}', persistence_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_persistence_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbPersistenceProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_load_balancer_persistence_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a load balancer pool
    # Update a load balancer pool. 
    # @param pool_id 
    # @param lb_pool 
    # @param [Hash] opts the optional parameters
    # @return [LbPool]
    def update_load_balancer_pool(pool_id, lb_pool, opts = {})
      data, _status_code, _headers = update_load_balancer_pool_with_http_info(pool_id, lb_pool, opts)
      return data
    end

    # Update a load balancer pool
    # Update a load balancer pool. 
    # @param pool_id 
    # @param lb_pool 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbPool, Fixnum, Hash)>] LbPool data, response status code and response headers
    def update_load_balancer_pool_with_http_info(pool_id, lb_pool, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_load_balancer_pool ..."
      end
      # verify the required parameter 'pool_id' is set
      if @api_client.config.client_side_validation && pool_id.nil?
        fail ArgumentError, "Missing the required parameter 'pool_id' when calling ServicesApi.update_load_balancer_pool"
      end
      # verify the required parameter 'lb_pool' is set
      if @api_client.config.client_side_validation && lb_pool.nil?
        fail ArgumentError, "Missing the required parameter 'lb_pool' when calling ServicesApi.update_load_balancer_pool"
      end
      # resource path
      local_var_path = "/loadbalancer/pools/{pool-id}".sub('{' + 'pool-id' + '}', pool_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_pool)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbPool')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_load_balancer_pool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a load balancer rule
    # Update a load balancer rule. 
    # @param rule_id 
    # @param lb_rule 
    # @param [Hash] opts the optional parameters
    # @return [LbRule]
    def update_load_balancer_rule(rule_id, lb_rule, opts = {})
      data, _status_code, _headers = update_load_balancer_rule_with_http_info(rule_id, lb_rule, opts)
      return data
    end

    # Update a load balancer rule
    # Update a load balancer rule. 
    # @param rule_id 
    # @param lb_rule 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbRule, Fixnum, Hash)>] LbRule data, response status code and response headers
    def update_load_balancer_rule_with_http_info(rule_id, lb_rule, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_load_balancer_rule ..."
      end
      # verify the required parameter 'rule_id' is set
      if @api_client.config.client_side_validation && rule_id.nil?
        fail ArgumentError, "Missing the required parameter 'rule_id' when calling ServicesApi.update_load_balancer_rule"
      end
      # verify the required parameter 'lb_rule' is set
      if @api_client.config.client_side_validation && lb_rule.nil?
        fail ArgumentError, "Missing the required parameter 'lb_rule' when calling ServicesApi.update_load_balancer_rule"
      end
      # resource path
      local_var_path = "/loadbalancer/rules/{rule-id}".sub('{' + 'rule-id' + '}', rule_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_rule)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbRule')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_load_balancer_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a load balancer server-ssl profile
    # Update a load balancer server-ssl profile. 
    # @param server_ssl_profile_id 
    # @param lb_server_ssl_profile 
    # @param [Hash] opts the optional parameters
    # @return [LbServerSslProfile]
    def update_load_balancer_server_ssl_profile(server_ssl_profile_id, lb_server_ssl_profile, opts = {})
      data, _status_code, _headers = update_load_balancer_server_ssl_profile_with_http_info(server_ssl_profile_id, lb_server_ssl_profile, opts)
      return data
    end

    # Update a load balancer server-ssl profile
    # Update a load balancer server-ssl profile. 
    # @param server_ssl_profile_id 
    # @param lb_server_ssl_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbServerSslProfile, Fixnum, Hash)>] LbServerSslProfile data, response status code and response headers
    def update_load_balancer_server_ssl_profile_with_http_info(server_ssl_profile_id, lb_server_ssl_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_load_balancer_server_ssl_profile ..."
      end
      # verify the required parameter 'server_ssl_profile_id' is set
      if @api_client.config.client_side_validation && server_ssl_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'server_ssl_profile_id' when calling ServicesApi.update_load_balancer_server_ssl_profile"
      end
      # verify the required parameter 'lb_server_ssl_profile' is set
      if @api_client.config.client_side_validation && lb_server_ssl_profile.nil?
        fail ArgumentError, "Missing the required parameter 'lb_server_ssl_profile' when calling ServicesApi.update_load_balancer_server_ssl_profile"
      end
      # resource path
      local_var_path = "/loadbalancer/server-ssl-profiles/{server-ssl-profile-id}".sub('{' + 'server-ssl-profile-id' + '}', server_ssl_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_server_ssl_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbServerSslProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_load_balancer_server_ssl_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a load balancer service
    # Update a load balancer service. 
    # @param service_id 
    # @param lb_service 
    # @param [Hash] opts the optional parameters
    # @return [LbService]
    def update_load_balancer_service(service_id, lb_service, opts = {})
      data, _status_code, _headers = update_load_balancer_service_with_http_info(service_id, lb_service, opts)
      return data
    end

    # Update a load balancer service
    # Update a load balancer service. 
    # @param service_id 
    # @param lb_service 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbService, Fixnum, Hash)>] LbService data, response status code and response headers
    def update_load_balancer_service_with_http_info(service_id, lb_service, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_load_balancer_service ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.update_load_balancer_service"
      end
      # verify the required parameter 'lb_service' is set
      if @api_client.config.client_side_validation && lb_service.nil?
        fail ArgumentError, "Missing the required parameter 'lb_service' when calling ServicesApi.update_load_balancer_service"
      end
      # resource path
      local_var_path = "/loadbalancer/services/{service-id}".sub('{' + 'service-id' + '}', service_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_service)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbService')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_load_balancer_service\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a load balancer TCP profile
    # Update a load balancer TCP profile. 
    # @param tcp_profile_id 
    # @param lb_tcp_profile 
    # @param [Hash] opts the optional parameters
    # @return [LbTcpProfile]
    def update_load_balancer_tcp_profile(tcp_profile_id, lb_tcp_profile, opts = {})
      data, _status_code, _headers = update_load_balancer_tcp_profile_with_http_info(tcp_profile_id, lb_tcp_profile, opts)
      return data
    end

    # Update a load balancer TCP profile
    # Update a load balancer TCP profile. 
    # @param tcp_profile_id 
    # @param lb_tcp_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbTcpProfile, Fixnum, Hash)>] LbTcpProfile data, response status code and response headers
    def update_load_balancer_tcp_profile_with_http_info(tcp_profile_id, lb_tcp_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_load_balancer_tcp_profile ..."
      end
      # verify the required parameter 'tcp_profile_id' is set
      if @api_client.config.client_side_validation && tcp_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'tcp_profile_id' when calling ServicesApi.update_load_balancer_tcp_profile"
      end
      # verify the required parameter 'lb_tcp_profile' is set
      if @api_client.config.client_side_validation && lb_tcp_profile.nil?
        fail ArgumentError, "Missing the required parameter 'lb_tcp_profile' when calling ServicesApi.update_load_balancer_tcp_profile"
      end
      # resource path
      local_var_path = "/loadbalancer/tcp-profiles/{tcp-profile-id}".sub('{' + 'tcp-profile-id' + '}', tcp_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_tcp_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbTcpProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_load_balancer_tcp_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a load balancer virtual server
    # Update a load balancer virtual server. 
    # @param virtual_server_id 
    # @param lb_virtual_server 
    # @param [Hash] opts the optional parameters
    # @return [LbVirtualServer]
    def update_load_balancer_virtual_server(virtual_server_id, lb_virtual_server, opts = {})
      data, _status_code, _headers = update_load_balancer_virtual_server_with_http_info(virtual_server_id, lb_virtual_server, opts)
      return data
    end

    # Update a load balancer virtual server
    # Update a load balancer virtual server. 
    # @param virtual_server_id 
    # @param lb_virtual_server 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbVirtualServer, Fixnum, Hash)>] LbVirtualServer data, response status code and response headers
    def update_load_balancer_virtual_server_with_http_info(virtual_server_id, lb_virtual_server, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_load_balancer_virtual_server ..."
      end
      # verify the required parameter 'virtual_server_id' is set
      if @api_client.config.client_side_validation && virtual_server_id.nil?
        fail ArgumentError, "Missing the required parameter 'virtual_server_id' when calling ServicesApi.update_load_balancer_virtual_server"
      end
      # verify the required parameter 'lb_virtual_server' is set
      if @api_client.config.client_side_validation && lb_virtual_server.nil?
        fail ArgumentError, "Missing the required parameter 'lb_virtual_server' when calling ServicesApi.update_load_balancer_virtual_server"
      end
      # resource path
      local_var_path = "/loadbalancer/virtual-servers/{virtual-server-id}".sub('{' + 'virtual-server-id' + '}', virtual_server_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_virtual_server)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbVirtualServer')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_load_balancer_virtual_server\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a load balancer virtual server with rules
    # It is used to update virtual servers, the associated rules and update the binding of virtual server and rules. To add new rules, make sure the rules which have no identifier specified, the new rules are automatically generated and associated to the virtual server. To delete old rules, the rules should not be configured in new action, the UUID of deleted rules should be also removed from rule_ids. To update rules, the rules should be specified with new change and configured with identifier. If there are some rules which are not modified, those rule should not be specified in the rules list, the UUID list of rules should be specified in rule_ids of LbVirtualServer. 
    # @param virtual_server_id 
    # @param lb_virtual_server_with_rule 
    # @param [Hash] opts the optional parameters
    # @return [LbVirtualServerWithRule]
    def update_load_balancer_virtual_server_with_rules_update_with_rules(virtual_server_id, lb_virtual_server_with_rule, opts = {})
      data, _status_code, _headers = update_load_balancer_virtual_server_with_rules_update_with_rules_with_http_info(virtual_server_id, lb_virtual_server_with_rule, opts)
      return data
    end

    # Update a load balancer virtual server with rules
    # It is used to update virtual servers, the associated rules and update the binding of virtual server and rules. To add new rules, make sure the rules which have no identifier specified, the new rules are automatically generated and associated to the virtual server. To delete old rules, the rules should not be configured in new action, the UUID of deleted rules should be also removed from rule_ids. To update rules, the rules should be specified with new change and configured with identifier. If there are some rules which are not modified, those rule should not be specified in the rules list, the UUID list of rules should be specified in rule_ids of LbVirtualServer. 
    # @param virtual_server_id 
    # @param lb_virtual_server_with_rule 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LbVirtualServerWithRule, Fixnum, Hash)>] LbVirtualServerWithRule data, response status code and response headers
    def update_load_balancer_virtual_server_with_rules_update_with_rules_with_http_info(virtual_server_id, lb_virtual_server_with_rule, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_load_balancer_virtual_server_with_rules_update_with_rules ..."
      end
      # verify the required parameter 'virtual_server_id' is set
      if @api_client.config.client_side_validation && virtual_server_id.nil?
        fail ArgumentError, "Missing the required parameter 'virtual_server_id' when calling ServicesApi.update_load_balancer_virtual_server_with_rules_update_with_rules"
      end
      # verify the required parameter 'lb_virtual_server_with_rule' is set
      if @api_client.config.client_side_validation && lb_virtual_server_with_rule.nil?
        fail ArgumentError, "Missing the required parameter 'lb_virtual_server_with_rule' when calling ServicesApi.update_load_balancer_virtual_server_with_rules_update_with_rules"
      end
      # resource path
      local_var_path = "/loadbalancer/virtual-servers/{virtual-server-id}?action=update_with_rules".sub('{' + 'virtual-server-id' + '}', virtual_server_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(lb_virtual_server_with_rule)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LbVirtualServerWithRule')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_load_balancer_virtual_server_with_rules_update_with_rules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a metadata proxy
    # Update a metadata proxy
    # @param proxy_id 
    # @param metadata_proxy 
    # @param [Hash] opts the optional parameters
    # @return [MetadataProxy]
    def update_metadata_proxy(proxy_id, metadata_proxy, opts = {})
      data, _status_code, _headers = update_metadata_proxy_with_http_info(proxy_id, metadata_proxy, opts)
      return data
    end

    # Update a metadata proxy
    # Update a metadata proxy
    # @param proxy_id 
    # @param metadata_proxy 
    # @param [Hash] opts the optional parameters
    # @return [Array<(MetadataProxy, Fixnum, Hash)>] MetadataProxy data, response status code and response headers
    def update_metadata_proxy_with_http_info(proxy_id, metadata_proxy, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_metadata_proxy ..."
      end
      # verify the required parameter 'proxy_id' is set
      if @api_client.config.client_side_validation && proxy_id.nil?
        fail ArgumentError, "Missing the required parameter 'proxy_id' when calling ServicesApi.update_metadata_proxy"
      end
      # verify the required parameter 'metadata_proxy' is set
      if @api_client.config.client_side_validation && metadata_proxy.nil?
        fail ArgumentError, "Missing the required parameter 'metadata_proxy' when calling ServicesApi.update_metadata_proxy"
      end
      # resource path
      local_var_path = "/md-proxies/{proxy-id}".sub('{' + 'proxy-id' + '}', proxy_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(metadata_proxy)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MetadataProxy')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_metadata_proxy\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update an Existing Rule
    # Modifies existing firewall rule in a firewall section. Updating firewall rule in a section modifies parent section entity and simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update. 
    # @param section_id 
    # @param rule_id 
    # @param firewall_rule 
    # @param [Hash] opts the optional parameters
    # @return [FirewallRule]
    def update_rule(section_id, rule_id, firewall_rule, opts = {})
      data, _status_code, _headers = update_rule_with_http_info(section_id, rule_id, firewall_rule, opts)
      return data
    end

    # Update an Existing Rule
    # Modifies existing firewall rule in a firewall section. Updating firewall rule in a section modifies parent section entity and simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update. 
    # @param section_id 
    # @param rule_id 
    # @param firewall_rule 
    # @param [Hash] opts the optional parameters
    # @return [Array<(FirewallRule, Fixnum, Hash)>] FirewallRule data, response status code and response headers
    def update_rule_with_http_info(section_id, rule_id, firewall_rule, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_rule ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.update_rule"
      end
      # verify the required parameter 'rule_id' is set
      if @api_client.config.client_side_validation && rule_id.nil?
        fail ArgumentError, "Missing the required parameter 'rule_id' when calling ServicesApi.update_rule"
      end
      # verify the required parameter 'firewall_rule' is set
      if @api_client.config.client_side_validation && firewall_rule.nil?
        fail ArgumentError, "Missing the required parameter 'firewall_rule' when calling ServicesApi.update_rule"
      end
      # resource path
      local_var_path = "/firewall/sections/{section-id}/rules/{rule-id}".sub('{' + 'section-id' + '}', section_id.to_s).sub('{' + 'rule-id' + '}', rule_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(firewall_rule)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallRule')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update an Existing Section
    # Modifies the specified section, but does not modify the section's associated rules. Simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update. 
    # @param section_id 
    # @param firewall_section 
    # @param [Hash] opts the optional parameters
    # @return [FirewallSection]
    def update_section(section_id, firewall_section, opts = {})
      data, _status_code, _headers = update_section_with_http_info(section_id, firewall_section, opts)
      return data
    end

    # Update an Existing Section
    # Modifies the specified section, but does not modify the section&#39;s associated rules. Simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update. 
    # @param section_id 
    # @param firewall_section 
    # @param [Hash] opts the optional parameters
    # @return [Array<(FirewallSection, Fixnum, Hash)>] FirewallSection data, response status code and response headers
    def update_section_with_http_info(section_id, firewall_section, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_section ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.update_section"
      end
      # verify the required parameter 'firewall_section' is set
      if @api_client.config.client_side_validation && firewall_section.nil?
        fail ArgumentError, "Missing the required parameter 'firewall_section' when calling ServicesApi.update_section"
      end
      # resource path
      local_var_path = "/firewall/sections/{section-id}".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(firewall_section)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallSection')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_section\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update an Existing Section, Including Its Rules
    # Modifies existing firewall section along with its association with rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to update rule content, use: PUT /api/v1/firewall/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt;  Simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update. 
    # @param section_id 
    # @param firewall_section_rule_list 
    # @param [Hash] opts the optional parameters
    # @return [FirewallSectionRuleList]
    def update_section_with_rules_update_with_rules(section_id, firewall_section_rule_list, opts = {})
      data, _status_code, _headers = update_section_with_rules_update_with_rules_with_http_info(section_id, firewall_section_rule_list, opts)
      return data
    end

    # Update an Existing Section, Including Its Rules
    # Modifies existing firewall section along with its association with rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to update rule content, use: PUT /api/v1/firewall/sections/&amp;lt;section-id&amp;gt;/rules/&amp;lt;rule-id&amp;gt;  Simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update. 
    # @param section_id 
    # @param firewall_section_rule_list 
    # @param [Hash] opts the optional parameters
    # @return [Array<(FirewallSectionRuleList, Fixnum, Hash)>] FirewallSectionRuleList data, response status code and response headers
    def update_section_with_rules_update_with_rules_with_http_info(section_id, firewall_section_rule_list, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_section_with_rules_update_with_rules ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.update_section_with_rules_update_with_rules"
      end
      # verify the required parameter 'firewall_section_rule_list' is set
      if @api_client.config.client_side_validation && firewall_section_rule_list.nil?
        fail ArgumentError, "Missing the required parameter 'firewall_section_rule_list' when calling ServicesApi.update_section_with_rules_update_with_rules"
      end
      # resource path
      local_var_path = "/firewall/sections/{section-id}?action=update_with_rules".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(firewall_section_rule_list)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FirewallSectionRuleList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_section_with_rules_update_with_rules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update an Existing Rule
    # Modifies existing serviceinsertion rule in a serviceinsertion section. 
    # @param section_id 
    # @param rule_id 
    # @param service_insertion_rule 
    # @param [Hash] opts the optional parameters
    # @return [ServiceInsertionRule]
    def update_service_insertion_rule(section_id, rule_id, service_insertion_rule, opts = {})
      data, _status_code, _headers = update_service_insertion_rule_with_http_info(section_id, rule_id, service_insertion_rule, opts)
      return data
    end

    # Update an Existing Rule
    # Modifies existing serviceinsertion rule in a serviceinsertion section. 
    # @param section_id 
    # @param rule_id 
    # @param service_insertion_rule 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ServiceInsertionRule, Fixnum, Hash)>] ServiceInsertionRule data, response status code and response headers
    def update_service_insertion_rule_with_http_info(section_id, rule_id, service_insertion_rule, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_service_insertion_rule ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.update_service_insertion_rule"
      end
      # verify the required parameter 'rule_id' is set
      if @api_client.config.client_side_validation && rule_id.nil?
        fail ArgumentError, "Missing the required parameter 'rule_id' when calling ServicesApi.update_service_insertion_rule"
      end
      # verify the required parameter 'service_insertion_rule' is set
      if @api_client.config.client_side_validation && service_insertion_rule.nil?
        fail ArgumentError, "Missing the required parameter 'service_insertion_rule' when calling ServicesApi.update_service_insertion_rule"
      end
      # resource path
      local_var_path = "/serviceinsertion/sections/{section-id}/rules/{rule-id}".sub('{' + 'section-id' + '}', section_id.to_s).sub('{' + 'rule-id' + '}', rule_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(service_insertion_rule)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceInsertionRule')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_service_insertion_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update an Existing Section
    # Modifies the specified section, but does not modify the section's associated rules. 
    # @param section_id 
    # @param service_insertion_section 
    # @param [Hash] opts the optional parameters
    # @return [ServiceInsertionSection]
    def update_service_insertion_section(section_id, service_insertion_section, opts = {})
      data, _status_code, _headers = update_service_insertion_section_with_http_info(section_id, service_insertion_section, opts)
      return data
    end

    # Update an Existing Section
    # Modifies the specified section, but does not modify the section&#39;s associated rules. 
    # @param section_id 
    # @param service_insertion_section 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ServiceInsertionSection, Fixnum, Hash)>] ServiceInsertionSection data, response status code and response headers
    def update_service_insertion_section_with_http_info(section_id, service_insertion_section, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_service_insertion_section ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.update_service_insertion_section"
      end
      # verify the required parameter 'service_insertion_section' is set
      if @api_client.config.client_side_validation && service_insertion_section.nil?
        fail ArgumentError, "Missing the required parameter 'service_insertion_section' when calling ServicesApi.update_service_insertion_section"
      end
      # resource path
      local_var_path = "/serviceinsertion/sections/{section-id}".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(service_insertion_section)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceInsertionSection')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_service_insertion_section\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update an Existing Section, Including Its Rules
    # Modifies existing serviceinsertion section along with its association with rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to update rule content, use: PUT /api/v1/serviceinsertion/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt; 
    # @param section_id 
    # @param service_insertion_section_rule_list 
    # @param [Hash] opts the optional parameters
    # @return [ServiceInsertionSectionRuleList]
    def update_service_insertion_section_with_rules_update_with_rules(section_id, service_insertion_section_rule_list, opts = {})
      data, _status_code, _headers = update_service_insertion_section_with_rules_update_with_rules_with_http_info(section_id, service_insertion_section_rule_list, opts)
      return data
    end

    # Update an Existing Section, Including Its Rules
    # Modifies existing serviceinsertion section along with its association with rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to update rule content, use: PUT /api/v1/serviceinsertion/sections/&amp;lt;section-id&amp;gt;/rules/&amp;lt;rule-id&amp;gt; 
    # @param section_id 
    # @param service_insertion_section_rule_list 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ServiceInsertionSectionRuleList, Fixnum, Hash)>] ServiceInsertionSectionRuleList data, response status code and response headers
    def update_service_insertion_section_with_rules_update_with_rules_with_http_info(section_id, service_insertion_section_rule_list, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_service_insertion_section_with_rules_update_with_rules ..."
      end
      # verify the required parameter 'section_id' is set
      if @api_client.config.client_side_validation && section_id.nil?
        fail ArgumentError, "Missing the required parameter 'section_id' when calling ServicesApi.update_service_insertion_section_with_rules_update_with_rules"
      end
      # verify the required parameter 'service_insertion_section_rule_list' is set
      if @api_client.config.client_side_validation && service_insertion_section_rule_list.nil?
        fail ArgumentError, "Missing the required parameter 'service_insertion_section_rule_list' when calling ServicesApi.update_service_insertion_section_with_rules_update_with_rules"
      end
      # resource path
      local_var_path = "/serviceinsertion/sections/{section-id}?action=update_with_rules".sub('{' + 'section-id' + '}', section_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(service_insertion_section_rule_list)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceInsertionSectionRuleList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_service_insertion_section_with_rules_update_with_rules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update an existing Service
    # Modifies the specified Service. 
    # @param service_id 
    # @param service_definition 
    # @param [Hash] opts the optional parameters
    # @return [ServiceDefinition]
    def update_service_insertion_service(service_id, service_definition, opts = {})
      data, _status_code, _headers = update_service_insertion_service_with_http_info(service_id, service_definition, opts)
      return data
    end

    # Update an existing Service
    # Modifies the specified Service. 
    # @param service_id 
    # @param service_definition 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ServiceDefinition, Fixnum, Hash)>] ServiceDefinition data, response status code and response headers
    def update_service_insertion_service_with_http_info(service_id, service_definition, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_service_insertion_service ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.update_service_insertion_service"
      end
      # verify the required parameter 'service_definition' is set
      if @api_client.config.client_side_validation && service_definition.nil?
        fail ArgumentError, "Missing the required parameter 'service_definition' when calling ServicesApi.update_service_insertion_service"
      end
      # resource path
      local_var_path = "/serviceinsertion/services/{service-id}".sub('{' + 'service-id' + '}', service_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(service_definition)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceDefinition')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_service_insertion_service\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update an existing Service-Instance.
    # Modifies an existing Service-Instance for a given Service-Insertion Service. 
    # @param service_id 
    # @param service_instance_id 
    # @param base_service_instance 
    # @param [Hash] opts the optional parameters
    # @return [BaseServiceInstance]
    def update_service_instance(service_id, service_instance_id, base_service_instance, opts = {})
      data, _status_code, _headers = update_service_instance_with_http_info(service_id, service_instance_id, base_service_instance, opts)
      return data
    end

    # Update an existing Service-Instance.
    # Modifies an existing Service-Instance for a given Service-Insertion Service. 
    # @param service_id 
    # @param service_instance_id 
    # @param base_service_instance 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BaseServiceInstance, Fixnum, Hash)>] BaseServiceInstance data, response status code and response headers
    def update_service_instance_with_http_info(service_id, service_instance_id, base_service_instance, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.update_service_instance ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.update_service_instance"
      end
      # verify the required parameter 'service_instance_id' is set
      if @api_client.config.client_side_validation && service_instance_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_instance_id' when calling ServicesApi.update_service_instance"
      end
      # verify the required parameter 'base_service_instance' is set
      if @api_client.config.client_side_validation && base_service_instance.nil?
        fail ArgumentError, "Missing the required parameter 'base_service_instance' when calling ServicesApi.update_service_instance"
      end
      # resource path
      local_var_path = "/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}".sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'service-instance-id' + '}', service_instance_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(base_service_instance)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BaseServiceInstance')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#update_service_instance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Upgrade service VMs using newer version of OVF
    # Upgrade service VMs using newer version of OVF.  In case of HA, the stand-by service VM will be upgrade first. Once it has been upgraded, it switches to be the Active one and then the other VM will be upgrade. 
    # @param service_id 
    # @param service_instance_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def upgrade_service_v_ms_upgrade(service_id, service_instance_id, opts = {})
      upgrade_service_v_ms_upgrade_with_http_info(service_id, service_instance_id, opts)
      return nil
    end

    # Upgrade service VMs using newer version of OVF
    # Upgrade service VMs using newer version of OVF.  In case of HA, the stand-by service VM will be upgrade first. Once it has been upgraded, it switches to be the Active one and then the other VM will be upgrade. 
    # @param service_id 
    # @param service_instance_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def upgrade_service_v_ms_upgrade_with_http_info(service_id, service_instance_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: ServicesApi.upgrade_service_v_ms_upgrade ..."
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling ServicesApi.upgrade_service_v_ms_upgrade"
      end
      # verify the required parameter 'service_instance_id' is set
      if @api_client.config.client_side_validation && service_instance_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_instance_id' when calling ServicesApi.upgrade_service_v_ms_upgrade"
      end
      # resource path
      local_var_path = "/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/instance-runtimes?action=upgrade".sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'service-instance-id' + '}', service_instance_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServicesApi#upgrade_service_v_ms_upgrade\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
