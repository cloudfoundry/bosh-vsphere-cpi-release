=begin
#NSX-T Manager API

#VMware NSX-T Manager REST API

OpenAPI spec version: 2.3.0.0.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.3.1

=end

require "uri"

module NSXT
  class NetworkTransportApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end

    # Create a Bridge Cluster
    # Creates a bridge cluster. It is collection of transport nodes that will do the bridging for overlay network to vlan networks. Bridge cluster may have one or more transport nodes 
    # @param bridge_cluster 
    # @param [Hash] opts the optional parameters
    # @return [BridgeCluster]
    def create_bridge_cluster(bridge_cluster, opts = {})
      data, _status_code, _headers = create_bridge_cluster_with_http_info(bridge_cluster, opts)
      return data
    end

    # Create a Bridge Cluster
    # Creates a bridge cluster. It is collection of transport nodes that will do the bridging for overlay network to vlan networks. Bridge cluster may have one or more transport nodes 
    # @param bridge_cluster 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BridgeCluster, Fixnum, Hash)>] BridgeCluster data, response status code and response headers
    def create_bridge_cluster_with_http_info(bridge_cluster, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.create_bridge_cluster ..."
      end
      # verify the required parameter 'bridge_cluster' is set
      if @api_client.config.client_side_validation && bridge_cluster.nil?
        fail ArgumentError, "Missing the required parameter 'bridge_cluster' when calling NetworkTransportApi.create_bridge_cluster"
      end
      # resource path
      local_var_path = "/bridge-clusters"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(bridge_cluster)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BridgeCluster')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#create_bridge_cluster\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a Bridge Endpoint
    # Creates a Bridge Endpoint. It describes the physical attributes of the bridge like vlan. A logical port can be attached to a vif providing bridging functionality from the logical overlay network to the physical vlan network 
    # @param bridge_endpoint 
    # @param [Hash] opts the optional parameters
    # @return [BridgeEndpoint]
    def create_bridge_endpoint(bridge_endpoint, opts = {})
      data, _status_code, _headers = create_bridge_endpoint_with_http_info(bridge_endpoint, opts)
      return data
    end

    # Create a Bridge Endpoint
    # Creates a Bridge Endpoint. It describes the physical attributes of the bridge like vlan. A logical port can be attached to a vif providing bridging functionality from the logical overlay network to the physical vlan network 
    # @param bridge_endpoint 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BridgeEndpoint, Fixnum, Hash)>] BridgeEndpoint data, response status code and response headers
    def create_bridge_endpoint_with_http_info(bridge_endpoint, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.create_bridge_endpoint ..."
      end
      # verify the required parameter 'bridge_endpoint' is set
      if @api_client.config.client_side_validation && bridge_endpoint.nil?
        fail ArgumentError, "Missing the required parameter 'bridge_endpoint' when calling NetworkTransportApi.create_bridge_endpoint"
      end
      # resource path
      local_var_path = "/bridge-endpoints"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(bridge_endpoint)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BridgeEndpoint')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#create_bridge_endpoint\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a Bridge Endpoint Profile
    # Creates a Bridge Endpoint Profile. Profile contains edge cluster id, indexes of the member nodes, fialover mode and high availability mode for a Bridge EndPoint 
    # @param bridge_endpoint_profile 
    # @param [Hash] opts the optional parameters
    # @return [BridgeEndpointProfile]
    def create_bridge_endpoint_profile(bridge_endpoint_profile, opts = {})
      data, _status_code, _headers = create_bridge_endpoint_profile_with_http_info(bridge_endpoint_profile, opts)
      return data
    end

    # Create a Bridge Endpoint Profile
    # Creates a Bridge Endpoint Profile. Profile contains edge cluster id, indexes of the member nodes, fialover mode and high availability mode for a Bridge EndPoint 
    # @param bridge_endpoint_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BridgeEndpointProfile, Fixnum, Hash)>] BridgeEndpointProfile data, response status code and response headers
    def create_bridge_endpoint_profile_with_http_info(bridge_endpoint_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.create_bridge_endpoint_profile ..."
      end
      # verify the required parameter 'bridge_endpoint_profile' is set
      if @api_client.config.client_side_validation && bridge_endpoint_profile.nil?
        fail ArgumentError, "Missing the required parameter 'bridge_endpoint_profile' when calling NetworkTransportApi.create_bridge_endpoint_profile"
      end
      # resource path
      local_var_path = "/bridge-endpoint-profiles"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(bridge_endpoint_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BridgeEndpointProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#create_bridge_endpoint_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a Cluster Profile
    # Create a cluster profile. The resource_type is required. 
    # @param cluster_profile 
    # @param [Hash] opts the optional parameters
    # @return [ClusterProfile]
    def create_cluster_profile(cluster_profile, opts = {})
      data, _status_code, _headers = create_cluster_profile_with_http_info(cluster_profile, opts)
      return data
    end

    # Create a Cluster Profile
    # Create a cluster profile. The resource_type is required. 
    # @param cluster_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ClusterProfile, Fixnum, Hash)>] ClusterProfile data, response status code and response headers
    def create_cluster_profile_with_http_info(cluster_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.create_cluster_profile ..."
      end
      # verify the required parameter 'cluster_profile' is set
      if @api_client.config.client_side_validation && cluster_profile.nil?
        fail ArgumentError, "Missing the required parameter 'cluster_profile' when calling NetworkTransportApi.create_cluster_profile"
      end
      # resource path
      local_var_path = "/cluster-profiles"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(cluster_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ClusterProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#create_cluster_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create transport node template for compute collection.
    # If automated transport node creation is configured on compute collection, this template will serve as the default setting for transport node creation.
    # @param compute_collection_transport_node_template 
    # @param [Hash] opts the optional parameters
    # @return [ComputeCollectionTransportNodeTemplate]
    def create_compute_collection_transport_node_template(compute_collection_transport_node_template, opts = {})
      data, _status_code, _headers = create_compute_collection_transport_node_template_with_http_info(compute_collection_transport_node_template, opts)
      return data
    end

    # Create transport node template for compute collection.
    # If automated transport node creation is configured on compute collection, this template will serve as the default setting for transport node creation.
    # @param compute_collection_transport_node_template 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ComputeCollectionTransportNodeTemplate, Fixnum, Hash)>] ComputeCollectionTransportNodeTemplate data, response status code and response headers
    def create_compute_collection_transport_node_template_with_http_info(compute_collection_transport_node_template, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.create_compute_collection_transport_node_template ..."
      end
      # verify the required parameter 'compute_collection_transport_node_template' is set
      if @api_client.config.client_side_validation && compute_collection_transport_node_template.nil?
        fail ArgumentError, "Missing the required parameter 'compute_collection_transport_node_template' when calling NetworkTransportApi.create_compute_collection_transport_node_template"
      end
      # resource path
      local_var_path = "/compute-collection-transport-node-templates"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(compute_collection_transport_node_template)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ComputeCollectionTransportNodeTemplate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#create_compute_collection_transport_node_template\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Edge Cluster
    # Creates a new edge cluster. It only supports homogeneous members. The TransportNodes backed by EdgeNode are only allowed in cluster members. DeploymentType (VIRTUAL_MACHINE|PHYSICAL_MACHINE) of these EdgeNodes is recommended to be the same. EdgeCluster supports members of different deployment types. 
    # @param edge_cluster 
    # @param [Hash] opts the optional parameters
    # @return [EdgeCluster]
    def create_edge_cluster(edge_cluster, opts = {})
      data, _status_code, _headers = create_edge_cluster_with_http_info(edge_cluster, opts)
      return data
    end

    # Create Edge Cluster
    # Creates a new edge cluster. It only supports homogeneous members. The TransportNodes backed by EdgeNode are only allowed in cluster members. DeploymentType (VIRTUAL_MACHINE|PHYSICAL_MACHINE) of these EdgeNodes is recommended to be the same. EdgeCluster supports members of different deployment types. 
    # @param edge_cluster 
    # @param [Hash] opts the optional parameters
    # @return [Array<(EdgeCluster, Fixnum, Hash)>] EdgeCluster data, response status code and response headers
    def create_edge_cluster_with_http_info(edge_cluster, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.create_edge_cluster ..."
      end
      # verify the required parameter 'edge_cluster' is set
      if @api_client.config.client_side_validation && edge_cluster.nil?
        fail ArgumentError, "Missing the required parameter 'edge_cluster' when calling NetworkTransportApi.create_edge_cluster"
      end
      # resource path
      local_var_path = "/edge-clusters"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(edge_cluster)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EdgeCluster')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#create_edge_cluster\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a Hostswitch Profile
    # Creates a hostswitch profile. The resource_type is required. For uplink profiles, the teaming and policy parameters are required. By default, the mtu is 1600 and the transport_vlan is 0. The supported MTU range is 1280 through 9000. 
    # @param base_host_switch_profile 
    # @param [Hash] opts the optional parameters
    # @return [BaseHostSwitchProfile]
    def create_host_switch_profile(base_host_switch_profile, opts = {})
      data, _status_code, _headers = create_host_switch_profile_with_http_info(base_host_switch_profile, opts)
      return data
    end

    # Create a Hostswitch Profile
    # Creates a hostswitch profile. The resource_type is required. For uplink profiles, the teaming and policy parameters are required. By default, the mtu is 1600 and the transport_vlan is 0. The supported MTU range is 1280 through 9000. 
    # @param base_host_switch_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BaseHostSwitchProfile, Fixnum, Hash)>] BaseHostSwitchProfile data, response status code and response headers
    def create_host_switch_profile_with_http_info(base_host_switch_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.create_host_switch_profile ..."
      end
      # verify the required parameter 'base_host_switch_profile' is set
      if @api_client.config.client_side_validation && base_host_switch_profile.nil?
        fail ArgumentError, "Missing the required parameter 'base_host_switch_profile' when calling NetworkTransportApi.create_host_switch_profile"
      end
      # resource path
      local_var_path = "/host-switch-profiles"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(base_host_switch_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BaseHostSwitchProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#create_host_switch_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a template of network migration specification.
    # Network migration specification once created and can be used as a template to indicate associated component which networks should be migrated and where. Currently migration template can be associated with compute collections which are managed by vCenter host profiles, to trigger automatic migration of networks for Stateless ESX hosts. Currently we only support creation of HostProfileNetworkMigrationSpec type of specification.
    # @param network_migration_spec 
    # @param [Hash] opts the optional parameters
    # @return [NetworkMigrationSpec]
    def create_network_migration_spec(network_migration_spec, opts = {})
      data, _status_code, _headers = create_network_migration_spec_with_http_info(network_migration_spec, opts)
      return data
    end

    # Create a template of network migration specification.
    # Network migration specification once created and can be used as a template to indicate associated component which networks should be migrated and where. Currently migration template can be associated with compute collections which are managed by vCenter host profiles, to trigger automatic migration of networks for Stateless ESX hosts. Currently we only support creation of HostProfileNetworkMigrationSpec type of specification.
    # @param network_migration_spec 
    # @param [Hash] opts the optional parameters
    # @return [Array<(NetworkMigrationSpec, Fixnum, Hash)>] NetworkMigrationSpec data, response status code and response headers
    def create_network_migration_spec_with_http_info(network_migration_spec, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.create_network_migration_spec ..."
      end
      # verify the required parameter 'network_migration_spec' is set
      if @api_client.config.client_side_validation && network_migration_spec.nil?
        fail ArgumentError, "Missing the required parameter 'network_migration_spec' when calling NetworkTransportApi.create_network_migration_spec"
      end
      # resource path
      local_var_path = "/network-migration-specs"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(network_migration_spec)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'NetworkMigrationSpec')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#create_network_migration_spec\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a Transport Node
    # Enables a fabric node to act as a transport node.  Additional documentation on creating a transport node can be found in the NSX-T Installation Guide.  Transport nodes are hypervisor hosts and NSX Edges that will participate in an NSX-T overlay. For a hypervisor host, this means that it hosts VMs that will communicate over NSX-T logical switches. For NSX Edges, this means that it will have logical router uplinks and downlinks.  When creating a transport node, you must provide the node id of an existing fabric node (hypervisor host or NSX Edge node) in the node_id property of the payload. This property is required.  Additionally, in order for the transport node to forward packets, the host_switch_spec property must be specified.  Host switches (called bridges in OVS on KVM hypervisors) are the individual switches within the host virtual switch. Virtual machines are connected to the host switches.  When creating a transport node, you need to specify if the host switches are already manually preconfigured on the node, or if NSX should create and manage the host switches. You specify this choice by the type of host switches you pass in the host_switch_spec property of the TransportNode request payload.  For a KVM host, you can preconfigure the host switch, or you can have NSX Manager perform the configuration. For an ESXi host or NSX Edge node, NSX Manager always configures the host switch.  To preconfigure the host switches on a KVM host, pass an array of PreconfiguredHostSwitchSpec objects that describes those host switches. In the current NSX-T release, only one prefonfigured host switch can be specified.  See the PreconfiguredHostSwitchSpec schema definition for documentation on the properties that must be provided. Preconfigured host switches are only supported on KVM hosts, not on ESXi hosts or NSX Edge nodes.  To allow NSX to manage the host switch configuration on KVM hosts, ESXi hosts, or NSX Edge nodes, pass an array of StandardHostSwitchSpec objects in the host_switch_spec property, and NSX will automatically create host switches with the properties you provide. In the current NSX-T release, up to 5 host switches can be automatically managed. See the StandardHostSwitchSpec schema definition for documentation on the properties that must be provided.  Note: previous versions of NSX-T used a property named host_switches to specify the host switch configuration on the transport node. That property is deprecated, but still functions. You should configure new host switches using the host_switch_spec property. 
    # @param transport_node 
    # @param [Hash] opts the optional parameters
    # @return [TransportNode]
    def create_transport_node(transport_node, opts = {})
      data, _status_code, _headers = create_transport_node_with_http_info(transport_node, opts)
      return data
    end

    # Create a Transport Node
    # Enables a fabric node to act as a transport node.  Additional documentation on creating a transport node can be found in the NSX-T Installation Guide.  Transport nodes are hypervisor hosts and NSX Edges that will participate in an NSX-T overlay. For a hypervisor host, this means that it hosts VMs that will communicate over NSX-T logical switches. For NSX Edges, this means that it will have logical router uplinks and downlinks.  When creating a transport node, you must provide the node id of an existing fabric node (hypervisor host or NSX Edge node) in the node_id property of the payload. This property is required.  Additionally, in order for the transport node to forward packets, the host_switch_spec property must be specified.  Host switches (called bridges in OVS on KVM hypervisors) are the individual switches within the host virtual switch. Virtual machines are connected to the host switches.  When creating a transport node, you need to specify if the host switches are already manually preconfigured on the node, or if NSX should create and manage the host switches. You specify this choice by the type of host switches you pass in the host_switch_spec property of the TransportNode request payload.  For a KVM host, you can preconfigure the host switch, or you can have NSX Manager perform the configuration. For an ESXi host or NSX Edge node, NSX Manager always configures the host switch.  To preconfigure the host switches on a KVM host, pass an array of PreconfiguredHostSwitchSpec objects that describes those host switches. In the current NSX-T release, only one prefonfigured host switch can be specified.  See the PreconfiguredHostSwitchSpec schema definition for documentation on the properties that must be provided. Preconfigured host switches are only supported on KVM hosts, not on ESXi hosts or NSX Edge nodes.  To allow NSX to manage the host switch configuration on KVM hosts, ESXi hosts, or NSX Edge nodes, pass an array of StandardHostSwitchSpec objects in the host_switch_spec property, and NSX will automatically create host switches with the properties you provide. In the current NSX-T release, up to 5 host switches can be automatically managed. See the StandardHostSwitchSpec schema definition for documentation on the properties that must be provided.  Note: previous versions of NSX-T used a property named host_switches to specify the host switch configuration on the transport node. That property is deprecated, but still functions. You should configure new host switches using the host_switch_spec property. 
    # @param transport_node 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransportNode, Fixnum, Hash)>] TransportNode data, response status code and response headers
    def create_transport_node_with_http_info(transport_node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.create_transport_node ..."
      end
      # verify the required parameter 'transport_node' is set
      if @api_client.config.client_side_validation && transport_node.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node' when calling NetworkTransportApi.create_transport_node"
      end
      # resource path
      local_var_path = "/transport-nodes"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(transport_node)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNode')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#create_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a Transport Zone
    # Creates a new transport zone. The required parameters are host_switch_name and transport_type (OVERLAY or VLAN). The optional parameters are description and display_name. 
    # @param transport_zone 
    # @param [Hash] opts the optional parameters
    # @return [TransportZone]
    def create_transport_zone(transport_zone, opts = {})
      data, _status_code, _headers = create_transport_zone_with_http_info(transport_zone, opts)
      return data
    end

    # Create a Transport Zone
    # Creates a new transport zone. The required parameters are host_switch_name and transport_type (OVERLAY or VLAN). The optional parameters are description and display_name. 
    # @param transport_zone 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransportZone, Fixnum, Hash)>] TransportZone data, response status code and response headers
    def create_transport_zone_with_http_info(transport_zone, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.create_transport_zone ..."
      end
      # verify the required parameter 'transport_zone' is set
      if @api_client.config.client_side_validation && transport_zone.nil?
        fail ArgumentError, "Missing the required parameter 'transport_zone' when calling NetworkTransportApi.create_transport_zone"
      end
      # resource path
      local_var_path = "/transport-zones"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(transport_zone)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportZone')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#create_transport_zone\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a transport zone Profile
    # Creates a transport zone profile. The resource_type is required. 
    # @param transport_zone_profile 
    # @param [Hash] opts the optional parameters
    # @return [TransportZoneProfile]
    def create_transport_zone_profile(transport_zone_profile, opts = {})
      data, _status_code, _headers = create_transport_zone_profile_with_http_info(transport_zone_profile, opts)
      return data
    end

    # Create a transport zone Profile
    # Creates a transport zone profile. The resource_type is required. 
    # @param transport_zone_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransportZoneProfile, Fixnum, Hash)>] TransportZoneProfile data, response status code and response headers
    def create_transport_zone_profile_with_http_info(transport_zone_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.create_transport_zone_profile ..."
      end
      # verify the required parameter 'transport_zone_profile' is set
      if @api_client.config.client_side_validation && transport_zone_profile.nil?
        fail ArgumentError, "Missing the required parameter 'transport_zone_profile' when calling NetworkTransportApi.create_transport_zone_profile"
      end
      # resource path
      local_var_path = "/transportzone-profiles"

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(transport_zone_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportZoneProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#create_transport_zone_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a Bridge Cluster
    # Removes the specified Bridge Cluster.
    # @param bridgecluster_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_bridge_cluster(bridgecluster_id, opts = {})
      delete_bridge_cluster_with_http_info(bridgecluster_id, opts)
      return nil
    end

    # Delete a Bridge Cluster
    # Removes the specified Bridge Cluster.
    # @param bridgecluster_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_bridge_cluster_with_http_info(bridgecluster_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.delete_bridge_cluster ..."
      end
      # verify the required parameter 'bridgecluster_id' is set
      if @api_client.config.client_side_validation && bridgecluster_id.nil?
        fail ArgumentError, "Missing the required parameter 'bridgecluster_id' when calling NetworkTransportApi.delete_bridge_cluster"
      end
      # resource path
      local_var_path = "/bridge-clusters/{bridgecluster-id}".sub('{' + 'bridgecluster-id' + '}', bridgecluster_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#delete_bridge_cluster\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a Bridge Endpoint
    # Deletes the specified Bridge Endpoint.
    # @param bridgeendpoint_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_bridge_endpoint(bridgeendpoint_id, opts = {})
      delete_bridge_endpoint_with_http_info(bridgeendpoint_id, opts)
      return nil
    end

    # Delete a Bridge Endpoint
    # Deletes the specified Bridge Endpoint.
    # @param bridgeendpoint_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_bridge_endpoint_with_http_info(bridgeendpoint_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.delete_bridge_endpoint ..."
      end
      # verify the required parameter 'bridgeendpoint_id' is set
      if @api_client.config.client_side_validation && bridgeendpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'bridgeendpoint_id' when calling NetworkTransportApi.delete_bridge_endpoint"
      end
      # resource path
      local_var_path = "/bridge-endpoints/{bridgeendpoint-id}".sub('{' + 'bridgeendpoint-id' + '}', bridgeendpoint_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#delete_bridge_endpoint\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a Bridge Endpoint Profile
    # Deletes the specified Bridge Endpoint Profile.
    # @param bridgeendpointprofile_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_bridge_endpoint_profile(bridgeendpointprofile_id, opts = {})
      delete_bridge_endpoint_profile_with_http_info(bridgeendpointprofile_id, opts)
      return nil
    end

    # Delete a Bridge Endpoint Profile
    # Deletes the specified Bridge Endpoint Profile.
    # @param bridgeendpointprofile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_bridge_endpoint_profile_with_http_info(bridgeendpointprofile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.delete_bridge_endpoint_profile ..."
      end
      # verify the required parameter 'bridgeendpointprofile_id' is set
      if @api_client.config.client_side_validation && bridgeendpointprofile_id.nil?
        fail ArgumentError, "Missing the required parameter 'bridgeendpointprofile_id' when calling NetworkTransportApi.delete_bridge_endpoint_profile"
      end
      # resource path
      local_var_path = "/bridge-endpoint-profiles/{bridgeendpointprofile-id}".sub('{' + 'bridgeendpointprofile-id' + '}', bridgeendpointprofile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#delete_bridge_endpoint_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a cluster profile
    # Delete a specified cluster profile.
    # @param cluster_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_cluster_profile(cluster_profile_id, opts = {})
      delete_cluster_profile_with_http_info(cluster_profile_id, opts)
      return nil
    end

    # Delete a cluster profile
    # Delete a specified cluster profile.
    # @param cluster_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_cluster_profile_with_http_info(cluster_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.delete_cluster_profile ..."
      end
      # verify the required parameter 'cluster_profile_id' is set
      if @api_client.config.client_side_validation && cluster_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'cluster_profile_id' when calling NetworkTransportApi.delete_cluster_profile"
      end
      # resource path
      local_var_path = "/cluster-profiles/{cluster-profile-id}".sub('{' + 'cluster-profile-id' + '}', cluster_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#delete_cluster_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a compute collection transport node template
    # Delete the specified compute collection transport node template.
    # @param template_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_compute_collection_transport_node_template(template_id, opts = {})
      delete_compute_collection_transport_node_template_with_http_info(template_id, opts)
      return nil
    end

    # Delete a compute collection transport node template
    # Delete the specified compute collection transport node template.
    # @param template_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_compute_collection_transport_node_template_with_http_info(template_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.delete_compute_collection_transport_node_template ..."
      end
      # verify the required parameter 'template_id' is set
      if @api_client.config.client_side_validation && template_id.nil?
        fail ArgumentError, "Missing the required parameter 'template_id' when calling NetworkTransportApi.delete_compute_collection_transport_node_template"
      end
      # resource path
      local_var_path = "/compute-collection-transport-node-templates/{template-id}".sub('{' + 'template-id' + '}', template_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#delete_compute_collection_transport_node_template\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Edge Cluster
    # Deletes the specified edge cluster.
    # @param edge_cluster_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_edge_cluster(edge_cluster_id, opts = {})
      delete_edge_cluster_with_http_info(edge_cluster_id, opts)
      return nil
    end

    # Delete Edge Cluster
    # Deletes the specified edge cluster.
    # @param edge_cluster_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_edge_cluster_with_http_info(edge_cluster_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.delete_edge_cluster ..."
      end
      # verify the required parameter 'edge_cluster_id' is set
      if @api_client.config.client_side_validation && edge_cluster_id.nil?
        fail ArgumentError, "Missing the required parameter 'edge_cluster_id' when calling NetworkTransportApi.delete_edge_cluster"
      end
      # resource path
      local_var_path = "/edge-clusters/{edge-cluster-id}".sub('{' + 'edge-cluster-id' + '}', edge_cluster_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#delete_edge_cluster\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a Hostswitch Profile
    # Deletes a specified hostswitch profile.
    # @param host_switch_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_host_switch_profile(host_switch_profile_id, opts = {})
      delete_host_switch_profile_with_http_info(host_switch_profile_id, opts)
      return nil
    end

    # Delete a Hostswitch Profile
    # Deletes a specified hostswitch profile.
    # @param host_switch_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_host_switch_profile_with_http_info(host_switch_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.delete_host_switch_profile ..."
      end
      # verify the required parameter 'host_switch_profile_id' is set
      if @api_client.config.client_side_validation && host_switch_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_switch_profile_id' when calling NetworkTransportApi.delete_host_switch_profile"
      end
      # resource path
      local_var_path = "/host-switch-profiles/{host-switch-profile-id}".sub('{' + 'host-switch-profile-id' + '}', host_switch_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#delete_host_switch_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a network migration specification template
    # Delete the specified network migration specification template. Delete will fail if this is a HostProfileNetworkMigrationSpec and is associated with certain compute collection.
    # @param template_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_network_migration_spec(template_id, opts = {})
      delete_network_migration_spec_with_http_info(template_id, opts)
      return nil
    end

    # Delete a network migration specification template
    # Delete the specified network migration specification template. Delete will fail if this is a HostProfileNetworkMigrationSpec and is associated with certain compute collection.
    # @param template_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_network_migration_spec_with_http_info(template_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.delete_network_migration_spec ..."
      end
      # verify the required parameter 'template_id' is set
      if @api_client.config.client_side_validation && template_id.nil?
        fail ArgumentError, "Missing the required parameter 'template_id' when calling NetworkTransportApi.delete_network_migration_spec"
      end
      # resource path
      local_var_path = "/network-migration-specs/{template-id}".sub('{' + 'template-id' + '}', template_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#delete_network_migration_spec\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a Transport Node
    # Deletes the specified transport node. Query param force can be used to force delete the host nodes. Force deletion of edge and public cloud gateway nodes is not supported. 
    # @param transportnode_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :force Force delete the resource even if it is being used somewhere  (default to false)
    # @return [nil]
    def delete_transport_node(transportnode_id, opts = {})
      delete_transport_node_with_http_info(transportnode_id, opts)
      return nil
    end

    # Delete a Transport Node
    # Deletes the specified transport node. Query param force can be used to force delete the host nodes. Force deletion of edge and public cloud gateway nodes is not supported. 
    # @param transportnode_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :force Force delete the resource even if it is being used somewhere 
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_transport_node_with_http_info(transportnode_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.delete_transport_node ..."
      end
      # verify the required parameter 'transportnode_id' is set
      if @api_client.config.client_side_validation && transportnode_id.nil?
        fail ArgumentError, "Missing the required parameter 'transportnode_id' when calling NetworkTransportApi.delete_transport_node"
      end
      # resource path
      local_var_path = "/transport-nodes/{transportnode-id}".sub('{' + 'transportnode-id' + '}', transportnode_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'force'] = opts[:'force'] if !opts[:'force'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#delete_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a Transport Zone
    # Deletes an existing transport zone.
    # @param zone_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_transport_zone(zone_id, opts = {})
      delete_transport_zone_with_http_info(zone_id, opts)
      return nil
    end

    # Delete a Transport Zone
    # Deletes an existing transport zone.
    # @param zone_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_transport_zone_with_http_info(zone_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.delete_transport_zone ..."
      end
      # verify the required parameter 'zone_id' is set
      if @api_client.config.client_side_validation && zone_id.nil?
        fail ArgumentError, "Missing the required parameter 'zone_id' when calling NetworkTransportApi.delete_transport_zone"
      end
      # resource path
      local_var_path = "/transport-zones/{zone-id}".sub('{' + 'zone-id' + '}', zone_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#delete_transport_zone\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a transport zone Profile
    # Deletes a specified transport zone profile.
    # @param transportzone_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_transport_zone_profile(transportzone_profile_id, opts = {})
      delete_transport_zone_profile_with_http_info(transportzone_profile_id, opts)
      return nil
    end

    # Delete a transport zone Profile
    # Deletes a specified transport zone profile.
    # @param transportzone_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_transport_zone_profile_with_http_info(transportzone_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.delete_transport_zone_profile ..."
      end
      # verify the required parameter 'transportzone_profile_id' is set
      if @api_client.config.client_side_validation && transportzone_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'transportzone_profile_id' when calling NetworkTransportApi.delete_transport_zone_profile"
      end
      # resource path
      local_var_path = "/transportzone-profiles/{transportzone-profile-id}".sub('{' + 'transportzone-profile-id' + '}', transportzone_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#delete_transport_zone_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Information about a bridge cluster
    # Returns information about a specified bridge cluster.
    # @param bridgecluster_id 
    # @param [Hash] opts the optional parameters
    # @return [BridgeCluster]
    def get_bridge_cluster(bridgecluster_id, opts = {})
      data, _status_code, _headers = get_bridge_cluster_with_http_info(bridgecluster_id, opts)
      return data
    end

    # Get Information about a bridge cluster
    # Returns information about a specified bridge cluster.
    # @param bridgecluster_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BridgeCluster, Fixnum, Hash)>] BridgeCluster data, response status code and response headers
    def get_bridge_cluster_with_http_info(bridgecluster_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.get_bridge_cluster ..."
      end
      # verify the required parameter 'bridgecluster_id' is set
      if @api_client.config.client_side_validation && bridgecluster_id.nil?
        fail ArgumentError, "Missing the required parameter 'bridgecluster_id' when calling NetworkTransportApi.get_bridge_cluster"
      end
      # resource path
      local_var_path = "/bridge-clusters/{bridgecluster-id}".sub('{' + 'bridgecluster-id' + '}', bridgecluster_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BridgeCluster')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#get_bridge_cluster\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Returns status of a specified Bridge Cluster
    # Get the status for the Bridge Cluster of the given cluster id
    # @param cluster_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [BridgeClusterStatus]
    def get_bridge_cluster_status(cluster_id, opts = {})
      data, _status_code, _headers = get_bridge_cluster_status_with_http_info(cluster_id, opts)
      return data
    end

    # Returns status of a specified Bridge Cluster
    # Get the status for the Bridge Cluster of the given cluster id
    # @param cluster_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(BridgeClusterStatus, Fixnum, Hash)>] BridgeClusterStatus data, response status code and response headers
    def get_bridge_cluster_status_with_http_info(cluster_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.get_bridge_cluster_status ..."
      end
      # verify the required parameter 'cluster_id' is set
      if @api_client.config.client_side_validation && cluster_id.nil?
        fail ArgumentError, "Missing the required parameter 'cluster_id' when calling NetworkTransportApi.get_bridge_cluster_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/bridge-clusters/{cluster-id}/status".sub('{' + 'cluster-id' + '}', cluster_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BridgeClusterStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#get_bridge_cluster_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Information about a bridge endpoint
    # Returns information about a specified bridge endpoint.
    # @param bridgeendpoint_id 
    # @param [Hash] opts the optional parameters
    # @return [BridgeEndpoint]
    def get_bridge_endpoint(bridgeendpoint_id, opts = {})
      data, _status_code, _headers = get_bridge_endpoint_with_http_info(bridgeendpoint_id, opts)
      return data
    end

    # Get Information about a bridge endpoint
    # Returns information about a specified bridge endpoint.
    # @param bridgeendpoint_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BridgeEndpoint, Fixnum, Hash)>] BridgeEndpoint data, response status code and response headers
    def get_bridge_endpoint_with_http_info(bridgeendpoint_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.get_bridge_endpoint ..."
      end
      # verify the required parameter 'bridgeendpoint_id' is set
      if @api_client.config.client_side_validation && bridgeendpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'bridgeendpoint_id' when calling NetworkTransportApi.get_bridge_endpoint"
      end
      # resource path
      local_var_path = "/bridge-endpoints/{bridgeendpoint-id}".sub('{' + 'bridgeendpoint-id' + '}', bridgeendpoint_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BridgeEndpoint')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#get_bridge_endpoint\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Information about a bridge endpoint Profile
    # Returns information about a specified bridge endpoint profile.
    # @param bridgeendpointprofile_id 
    # @param [Hash] opts the optional parameters
    # @return [BridgeEndpointProfile]
    def get_bridge_endpoint_profile(bridgeendpointprofile_id, opts = {})
      data, _status_code, _headers = get_bridge_endpoint_profile_with_http_info(bridgeendpointprofile_id, opts)
      return data
    end

    # Get Information about a bridge endpoint Profile
    # Returns information about a specified bridge endpoint profile.
    # @param bridgeendpointprofile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BridgeEndpointProfile, Fixnum, Hash)>] BridgeEndpointProfile data, response status code and response headers
    def get_bridge_endpoint_profile_with_http_info(bridgeendpointprofile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.get_bridge_endpoint_profile ..."
      end
      # verify the required parameter 'bridgeendpointprofile_id' is set
      if @api_client.config.client_side_validation && bridgeendpointprofile_id.nil?
        fail ArgumentError, "Missing the required parameter 'bridgeendpointprofile_id' when calling NetworkTransportApi.get_bridge_endpoint_profile"
      end
      # resource path
      local_var_path = "/bridge-endpoint-profiles/{bridgeendpointprofile-id}".sub('{' + 'bridgeendpointprofile-id' + '}', bridgeendpointprofile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BridgeEndpointProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#get_bridge_endpoint_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Returns statistics of a specified Bridge Endpoint
    # Get the statistics for the Bridge Endpoint of the given Endpoint id (endpoint-id)
    # @param endpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [BridgeEndpointStatistics]
    def get_bridge_endpoint_statistics(endpoint_id, opts = {})
      data, _status_code, _headers = get_bridge_endpoint_statistics_with_http_info(endpoint_id, opts)
      return data
    end

    # Returns statistics of a specified Bridge Endpoint
    # Get the statistics for the Bridge Endpoint of the given Endpoint id (endpoint-id)
    # @param endpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(BridgeEndpointStatistics, Fixnum, Hash)>] BridgeEndpointStatistics data, response status code and response headers
    def get_bridge_endpoint_statistics_with_http_info(endpoint_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.get_bridge_endpoint_statistics ..."
      end
      # verify the required parameter 'endpoint_id' is set
      if @api_client.config.client_side_validation && endpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'endpoint_id' when calling NetworkTransportApi.get_bridge_endpoint_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/bridge-endpoints/{endpoint-id}/statistics".sub('{' + 'endpoint-id' + '}', endpoint_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BridgeEndpointStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#get_bridge_endpoint_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Returns status of a specified Bridge Endpoint
    # Get the status for the Bridge Endpoint of the given Endpoint id
    # @param endpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [BridgeEndpointStatus]
    def get_bridge_endpoint_status(endpoint_id, opts = {})
      data, _status_code, _headers = get_bridge_endpoint_status_with_http_info(endpoint_id, opts)
      return data
    end

    # Returns status of a specified Bridge Endpoint
    # Get the status for the Bridge Endpoint of the given Endpoint id
    # @param endpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(BridgeEndpointStatus, Fixnum, Hash)>] BridgeEndpointStatus data, response status code and response headers
    def get_bridge_endpoint_status_with_http_info(endpoint_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.get_bridge_endpoint_status ..."
      end
      # verify the required parameter 'endpoint_id' is set
      if @api_client.config.client_side_validation && endpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'endpoint_id' when calling NetworkTransportApi.get_bridge_endpoint_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = "/bridge-endpoints/{endpoint-id}/status".sub('{' + 'endpoint-id' + '}', endpoint_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BridgeEndpointStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#get_bridge_endpoint_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get cluster profile by Id
    # Returns information about a specified cluster profile.
    # @param cluster_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [ClusterProfile]
    def get_cluster_profile(cluster_profile_id, opts = {})
      data, _status_code, _headers = get_cluster_profile_with_http_info(cluster_profile_id, opts)
      return data
    end

    # Get cluster profile by Id
    # Returns information about a specified cluster profile.
    # @param cluster_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ClusterProfile, Fixnum, Hash)>] ClusterProfile data, response status code and response headers
    def get_cluster_profile_with_http_info(cluster_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.get_cluster_profile ..."
      end
      # verify the required parameter 'cluster_profile_id' is set
      if @api_client.config.client_side_validation && cluster_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'cluster_profile_id' when calling NetworkTransportApi.get_cluster_profile"
      end
      # resource path
      local_var_path = "/cluster-profiles/{cluster-profile-id}".sub('{' + 'cluster-profile-id' + '}', cluster_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ClusterProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#get_cluster_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get compute collection transportnode template by id
    # Returns compute collection transportnode template by id
    # @param template_id 
    # @param [Hash] opts the optional parameters
    # @return [ComputeCollectionTransportNodeTemplate]
    def get_compute_collection_transport_node_template(template_id, opts = {})
      data, _status_code, _headers = get_compute_collection_transport_node_template_with_http_info(template_id, opts)
      return data
    end

    # Get compute collection transportnode template by id
    # Returns compute collection transportnode template by id
    # @param template_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ComputeCollectionTransportNodeTemplate, Fixnum, Hash)>] ComputeCollectionTransportNodeTemplate data, response status code and response headers
    def get_compute_collection_transport_node_template_with_http_info(template_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.get_compute_collection_transport_node_template ..."
      end
      # verify the required parameter 'template_id' is set
      if @api_client.config.client_side_validation && template_id.nil?
        fail ArgumentError, "Missing the required parameter 'template_id' when calling NetworkTransportApi.get_compute_collection_transport_node_template"
      end
      # resource path
      local_var_path = "/compute-collection-transport-node-templates/{template-id}".sub('{' + 'template-id' + '}', template_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ComputeCollectionTransportNodeTemplate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#get_compute_collection_transport_node_template\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get compute collection transportnode template application states
    # Returns detailed transport node states for this compute collection
    # @param template_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :compute_collection_id Compute collection id
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [ComputeCollectionTransportNodeTemplateStateList]
    def get_compute_collection_transport_node_template_state(template_id, opts = {})
      data, _status_code, _headers = get_compute_collection_transport_node_template_state_with_http_info(template_id, opts)
      return data
    end

    # Get compute collection transportnode template application states
    # Returns detailed transport node states for this compute collection
    # @param template_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :compute_collection_id Compute collection id
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(ComputeCollectionTransportNodeTemplateStateList, Fixnum, Hash)>] ComputeCollectionTransportNodeTemplateStateList data, response status code and response headers
    def get_compute_collection_transport_node_template_state_with_http_info(template_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.get_compute_collection_transport_node_template_state ..."
      end
      # verify the required parameter 'template_id' is set
      if @api_client.config.client_side_validation && template_id.nil?
        fail ArgumentError, "Missing the required parameter 'template_id' when calling NetworkTransportApi.get_compute_collection_transport_node_template_state"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.get_compute_collection_transport_node_template_state, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.get_compute_collection_transport_node_template_state, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/compute-collection-transport-node-templates/{template-id}/state".sub('{' + 'template-id' + '}', template_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'compute_collection_id'] = opts[:'compute_collection_id'] if !opts[:'compute_collection_id'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ComputeCollectionTransportNodeTemplateStateList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#get_compute_collection_transport_node_template_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a Hostswitch Profile by ID
    # Returns information about a specified hostswitch profile.
    # @param host_switch_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [BaseHostSwitchProfile]
    def get_host_switch_profile(host_switch_profile_id, opts = {})
      data, _status_code, _headers = get_host_switch_profile_with_http_info(host_switch_profile_id, opts)
      return data
    end

    # Get a Hostswitch Profile by ID
    # Returns information about a specified hostswitch profile.
    # @param host_switch_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BaseHostSwitchProfile, Fixnum, Hash)>] BaseHostSwitchProfile data, response status code and response headers
    def get_host_switch_profile_with_http_info(host_switch_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.get_host_switch_profile ..."
      end
      # verify the required parameter 'host_switch_profile_id' is set
      if @api_client.config.client_side_validation && host_switch_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_switch_profile_id' when calling NetworkTransportApi.get_host_switch_profile"
      end
      # resource path
      local_var_path = "/host-switch-profiles/{host-switch-profile-id}".sub('{' + 'host-switch-profile-id' + '}', host_switch_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BaseHostSwitchProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#get_host_switch_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get network migration specification template by id.
    # Network migration specification once created and can be used as a template to indicate associated component which networks should be migrated and where. Currently migration template can be associated with compute collections which are managed by vCenter host profiles, to trigger automatic migration of networks for Stateless ESX hosts. Currently we only support creation of HostProfileNetworkMigrationSpec type of specification.
    # @param template_id 
    # @param [Hash] opts the optional parameters
    # @return [NetworkMigrationSpec]
    def get_network_migration_spec(template_id, opts = {})
      data, _status_code, _headers = get_network_migration_spec_with_http_info(template_id, opts)
      return data
    end

    # Get network migration specification template by id.
    # Network migration specification once created and can be used as a template to indicate associated component which networks should be migrated and where. Currently migration template can be associated with compute collections which are managed by vCenter host profiles, to trigger automatic migration of networks for Stateless ESX hosts. Currently we only support creation of HostProfileNetworkMigrationSpec type of specification.
    # @param template_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(NetworkMigrationSpec, Fixnum, Hash)>] NetworkMigrationSpec data, response status code and response headers
    def get_network_migration_spec_with_http_info(template_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.get_network_migration_spec ..."
      end
      # verify the required parameter 'template_id' is set
      if @api_client.config.client_side_validation && template_id.nil?
        fail ArgumentError, "Missing the required parameter 'template_id' when calling NetworkTransportApi.get_network_migration_spec"
      end
      # resource path
      local_var_path = "/network-migration-specs/{template-id}".sub('{' + 'template-id' + '}', template_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'NetworkMigrationSpec')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#get_network_migration_spec\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a Transport Node
    # Returns information about a specified transport node.
    # @param transportnode_id 
    # @param [Hash] opts the optional parameters
    # @return [TransportNode]
    def get_transport_node(transportnode_id, opts = {})
      data, _status_code, _headers = get_transport_node_with_http_info(transportnode_id, opts)
      return data
    end

    # Get a Transport Node
    # Returns information about a specified transport node.
    # @param transportnode_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransportNode, Fixnum, Hash)>] TransportNode data, response status code and response headers
    def get_transport_node_with_http_info(transportnode_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.get_transport_node ..."
      end
      # verify the required parameter 'transportnode_id' is set
      if @api_client.config.client_side_validation && transportnode_id.nil?
        fail ArgumentError, "Missing the required parameter 'transportnode_id' when calling NetworkTransportApi.get_transport_node"
      end
      # resource path
      local_var_path = "/transport-nodes/{transportnode-id}".sub('{' + 'transportnode-id' + '}', transportnode_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNode')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#get_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a Transport Node's State
    # Returns information about the current state of the transport node configuration and information about the associated hostswitch. 
    # @param transportnode_id 
    # @param [Hash] opts the optional parameters
    # @return [TransportNodeState]
    def get_transport_node_state(transportnode_id, opts = {})
      data, _status_code, _headers = get_transport_node_state_with_http_info(transportnode_id, opts)
      return data
    end

    # Get a Transport Node&#39;s State
    # Returns information about the current state of the transport node configuration and information about the associated hostswitch. 
    # @param transportnode_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransportNodeState, Fixnum, Hash)>] TransportNodeState data, response status code and response headers
    def get_transport_node_state_with_http_info(transportnode_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.get_transport_node_state ..."
      end
      # verify the required parameter 'transportnode_id' is set
      if @api_client.config.client_side_validation && transportnode_id.nil?
        fail ArgumentError, "Missing the required parameter 'transportnode_id' when calling NetworkTransportApi.get_transport_node_state"
      end
      # resource path
      local_var_path = "/transport-nodes/{transportnode-id}/state".sub('{' + 'transportnode-id' + '}', transportnode_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNodeState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#get_transport_node_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a Transport Zone
    # Returns information about a single transport zone.
    # @param zone_id 
    # @param [Hash] opts the optional parameters
    # @return [TransportZone]
    def get_transport_zone(zone_id, opts = {})
      data, _status_code, _headers = get_transport_zone_with_http_info(zone_id, opts)
      return data
    end

    # Get a Transport Zone
    # Returns information about a single transport zone.
    # @param zone_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransportZone, Fixnum, Hash)>] TransportZone data, response status code and response headers
    def get_transport_zone_with_http_info(zone_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.get_transport_zone ..."
      end
      # verify the required parameter 'zone_id' is set
      if @api_client.config.client_side_validation && zone_id.nil?
        fail ArgumentError, "Missing the required parameter 'zone_id' when calling NetworkTransportApi.get_transport_zone"
      end
      # resource path
      local_var_path = "/transport-zones/{zone-id}".sub('{' + 'zone-id' + '}', zone_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportZone')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#get_transport_zone\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get transport zone profile by identifier
    # Returns information about a specified transport zone profile.
    # @param transportzone_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [TransportZoneProfile]
    def get_transport_zone_profile(transportzone_profile_id, opts = {})
      data, _status_code, _headers = get_transport_zone_profile_with_http_info(transportzone_profile_id, opts)
      return data
    end

    # Get transport zone profile by identifier
    # Returns information about a specified transport zone profile.
    # @param transportzone_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransportZoneProfile, Fixnum, Hash)>] TransportZoneProfile data, response status code and response headers
    def get_transport_zone_profile_with_http_info(transportzone_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.get_transport_zone_profile ..."
      end
      # verify the required parameter 'transportzone_profile_id' is set
      if @api_client.config.client_side_validation && transportzone_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'transportzone_profile_id' when calling NetworkTransportApi.get_transport_zone_profile"
      end
      # resource path
      local_var_path = "/transportzone-profiles/{transportzone-profile-id}".sub('{' + 'transportzone-profile-id' + '}', transportzone_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportZoneProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#get_transport_zone_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a Transport Zone's Current Runtime Status Information
    # Returns information about a specified transport zone, including the number of logical switches in the transport zone, number of logical spitch ports assigned to the transport zone, and number of transport nodes in the transport zone. 
    # @param zone_id 
    # @param [Hash] opts the optional parameters
    # @return [TransportZoneStatus]
    def get_transport_zone_status(zone_id, opts = {})
      data, _status_code, _headers = get_transport_zone_status_with_http_info(zone_id, opts)
      return data
    end

    # Get a Transport Zone&#39;s Current Runtime Status Information
    # Returns information about a specified transport zone, including the number of logical switches in the transport zone, number of logical spitch ports assigned to the transport zone, and number of transport nodes in the transport zone. 
    # @param zone_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransportZoneStatus, Fixnum, Hash)>] TransportZoneStatus data, response status code and response headers
    def get_transport_zone_status_with_http_info(zone_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.get_transport_zone_status ..."
      end
      # verify the required parameter 'zone_id' is set
      if @api_client.config.client_side_validation && zone_id.nil?
        fail ArgumentError, "Missing the required parameter 'zone_id' when calling NetworkTransportApi.get_transport_zone_status"
      end
      # resource path
      local_var_path = "/transport-zones/{zone-id}/summary".sub('{' + 'zone-id' + '}', zone_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportZoneStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#get_transport_zone_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List All Bridge Clusters
    # Returns information about all configured bridge clusters 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [BridgeClusterListResult]
    def list_bridge_clusters(opts = {})
      data, _status_code, _headers = list_bridge_clusters_with_http_info(opts)
      return data
    end

    # List All Bridge Clusters
    # Returns information about all configured bridge clusters 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(BridgeClusterListResult, Fixnum, Hash)>] BridgeClusterListResult data, response status code and response headers
    def list_bridge_clusters_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.list_bridge_clusters ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.list_bridge_clusters, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.list_bridge_clusters, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/bridge-clusters"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BridgeClusterListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#list_bridge_clusters\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List All Bridge Endpoint Profiles
    # Returns information about all configured bridge endoint profiles 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_cluster_id Edge Cluster Identifier
    # @option opts [String] :failover_mode 
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [BridgeEndpointProfileListResult]
    def list_bridge_endpoint_profiles(opts = {})
      data, _status_code, _headers = list_bridge_endpoint_profiles_with_http_info(opts)
      return data
    end

    # List All Bridge Endpoint Profiles
    # Returns information about all configured bridge endoint profiles 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_cluster_id Edge Cluster Identifier
    # @option opts [String] :failover_mode 
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(BridgeEndpointProfileListResult, Fixnum, Hash)>] BridgeEndpointProfileListResult data, response status code and response headers
    def list_bridge_endpoint_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.list_bridge_endpoint_profiles ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.list_bridge_endpoint_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.list_bridge_endpoint_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/bridge-endpoint-profiles"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_cluster_id'] = opts[:'edge_cluster_id'] if !opts[:'edge_cluster_id'].nil?
      query_params[:'failover_mode'] = opts[:'failover_mode'] if !opts[:'failover_mode'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BridgeEndpointProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#list_bridge_endpoint_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List All Bridge Endpoints
    # Returns information about all configured bridge endoints 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bridge_cluster_id Bridge Cluster Identifier
    # @option opts [String] :bridge_endpoint_profile_id Bridge endpoint profile used by the edge cluster
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :logical_switch_id Logical Switch Identifier
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :vlan_transport_zone_id VLAN transport zone id used by the edge cluster
    # @return [BridgeEndpointListResult]
    def list_bridge_endpoints(opts = {})
      data, _status_code, _headers = list_bridge_endpoints_with_http_info(opts)
      return data
    end

    # List All Bridge Endpoints
    # Returns information about all configured bridge endoints 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bridge_cluster_id Bridge Cluster Identifier
    # @option opts [String] :bridge_endpoint_profile_id Bridge endpoint profile used by the edge cluster
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :logical_switch_id Logical Switch Identifier
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :vlan_transport_zone_id VLAN transport zone id used by the edge cluster
    # @return [Array<(BridgeEndpointListResult, Fixnum, Hash)>] BridgeEndpointListResult data, response status code and response headers
    def list_bridge_endpoints_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.list_bridge_endpoints ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.list_bridge_endpoints, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.list_bridge_endpoints, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/bridge-endpoints"

      # query parameters
      query_params = {}
      query_params[:'bridge_cluster_id'] = opts[:'bridge_cluster_id'] if !opts[:'bridge_cluster_id'].nil?
      query_params[:'bridge_endpoint_profile_id'] = opts[:'bridge_endpoint_profile_id'] if !opts[:'bridge_endpoint_profile_id'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'logical_switch_id'] = opts[:'logical_switch_id'] if !opts[:'logical_switch_id'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'vlan_transport_zone_id'] = opts[:'vlan_transport_zone_id'] if !opts[:'vlan_transport_zone_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BridgeEndpointListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#list_bridge_endpoints\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Cluster Profiles
    # Returns paginated list of cluster profiles Cluster profiles define policies for edge cluster and bridge cluster. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_system_owned Whether the list result contains system resources (default to true)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :resource_type Supported cluster profiles.
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [ClusterProfileListResult]
    def list_cluster_profiles(opts = {})
      data, _status_code, _headers = list_cluster_profiles_with_http_info(opts)
      return data
    end

    # List Cluster Profiles
    # Returns paginated list of cluster profiles Cluster profiles define policies for edge cluster and bridge cluster. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_system_owned Whether the list result contains system resources
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :resource_type Supported cluster profiles.
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(ClusterProfileListResult, Fixnum, Hash)>] ClusterProfileListResult data, response status code and response headers
    def list_cluster_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.list_cluster_profiles ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.list_cluster_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.list_cluster_profiles, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'resource_type'] && !['EdgeHighAvailabilityProfile', 'BridgeHighAvailabilityClusterProfile'].include?(opts[:'resource_type'])
        fail ArgumentError, 'invalid value for "resource_type", must be one of EdgeHighAvailabilityProfile, BridgeHighAvailabilityClusterProfile'
      end
      # resource path
      local_var_path = "/cluster-profiles"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_system_owned'] = opts[:'include_system_owned'] if !opts[:'include_system_owned'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'resource_type'] = opts[:'resource_type'] if !opts[:'resource_type'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ClusterProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#list_cluster_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List compute collection transportnode templates
    # Returns all eligible compute collection transportnode templates
    # @param [Hash] opts the optional parameters
    # @option opts [String] :compute_collection_id Compute collection id
    # @return [TransportNodeTemplateListResult]
    def list_compute_collection_transport_node_templates(opts = {})
      data, _status_code, _headers = list_compute_collection_transport_node_templates_with_http_info(opts)
      return data
    end

    # List compute collection transportnode templates
    # Returns all eligible compute collection transportnode templates
    # @param [Hash] opts the optional parameters
    # @option opts [String] :compute_collection_id Compute collection id
    # @return [Array<(TransportNodeTemplateListResult, Fixnum, Hash)>] TransportNodeTemplateListResult data, response status code and response headers
    def list_compute_collection_transport_node_templates_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.list_compute_collection_transport_node_templates ..."
      end
      # resource path
      local_var_path = "/compute-collection-transport-node-templates"

      # query parameters
      query_params = {}
      query_params[:'compute_collection_id'] = opts[:'compute_collection_id'] if !opts[:'compute_collection_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNodeTemplateListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#list_compute_collection_transport_node_templates\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Edge Clusters
    # Returns information about the configured edge clusters, which enable you to group together transport nodes of the type EdgeNode and apply fabric profiles to all members of the edge cluster. Each edge node can participate in only one edge cluster. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [EdgeClusterListResult]
    def list_edge_clusters(opts = {})
      data, _status_code, _headers = list_edge_clusters_with_http_info(opts)
      return data
    end

    # List Edge Clusters
    # Returns information about the configured edge clusters, which enable you to group together transport nodes of the type EdgeNode and apply fabric profiles to all members of the edge cluster. Each edge node can participate in only one edge cluster. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(EdgeClusterListResult, Fixnum, Hash)>] EdgeClusterListResult data, response status code and response headers
    def list_edge_clusters_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.list_edge_clusters ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.list_edge_clusters, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.list_edge_clusters, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/edge-clusters"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EdgeClusterListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#list_edge_clusters\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Hostswitch Profiles
    # Returns information about the configured hostswitch profiles. Hostswitch profiles define networking policies for hostswitches (sometimes referred to as bridges in OVS). Currently, only uplink teaming is supported. Uplink teaming allows NSX to load balance traffic across different physical NICs (PNICs) on the hypervisor hosts. Multiple teaming policies are supported, including LACP active, LACP passive, load balancing based on source ID, and failover order. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :hostswitch_profile_type Supported HostSwitch profiles.
    # @option opts [BOOLEAN] :include_system_owned Whether the list result contains system resources (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :uplink_teaming_policy_name The host switch profile&#39;s uplink teaming policy name
    # @return [HostSwitchProfilesListResult]
    def list_host_switch_profiles(opts = {})
      data, _status_code, _headers = list_host_switch_profiles_with_http_info(opts)
      return data
    end

    # List Hostswitch Profiles
    # Returns information about the configured hostswitch profiles. Hostswitch profiles define networking policies for hostswitches (sometimes referred to as bridges in OVS). Currently, only uplink teaming is supported. Uplink teaming allows NSX to load balance traffic across different physical NICs (PNICs) on the hypervisor hosts. Multiple teaming policies are supported, including LACP active, LACP passive, load balancing based on source ID, and failover order. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :hostswitch_profile_type Supported HostSwitch profiles.
    # @option opts [BOOLEAN] :include_system_owned Whether the list result contains system resources
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :uplink_teaming_policy_name The host switch profile&#39;s uplink teaming policy name
    # @return [Array<(HostSwitchProfilesListResult, Fixnum, Hash)>] HostSwitchProfilesListResult data, response status code and response headers
    def list_host_switch_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.list_host_switch_profiles ..."
      end
      if @api_client.config.client_side_validation && opts[:'hostswitch_profile_type'] && !['UplinkHostSwitchProfile', 'LldpHostSwitchProfile', 'NiocProfile', 'ExtraConfigHostSwitchProfile'].include?(opts[:'hostswitch_profile_type'])
        fail ArgumentError, 'invalid value for "hostswitch_profile_type", must be one of UplinkHostSwitchProfile, LldpHostSwitchProfile, NiocProfile, ExtraConfigHostSwitchProfile'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.list_host_switch_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.list_host_switch_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/host-switch-profiles"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'hostswitch_profile_type'] = opts[:'hostswitch_profile_type'] if !opts[:'hostswitch_profile_type'].nil?
      query_params[:'include_system_owned'] = opts[:'include_system_owned'] if !opts[:'include_system_owned'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'uplink_teaming_policy_name'] = opts[:'uplink_teaming_policy_name'] if !opts[:'uplink_teaming_policy_name'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'HostSwitchProfilesListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#list_host_switch_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List LLDP Neighbor Properties
    # List LLDP Neighbor Properties
    # @param node_id ID of transport node
    # @param [Hash] opts the optional parameters
    # @return [InterfaceNeighborPropertyListResult]
    def list_neighbor_properties(node_id, opts = {})
      data, _status_code, _headers = list_neighbor_properties_with_http_info(node_id, opts)
      return data
    end

    # List LLDP Neighbor Properties
    # List LLDP Neighbor Properties
    # @param node_id ID of transport node
    # @param [Hash] opts the optional parameters
    # @return [Array<(InterfaceNeighborPropertyListResult, Fixnum, Hash)>] InterfaceNeighborPropertyListResult data, response status code and response headers
    def list_neighbor_properties_with_http_info(node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.list_neighbor_properties ..."
      end
      # verify the required parameter 'node_id' is set
      if @api_client.config.client_side_validation && node_id.nil?
        fail ArgumentError, "Missing the required parameter 'node_id' when calling NetworkTransportApi.list_neighbor_properties"
      end
      # resource path
      local_var_path = "/lldp/transport-nodes/{node-id}/interfaces".sub('{' + 'node-id' + '}', node_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'InterfaceNeighborPropertyListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#list_neighbor_properties\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List all network migration specification templates.
    # Network migration specification once created and can be used as a template to indicate associated component which networks should be migrated and where. Currently migration template can be associated with compute collections which are managed by vCenter host profiles, to trigger automatic migration of networks for Stateless ESX hosts. Currently we only support creation of HostProfileNetworkMigrationSpec type of specification.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_system_owned Whether the list result contains system resources (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Supported network migration specification types.
    # @return [NetworkMigrationSpecListResult]
    def list_network_migration_specs(opts = {})
      data, _status_code, _headers = list_network_migration_specs_with_http_info(opts)
      return data
    end

    # List all network migration specification templates.
    # Network migration specification once created and can be used as a template to indicate associated component which networks should be migrated and where. Currently migration template can be associated with compute collections which are managed by vCenter host profiles, to trigger automatic migration of networks for Stateless ESX hosts. Currently we only support creation of HostProfileNetworkMigrationSpec type of specification.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_system_owned Whether the list result contains system resources
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Supported network migration specification types.
    # @return [Array<(NetworkMigrationSpecListResult, Fixnum, Hash)>] NetworkMigrationSpecListResult data, response status code and response headers
    def list_network_migration_specs_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.list_network_migration_specs ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.list_network_migration_specs, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.list_network_migration_specs, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['HostProfileNetworkMigrationSpec'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of HostProfileNetworkMigrationSpec'
      end
      # resource path
      local_var_path = "/network-migration-specs"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_system_owned'] = opts[:'include_system_owned'] if !opts[:'include_system_owned'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'NetworkMigrationSpecListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#list_network_migration_specs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Transport Nodes
    # Returns information about all transport nodes. A transport node is a fabric node (host or edge) that contains hostswitches. A hostswitch can have virtual machines connected to them.  Because each transport node has HostSwitches, transport nodes can also have virtual tunnel endpoints, which means that they can be part of the overlay. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :in_maintenance_mode maintenance mode flag
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id node identifier
    # @option opts [String] :node_ip Fabric node IP address
    # @option opts [String] :node_types a list of fabric node types separated by comma or a single type
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :transport_zone_id Transport zone identifier
    # @return [TransportNodeListResult]
    def list_transport_nodes(opts = {})
      data, _status_code, _headers = list_transport_nodes_with_http_info(opts)
      return data
    end

    # List Transport Nodes
    # Returns information about all transport nodes. A transport node is a fabric node (host or edge) that contains hostswitches. A hostswitch can have virtual machines connected to them.  Because each transport node has HostSwitches, transport nodes can also have virtual tunnel endpoints, which means that they can be part of the overlay. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :in_maintenance_mode maintenance mode flag
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id node identifier
    # @option opts [String] :node_ip Fabric node IP address
    # @option opts [String] :node_types a list of fabric node types separated by comma or a single type
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :transport_zone_id Transport zone identifier
    # @return [Array<(TransportNodeListResult, Fixnum, Hash)>] TransportNodeListResult data, response status code and response headers
    def list_transport_nodes_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.list_transport_nodes ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.list_transport_nodes, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.list_transport_nodes, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/transport-nodes"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'in_maintenance_mode'] = opts[:'in_maintenance_mode'] if !opts[:'in_maintenance_mode'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'node_id'] = opts[:'node_id'] if !opts[:'node_id'].nil?
      query_params[:'node_ip'] = opts[:'node_ip'] if !opts[:'node_ip'].nil?
      query_params[:'node_types'] = opts[:'node_types'] if !opts[:'node_types'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'transport_zone_id'] = opts[:'transport_zone_id'] if !opts[:'transport_zone_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNodeListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#list_transport_nodes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List transport nodes by realized state
    # Returns a list of transport node states that have realized state as provided as query parameter 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :mm_state maintenance mode state
    # @option opts [String] :status Realized state of transport nodes
    # @option opts [String] :vtep_ip Virtual tunnel endpoint ip address of transport node
    # @return [TransportNodeStateListResult]
    def list_transport_nodes_by_state(opts = {})
      data, _status_code, _headers = list_transport_nodes_by_state_with_http_info(opts)
      return data
    end

    # List transport nodes by realized state
    # Returns a list of transport node states that have realized state as provided as query parameter 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :mm_state maintenance mode state
    # @option opts [String] :status Realized state of transport nodes
    # @option opts [String] :vtep_ip Virtual tunnel endpoint ip address of transport node
    # @return [Array<(TransportNodeStateListResult, Fixnum, Hash)>] TransportNodeStateListResult data, response status code and response headers
    def list_transport_nodes_by_state_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.list_transport_nodes_by_state ..."
      end
      if @api_client.config.client_side_validation && opts[:'mm_state'] && !['ENTERING', 'ENABLED', 'EXITING', 'DISABLED'].include?(opts[:'mm_state'])
        fail ArgumentError, 'invalid value for "mm_state", must be one of ENTERING, ENABLED, EXITING, DISABLED'
      end
      if @api_client.config.client_side_validation && opts[:'status'] && !['PENDING', 'IN_PROGRESS', 'SUCCESS', 'PARTIAL_SUCCESS', 'FAILED', 'ORPHANED'].include?(opts[:'status'])
        fail ArgumentError, 'invalid value for "status", must be one of PENDING, IN_PROGRESS, SUCCESS, PARTIAL_SUCCESS, FAILED, ORPHANED'
      end
      # resource path
      local_var_path = "/transport-nodes/state"

      # query parameters
      query_params = {}
      query_params[:'mm_state'] = opts[:'mm_state'] if !opts[:'mm_state'].nil?
      query_params[:'status'] = opts[:'status'] if !opts[:'status'].nil?
      query_params[:'vtep_ip'] = opts[:'vtep_ip'] if !opts[:'vtep_ip'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNodeStateListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#list_transport_nodes_by_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List transport zone profiles
    # Returns information about the configured transport zone profiles. Transport zone profiles define networking policies for transport zones and transport zone endpoints. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_system_owned Whether the list result contains system resources (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :resource_type comma-separated list of transport zone profile types, e.g. ?resource_type&#x3D;BfdHealthMonitoringProfile
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [TransportZoneProfileListResult]
    def list_transport_zone_profiles(opts = {})
      data, _status_code, _headers = list_transport_zone_profiles_with_http_info(opts)
      return data
    end

    # List transport zone profiles
    # Returns information about the configured transport zone profiles. Transport zone profiles define networking policies for transport zones and transport zone endpoints. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_system_owned Whether the list result contains system resources
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :resource_type comma-separated list of transport zone profile types, e.g. ?resource_type&#x3D;BfdHealthMonitoringProfile
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(TransportZoneProfileListResult, Fixnum, Hash)>] TransportZoneProfileListResult data, response status code and response headers
    def list_transport_zone_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.list_transport_zone_profiles ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.list_transport_zone_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.list_transport_zone_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/transportzone-profiles"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_system_owned'] = opts[:'include_system_owned'] if !opts[:'include_system_owned'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'resource_type'] = opts[:'resource_type'] if !opts[:'resource_type'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportZoneProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#list_transport_zone_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Transport Zones
    # Returns information about configured transport zones. NSX requires at least one transport zone. NSX uses transport zones to provide connectivity based on the topology of the underlying network, trust zones, or organizational separations. For example, you might have hypervisors that use one network for management traffic and a different network for VM traffic. This architecture would require two transport zones. The combination of transport zones plus transport connectors enables NSX to form tunnels between hypervisors. Transport zones define which interfaces on the hypervisors can communicate with which other interfaces on other hypervisors to establish overlay tunnels or provide connectivity to a VLAN. A logical switch can be in one (and only one) transport zone. This means that all of a switch's interfaces must be in the same transport zone. However, each hypervisor virtual switch (OVS or VDS) has multiple interfaces (connectors), and each connector can be attached to a different logical switch. For example, on a single hypervisor with two connectors, connector A can be attached to logical switch 1 in transport zone A, while connector B is attached to logical switch 2 in transport zone B. In this way, a single hypervisor can participate in multiple transport zones. The API for creating a transport zone requires that a single host switch be specified for each transport zone, and multiple transport zones can share the same host switch. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :uplink_teaming_policy_name The transport zone&#39;s uplink teaming policy name
    # @return [TransportZoneListResult]
    def list_transport_zones(opts = {})
      data, _status_code, _headers = list_transport_zones_with_http_info(opts)
      return data
    end

    # List Transport Zones
    # Returns information about configured transport zones. NSX requires at least one transport zone. NSX uses transport zones to provide connectivity based on the topology of the underlying network, trust zones, or organizational separations. For example, you might have hypervisors that use one network for management traffic and a different network for VM traffic. This architecture would require two transport zones. The combination of transport zones plus transport connectors enables NSX to form tunnels between hypervisors. Transport zones define which interfaces on the hypervisors can communicate with which other interfaces on other hypervisors to establish overlay tunnels or provide connectivity to a VLAN. A logical switch can be in one (and only one) transport zone. This means that all of a switch&#39;s interfaces must be in the same transport zone. However, each hypervisor virtual switch (OVS or VDS) has multiple interfaces (connectors), and each connector can be attached to a different logical switch. For example, on a single hypervisor with two connectors, connector A can be attached to logical switch 1 in transport zone A, while connector B is attached to logical switch 2 in transport zone B. In this way, a single hypervisor can participate in multiple transport zones. The API for creating a transport zone requires that a single host switch be specified for each transport zone, and multiple transport zones can share the same host switch. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :uplink_teaming_policy_name The transport zone&#39;s uplink teaming policy name
    # @return [Array<(TransportZoneListResult, Fixnum, Hash)>] TransportZoneListResult data, response status code and response headers
    def list_transport_zones_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.list_transport_zones ..."
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.list_transport_zones, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling NetworkTransportApi.list_transport_zones, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = "/transport-zones"

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'uplink_teaming_policy_name'] = opts[:'uplink_teaming_policy_name'] if !opts[:'uplink_teaming_policy_name'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportZoneListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#list_transport_zones\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Read Edge Cluster
    # Returns information about the specified edge cluster.
    # @param edge_cluster_id 
    # @param [Hash] opts the optional parameters
    # @return [EdgeCluster]
    def read_edge_cluster(edge_cluster_id, opts = {})
      data, _status_code, _headers = read_edge_cluster_with_http_info(edge_cluster_id, opts)
      return data
    end

    # Read Edge Cluster
    # Returns information about the specified edge cluster.
    # @param edge_cluster_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(EdgeCluster, Fixnum, Hash)>] EdgeCluster data, response status code and response headers
    def read_edge_cluster_with_http_info(edge_cluster_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.read_edge_cluster ..."
      end
      # verify the required parameter 'edge_cluster_id' is set
      if @api_client.config.client_side_validation && edge_cluster_id.nil?
        fail ArgumentError, "Missing the required parameter 'edge_cluster_id' when calling NetworkTransportApi.read_edge_cluster"
      end
      # resource path
      local_var_path = "/edge-clusters/{edge-cluster-id}".sub('{' + 'edge-cluster-id' + '}', edge_cluster_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EdgeCluster')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#read_edge_cluster\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Read LLDP Neighbor Properties
    # Read LLDP Neighbor Properties
    # @param node_id ID of transport node
    # @param interface_name Interface name to read
    # @param [Hash] opts the optional parameters
    # @return [InterfaceNeighborProperties]
    def read_neighbor_properties(node_id, interface_name, opts = {})
      data, _status_code, _headers = read_neighbor_properties_with_http_info(node_id, interface_name, opts)
      return data
    end

    # Read LLDP Neighbor Properties
    # Read LLDP Neighbor Properties
    # @param node_id ID of transport node
    # @param interface_name Interface name to read
    # @param [Hash] opts the optional parameters
    # @return [Array<(InterfaceNeighborProperties, Fixnum, Hash)>] InterfaceNeighborProperties data, response status code and response headers
    def read_neighbor_properties_with_http_info(node_id, interface_name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.read_neighbor_properties ..."
      end
      # verify the required parameter 'node_id' is set
      if @api_client.config.client_side_validation && node_id.nil?
        fail ArgumentError, "Missing the required parameter 'node_id' when calling NetworkTransportApi.read_neighbor_properties"
      end
      # verify the required parameter 'interface_name' is set
      if @api_client.config.client_side_validation && interface_name.nil?
        fail ArgumentError, "Missing the required parameter 'interface_name' when calling NetworkTransportApi.read_neighbor_properties"
      end
      # resource path
      local_var_path = "/lldp/transport-nodes/{node-id}/interfaces/{interface-name}".sub('{' + 'node-id' + '}', node_id.to_s).sub('{' + 'interface-name' + '}', interface_name.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'InterfaceNeighborProperties')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#read_neighbor_properties\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Replace the transport node in the specified member of the edge-cluster
    # Replace the transport node in the specified member of the edge-cluster. This is a disruptive action. This will move all the LogicalRouterPorts(uplink and routerLink) host on the old transport_node to the new transport_node. The transportNode cannot be present in another member of any edgeClusters. 
    # @param edge_cluster_id 
    # @param edge_cluster_member_transport_node 
    # @param [Hash] opts the optional parameters
    # @return [EdgeCluster]
    def replace_edge_cluster_member_transport_node_replace_transport_node(edge_cluster_id, edge_cluster_member_transport_node, opts = {})
      data, _status_code, _headers = replace_edge_cluster_member_transport_node_replace_transport_node_with_http_info(edge_cluster_id, edge_cluster_member_transport_node, opts)
      return data
    end

    # Replace the transport node in the specified member of the edge-cluster
    # Replace the transport node in the specified member of the edge-cluster. This is a disruptive action. This will move all the LogicalRouterPorts(uplink and routerLink) host on the old transport_node to the new transport_node. The transportNode cannot be present in another member of any edgeClusters. 
    # @param edge_cluster_id 
    # @param edge_cluster_member_transport_node 
    # @param [Hash] opts the optional parameters
    # @return [Array<(EdgeCluster, Fixnum, Hash)>] EdgeCluster data, response status code and response headers
    def replace_edge_cluster_member_transport_node_replace_transport_node_with_http_info(edge_cluster_id, edge_cluster_member_transport_node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.replace_edge_cluster_member_transport_node_replace_transport_node ..."
      end
      # verify the required parameter 'edge_cluster_id' is set
      if @api_client.config.client_side_validation && edge_cluster_id.nil?
        fail ArgumentError, "Missing the required parameter 'edge_cluster_id' when calling NetworkTransportApi.replace_edge_cluster_member_transport_node_replace_transport_node"
      end
      # verify the required parameter 'edge_cluster_member_transport_node' is set
      if @api_client.config.client_side_validation && edge_cluster_member_transport_node.nil?
        fail ArgumentError, "Missing the required parameter 'edge_cluster_member_transport_node' when calling NetworkTransportApi.replace_edge_cluster_member_transport_node_replace_transport_node"
      end
      # resource path
      local_var_path = "/edge-clusters/{edge-cluster-id}?action=replace_transport_node".sub('{' + 'edge-cluster-id' + '}', edge_cluster_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(edge_cluster_member_transport_node)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EdgeCluster')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#replace_edge_cluster_member_transport_node_replace_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Resync a Transport Node
    # Resync the TransportNode configuration on a host. It is similar to updating the TransportNode with existing configuration, but force synce these configurations to the host (no backend optimizations). 
    # @param transportnode_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def resync_transport_node_resync_host_config(transportnode_id, opts = {})
      resync_transport_node_resync_host_config_with_http_info(transportnode_id, opts)
      return nil
    end

    # Resync a Transport Node
    # Resync the TransportNode configuration on a host. It is similar to updating the TransportNode with existing configuration, but force synce these configurations to the host (no backend optimizations). 
    # @param transportnode_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def resync_transport_node_resync_host_config_with_http_info(transportnode_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.resync_transport_node_resync_host_config ..."
      end
      # verify the required parameter 'transportnode_id' is set
      if @api_client.config.client_side_validation && transportnode_id.nil?
        fail ArgumentError, "Missing the required parameter 'transportnode_id' when calling NetworkTransportApi.resync_transport_node_resync_host_config"
      end
      # resource path
      local_var_path = "/transport-nodes/{transportnode-id}?action=resync_host_config".sub('{' + 'transportnode-id' + '}', transportnode_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#resync_transport_node_resync_host_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a Bridge Cluster
    # Modifies a existing bridge cluster. One of more transport nodes can be added or removed from the bridge cluster using this API. 
    # @param bridgecluster_id 
    # @param bridge_cluster 
    # @param [Hash] opts the optional parameters
    # @return [BridgeCluster]
    def update_bridge_cluster(bridgecluster_id, bridge_cluster, opts = {})
      data, _status_code, _headers = update_bridge_cluster_with_http_info(bridgecluster_id, bridge_cluster, opts)
      return data
    end

    # Update a Bridge Cluster
    # Modifies a existing bridge cluster. One of more transport nodes can be added or removed from the bridge cluster using this API. 
    # @param bridgecluster_id 
    # @param bridge_cluster 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BridgeCluster, Fixnum, Hash)>] BridgeCluster data, response status code and response headers
    def update_bridge_cluster_with_http_info(bridgecluster_id, bridge_cluster, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.update_bridge_cluster ..."
      end
      # verify the required parameter 'bridgecluster_id' is set
      if @api_client.config.client_side_validation && bridgecluster_id.nil?
        fail ArgumentError, "Missing the required parameter 'bridgecluster_id' when calling NetworkTransportApi.update_bridge_cluster"
      end
      # verify the required parameter 'bridge_cluster' is set
      if @api_client.config.client_side_validation && bridge_cluster.nil?
        fail ArgumentError, "Missing the required parameter 'bridge_cluster' when calling NetworkTransportApi.update_bridge_cluster"
      end
      # resource path
      local_var_path = "/bridge-clusters/{bridgecluster-id}".sub('{' + 'bridgecluster-id' + '}', bridgecluster_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(bridge_cluster)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BridgeCluster')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#update_bridge_cluster\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a Bridge Endpoint
    # Modifies a existing bridge endpoint. 
    # @param bridgeendpoint_id 
    # @param bridge_endpoint 
    # @param [Hash] opts the optional parameters
    # @return [BridgeEndpoint]
    def update_bridge_endpoint(bridgeendpoint_id, bridge_endpoint, opts = {})
      data, _status_code, _headers = update_bridge_endpoint_with_http_info(bridgeendpoint_id, bridge_endpoint, opts)
      return data
    end

    # Update a Bridge Endpoint
    # Modifies a existing bridge endpoint. 
    # @param bridgeendpoint_id 
    # @param bridge_endpoint 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BridgeEndpoint, Fixnum, Hash)>] BridgeEndpoint data, response status code and response headers
    def update_bridge_endpoint_with_http_info(bridgeendpoint_id, bridge_endpoint, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.update_bridge_endpoint ..."
      end
      # verify the required parameter 'bridgeendpoint_id' is set
      if @api_client.config.client_side_validation && bridgeendpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'bridgeendpoint_id' when calling NetworkTransportApi.update_bridge_endpoint"
      end
      # verify the required parameter 'bridge_endpoint' is set
      if @api_client.config.client_side_validation && bridge_endpoint.nil?
        fail ArgumentError, "Missing the required parameter 'bridge_endpoint' when calling NetworkTransportApi.update_bridge_endpoint"
      end
      # resource path
      local_var_path = "/bridge-endpoints/{bridgeendpoint-id}".sub('{' + 'bridgeendpoint-id' + '}', bridgeendpoint_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(bridge_endpoint)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BridgeEndpoint')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#update_bridge_endpoint\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a Bridge Endpoint Profile
    # Modifies a existing bridge endpoint profile. 
    # @param bridgeendpointprofile_id 
    # @param bridge_endpoint_profile 
    # @param [Hash] opts the optional parameters
    # @return [BridgeEndpointProfile]
    def update_bridge_endpoint_profile(bridgeendpointprofile_id, bridge_endpoint_profile, opts = {})
      data, _status_code, _headers = update_bridge_endpoint_profile_with_http_info(bridgeendpointprofile_id, bridge_endpoint_profile, opts)
      return data
    end

    # Update a Bridge Endpoint Profile
    # Modifies a existing bridge endpoint profile. 
    # @param bridgeendpointprofile_id 
    # @param bridge_endpoint_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BridgeEndpointProfile, Fixnum, Hash)>] BridgeEndpointProfile data, response status code and response headers
    def update_bridge_endpoint_profile_with_http_info(bridgeendpointprofile_id, bridge_endpoint_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.update_bridge_endpoint_profile ..."
      end
      # verify the required parameter 'bridgeendpointprofile_id' is set
      if @api_client.config.client_side_validation && bridgeendpointprofile_id.nil?
        fail ArgumentError, "Missing the required parameter 'bridgeendpointprofile_id' when calling NetworkTransportApi.update_bridge_endpoint_profile"
      end
      # verify the required parameter 'bridge_endpoint_profile' is set
      if @api_client.config.client_side_validation && bridge_endpoint_profile.nil?
        fail ArgumentError, "Missing the required parameter 'bridge_endpoint_profile' when calling NetworkTransportApi.update_bridge_endpoint_profile"
      end
      # resource path
      local_var_path = "/bridge-endpoint-profiles/{bridgeendpointprofile-id}".sub('{' + 'bridgeendpointprofile-id' + '}', bridgeendpointprofile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(bridge_endpoint_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BridgeEndpointProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#update_bridge_endpoint_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a cluster profile
    # Modifie a specified cluster profile. The body of the PUT request must include the resource_type. 
    # @param cluster_profile_id 
    # @param cluster_profile 
    # @param [Hash] opts the optional parameters
    # @return [ClusterProfile]
    def update_cluster_profile(cluster_profile_id, cluster_profile, opts = {})
      data, _status_code, _headers = update_cluster_profile_with_http_info(cluster_profile_id, cluster_profile, opts)
      return data
    end

    # Update a cluster profile
    # Modifie a specified cluster profile. The body of the PUT request must include the resource_type. 
    # @param cluster_profile_id 
    # @param cluster_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ClusterProfile, Fixnum, Hash)>] ClusterProfile data, response status code and response headers
    def update_cluster_profile_with_http_info(cluster_profile_id, cluster_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.update_cluster_profile ..."
      end
      # verify the required parameter 'cluster_profile_id' is set
      if @api_client.config.client_side_validation && cluster_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'cluster_profile_id' when calling NetworkTransportApi.update_cluster_profile"
      end
      # verify the required parameter 'cluster_profile' is set
      if @api_client.config.client_side_validation && cluster_profile.nil?
        fail ArgumentError, "Missing the required parameter 'cluster_profile' when calling NetworkTransportApi.update_cluster_profile"
      end
      # resource path
      local_var_path = "/cluster-profiles/{cluster-profile-id}".sub('{' + 'cluster-profile-id' + '}', cluster_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(cluster_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ClusterProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#update_cluster_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update compute collection transportnode template
    # Update configuration of compute collection transportnode template. Compute_collection_id isn't allowed to be changed since it represents the association between ComputeCollection and this template. This is determined when ComputeCollectionTransportNodeTemplate got created. 
    # @param template_id 
    # @param compute_collection_transport_node_template 
    # @param [Hash] opts the optional parameters
    # @return [ComputeCollectionTransportNodeTemplate]
    def update_compute_collection_transport_node_template(template_id, compute_collection_transport_node_template, opts = {})
      data, _status_code, _headers = update_compute_collection_transport_node_template_with_http_info(template_id, compute_collection_transport_node_template, opts)
      return data
    end

    # Update compute collection transportnode template
    # Update configuration of compute collection transportnode template. Compute_collection_id isn&#39;t allowed to be changed since it represents the association between ComputeCollection and this template. This is determined when ComputeCollectionTransportNodeTemplate got created. 
    # @param template_id 
    # @param compute_collection_transport_node_template 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ComputeCollectionTransportNodeTemplate, Fixnum, Hash)>] ComputeCollectionTransportNodeTemplate data, response status code and response headers
    def update_compute_collection_transport_node_template_with_http_info(template_id, compute_collection_transport_node_template, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.update_compute_collection_transport_node_template ..."
      end
      # verify the required parameter 'template_id' is set
      if @api_client.config.client_side_validation && template_id.nil?
        fail ArgumentError, "Missing the required parameter 'template_id' when calling NetworkTransportApi.update_compute_collection_transport_node_template"
      end
      # verify the required parameter 'compute_collection_transport_node_template' is set
      if @api_client.config.client_side_validation && compute_collection_transport_node_template.nil?
        fail ArgumentError, "Missing the required parameter 'compute_collection_transport_node_template' when calling NetworkTransportApi.update_compute_collection_transport_node_template"
      end
      # resource path
      local_var_path = "/compute-collection-transport-node-templates/{template-id}".sub('{' + 'template-id' + '}', template_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(compute_collection_transport_node_template)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ComputeCollectionTransportNodeTemplate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#update_compute_collection_transport_node_template\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Edge Cluster
    # Modifies the specified edge cluster. Modifiable parameters include the description, display_name, transport-node-id. If the optional fabric_profile_binding is included, resource_type and profile_id are required. User should do a GET on the edge-cluster and obtain the payload and retain the member_index of the existing members as returning in the GET output. For new member additions, the member_index cannot be defined by the user, user can read the system allocated index to the new member in the output of this API call or by doing a GET call. User cannot use this PUT api to replace the transport_node of an existing member because this is a disruption action, we have exposed a explicit API for doing so, refer to \"ReplaceEdgeClusterMemberTransportNode\" EdgeCluster only supports homogeneous members. The TransportNodes backed by EdgeNode are only allowed in cluster members. DeploymentType (VIRTUAL_MACHINE|PHYSICAL_MACHINE) of these EdgeNodes is recommended to be the same. EdgeCluster supports members of different deployment types. 
    # @param edge_cluster_id 
    # @param edge_cluster 
    # @param [Hash] opts the optional parameters
    # @return [EdgeCluster]
    def update_edge_cluster(edge_cluster_id, edge_cluster, opts = {})
      data, _status_code, _headers = update_edge_cluster_with_http_info(edge_cluster_id, edge_cluster, opts)
      return data
    end

    # Update Edge Cluster
    # Modifies the specified edge cluster. Modifiable parameters include the description, display_name, transport-node-id. If the optional fabric_profile_binding is included, resource_type and profile_id are required. User should do a GET on the edge-cluster and obtain the payload and retain the member_index of the existing members as returning in the GET output. For new member additions, the member_index cannot be defined by the user, user can read the system allocated index to the new member in the output of this API call or by doing a GET call. User cannot use this PUT api to replace the transport_node of an existing member because this is a disruption action, we have exposed a explicit API for doing so, refer to \&quot;ReplaceEdgeClusterMemberTransportNode\&quot; EdgeCluster only supports homogeneous members. The TransportNodes backed by EdgeNode are only allowed in cluster members. DeploymentType (VIRTUAL_MACHINE|PHYSICAL_MACHINE) of these EdgeNodes is recommended to be the same. EdgeCluster supports members of different deployment types. 
    # @param edge_cluster_id 
    # @param edge_cluster 
    # @param [Hash] opts the optional parameters
    # @return [Array<(EdgeCluster, Fixnum, Hash)>] EdgeCluster data, response status code and response headers
    def update_edge_cluster_with_http_info(edge_cluster_id, edge_cluster, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.update_edge_cluster ..."
      end
      # verify the required parameter 'edge_cluster_id' is set
      if @api_client.config.client_side_validation && edge_cluster_id.nil?
        fail ArgumentError, "Missing the required parameter 'edge_cluster_id' when calling NetworkTransportApi.update_edge_cluster"
      end
      # verify the required parameter 'edge_cluster' is set
      if @api_client.config.client_side_validation && edge_cluster.nil?
        fail ArgumentError, "Missing the required parameter 'edge_cluster' when calling NetworkTransportApi.update_edge_cluster"
      end
      # resource path
      local_var_path = "/edge-clusters/{edge-cluster-id}".sub('{' + 'edge-cluster-id' + '}', edge_cluster_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(edge_cluster)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EdgeCluster')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#update_edge_cluster\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a Hostswitch Profile
    # Modifies a specified hostswitch profile. The body of the PUT request must include the resource_type. For uplink profiles, the put request must also include teaming parameters. Modifiable attributes include display_name, mtu, and transport_vlan. For uplink teaming policies, uplink_name and policy are also modifiable. 
    # @param host_switch_profile_id 
    # @param base_host_switch_profile 
    # @param [Hash] opts the optional parameters
    # @return [BaseHostSwitchProfile]
    def update_host_switch_profile(host_switch_profile_id, base_host_switch_profile, opts = {})
      data, _status_code, _headers = update_host_switch_profile_with_http_info(host_switch_profile_id, base_host_switch_profile, opts)
      return data
    end

    # Update a Hostswitch Profile
    # Modifies a specified hostswitch profile. The body of the PUT request must include the resource_type. For uplink profiles, the put request must also include teaming parameters. Modifiable attributes include display_name, mtu, and transport_vlan. For uplink teaming policies, uplink_name and policy are also modifiable. 
    # @param host_switch_profile_id 
    # @param base_host_switch_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BaseHostSwitchProfile, Fixnum, Hash)>] BaseHostSwitchProfile data, response status code and response headers
    def update_host_switch_profile_with_http_info(host_switch_profile_id, base_host_switch_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.update_host_switch_profile ..."
      end
      # verify the required parameter 'host_switch_profile_id' is set
      if @api_client.config.client_side_validation && host_switch_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_switch_profile_id' when calling NetworkTransportApi.update_host_switch_profile"
      end
      # verify the required parameter 'base_host_switch_profile' is set
      if @api_client.config.client_side_validation && base_host_switch_profile.nil?
        fail ArgumentError, "Missing the required parameter 'base_host_switch_profile' when calling NetworkTransportApi.update_host_switch_profile"
      end
      # resource path
      local_var_path = "/host-switch-profiles/{host-switch-profile-id}".sub('{' + 'host-switch-profile-id' + '}', host_switch_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(base_host_switch_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BaseHostSwitchProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#update_host_switch_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a template of network migration specification.
    # Network migration specification once created and can be used as a template to indicate associated component which networks should be migrated and where. Currently migration template can be associated with compute collections which are managed by vCenter host profiles, to trigger automatic migration of networks for Stateless ESX hosts. Currently we only support creation of HostProfileNetworkMigrationSpec type of specification. For a HostProfileNetworkMigrationSpec which is already associated with a compute collection, updating it would mean next time the system needs to trigger migration for hosts managed by compute collection, it will use the updated migration specification.
    # @param template_id 
    # @param network_migration_spec 
    # @param [Hash] opts the optional parameters
    # @return [NetworkMigrationSpec]
    def update_network_migration_spec(template_id, network_migration_spec, opts = {})
      data, _status_code, _headers = update_network_migration_spec_with_http_info(template_id, network_migration_spec, opts)
      return data
    end

    # Update a template of network migration specification.
    # Network migration specification once created and can be used as a template to indicate associated component which networks should be migrated and where. Currently migration template can be associated with compute collections which are managed by vCenter host profiles, to trigger automatic migration of networks for Stateless ESX hosts. Currently we only support creation of HostProfileNetworkMigrationSpec type of specification. For a HostProfileNetworkMigrationSpec which is already associated with a compute collection, updating it would mean next time the system needs to trigger migration for hosts managed by compute collection, it will use the updated migration specification.
    # @param template_id 
    # @param network_migration_spec 
    # @param [Hash] opts the optional parameters
    # @return [Array<(NetworkMigrationSpec, Fixnum, Hash)>] NetworkMigrationSpec data, response status code and response headers
    def update_network_migration_spec_with_http_info(template_id, network_migration_spec, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.update_network_migration_spec ..."
      end
      # verify the required parameter 'template_id' is set
      if @api_client.config.client_side_validation && template_id.nil?
        fail ArgumentError, "Missing the required parameter 'template_id' when calling NetworkTransportApi.update_network_migration_spec"
      end
      # verify the required parameter 'network_migration_spec' is set
      if @api_client.config.client_side_validation && network_migration_spec.nil?
        fail ArgumentError, "Missing the required parameter 'network_migration_spec' when calling NetworkTransportApi.update_network_migration_spec"
      end
      # resource path
      local_var_path = "/network-migration-specs/{template-id}".sub('{' + 'template-id' + '}', template_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(network_migration_spec)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'NetworkMigrationSpec')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#update_network_migration_spec\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a Transport Node
    # Modifies the transport node information. Modifiable parameters include the host_switch_spec and transport_zone_endpoints. The host_switch_name field must match the host_switch_name value specified in the transport zone (API: transport-zones). You must create the associated uplink profile (API: host-switch-profiles) before you can specify an uplink_name here. If the host is an ESX and has only one physical NIC being used by a vSphere standard switch, TransportNodeUpdateParameters should be used to migrate the management interface and the physical NIC into a logical switch that is in a transport zone this transport node will join or has already joined. If the migration is already done, TransportNodeUpdateParameters can also be used to migrate the management interface and the physical NIC back to a vSphere standard switch. In other cases, the TransportNodeUpdateParameters should NOT be used. When updating transport node user should follow pattern where he should fetch the existing transport node and then only modify the required properties keeping other properties as is. For API backward compatibility, property host_switches will be still returned in response and will contain the configuration matching the one in host_switch_spec. In update call user should only modify configuration in either host_switch_spec or host_switches, but not both. Property host_switch_spec should be preferred over deprecated host_switches property when creating or updating transport nodes. 
    # @param transportnode_id 
    # @param transport_node 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :esx_mgmt_if_migration_dest The network ids to which the ESX vmk interfaces will be migrated
    # @option opts [String] :if_id The ESX vmk interfaces to migrate
    # @option opts [String] :vnic The ESX vmk interfaces and/or VM NIC to migrate
    # @option opts [String] :vnic_migration_dest The migration destinations of ESX vmk interfaces and/or VM NIC
    # @return [TransportNode]
    def update_transport_node(transportnode_id, transport_node, opts = {})
      data, _status_code, _headers = update_transport_node_with_http_info(transportnode_id, transport_node, opts)
      return data
    end

    # Update a Transport Node
    # Modifies the transport node information. Modifiable parameters include the host_switch_spec and transport_zone_endpoints. The host_switch_name field must match the host_switch_name value specified in the transport zone (API: transport-zones). You must create the associated uplink profile (API: host-switch-profiles) before you can specify an uplink_name here. If the host is an ESX and has only one physical NIC being used by a vSphere standard switch, TransportNodeUpdateParameters should be used to migrate the management interface and the physical NIC into a logical switch that is in a transport zone this transport node will join or has already joined. If the migration is already done, TransportNodeUpdateParameters can also be used to migrate the management interface and the physical NIC back to a vSphere standard switch. In other cases, the TransportNodeUpdateParameters should NOT be used. When updating transport node user should follow pattern where he should fetch the existing transport node and then only modify the required properties keeping other properties as is. For API backward compatibility, property host_switches will be still returned in response and will contain the configuration matching the one in host_switch_spec. In update call user should only modify configuration in either host_switch_spec or host_switches, but not both. Property host_switch_spec should be preferred over deprecated host_switches property when creating or updating transport nodes. 
    # @param transportnode_id 
    # @param transport_node 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :esx_mgmt_if_migration_dest The network ids to which the ESX vmk interfaces will be migrated
    # @option opts [String] :if_id The ESX vmk interfaces to migrate
    # @option opts [String] :vnic The ESX vmk interfaces and/or VM NIC to migrate
    # @option opts [String] :vnic_migration_dest The migration destinations of ESX vmk interfaces and/or VM NIC
    # @return [Array<(TransportNode, Fixnum, Hash)>] TransportNode data, response status code and response headers
    def update_transport_node_with_http_info(transportnode_id, transport_node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.update_transport_node ..."
      end
      # verify the required parameter 'transportnode_id' is set
      if @api_client.config.client_side_validation && transportnode_id.nil?
        fail ArgumentError, "Missing the required parameter 'transportnode_id' when calling NetworkTransportApi.update_transport_node"
      end
      # verify the required parameter 'transport_node' is set
      if @api_client.config.client_side_validation && transport_node.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node' when calling NetworkTransportApi.update_transport_node"
      end
      # resource path
      local_var_path = "/transport-nodes/{transportnode-id}".sub('{' + 'transportnode-id' + '}', transportnode_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'esx_mgmt_if_migration_dest'] = opts[:'esx_mgmt_if_migration_dest'] if !opts[:'esx_mgmt_if_migration_dest'].nil?
      query_params[:'if_id'] = opts[:'if_id'] if !opts[:'if_id'].nil?
      query_params[:'vnic'] = opts[:'vnic'] if !opts[:'vnic'].nil?
      query_params[:'vnic_migration_dest'] = opts[:'vnic_migration_dest'] if !opts[:'vnic_migration_dest'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(transport_node)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNode')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#update_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update transport node maintenance mode
    # Put transport node into maintenance mode or exit from maintenance mode.
    # @param transportnode_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :action 
    # @return [nil]
    def update_transport_node_maintenance_mode(transportnode_id, opts = {})
      update_transport_node_maintenance_mode_with_http_info(transportnode_id, opts)
      return nil
    end

    # Update transport node maintenance mode
    # Put transport node into maintenance mode or exit from maintenance mode.
    # @param transportnode_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :action 
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def update_transport_node_maintenance_mode_with_http_info(transportnode_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.update_transport_node_maintenance_mode ..."
      end
      # verify the required parameter 'transportnode_id' is set
      if @api_client.config.client_side_validation && transportnode_id.nil?
        fail ArgumentError, "Missing the required parameter 'transportnode_id' when calling NetworkTransportApi.update_transport_node_maintenance_mode"
      end
      if @api_client.config.client_side_validation && opts[:'action'] && !['enter_maintenance_mode', 'forced_enter_maintenance_mode', 'exit_maintenance_mode'].include?(opts[:'action'])
        fail ArgumentError, 'invalid value for "action", must be one of enter_maintenance_mode, forced_enter_maintenance_mode, exit_maintenance_mode'
      end
      # resource path
      local_var_path = "/transport-nodes/{transportnode-id}".sub('{' + 'transportnode-id' + '}', transportnode_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'action'] = opts[:'action'] if !opts[:'action'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#update_transport_node_maintenance_mode\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a Transport Zone
    # Updates an existing transport zone. Modifiable parameters are transport_type (VLAN or OVERLAY), description, and display_name. The request must include the existing host_switch_name. 
    # @param zone_id 
    # @param transport_zone 
    # @param [Hash] opts the optional parameters
    # @return [TransportZone]
    def update_transport_zone(zone_id, transport_zone, opts = {})
      data, _status_code, _headers = update_transport_zone_with_http_info(zone_id, transport_zone, opts)
      return data
    end

    # Update a Transport Zone
    # Updates an existing transport zone. Modifiable parameters are transport_type (VLAN or OVERLAY), description, and display_name. The request must include the existing host_switch_name. 
    # @param zone_id 
    # @param transport_zone 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransportZone, Fixnum, Hash)>] TransportZone data, response status code and response headers
    def update_transport_zone_with_http_info(zone_id, transport_zone, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.update_transport_zone ..."
      end
      # verify the required parameter 'zone_id' is set
      if @api_client.config.client_side_validation && zone_id.nil?
        fail ArgumentError, "Missing the required parameter 'zone_id' when calling NetworkTransportApi.update_transport_zone"
      end
      # verify the required parameter 'transport_zone' is set
      if @api_client.config.client_side_validation && transport_zone.nil?
        fail ArgumentError, "Missing the required parameter 'transport_zone' when calling NetworkTransportApi.update_transport_zone"
      end
      # resource path
      local_var_path = "/transport-zones/{zone-id}".sub('{' + 'zone-id' + '}', zone_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(transport_zone)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportZone')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#update_transport_zone\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a transport zone profile
    # Modifies a specified transport zone profile. The body of the PUT request must include the resource_type. 
    # @param transportzone_profile_id 
    # @param transport_zone_profile 
    # @param [Hash] opts the optional parameters
    # @return [TransportZoneProfile]
    def update_transport_zone_profile(transportzone_profile_id, transport_zone_profile, opts = {})
      data, _status_code, _headers = update_transport_zone_profile_with_http_info(transportzone_profile_id, transport_zone_profile, opts)
      return data
    end

    # Update a transport zone profile
    # Modifies a specified transport zone profile. The body of the PUT request must include the resource_type. 
    # @param transportzone_profile_id 
    # @param transport_zone_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransportZoneProfile, Fixnum, Hash)>] TransportZoneProfile data, response status code and response headers
    def update_transport_zone_profile_with_http_info(transportzone_profile_id, transport_zone_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug "Calling API: NetworkTransportApi.update_transport_zone_profile ..."
      end
      # verify the required parameter 'transportzone_profile_id' is set
      if @api_client.config.client_side_validation && transportzone_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'transportzone_profile_id' when calling NetworkTransportApi.update_transport_zone_profile"
      end
      # verify the required parameter 'transport_zone_profile' is set
      if @api_client.config.client_side_validation && transport_zone_profile.nil?
        fail ArgumentError, "Missing the required parameter 'transport_zone_profile' when calling NetworkTransportApi.update_transport_zone_profile"
      end
      # resource path
      local_var_path = "/transportzone-profiles/{transportzone-profile-id}".sub('{' + 'transportzone-profile-id' + '}', transportzone_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(transport_zone_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportZoneProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NetworkTransportApi#update_transport_zone_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
