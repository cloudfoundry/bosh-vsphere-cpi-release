=begin
#NSX Policy API

#VMware NSX Policy REST API

OpenAPI spec version: 9.0.0.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.4.46

=end

require 'date'

module Nsxt9PolicyClient
  # Standard host switch specification
  class StandardHostSwitch
    # This field is writable only in case of NVDS type HostSwitch and system generated for VDS type. For NVDS type host switch, If this name is unset or empty then the default host switch name will be used. The name must be unique among all host switches specified in a given transport node; unset name, empty name and the default host switch name are considered the same in terms of uniqueness. For VDS type host switch, Manager fetches VDS name from corresponding Compute Manager and populates this field. If VDS name is given (correct or incorrect) it is ignored and overwritten with correct one.
    attr_accessor :host_switch_name

    # This field is writable only in case of VDS type HostSwitch and system generated for NVDS type. For VDS type host switch, This field is used to lookup a VDS from corresponding Compute Manager and then can be configured for logical networking. For NVDS type host switch, This field is system generated and if provided will be overwritten.
    attr_accessor :host_switch_id

    # VDS represents VMware vSphere Distributed Switch from vSphere that is used as HostSwitch through TransportNode or TransportNodeProfile configuration. When VDS is used as a HostSwitch, Hosts have to be added to VDS from vSphere and VDS instance is created on Hosts. To configure NSX on such hosts, you can use this VDS as a HostSwitch from NSX manager. vCenter has the ownership of MTU, LAG, NIOC and LLDP configuration of such VDS backed HostSwitch. Remaining configuration (e.g. UplinkHostswitchProfile) will be managed by NSX. NVDS represents NSX Virtual Switch which is NSX native HostSwitch. All configurations of NVDS will be managed by NSX. HostSwitch of type NVDS has been deprecated on ESX hosts that are managed by a vCenter Server.
    attr_accessor :host_switch_type

    # STANDARD - This mode applies to all transport nodes. This is realized as pktHandle mode in the dataplane. ENS - This is the Enhanced Data Path switch mode for ESX host tranport node. This mode provides accelerated networking performances but also introduces additional prerequisites. In order to benefit from this mode, workloads will be need to be compiled with DPDK and will use VMXNET3 for their vNIC. This mode is only available on ESX hypervisor (6.7 and above, recommended 6.7 U2 and above) and unavailable on KVM, EDGE and Public Cloud Gateway. Not all NSX features are available in this mode, please consult the documentation. ENS_INTERRUPT - This is an interrupt driven variant of the Enhanced Data Path mode. Please, consult your account representative for applicability. This mode is available only on ESX hypervisor (7.0 and above). LEGACY - This mode applies to all transport nodes. This mode was formerly called as STANDARD and is realized as pktHandle. NOTE: If a value is not specified for this property, we use the default_host_switch_mode value from GlobalConfig Policy API as the operational mode for this HostSwitch. IMPORTANT: ENS and ENS_INTERRUPT modes require a higher tier of NSX licenses. ENS and ENS_INTERRUPT with classic Nic - NSX advanced or higher ENS with SmartNic : NSX Enterprise Plus or higher. Please consult NSX documentation for complete details. 
    attr_accessor :host_switch_mode

    # ECMP mode that will be configured on the VDS HostSwitch. If the host_switch_mode is ENS or ENS_INTERRUPT,  then the value of this attribute can be set to either L3 or L4.  If VDS is configured in STANDARD mode, then it will support L3 mode only. If the VDS HostSwitch is not associated with an Overlay TransportZone,  then the value of ECMP mode is ignored. 
    attr_accessor :ecmp_mode

    # Host switch profiles bound to this host switch. If a profile ID is not provided for any HostSwitchProfileType that is supported by the transport node, the corresponding default profile will be bound to the host switch. If transport node is created using Policy APIs, use policyPaths instead of UUIDs.
    attr_accessor :host_switch_profile_ids

    # When using the Quick Start workflow on 7.0 and above vCenter clusters, pnic information will be populated by the recommendation engine when providing a VDS HostSwitch based recommendation for a VSS HostSwitch.
    attr_accessor :pnics

    # If VDS is used as a HostSwitch this attribute must be specified. You can associate uplinks from UplinkHostSwitchProfile to either VDS uplink or LAG. VDS uplink or LAG will inherit the global VDS level teaming policy from vSphere. NSX managed uplink or LAG will have NSX teaming policy configured through UplinkHostSwitchProfile.
    attr_accessor :uplinks

    # When using the Quick Start workflow on 7.0 and above vCenter clusters, if the pnics specified in the pnics field are used by a single VSS HostSwitch, then they are migrated over to recommended VDS HostSwitch. If any two pnics are not used by the same VSS HostSwitch or VDS HostSwitch, it is not supported. In such cases, please migrate them in multiple steps, one VSS HostSwitch or VDS HostSwitch at a time.
    attr_accessor :is_migrate_pnics

    attr_accessor :ip_assignment_spec

    # VLAN used for tagging Overlay traffic of associated Edge TN Switch. Specified value will override the uplink profile vlan ID. This value is applicable for edge transport node only . 
    attr_accessor :vlan

    # CPU configuration specifies number of Logical cpu cores (Lcores) per Non Uniform Memory Access (NUMA) node dedicated to Enhanced Networking Stack enabled HostSwitch to get the best performance. If CPU configuration is not mentioned, the default value of numa_node_index will be '0' and default value of num_lcores will be '1'.
    attr_accessor :cpu_config

    attr_accessor :real_time_eth_config

    # List of TransportZones that are to be associated with specified host switch. If this property is specified, host_switch_mode at StandardHostSwitch level must be specified.
    attr_accessor :transport_zone_endpoints

    # When using the Quick Start workflow on 7.0 and above vCenter clusters, vmnk_install_migration will be populated by the recommendation engine when providing a VDS HostSwitch based recommendation for a VSS HostSwitch. It will contain The vmk interfaces and the associated logical switches on the HostSwitch. The state of this field is realized on the transport node during creation
    attr_accessor :vmk_install_migration

    # This is only supported for NVDS type of host switch. If this is specified for VDS type of host switch, an error will be returned to user. The pnics to be migrated out to a non N-VDS switch during transport node deletion.
    attr_accessor :pnics_uninstall_migration

    # This is only supported for NVDS type of host switch. If this is specified for VDS type of host switch, an error will be returned to user. The vmk interfaces and the associated portgroups on the VSS/DVS. This field is realized on the host during transport node deletion or NSX uninstallation to specify the destination for all vmks on N-VDS switches.
    attr_accessor :vmk_uninstall_migration

    # A transport zone will be created for each DVS found across all hosts in a cluster that is installed for NSX on DVPG. This field, populated by NSX, is the ID of the transport zone created for the DVS this host switch represents. All discovered segments created for the DVPGs found on the DVS will have this ID specified as the transport zone id.
    attr_accessor :portgroup_transport_zone_id

    # This field is supported only for Tranport Node Profile Configurations. This field is used for adding a subset of the host switch configuration under a Transport Node Profile. This field is applicable only for a VDS based host switch and not for an NVDS based host switch.
    attr_accessor :transport_node_profile_sub_configs

    attr_accessor :ipv6_assignment_spec

    class EnumAttributeValidator
      attr_reader :datatype
      attr_reader :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'host_switch_name' => :'host_switch_name',
        :'host_switch_id' => :'host_switch_id',
        :'host_switch_type' => :'host_switch_type',
        :'host_switch_mode' => :'host_switch_mode',
        :'ecmp_mode' => :'ecmp_mode',
        :'host_switch_profile_ids' => :'host_switch_profile_ids',
        :'pnics' => :'pnics',
        :'uplinks' => :'uplinks',
        :'is_migrate_pnics' => :'is_migrate_pnics',
        :'ip_assignment_spec' => :'ip_assignment_spec',
        :'vlan' => :'vlan',
        :'cpu_config' => :'cpu_config',
        :'real_time_eth_config' => :'real_time_eth_config',
        :'transport_zone_endpoints' => :'transport_zone_endpoints',
        :'vmk_install_migration' => :'vmk_install_migration',
        :'pnics_uninstall_migration' => :'pnics_uninstall_migration',
        :'vmk_uninstall_migration' => :'vmk_uninstall_migration',
        :'portgroup_transport_zone_id' => :'portgroup_transport_zone_id',
        :'transport_node_profile_sub_configs' => :'transport_node_profile_sub_configs',
        :'ipv6_assignment_spec' => :'ipv6_assignment_spec'
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        :'host_switch_name' => :'String',
        :'host_switch_id' => :'String',
        :'host_switch_type' => :'String',
        :'host_switch_mode' => :'String',
        :'ecmp_mode' => :'String',
        :'host_switch_profile_ids' => :'Array<HostSwitchProfileTypeIdEntry>',
        :'pnics' => :'Array<Pnic>',
        :'uplinks' => :'Array<VdsUplink>',
        :'is_migrate_pnics' => :'BOOLEAN',
        :'ip_assignment_spec' => :'IpAssignmentSpec',
        :'vlan' => :'Integer',
        :'cpu_config' => :'Array<CpuCoreConfigForEnhancedNetworkingStackSwitch>',
        :'real_time_eth_config' => :'RealTimeEthernetConfigForEnhancedNetworkingStackSwitch',
        :'transport_zone_endpoints' => :'Array<TransportZoneEndPoint>',
        :'vmk_install_migration' => :'Array<VmknicNetwork>',
        :'pnics_uninstall_migration' => :'Array<Pnic>',
        :'vmk_uninstall_migration' => :'Array<VmknicNetwork>',
        :'portgroup_transport_zone_id' => :'String',
        :'transport_node_profile_sub_configs' => :'Array<TransportNodeProfileSubConfig>',
        :'ipv6_assignment_spec' => :'Ipv6AssignmentSpec'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      if attributes.has_key?(:'host_switch_name')
        self.host_switch_name = attributes[:'host_switch_name']
      else
        self.host_switch_name = 'nsxDefaultHostSwitch'
      end

      if attributes.has_key?(:'host_switch_id')
        self.host_switch_id = attributes[:'host_switch_id']
      end

      if attributes.has_key?(:'host_switch_type')
        self.host_switch_type = attributes[:'host_switch_type']
      else
        self.host_switch_type = 'NVDS'
      end

      if attributes.has_key?(:'host_switch_mode')
        self.host_switch_mode = attributes[:'host_switch_mode']
      end

      if attributes.has_key?(:'ecmp_mode')
        self.ecmp_mode = attributes[:'ecmp_mode']
      else
        self.ecmp_mode = 'L3'
      end

      if attributes.has_key?(:'host_switch_profile_ids')
        if (value = attributes[:'host_switch_profile_ids']).is_a?(Array)
          self.host_switch_profile_ids = value
        end
      end

      if attributes.has_key?(:'pnics')
        if (value = attributes[:'pnics']).is_a?(Array)
          self.pnics = value
        end
      end

      if attributes.has_key?(:'uplinks')
        if (value = attributes[:'uplinks']).is_a?(Array)
          self.uplinks = value
        end
      end

      if attributes.has_key?(:'is_migrate_pnics')
        self.is_migrate_pnics = attributes[:'is_migrate_pnics']
      else
        self.is_migrate_pnics = false
      end

      if attributes.has_key?(:'ip_assignment_spec')
        self.ip_assignment_spec = attributes[:'ip_assignment_spec']
      end

      if attributes.has_key?(:'vlan')
        self.vlan = attributes[:'vlan']
      end

      if attributes.has_key?(:'cpu_config')
        if (value = attributes[:'cpu_config']).is_a?(Array)
          self.cpu_config = value
        end
      end

      if attributes.has_key?(:'real_time_eth_config')
        self.real_time_eth_config = attributes[:'real_time_eth_config']
      end

      if attributes.has_key?(:'transport_zone_endpoints')
        if (value = attributes[:'transport_zone_endpoints']).is_a?(Array)
          self.transport_zone_endpoints = value
        end
      end

      if attributes.has_key?(:'vmk_install_migration')
        if (value = attributes[:'vmk_install_migration']).is_a?(Array)
          self.vmk_install_migration = value
        end
      end

      if attributes.has_key?(:'pnics_uninstall_migration')
        if (value = attributes[:'pnics_uninstall_migration']).is_a?(Array)
          self.pnics_uninstall_migration = value
        end
      end

      if attributes.has_key?(:'vmk_uninstall_migration')
        if (value = attributes[:'vmk_uninstall_migration']).is_a?(Array)
          self.vmk_uninstall_migration = value
        end
      end

      if attributes.has_key?(:'portgroup_transport_zone_id')
        self.portgroup_transport_zone_id = attributes[:'portgroup_transport_zone_id']
      end

      if attributes.has_key?(:'transport_node_profile_sub_configs')
        if (value = attributes[:'transport_node_profile_sub_configs']).is_a?(Array)
          self.transport_node_profile_sub_configs = value
        end
      end

      if attributes.has_key?(:'ipv6_assignment_spec')
        self.ipv6_assignment_spec = attributes[:'ipv6_assignment_spec']
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      host_switch_type_validator = EnumAttributeValidator.new('String', ['NVDS', 'VDS'])
      return false unless host_switch_type_validator.valid?(@host_switch_type)
      host_switch_mode_validator = EnumAttributeValidator.new('String', ['STANDARD', 'ENS', 'ENS_INTERRUPT', 'LEGACY'])
      return false unless host_switch_mode_validator.valid?(@host_switch_mode)
      ecmp_mode_validator = EnumAttributeValidator.new('String', ['L3', 'L4'])
      return false unless ecmp_mode_validator.valid?(@ecmp_mode)
      true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] host_switch_type Object to be assigned
    def host_switch_type=(host_switch_type)
      validator = EnumAttributeValidator.new('String', ['NVDS', 'VDS'])
      unless validator.valid?(host_switch_type)
        fail ArgumentError, 'invalid value for "host_switch_type", must be one of #{validator.allowable_values}.'
      end
      @host_switch_type = host_switch_type
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] host_switch_mode Object to be assigned
    def host_switch_mode=(host_switch_mode)
      validator = EnumAttributeValidator.new('String', ['STANDARD', 'ENS', 'ENS_INTERRUPT', 'LEGACY'])
      unless validator.valid?(host_switch_mode)
        fail ArgumentError, 'invalid value for "host_switch_mode", must be one of #{validator.allowable_values}.'
      end
      @host_switch_mode = host_switch_mode
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] ecmp_mode Object to be assigned
    def ecmp_mode=(ecmp_mode)
      validator = EnumAttributeValidator.new('String', ['L3', 'L4'])
      unless validator.valid?(ecmp_mode)
        fail ArgumentError, 'invalid value for "ecmp_mode", must be one of #{validator.allowable_values}.'
      end
      @ecmp_mode = ecmp_mode
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          host_switch_name == o.host_switch_name &&
          host_switch_id == o.host_switch_id &&
          host_switch_type == o.host_switch_type &&
          host_switch_mode == o.host_switch_mode &&
          ecmp_mode == o.ecmp_mode &&
          host_switch_profile_ids == o.host_switch_profile_ids &&
          pnics == o.pnics &&
          uplinks == o.uplinks &&
          is_migrate_pnics == o.is_migrate_pnics &&
          ip_assignment_spec == o.ip_assignment_spec &&
          vlan == o.vlan &&
          cpu_config == o.cpu_config &&
          real_time_eth_config == o.real_time_eth_config &&
          transport_zone_endpoints == o.transport_zone_endpoints &&
          vmk_install_migration == o.vmk_install_migration &&
          pnics_uninstall_migration == o.pnics_uninstall_migration &&
          vmk_uninstall_migration == o.vmk_uninstall_migration &&
          portgroup_transport_zone_id == o.portgroup_transport_zone_id &&
          transport_node_profile_sub_configs == o.transport_node_profile_sub_configs &&
          ipv6_assignment_spec == o.ipv6_assignment_spec
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [host_switch_name, host_switch_id, host_switch_type, host_switch_mode, ecmp_mode, host_switch_profile_ids, pnics, uplinks, is_migrate_pnics, ip_assignment_spec, vlan, cpu_config, real_time_eth_config, transport_zone_endpoints, vmk_install_migration, pnics_uninstall_migration, vmk_uninstall_migration, portgroup_transport_zone_id, transport_node_profile_sub_configs, ipv6_assignment_spec].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.swagger_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = Nsxt9PolicyClient.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end
end
