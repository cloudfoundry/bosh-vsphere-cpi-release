=begin
#NSX Policy API

#VMware NSX Policy REST API

OpenAPI spec version: 9.0.0.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.4.46

=end

require 'uri'

module Nsxt9PolicyClient
  class SystemAdministrationApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Accept end user license agreement 
    # Accept end user license agreement 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def accept_eula(opts = {})
      accept_eula_with_http_info(opts)
      nil
    end

    # Accept end user license agreement 
    # Accept end user license agreement 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def accept_eula_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.accept_eula ...'
      end
      # resource path
      local_var_path = '/eula/accept'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#accept_eula\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Set the cluster configuration for the Avi Load Balancer Controller node. The VIP can be set once. Attempting to change the VIP once set will return an error in case Avi Controllers are deployed.
    # Set the cluster configuration for Avi Load Balancer Controller cluster. 
    # @param alb_controller_node_vm_cluster_config 
    # @param [Hash] opts the optional parameters
    # @return [ALBControllerNodeVMClusterConfig]
    def add_alb_controller_node_cluster_config(alb_controller_node_vm_cluster_config, opts = {})
      data, _status_code, _headers = add_alb_controller_node_cluster_config_with_http_info(alb_controller_node_vm_cluster_config, opts)
      data
    end

    # Set the cluster configuration for the Avi Load Balancer Controller node. The VIP can be set once. Attempting to change the VIP once set will return an error in case Avi Controllers are deployed.
    # Set the cluster configuration for Avi Load Balancer Controller cluster. 
    # @param alb_controller_node_vm_cluster_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ALBControllerNodeVMClusterConfig, Fixnum, Hash)>] ALBControllerNodeVMClusterConfig data, response status code and response headers
    def add_alb_controller_node_cluster_config_with_http_info(alb_controller_node_vm_cluster_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.add_alb_controller_node_cluster_config ...'
      end
      # verify the required parameter 'alb_controller_node_vm_cluster_config' is set
      if @api_client.config.client_side_validation && alb_controller_node_vm_cluster_config.nil?
        fail ArgumentError, "Missing the required parameter 'alb_controller_node_vm_cluster_config' when calling SystemAdministrationApi.add_alb_controller_node_cluster_config"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/clusterconfig'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(alb_controller_node_vm_cluster_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerNodeVMClusterConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#add_alb_controller_node_cluster_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Deploy and register a Avi Load Balancer Controller node
    # Deploys a Avi Load Balancer Controller node as specified by the deployment config. 
    # @param add_alb_controller_node_vm_info 
    # @param [Hash] opts the optional parameters
    # @return [ALBControllerNodeVMDeploymentRequestList]
    def add_alb_controller_node_vm(add_alb_controller_node_vm_info, opts = {})
      data, _status_code, _headers = add_alb_controller_node_vm_with_http_info(add_alb_controller_node_vm_info, opts)
      data
    end

    # Deploy and register a Avi Load Balancer Controller node
    # Deploys a Avi Load Balancer Controller node as specified by the deployment config. 
    # @param add_alb_controller_node_vm_info 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ALBControllerNodeVMDeploymentRequestList, Fixnum, Hash)>] ALBControllerNodeVMDeploymentRequestList data, response status code and response headers
    def add_alb_controller_node_vm_with_http_info(add_alb_controller_node_vm_info, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.add_alb_controller_node_vm ...'
      end
      # verify the required parameter 'add_alb_controller_node_vm_info' is set
      if @api_client.config.client_side_validation && add_alb_controller_node_vm_info.nil?
        fail ArgumentError, "Missing the required parameter 'add_alb_controller_node_vm_info' when calling SystemAdministrationApi.add_alb_controller_node_vm"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/deployments'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(add_alb_controller_node_vm_info)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerNodeVMDeploymentRequestList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#add_alb_controller_node_vm\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Validate admin password for Avi Load Balancer Controller.
    # Use this API to validate admin password in Avi Load Balancer Controller. This API is for VCF deployments only. 
    # @param alb_controller_admin_credential 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def admin_check_password(alb_controller_admin_credential, opts = {})
      admin_check_password_with_http_info(alb_controller_admin_credential, opts)
      nil
    end

    # Validate admin password for Avi Load Balancer Controller.
    # Use this API to validate admin password in Avi Load Balancer Controller. This API is for VCF deployments only. 
    # @param alb_controller_admin_credential 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def admin_check_password_with_http_info(alb_controller_admin_credential, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.admin_check_password ...'
      end
      # verify the required parameter 'alb_controller_admin_credential' is set
      if @api_client.config.client_side_validation && alb_controller_admin_credential.nil?
        fail ArgumentError, "Missing the required parameter 'alb_controller_admin_credential' when calling SystemAdministrationApi.admin_check_password"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/check-password'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(alb_controller_admin_credential)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#admin_check_password\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Advance any suspended restore operation
    # Advance any currently suspended restore operation. The operation might have been suspended because (1) the user had suspended it previously, or (2) the operation is waiting for user input, to be provided as a part of the POST request body. This operation is only valid when a GET cluster/restore/status returns a status with value SUSPENDED. Otherwise, a 409 response is returned. 
    # @param advance_cluster_restore_request 
    # @param [Hash] opts the optional parameters
    # @return [ClusterRestoreStatus]
    def advance_cluster_restore(advance_cluster_restore_request, opts = {})
      data, _status_code, _headers = advance_cluster_restore_with_http_info(advance_cluster_restore_request, opts)
      data
    end

    # Advance any suspended restore operation
    # Advance any currently suspended restore operation. The operation might have been suspended because (1) the user had suspended it previously, or (2) the operation is waiting for user input, to be provided as a part of the POST request body. This operation is only valid when a GET cluster/restore/status returns a status with value SUSPENDED. Otherwise, a 409 response is returned. 
    # @param advance_cluster_restore_request 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ClusterRestoreStatus, Fixnum, Hash)>] ClusterRestoreStatus data, response status code and response headers
    def advance_cluster_restore_with_http_info(advance_cluster_restore_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.advance_cluster_restore ...'
      end
      # verify the required parameter 'advance_cluster_restore_request' is set
      if @api_client.config.client_side_validation && advance_cluster_restore_request.nil?
        fail ArgumentError, "Missing the required parameter 'advance_cluster_restore_request' when calling SystemAdministrationApi.advance_cluster_restore"
      end
      # resource path
      local_var_path = '/cluster/restore?action=advance'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(advance_cluster_restore_request)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ClusterRestoreStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#advance_cluster_restore\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Trigger to query VCF licenses from all registered vCenters asynchronous 
    # Trigger to query VCF licenses from all registered vCenters and update licenses in NSX in an asynchronous manner. 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def async_vcf_licenses(opts = {})
      async_vcf_licenses_with_http_info(opts)
      nil
    end

    # Trigger to query VCF licenses from all registered vCenters asynchronous 
    # Trigger to query VCF licenses from all registered vCenters and update licenses in NSX in an asynchronous manner. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def async_vcf_licenses_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.async_vcf_licenses ...'
      end
      # resource path
      local_var_path = '/licenses/vcf/action/async'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#async_vcf_licenses\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Cancel any running restore operation
    # This operation is only valid when a restore is in suspended state. The UI user can cancel any restore operation when the restore is suspended either due to an error, or for a user input. The API user would need to monitor the progression of a restore by calling periodically \"/api/v1/cluster/restore/status\" API. The response object (ClusterRestoreStatus), contains a field \"endpoints\". The API user can cancel the restore process if 'cancel' action is shown in the endpoint field. This operation is only valid when a GET cluster/restore/status returns a status with value SUSPENDED. 
    # @param [Hash] opts the optional parameters
    # @return [ClusterRestoreStatus]
    def cancel_cluster_restore(opts = {})
      data, _status_code, _headers = cancel_cluster_restore_with_http_info(opts)
      data
    end

    # Cancel any running restore operation
    # This operation is only valid when a restore is in suspended state. The UI user can cancel any restore operation when the restore is suspended either due to an error, or for a user input. The API user would need to monitor the progression of a restore by calling periodically \&quot;/api/v1/cluster/restore/status\&quot; API. The response object (ClusterRestoreStatus), contains a field \&quot;endpoints\&quot;. The API user can cancel the restore process if &#39;cancel&#39; action is shown in the endpoint field. This operation is only valid when a GET cluster/restore/status returns a status with value SUSPENDED. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ClusterRestoreStatus, Fixnum, Hash)>] ClusterRestoreStatus data, response status code and response headers
    def cancel_cluster_restore_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.cancel_cluster_restore ...'
      end
      # resource path
      local_var_path = '/cluster/restore?action=cancel'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ClusterRestoreStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#cancel_cluster_restore\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Clone an already present role
    # The role with id &lt;role&gt; is cloned and the new id, name and description are the ones provided in the request body. 
    # @param role Role id
    # @param new_role 
    # @param [Hash] opts the optional parameters
    # @return [NewRole]
    def clone_role(role, new_role, opts = {})
      data, _status_code, _headers = clone_role_with_http_info(role, new_role, opts)
      data
    end

    # Clone an already present role
    # The role with id &amp;lt;role&amp;gt; is cloned and the new id, name and description are the ones provided in the request body. 
    # @param role Role id
    # @param new_role 
    # @param [Hash] opts the optional parameters
    # @return [Array<(NewRole, Fixnum, Hash)>] NewRole data, response status code and response headers
    def clone_role_with_http_info(role, new_role, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.clone_role ...'
      end
      # verify the required parameter 'role' is set
      if @api_client.config.client_side_validation && role.nil?
        fail ArgumentError, "Missing the required parameter 'role' when calling SystemAdministrationApi.clone_role"
      end
      # verify the required parameter 'new_role' is set
      if @api_client.config.client_side_validation && new_role.nil?
        fail ArgumentError, "Missing the required parameter 'new_role' when calling SystemAdministrationApi.clone_role"
      end
      # resource path
      local_var_path = '/aaa/roles/{role}?action=clone'.sub('{' + 'role' + '}', role.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(new_role)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'NewRole')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#clone_role\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Configure backup
    # Configure file server and timers for automated backup. If secret fields are omitted (password, passphrase) then use the previously set value. 
    # @param backup_configuration 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :frame_type Frame type (default to LOCAL_LOCAL_MANAGER)
    # @option opts [String] :site_id Site ID (default to localhost)
    # @return [BackupConfiguration]
    def configure_backup_config(backup_configuration, opts = {})
      data, _status_code, _headers = configure_backup_config_with_http_info(backup_configuration, opts)
      data
    end

    # Configure backup
    # Configure file server and timers for automated backup. If secret fields are omitted (password, passphrase) then use the previously set value. 
    # @param backup_configuration 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :frame_type Frame type
    # @option opts [String] :site_id Site ID
    # @return [Array<(BackupConfiguration, Fixnum, Hash)>] BackupConfiguration data, response status code and response headers
    def configure_backup_config_with_http_info(backup_configuration, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.configure_backup_config ...'
      end
      # verify the required parameter 'backup_configuration' is set
      if @api_client.config.client_side_validation && backup_configuration.nil?
        fail ArgumentError, "Missing the required parameter 'backup_configuration' when calling SystemAdministrationApi.configure_backup_config"
      end
      if @api_client.config.client_side_validation && opts[:'frame_type'] && !['GLOBAL_MANAGER', 'LOCAL_MANAGER', 'LOCAL_LOCAL_MANAGER', 'NSX_INTELLIGENCE'].include?(opts[:'frame_type'])
        fail ArgumentError, 'invalid value for "frame_type", must be one of GLOBAL_MANAGER, LOCAL_MANAGER, LOCAL_LOCAL_MANAGER, NSX_INTELLIGENCE'
      end
      # resource path
      local_var_path = '/cluster/backups/config'

      # query parameters
      query_params = {}
      query_params[:'frame_type'] = opts[:'frame_type'] if !opts[:'frame_type'].nil?
      query_params[:'site_id'] = opts[:'site_id'] if !opts[:'site_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(backup_configuration)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BackupConfiguration')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#configure_backup_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Deprecated. Configure Restore SFTP server credentials
    # Configure file server where the backed-up files used for the Restore operation are available.  <br> Please use API /cluster/backups/config, to configure remote file server(where backed-up files are stored) details during restore.
    # @param restore_configuration 
    # @param [Hash] opts the optional parameters
    # @return [RestoreConfiguration]
    def configure_restore_config(restore_configuration, opts = {})
      data, _status_code, _headers = configure_restore_config_with_http_info(restore_configuration, opts)
      data
    end

    # Deprecated. Configure Restore SFTP server credentials
    # Configure file server where the backed-up files used for the Restore operation are available.  &lt;br&gt; Please use API /cluster/backups/config, to configure remote file server(where backed-up files are stored) details during restore.
    # @param restore_configuration 
    # @param [Hash] opts the optional parameters
    # @return [Array<(RestoreConfiguration, Fixnum, Hash)>] RestoreConfiguration data, response status code and response headers
    def configure_restore_config_with_http_info(restore_configuration, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.configure_restore_config ...'
      end
      # verify the required parameter 'restore_configuration' is set
      if @api_client.config.client_side_validation && restore_configuration.nil?
        fail ArgumentError, "Missing the required parameter 'restore_configuration' when calling SystemAdministrationApi.configure_restore_config"
      end
      # resource path
      local_var_path = '/cluster/restore/config'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(restore_configuration)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RestoreConfiguration')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#configure_restore_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Configure the cluster for security
    # This API configures a compute collection for security. In the request body, specify a Transport Node Collection with only the ID of the target compute collection meant for security. Specifically, a Transport Node Profile ID should not be specified. This API will define a system-generated security Transport Node Profile and apply it on the compute collection to create the Transport Node Collection.
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param host_transport_node_collection 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def configure_transport_node_collection_for_security(site_id, enforcementpoint_id, transport_node_collection_id, host_transport_node_collection, opts = {})
      configure_transport_node_collection_for_security_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, host_transport_node_collection, opts)
      nil
    end

    # Configure the cluster for security
    # This API configures a compute collection for security. In the request body, specify a Transport Node Collection with only the ID of the target compute collection meant for security. Specifically, a Transport Node Profile ID should not be specified. This API will define a system-generated security Transport Node Profile and apply it on the compute collection to create the Transport Node Collection.
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param host_transport_node_collection 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def configure_transport_node_collection_for_security_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, host_transport_node_collection, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.configure_transport_node_collection_for_security ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.configure_transport_node_collection_for_security"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.configure_transport_node_collection_for_security"
      end
      # verify the required parameter 'transport_node_collection_id' is set
      if @api_client.config.client_side_validation && transport_node_collection_id.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_collection_id' when calling SystemAdministrationApi.configure_transport_node_collection_for_security"
      end
      # verify the required parameter 'host_transport_node_collection' is set
      if @api_client.config.client_side_validation && host_transport_node_collection.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_collection' when calling SystemAdministrationApi.configure_transport_node_collection_for_security"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/transport-node-collections/{transport-node-collection-id}?action=install_for_microseg'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'transport-node-collection-id' + '}', transport_node_collection_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(host_transport_node_collection)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#configure_transport_node_collection_for_security\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create portal certificate CSR for Avi Load Balancer Controller.
    # Use this API to create portal certificate CSR for Avi Load Balancer Controller. 
    # @param alb_controller_certificate_csr 
    # @param [Hash] opts the optional parameters
    # @return [ALBControllerCertificate]
    def create_alb_portal_certificate_csr(alb_controller_certificate_csr, opts = {})
      data, _status_code, _headers = create_alb_portal_certificate_csr_with_http_info(alb_controller_certificate_csr, opts)
      data
    end

    # Create portal certificate CSR for Avi Load Balancer Controller.
    # Use this API to create portal certificate CSR for Avi Load Balancer Controller. 
    # @param alb_controller_certificate_csr 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ALBControllerCertificate, Fixnum, Hash)>] ALBControllerCertificate data, response status code and response headers
    def create_alb_portal_certificate_csr_with_http_info(alb_controller_certificate_csr, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.create_alb_portal_certificate_csr ...'
      end
      # verify the required parameter 'alb_controller_certificate_csr' is set
      if @api_client.config.client_side_validation && alb_controller_certificate_csr.nil?
        fail ArgumentError, "Missing the required parameter 'alb_controller_certificate_csr' when calling SystemAdministrationApi.create_alb_portal_certificate_csr"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/certificate/csr'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(alb_controller_certificate_csr)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#create_alb_portal_certificate_csr\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create service user object credential in Avi Load Balancer Controller cluster.
    # Use this API to create service user object credential in Avi Load Balancer Controller cluster. This API is for VCF deployments only. 
    # @param alb_controller_user_credential 
    # @param [Hash] opts the optional parameters
    # @return [ALBControllerUserCredentialResponse]
    def create_alb_user_credential_object(alb_controller_user_credential, opts = {})
      data, _status_code, _headers = create_alb_user_credential_object_with_http_info(alb_controller_user_credential, opts)
      data
    end

    # Create service user object credential in Avi Load Balancer Controller cluster.
    # Use this API to create service user object credential in Avi Load Balancer Controller cluster. This API is for VCF deployments only. 
    # @param alb_controller_user_credential 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ALBControllerUserCredentialResponse, Fixnum, Hash)>] ALBControllerUserCredentialResponse data, response status code and response headers
    def create_alb_user_credential_object_with_http_info(alb_controller_user_credential, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.create_alb_user_credential_object ...'
      end
      # verify the required parameter 'alb_controller_user_credential' is set
      if @api_client.config.client_side_validation && alb_controller_user_credential.nil?
        fail ArgumentError, "Missing the required parameter 'alb_controller_user_credential' when calling SystemAdministrationApi.create_alb_user_credential_object"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/user-credential'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(alb_controller_user_credential)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerUserCredentialResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#create_alb_user_credential_object\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update deployment information.
    # This is an API called by VCF to store or update deployment information. 
    # @param nsx_manager_deployment_info 
    # @param [Hash] opts the optional parameters
    # @return [NSXManagerDeploymentInfo]
    def create_deployment_info(nsx_manager_deployment_info, opts = {})
      data, _status_code, _headers = create_deployment_info_with_http_info(nsx_manager_deployment_info, opts)
      data
    end

    # Create or update deployment information.
    # This is an API called by VCF to store or update deployment information. 
    # @param nsx_manager_deployment_info 
    # @param [Hash] opts the optional parameters
    # @return [Array<(NSXManagerDeploymentInfo, Fixnum, Hash)>] NSXManagerDeploymentInfo data, response status code and response headers
    def create_deployment_info_with_http_info(nsx_manager_deployment_info, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.create_deployment_info ...'
      end
      # verify the required parameter 'nsx_manager_deployment_info' is set
      if @api_client.config.client_side_validation && nsx_manager_deployment_info.nil?
        fail ArgumentError, "Missing the required parameter 'nsx_manager_deployment_info' when calling SystemAdministrationApi.create_deployment_info"
      end
      # resource path
      local_var_path = '/watermark'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(nsx_manager_deployment_info)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'NSXManagerDeploymentInfo')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#create_deployment_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Registration URL
    # Registration URL.
    # @param region Region
    # @param [Hash] opts the optional parameters
    # @return [MalwarePreventionTeaserRegistrationURL]
    def create_malware_prevention_teaser_registration_url(region, opts = {})
      data, _status_code, _headers = create_malware_prevention_teaser_registration_url_with_http_info(region, opts)
      data
    end

    # Registration URL
    # Registration URL.
    # @param region Region
    # @param [Hash] opts the optional parameters
    # @return [Array<(MalwarePreventionTeaserRegistrationURL, Fixnum, Hash)>] MalwarePreventionTeaserRegistrationURL data, response status code and response headers
    def create_malware_prevention_teaser_registration_url_with_http_info(region, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.create_malware_prevention_teaser_registration_url ...'
      end
      # verify the required parameter 'region' is set
      if @api_client.config.client_side_validation && region.nil?
        fail ArgumentError, "Missing the required parameter 'region' when calling SystemAdministrationApi.create_malware_prevention_teaser_registration_url"
      end
      # resource path
      local_var_path = '/malware-prevention/teaser/registration_url'

      # query parameters
      query_params = {}
      query_params[:'region'] = region

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MalwarePreventionTeaserRegistrationURL')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#create_malware_prevention_teaser_registration_url\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create a Event Log server for Firewall Identity store
    # More than one Event Log server can be created and only one event log server is used to synchronize directory objects. If more than one Event Log server is configured, NSX will try all the servers until it is able to successfully connect to one.  <br> <br> Use the following Policy API - <br> PATCH /infra/identity-firewall-stores/&lt;identity-firewall-store-id&gt;/event-log-servers/&lt;event-log-server-id&gt;
    # @param firewall_identity_store_id Firewall Identity store identifier
    # @param event_log_server_id Event Log server identifier
    # @param directory_event_log_server 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @return [nil]
    def create_or_patch_firewall_identity_store_event_log_server(firewall_identity_store_id, event_log_server_id, directory_event_log_server, opts = {})
      create_or_patch_firewall_identity_store_event_log_server_with_http_info(firewall_identity_store_id, event_log_server_id, directory_event_log_server, opts)
      nil
    end

    # Create a Event Log server for Firewall Identity store
    # More than one Event Log server can be created and only one event log server is used to synchronize directory objects. If more than one Event Log server is configured, NSX will try all the servers until it is able to successfully connect to one.  &lt;br&gt; &lt;br&gt; Use the following Policy API - &lt;br&gt; PATCH /infra/identity-firewall-stores/&amp;lt;identity-firewall-store-id&amp;gt;/event-log-servers/&amp;lt;event-log-server-id&amp;gt;
    # @param firewall_identity_store_id Firewall Identity store identifier
    # @param event_log_server_id Event Log server identifier
    # @param directory_event_log_server 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def create_or_patch_firewall_identity_store_event_log_server_with_http_info(firewall_identity_store_id, event_log_server_id, directory_event_log_server, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.create_or_patch_firewall_identity_store_event_log_server ...'
      end
      # verify the required parameter 'firewall_identity_store_id' is set
      if @api_client.config.client_side_validation && firewall_identity_store_id.nil?
        fail ArgumentError, "Missing the required parameter 'firewall_identity_store_id' when calling SystemAdministrationApi.create_or_patch_firewall_identity_store_event_log_server"
      end
      # verify the required parameter 'event_log_server_id' is set
      if @api_client.config.client_side_validation && event_log_server_id.nil?
        fail ArgumentError, "Missing the required parameter 'event_log_server_id' when calling SystemAdministrationApi.create_or_patch_firewall_identity_store_event_log_server"
      end
      # verify the required parameter 'directory_event_log_server' is set
      if @api_client.config.client_side_validation && directory_event_log_server.nil?
        fail ArgumentError, "Missing the required parameter 'directory_event_log_server' when calling SystemAdministrationApi.create_or_patch_firewall_identity_store_event_log_server"
      end
      # resource path
      local_var_path = '/infra/firewall-identity-stores/{firewall-identity-store-id}/event-log-servers/{event-log-server-id}'.sub('{' + 'firewall-identity-store-id' + '}', firewall_identity_store_id.to_s).sub('{' + 'event-log-server-id' + '}', event_log_server_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(directory_event_log_server)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#create_or_patch_firewall_identity_store_event_log_server\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or Update Cluster Control Plane to NSX-T
    # Joins a Cluster Control Plane to NSX-T 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param cluster_control_plane 
    # @param [Hash] opts the optional parameters
    # @return [ClusterControlPlane]
    def create_or_update_cluster_control_plane(site_id, enforcementpoint_id, cluster_control_plane_id, cluster_control_plane, opts = {})
      data, _status_code, _headers = create_or_update_cluster_control_plane_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, cluster_control_plane, opts)
      data
    end

    # Create or Update Cluster Control Plane to NSX-T
    # Joins a Cluster Control Plane to NSX-T 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param cluster_control_plane 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ClusterControlPlane, Fixnum, Hash)>] ClusterControlPlane data, response status code and response headers
    def create_or_update_cluster_control_plane_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, cluster_control_plane, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.create_or_update_cluster_control_plane ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.create_or_update_cluster_control_plane"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.create_or_update_cluster_control_plane"
      end
      # verify the required parameter 'cluster_control_plane_id' is set
      if @api_client.config.client_side_validation && cluster_control_plane_id.nil?
        fail ArgumentError, "Missing the required parameter 'cluster_control_plane_id' when calling SystemAdministrationApi.create_or_update_cluster_control_plane"
      end
      # verify the required parameter 'cluster_control_plane' is set
      if @api_client.config.client_side_validation && cluster_control_plane.nil?
        fail ArgumentError, "Missing the required parameter 'cluster_control_plane' when calling SystemAdministrationApi.create_or_update_cluster_control_plane"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/cluster-control-planes/{cluster-control-plane-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'cluster-control-plane-id' + '}', cluster_control_plane_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(cluster_control_plane)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ClusterControlPlane')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#create_or_update_cluster_control_plane\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update deployment information.
    # This is an API called by VCF to update stored deployment information. 
    # @param nsx_manager_deployment_info 
    # @param [Hash] opts the optional parameters
    # @return [NSXManagerDeploymentInfo]
    def create_or_update_deployment_info(nsx_manager_deployment_info, opts = {})
      data, _status_code, _headers = create_or_update_deployment_info_with_http_info(nsx_manager_deployment_info, opts)
      data
    end

    # Create or update deployment information.
    # This is an API called by VCF to update stored deployment information. 
    # @param nsx_manager_deployment_info 
    # @param [Hash] opts the optional parameters
    # @return [Array<(NSXManagerDeploymentInfo, Fixnum, Hash)>] NSXManagerDeploymentInfo data, response status code and response headers
    def create_or_update_deployment_info_with_http_info(nsx_manager_deployment_info, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.create_or_update_deployment_info ...'
      end
      # verify the required parameter 'nsx_manager_deployment_info' is set
      if @api_client.config.client_side_validation && nsx_manager_deployment_info.nil?
        fail ArgumentError, "Missing the required parameter 'nsx_manager_deployment_info' when calling SystemAdministrationApi.create_or_update_deployment_info"
      end
      # resource path
      local_var_path = '/watermark'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(nsx_manager_deployment_info)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'NSXManagerDeploymentInfo')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#create_or_update_deployment_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a Host Transport Node
    # Transport nodes are hypervisor hosts that will participate in an NSX-T overlay. For a hypervisor host, this means that it hosts VMs that will communicate over NSX-T logical switches.  This API creates transport node for a host node (hypervisor) in the transport network.  When you run this command for a host, NSX Manager attempts to install the NSX kernel modules, which are packaged as VIB, RPM, or DEB files. For the installation to succeed, you must provide the host login credentials and the host thumbprint.  To get the ESXi host thumbprint, SSH to the host and run the <b>openssl x509 -in /etc/vmware/ssl/rui.crt -fingerprint -sha256 -noout</b> command.  To generate host key thumbprint using SHA-256 algorithm please follow the steps below.  Log into the host, making sure that the connection is not vulnerable to a man in the middle attack. Check whether a public key already exists. Host public key is generally located at '/etc/ssh/ssh_host_rsa_key.pub'. If the key is not present then generate a new key by running the following command and follow the instructions.  <b>ssh-keygen -t rsa</b>  Now generate a SHA256 hash of the key using the following command. Please make sure to pass the appropriate file name if the public key is stored with a different file name other than the default 'id_rsa.pub'.  <b>awk '{print $2}' id_rsa.pub | base64 -d | sha256sum -b | sed 's/ .*$//' | xxd -r -p | base64</b>  Additional documentation on creating a transport node can be found in the NSX-T Installation Guide.  In order for the transport node to forward packets, the host_switch_spec property must be specified.  Host switches (called bridges in OVS on KVM hypervisors) are the individual switches within the host virtual switch. Virtual machines are connected to the host switches.  When creating a transport node, you need to specify if the host switches are already manually preconfigured on the node, or if NSX should create and manage the host switches. You specify this choice by the type of host switches you pass in the host_switch_spec property of the TransportNode request payload.  For a KVM host, you can preconfigure the host switch, or you can have NSX Manager perform the configuration. For an ESXi host NSX Manager always configures the host switch.  To preconfigure the host switches on a KVM host, pass an array of PreconfiguredHostSwitchSpec objects that describes those host switches. In the current NSX-T release, only one prefonfigured host switch can be specified.  See the PreconfiguredHostSwitchSpec schema definition for documentation on the properties that must be provided. Preconfigured host switches are only supported on KVM hosts, not on ESXi hosts.  To allow NSX to manage the host switch configuration on KVM hosts, ESXi hosts, pass an array of StandardHostSwitchSpec objects in the host_switch_spec property, and NSX will automatically create host switches with the properties you provide. In the current NSX-T release, up to 16 host switches can be automatically managed. See the StandardHostSwitchSpec schema definition for documentation on the properties that must be provided.  The request should provide node_deployement_info. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param host_transport_node 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :esx_mgmt_if_migration_dest The network ids to which the ESX vmk interfaces will be migrated
    # @option opts [String] :if_id The ESX vmk interfaces to migrate
    # @option opts [BOOLEAN] :override_nsx_ownership Override NSX Ownership (default to false)
    # @option opts [String] :ping_ip IP Addresses to ping right after ESX vmk interfaces were migrated.
    # @option opts [BOOLEAN] :skip_validation Whether to skip front-end validation for vmk/vnic/pnic migration (default to false)
    # @option opts [String] :vnic The ESX vmk interfaces and/or VM NIC to migrate
    # @option opts [String] :vnic_migration_dest The migration destinations of ESX vmk interfaces and/or VM NIC
    # @return [HostTransportNode]
    def create_or_update_host_transport_node(site_id, enforcementpoint_id, host_transport_node_id, host_transport_node, opts = {})
      data, _status_code, _headers = create_or_update_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, host_transport_node, opts)
      data
    end

    # Create or update a Host Transport Node
    # Transport nodes are hypervisor hosts that will participate in an NSX-T overlay. For a hypervisor host, this means that it hosts VMs that will communicate over NSX-T logical switches.  This API creates transport node for a host node (hypervisor) in the transport network.  When you run this command for a host, NSX Manager attempts to install the NSX kernel modules, which are packaged as VIB, RPM, or DEB files. For the installation to succeed, you must provide the host login credentials and the host thumbprint.  To get the ESXi host thumbprint, SSH to the host and run the &lt;b&gt;openssl x509 -in /etc/vmware/ssl/rui.crt -fingerprint -sha256 -noout&lt;/b&gt; command.  To generate host key thumbprint using SHA-256 algorithm please follow the steps below.  Log into the host, making sure that the connection is not vulnerable to a man in the middle attack. Check whether a public key already exists. Host public key is generally located at &#39;/etc/ssh/ssh_host_rsa_key.pub&#39;. If the key is not present then generate a new key by running the following command and follow the instructions.  &lt;b&gt;ssh-keygen -t rsa&lt;/b&gt;  Now generate a SHA256 hash of the key using the following command. Please make sure to pass the appropriate file name if the public key is stored with a different file name other than the default &#39;id_rsa.pub&#39;.  &lt;b&gt;awk &#39;{print $2}&#39; id_rsa.pub | base64 -d | sha256sum -b | sed &#39;s/ .*$//&#39; | xxd -r -p | base64&lt;/b&gt;  Additional documentation on creating a transport node can be found in the NSX-T Installation Guide.  In order for the transport node to forward packets, the host_switch_spec property must be specified.  Host switches (called bridges in OVS on KVM hypervisors) are the individual switches within the host virtual switch. Virtual machines are connected to the host switches.  When creating a transport node, you need to specify if the host switches are already manually preconfigured on the node, or if NSX should create and manage the host switches. You specify this choice by the type of host switches you pass in the host_switch_spec property of the TransportNode request payload.  For a KVM host, you can preconfigure the host switch, or you can have NSX Manager perform the configuration. For an ESXi host NSX Manager always configures the host switch.  To preconfigure the host switches on a KVM host, pass an array of PreconfiguredHostSwitchSpec objects that describes those host switches. In the current NSX-T release, only one prefonfigured host switch can be specified.  See the PreconfiguredHostSwitchSpec schema definition for documentation on the properties that must be provided. Preconfigured host switches are only supported on KVM hosts, not on ESXi hosts.  To allow NSX to manage the host switch configuration on KVM hosts, ESXi hosts, pass an array of StandardHostSwitchSpec objects in the host_switch_spec property, and NSX will automatically create host switches with the properties you provide. In the current NSX-T release, up to 16 host switches can be automatically managed. See the StandardHostSwitchSpec schema definition for documentation on the properties that must be provided.  The request should provide node_deployement_info. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param host_transport_node 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :esx_mgmt_if_migration_dest The network ids to which the ESX vmk interfaces will be migrated
    # @option opts [String] :if_id The ESX vmk interfaces to migrate
    # @option opts [BOOLEAN] :override_nsx_ownership Override NSX Ownership
    # @option opts [String] :ping_ip IP Addresses to ping right after ESX vmk interfaces were migrated.
    # @option opts [BOOLEAN] :skip_validation Whether to skip front-end validation for vmk/vnic/pnic migration
    # @option opts [String] :vnic The ESX vmk interfaces and/or VM NIC to migrate
    # @option opts [String] :vnic_migration_dest The migration destinations of ESX vmk interfaces and/or VM NIC
    # @return [Array<(HostTransportNode, Fixnum, Hash)>] HostTransportNode data, response status code and response headers
    def create_or_update_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, host_transport_node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.create_or_update_host_transport_node ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.create_or_update_host_transport_node"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.create_or_update_host_transport_node"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling SystemAdministrationApi.create_or_update_host_transport_node"
      end
      # verify the required parameter 'host_transport_node' is set
      if @api_client.config.client_side_validation && host_transport_node.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node' when calling SystemAdministrationApi.create_or_update_host_transport_node"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'esx_mgmt_if_migration_dest'] = opts[:'esx_mgmt_if_migration_dest'] if !opts[:'esx_mgmt_if_migration_dest'].nil?
      query_params[:'if_id'] = opts[:'if_id'] if !opts[:'if_id'].nil?
      query_params[:'override_nsx_ownership'] = opts[:'override_nsx_ownership'] if !opts[:'override_nsx_ownership'].nil?
      query_params[:'ping_ip'] = opts[:'ping_ip'] if !opts[:'ping_ip'].nil?
      query_params[:'skip_validation'] = opts[:'skip_validation'] if !opts[:'skip_validation'].nil?
      query_params[:'vnic'] = opts[:'vnic'] if !opts[:'vnic'].nil?
      query_params[:'vnic_migration_dest'] = opts[:'vnic_migration_dest'] if !opts[:'vnic_migration_dest'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(host_transport_node)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'HostTransportNode')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#create_or_update_host_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create transport node collection by attaching Transport Node Profile to cluster.
    # When transport node collection is created the hosts which are part of compute collection will be prepared automatically i.e. NSX Manager attempts to install the NSX components on hosts. Transport nodes for these hosts are created using the configuration specified in transport node profile. Pass apply_profile to false, if you do not want to apply transport node profile on the existing transport node with overridden host flag set and ignore overridden hosts flag is set to true on the transport node profile. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collections_id 
    # @param host_transport_node_collection 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :apply_profile Indicates if the Transport Node Profile (TNP) configuration should be applied during creation (default to true)
    # @option opts [BOOLEAN] :override_nsx_ownership Override NSX Ownership (default to false)
    # @return [HostTransportNodeCollection]
    def create_or_update_host_transport_node_collection(site_id, enforcementpoint_id, transport_node_collections_id, host_transport_node_collection, opts = {})
      data, _status_code, _headers = create_or_update_host_transport_node_collection_with_http_info(site_id, enforcementpoint_id, transport_node_collections_id, host_transport_node_collection, opts)
      data
    end

    # Create transport node collection by attaching Transport Node Profile to cluster.
    # When transport node collection is created the hosts which are part of compute collection will be prepared automatically i.e. NSX Manager attempts to install the NSX components on hosts. Transport nodes for these hosts are created using the configuration specified in transport node profile. Pass apply_profile to false, if you do not want to apply transport node profile on the existing transport node with overridden host flag set and ignore overridden hosts flag is set to true on the transport node profile. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collections_id 
    # @param host_transport_node_collection 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :apply_profile Indicates if the Transport Node Profile (TNP) configuration should be applied during creation
    # @option opts [BOOLEAN] :override_nsx_ownership Override NSX Ownership
    # @return [Array<(HostTransportNodeCollection, Fixnum, Hash)>] HostTransportNodeCollection data, response status code and response headers
    def create_or_update_host_transport_node_collection_with_http_info(site_id, enforcementpoint_id, transport_node_collections_id, host_transport_node_collection, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.create_or_update_host_transport_node_collection ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.create_or_update_host_transport_node_collection"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.create_or_update_host_transport_node_collection"
      end
      # verify the required parameter 'transport_node_collections_id' is set
      if @api_client.config.client_side_validation && transport_node_collections_id.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_collections_id' when calling SystemAdministrationApi.create_or_update_host_transport_node_collection"
      end
      # verify the required parameter 'host_transport_node_collection' is set
      if @api_client.config.client_side_validation && host_transport_node_collection.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_collection' when calling SystemAdministrationApi.create_or_update_host_transport_node_collection"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/transport-node-collections/{transport-node-collections-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'transport-node-collections-id' + '}', transport_node_collections_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'apply_profile'] = opts[:'apply_profile'] if !opts[:'apply_profile'].nil?
      query_params[:'override_nsx_ownership'] = opts[:'override_nsx_ownership'] if !opts[:'override_nsx_ownership'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(host_transport_node_collection)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'HostTransportNodeCollection')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#create_or_update_host_transport_node_collection\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update an LDAP identity source
    # Create a new LDAP identity source or update the configuration of an existing LDAP identity source. You may wish to verify the new configuration using the POST /aaa/ldap-identity-sources?action=probe API before creating or changing the configuration. Note that if you are using LDAP on an active and standby NSX-T Global Manager in a federated environment, you must use the same name for your LDAP identity sources on the active and standby Global Managers.
    # @param ldap_identity_source_id 
    # @param ldap_identity_source 
    # @param [Hash] opts the optional parameters
    # @return [LdapIdentitySource]
    def create_or_update_ldap_identity_source(ldap_identity_source_id, ldap_identity_source, opts = {})
      data, _status_code, _headers = create_or_update_ldap_identity_source_with_http_info(ldap_identity_source_id, ldap_identity_source, opts)
      data
    end

    # Create or update an LDAP identity source
    # Create a new LDAP identity source or update the configuration of an existing LDAP identity source. You may wish to verify the new configuration using the POST /aaa/ldap-identity-sources?action&#x3D;probe API before creating or changing the configuration. Note that if you are using LDAP on an active and standby NSX-T Global Manager in a federated environment, you must use the same name for your LDAP identity sources on the active and standby Global Managers.
    # @param ldap_identity_source_id 
    # @param ldap_identity_source 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LdapIdentitySource, Fixnum, Hash)>] LdapIdentitySource data, response status code and response headers
    def create_or_update_ldap_identity_source_with_http_info(ldap_identity_source_id, ldap_identity_source, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.create_or_update_ldap_identity_source ...'
      end
      # verify the required parameter 'ldap_identity_source_id' is set
      if @api_client.config.client_side_validation && ldap_identity_source_id.nil?
        fail ArgumentError, "Missing the required parameter 'ldap_identity_source_id' when calling SystemAdministrationApi.create_or_update_ldap_identity_source"
      end
      # verify the required parameter 'ldap_identity_source' is set
      if @api_client.config.client_side_validation && ldap_identity_source.nil?
        fail ArgumentError, "Missing the required parameter 'ldap_identity_source' when calling SystemAdministrationApi.create_or_update_ldap_identity_source"
      end
      # resource path
      local_var_path = '/aaa/ldap-identity-sources/{ldap-identity-source-id}'.sub('{' + 'ldap-identity-source-id' + '}', ldap_identity_source_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(ldap_identity_source)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LdapIdentitySource')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#create_or_update_ldap_identity_source\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a Hostswitch Profile
    # Create or update a hostswitch profile. The resource_type is required and needs to be one of the following, UplinkHostSwitchProfile, LldpHostSwitchProfile, NiocProfile & ExtraConfigHostSwitchProfile. Uplink profile - For uplink profiles, the teaming and policy parameters are required. By default, the mtu is 1600 and the transport_vlan is 0. The supported MTU range is 1280 through (uplink_mtu_threshold). uplink_mtu_threshold is 9000 by default. Range can be extended by modifying (uplink_mtu_threshold) in SwitchingGlobalConfig to the required upper threshold. Teaming defined in this profile allows NSX to load balance traffic across different physical NICs (PNICs) on the hypervisor hosts. Multiple teaming policies are supported, including LACP active, LACP passive, load balancing based on source ID, and failover order. Lldp profile - Activate or deactivate sending LLDP packets NiocProfile - Network I/O Control settings: defines limits, shares and reservations for various host traffic types. ExtraConfig - Vendor specific configuration on HostSwitch, logical switch or logical port 
    # @param host_switch_profile_id 
    # @param policy_base_host_switch_profile 
    # @param [Hash] opts the optional parameters
    # @return [PolicyBaseHostSwitchProfile]
    def create_or_update_policy_host_switch_profile(host_switch_profile_id, policy_base_host_switch_profile, opts = {})
      data, _status_code, _headers = create_or_update_policy_host_switch_profile_with_http_info(host_switch_profile_id, policy_base_host_switch_profile, opts)
      data
    end

    # Create or update a Hostswitch Profile
    # Create or update a hostswitch profile. The resource_type is required and needs to be one of the following, UplinkHostSwitchProfile, LldpHostSwitchProfile, NiocProfile &amp; ExtraConfigHostSwitchProfile. Uplink profile - For uplink profiles, the teaming and policy parameters are required. By default, the mtu is 1600 and the transport_vlan is 0. The supported MTU range is 1280 through (uplink_mtu_threshold). uplink_mtu_threshold is 9000 by default. Range can be extended by modifying (uplink_mtu_threshold) in SwitchingGlobalConfig to the required upper threshold. Teaming defined in this profile allows NSX to load balance traffic across different physical NICs (PNICs) on the hypervisor hosts. Multiple teaming policies are supported, including LACP active, LACP passive, load balancing based on source ID, and failover order. Lldp profile - Activate or deactivate sending LLDP packets NiocProfile - Network I/O Control settings: defines limits, shares and reservations for various host traffic types. ExtraConfig - Vendor specific configuration on HostSwitch, logical switch or logical port 
    # @param host_switch_profile_id 
    # @param policy_base_host_switch_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PolicyBaseHostSwitchProfile, Fixnum, Hash)>] PolicyBaseHostSwitchProfile data, response status code and response headers
    def create_or_update_policy_host_switch_profile_with_http_info(host_switch_profile_id, policy_base_host_switch_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.create_or_update_policy_host_switch_profile ...'
      end
      # verify the required parameter 'host_switch_profile_id' is set
      if @api_client.config.client_side_validation && host_switch_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_switch_profile_id' when calling SystemAdministrationApi.create_or_update_policy_host_switch_profile"
      end
      # verify the required parameter 'policy_base_host_switch_profile' is set
      if @api_client.config.client_side_validation && policy_base_host_switch_profile.nil?
        fail ArgumentError, "Missing the required parameter 'policy_base_host_switch_profile' when calling SystemAdministrationApi.create_or_update_policy_host_switch_profile"
      end
      # resource path
      local_var_path = '/infra/host-switch-profiles/{host-switch-profile-id}'.sub('{' + 'host-switch-profile-id' + '}', host_switch_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(policy_base_host_switch_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyBaseHostSwitchProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#create_or_update_policy_host_switch_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update a Host Transport Node Profile
    # Host transport node profile captures the configuration needed to create a host transport node. A host transport node profile can be attached to compute collections for automatic host transport node creation of member hosts.  When configurations of a host transport node profile(TNP) are updated, all the host transport nodes in all the compute collections to which this TNP is attached are updated to reflect the updated configuration. 
    # @param transport_node_profile_id 
    # @param policy_host_transport_node_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override_nsx_ownership Override NSX Ownership (default to false)
    # @return [PolicyHostTransportNodeProfile]
    def create_or_update_policy_host_transport_node_profile(transport_node_profile_id, policy_host_transport_node_profile, opts = {})
      data, _status_code, _headers = create_or_update_policy_host_transport_node_profile_with_http_info(transport_node_profile_id, policy_host_transport_node_profile, opts)
      data
    end

    # Update a Host Transport Node Profile
    # Host transport node profile captures the configuration needed to create a host transport node. A host transport node profile can be attached to compute collections for automatic host transport node creation of member hosts.  When configurations of a host transport node profile(TNP) are updated, all the host transport nodes in all the compute collections to which this TNP is attached are updated to reflect the updated configuration. 
    # @param transport_node_profile_id 
    # @param policy_host_transport_node_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override_nsx_ownership Override NSX Ownership
    # @return [Array<(PolicyHostTransportNodeProfile, Fixnum, Hash)>] PolicyHostTransportNodeProfile data, response status code and response headers
    def create_or_update_policy_host_transport_node_profile_with_http_info(transport_node_profile_id, policy_host_transport_node_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.create_or_update_policy_host_transport_node_profile ...'
      end
      # verify the required parameter 'transport_node_profile_id' is set
      if @api_client.config.client_side_validation && transport_node_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_profile_id' when calling SystemAdministrationApi.create_or_update_policy_host_transport_node_profile"
      end
      # verify the required parameter 'policy_host_transport_node_profile' is set
      if @api_client.config.client_side_validation && policy_host_transport_node_profile.nil?
        fail ArgumentError, "Missing the required parameter 'policy_host_transport_node_profile' when calling SystemAdministrationApi.create_or_update_policy_host_transport_node_profile"
      end
      # resource path
      local_var_path = '/infra/host-transport-node-profiles/{transport-node-profile-id}'.sub('{' + 'transport-node-profile-id' + '}', transport_node_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override_nsx_ownership'] = opts[:'override_nsx_ownership'] if !opts[:'override_nsx_ownership'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(policy_host_transport_node_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyHostTransportNodeProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#create_or_update_policy_host_transport_node_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update custom role
    # Creates a new role with id as &lt;role&gt; if there does not exist any role with id &lt;role&gt;, else updates the existing role. Permissions for features marked is_internal as true will be ignored if provided in request payload. These features' permission are set internally. 
    # @param role Custom role id
    # @param role_with_features 
    # @param [Hash] opts the optional parameters
    # @return [RoleWithFeatures]
    def create_or_update_role(role, role_with_features, opts = {})
      data, _status_code, _headers = create_or_update_role_with_http_info(role, role_with_features, opts)
      data
    end

    # Update custom role
    # Creates a new role with id as &amp;lt;role&amp;gt; if there does not exist any role with id &amp;lt;role&amp;gt;, else updates the existing role. Permissions for features marked is_internal as true will be ignored if provided in request payload. These features&#39; permission are set internally. 
    # @param role Custom role id
    # @param role_with_features 
    # @param [Hash] opts the optional parameters
    # @return [Array<(RoleWithFeatures, Fixnum, Hash)>] RoleWithFeatures data, response status code and response headers
    def create_or_update_role_with_http_info(role, role_with_features, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.create_or_update_role ...'
      end
      # verify the required parameter 'role' is set
      if @api_client.config.client_side_validation && role.nil?
        fail ArgumentError, "Missing the required parameter 'role' when calling SystemAdministrationApi.create_or_update_role"
      end
      # verify the required parameter 'role_with_features' is set
      if @api_client.config.client_side_validation && role_with_features.nil?
        fail ArgumentError, "Missing the required parameter 'role_with_features' when calling SystemAdministrationApi.create_or_update_role"
      end
      # resource path
      local_var_path = '/aaa/roles/{role}'.sub('{' + 'role' + '}', role.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(role_with_features)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoleWithFeatures')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#create_or_update_role\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Assign roles to User or Group
    # This API is used to assign a user/group any role(s) of choice on CSP. It is recommended to use the new property roles_for_paths instead of roles. When using the roles_for_paths, set the read_roles_for_paths as true. User has union of all the roles assigned to it on a particular path and its sub-tree. User name is dealt case-insensitively. 
    # @param org_id 
    # @param project_id 
    # @param role_binding 
    # @param [Hash] opts the optional parameters
    # @return [RoleBinding]
    def create_or_update_role_binding_multitenancy_project(org_id, project_id, role_binding, opts = {})
      data, _status_code, _headers = create_or_update_role_binding_multitenancy_project_with_http_info(org_id, project_id, role_binding, opts)
      data
    end

    # Assign roles to User or Group
    # This API is used to assign a user/group any role(s) of choice on CSP. It is recommended to use the new property roles_for_paths instead of roles. When using the roles_for_paths, set the read_roles_for_paths as true. User has union of all the roles assigned to it on a particular path and its sub-tree. User name is dealt case-insensitively. 
    # @param org_id 
    # @param project_id 
    # @param role_binding 
    # @param [Hash] opts the optional parameters
    # @return [Array<(RoleBinding, Fixnum, Hash)>] RoleBinding data, response status code and response headers
    def create_or_update_role_binding_multitenancy_project_with_http_info(org_id, project_id, role_binding, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.create_or_update_role_binding_multitenancy_project ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SystemAdministrationApi.create_or_update_role_binding_multitenancy_project"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SystemAdministrationApi.create_or_update_role_binding_multitenancy_project"
      end
      # verify the required parameter 'role_binding' is set
      if @api_client.config.client_side_validation && role_binding.nil?
        fail ArgumentError, "Missing the required parameter 'role_binding' when calling SystemAdministrationApi.create_or_update_role_binding_multitenancy_project"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/aaa/role-bindings'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(role_binding)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoleBinding')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#create_or_update_role_binding_multitenancy_project\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Assign roles to User or Group
    # This API is used to assign a user/group any role(s) of choice on CSP. It is recommended to use the new property roles_for_paths instead of roles. When using the roles_for_paths, set the read_roles_for_paths as true. User has union of all the roles assigned to it on a particular path and its sub-tree. User name is dealt case-insensitively. 
    # @param org_id 
    # @param project_id 
    # @param vpc_id 
    # @param role_binding 
    # @param [Hash] opts the optional parameters
    # @return [RoleBinding]
    def create_or_update_role_binding_multitenancy_vpc(org_id, project_id, vpc_id, role_binding, opts = {})
      data, _status_code, _headers = create_or_update_role_binding_multitenancy_vpc_with_http_info(org_id, project_id, vpc_id, role_binding, opts)
      data
    end

    # Assign roles to User or Group
    # This API is used to assign a user/group any role(s) of choice on CSP. It is recommended to use the new property roles_for_paths instead of roles. When using the roles_for_paths, set the read_roles_for_paths as true. User has union of all the roles assigned to it on a particular path and its sub-tree. User name is dealt case-insensitively. 
    # @param org_id 
    # @param project_id 
    # @param vpc_id 
    # @param role_binding 
    # @param [Hash] opts the optional parameters
    # @return [Array<(RoleBinding, Fixnum, Hash)>] RoleBinding data, response status code and response headers
    def create_or_update_role_binding_multitenancy_vpc_with_http_info(org_id, project_id, vpc_id, role_binding, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.create_or_update_role_binding_multitenancy_vpc ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SystemAdministrationApi.create_or_update_role_binding_multitenancy_vpc"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SystemAdministrationApi.create_or_update_role_binding_multitenancy_vpc"
      end
      # verify the required parameter 'vpc_id' is set
      if @api_client.config.client_side_validation && vpc_id.nil?
        fail ArgumentError, "Missing the required parameter 'vpc_id' when calling SystemAdministrationApi.create_or_update_role_binding_multitenancy_vpc"
      end
      # verify the required parameter 'role_binding' is set
      if @api_client.config.client_side_validation && role_binding.nil?
        fail ArgumentError, "Missing the required parameter 'role_binding' when calling SystemAdministrationApi.create_or_update_role_binding_multitenancy_vpc"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/vpcs/{vpc-id}/aaa/role-bindings'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'vpc-id' + '}', vpc_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(role_binding)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoleBinding')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#create_or_update_role_binding_multitenancy_vpc\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or Update a sub-cluster
    # Create or update a sub-cluster under a compute collection. Maximum number of sub-clusters that can be created under a compute collection is 16. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param subcluster_id 
    # @param sub_cluster 
    # @param [Hash] opts the optional parameters
    # @return [SubCluster]
    def create_or_update_sub_cluster(site_id, enforcementpoint_id, subcluster_id, sub_cluster, opts = {})
      data, _status_code, _headers = create_or_update_sub_cluster_with_http_info(site_id, enforcementpoint_id, subcluster_id, sub_cluster, opts)
      data
    end

    # Create or Update a sub-cluster
    # Create or update a sub-cluster under a compute collection. Maximum number of sub-clusters that can be created under a compute collection is 16. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param subcluster_id 
    # @param sub_cluster 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SubCluster, Fixnum, Hash)>] SubCluster data, response status code and response headers
    def create_or_update_sub_cluster_with_http_info(site_id, enforcementpoint_id, subcluster_id, sub_cluster, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.create_or_update_sub_cluster ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.create_or_update_sub_cluster"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.create_or_update_sub_cluster"
      end
      # verify the required parameter 'subcluster_id' is set
      if @api_client.config.client_side_validation && subcluster_id.nil?
        fail ArgumentError, "Missing the required parameter 'subcluster_id' when calling SystemAdministrationApi.create_or_update_sub_cluster"
      end
      # verify the required parameter 'sub_cluster' is set
      if @api_client.config.client_side_validation && sub_cluster.nil?
        fail ArgumentError, "Missing the required parameter 'sub_cluster' when calling SystemAdministrationApi.create_or_update_sub_cluster"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/sub-clusters/{subcluster-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'subcluster-id' + '}', subcluster_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(sub_cluster)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SubCluster')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#create_or_update_sub_cluster\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create registration access token
    # The privileges of the registration token will be the same as the caller.
    # @param [Hash] opts the optional parameters
    # @return [RegistrationToken]
    def create_registration_token(opts = {})
      data, _status_code, _headers = create_registration_token_with_http_info(opts)
      data
    end

    # Create registration access token
    # The privileges of the registration token will be the same as the caller.
    # @param [Hash] opts the optional parameters
    # @return [Array<(RegistrationToken, Fixnum, Hash)>] RegistrationToken data, response status code and response headers
    def create_registration_token_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.create_registration_token ...'
      end
      # resource path
      local_var_path = '/aaa/registration-token'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RegistrationToken')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#create_registration_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Assign roles to User or Group
    # This API is used to assign a user/group any role(s) of choice. It is recommended to use the new property roles_for_paths instead of roles. When using the roles_for_paths, set the read_roles_for_paths as true. User has union of all the roles assigned to it on a particular path and its sub-tree. User name is dealt case-insensitively. 
    # @param role_binding 
    # @param [Hash] opts the optional parameters
    # @return [RoleBinding]
    def create_role_binding(role_binding, opts = {})
      data, _status_code, _headers = create_role_binding_with_http_info(role_binding, opts)
      data
    end

    # Assign roles to User or Group
    # This API is used to assign a user/group any role(s) of choice. It is recommended to use the new property roles_for_paths instead of roles. When using the roles_for_paths, set the read_roles_for_paths as true. User has union of all the roles assigned to it on a particular path and its sub-tree. User name is dealt case-insensitively. 
    # @param role_binding 
    # @param [Hash] opts the optional parameters
    # @return [Array<(RoleBinding, Fixnum, Hash)>] RoleBinding data, response status code and response headers
    def create_role_binding_with_http_info(role_binding, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.create_role_binding ...'
      end
      # verify the required parameter 'role_binding' is set
      if @api_client.config.client_side_validation && role_binding.nil?
        fail ArgumentError, "Missing the required parameter 'role_binding' when calling SystemAdministrationApi.create_role_binding"
      end
      # resource path
      local_var_path = '/aaa/role-bindings'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(role_binding)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoleBinding')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#create_role_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create sensor registration access token
    # The privileges of the registration token will be user with sensor role.
    # @param [Hash] opts the optional parameters
    # @return [RegistrationToken]
    def create_sensor_registration_token(opts = {})
      data, _status_code, _headers = create_sensor_registration_token_with_http_info(opts)
      data
    end

    # Create sensor registration access token
    # The privileges of the registration token will be user with sensor role.
    # @param [Hash] opts the optional parameters
    # @return [Array<(RegistrationToken, Fixnum, Hash)>] RegistrationToken data, response status code and response headers
    def create_sensor_registration_token_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.create_sensor_registration_token ...'
      end
      # resource path
      local_var_path = '/security/sensor-registration-token'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RegistrationToken')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#create_sensor_registration_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Creates a new View.
    # Creates a new View. <br> This API is deprecated and will be unavailable in later releases.
    # @param view 
    # @param [Hash] opts the optional parameters
    # @return [View]
    def create_view(view, opts = {})
      data, _status_code, _headers = create_view_with_http_info(view, opts)
      data
    end

    # Creates a new View.
    # Creates a new View. &lt;br&gt; This API is deprecated and will be unavailable in later releases.
    # @param view 
    # @param [Hash] opts the optional parameters
    # @return [Array<(View, Fixnum, Hash)>] View data, response status code and response headers
    def create_view_with_http_info(view, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.create_view ...'
      end
      # verify the required parameter 'view' is set
      if @api_client.config.client_side_validation && view.nil?
        fail ArgumentError, "Missing the required parameter 'view' when calling SystemAdministrationApi.create_view"
      end
      # resource path
      local_var_path = '/ui-views'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(view)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'View')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#create_view\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Creates a new Widget Configuration.
    # Creates a new Widget Configuration and adds it to the specified view. Supported resource_types are LabelValueConfiguration, DonutConfiguration, GridConfiguration, StatsConfiguration, MultiWidgetConfiguration, GraphConfiguration and ContainerConfiguration.  Note: Expressions should be given in a single line. If an expression spans   multiple lines, then form the expression in a single line. For label-value pairs, expressions are evaluated as follows:   a. First, render configurations are evaluated in their order of      appearance in the widget config. The 'field' is evaluated at the end.   b. Second, when render configuration is provided then the order of      evaluation is      1. If expressions provided in 'condition' and 'display value' are         well-formed and free of runtime-errors such as 'null pointers' and         evaluates to 'true'; Then remaining render configurations are not         evaluated, and the current render configuration's 'display value'         is taken as the final value.      2. If expression provided in 'condition' of render configuration is         false, then next render configuration is evaluated.      3. Finally, 'field' is evaluated only when every render configuration         evaluates to false and no error occurs during steps 1 and 2 above.  If an error occurs during evaluation of render configuration, then an   error message is shown. The display value corresponding to that label is   not shown and evaluation of the remaining render configurations continues   to collect and show all the error messages (marked with the 'Label' for   identification) as 'Error_Messages: {}'.  If during evaluation of expressions for any label-value pair an error   occurs, then it is marked with error. The errors are shown in the report,   along with the label value pairs that are error-free.  Important: For elements that take expressions, strings should be provided   by escaping them with a back-slash. These elements are - condition, field,   tooltip text and render_configuration's display_value.  <br> This API is deprecated and will be unavailable in later releases.
    # @param view_id 
    # @param widget_configuration 
    # @param [Hash] opts the optional parameters
    # @return [WidgetConfiguration]
    def create_widget_configuration(view_id, widget_configuration, opts = {})
      data, _status_code, _headers = create_widget_configuration_with_http_info(view_id, widget_configuration, opts)
      data
    end

    # Creates a new Widget Configuration.
    # Creates a new Widget Configuration and adds it to the specified view. Supported resource_types are LabelValueConfiguration, DonutConfiguration, GridConfiguration, StatsConfiguration, MultiWidgetConfiguration, GraphConfiguration and ContainerConfiguration.  Note: Expressions should be given in a single line. If an expression spans   multiple lines, then form the expression in a single line. For label-value pairs, expressions are evaluated as follows:   a. First, render configurations are evaluated in their order of      appearance in the widget config. The &#39;field&#39; is evaluated at the end.   b. Second, when render configuration is provided then the order of      evaluation is      1. If expressions provided in &#39;condition&#39; and &#39;display value&#39; are         well-formed and free of runtime-errors such as &#39;null pointers&#39; and         evaluates to &#39;true&#39;; Then remaining render configurations are not         evaluated, and the current render configuration&#39;s &#39;display value&#39;         is taken as the final value.      2. If expression provided in &#39;condition&#39; of render configuration is         false, then next render configuration is evaluated.      3. Finally, &#39;field&#39; is evaluated only when every render configuration         evaluates to false and no error occurs during steps 1 and 2 above.  If an error occurs during evaluation of render configuration, then an   error message is shown. The display value corresponding to that label is   not shown and evaluation of the remaining render configurations continues   to collect and show all the error messages (marked with the &#39;Label&#39; for   identification) as &#39;Error_Messages: {}&#39;.  If during evaluation of expressions for any label-value pair an error   occurs, then it is marked with error. The errors are shown in the report,   along with the label value pairs that are error-free.  Important: For elements that take expressions, strings should be provided   by escaping them with a back-slash. These elements are - condition, field,   tooltip text and render_configuration&#39;s display_value.  &lt;br&gt; This API is deprecated and will be unavailable in later releases.
    # @param view_id 
    # @param widget_configuration 
    # @param [Hash] opts the optional parameters
    # @return [Array<(WidgetConfiguration, Fixnum, Hash)>] WidgetConfiguration data, response status code and response headers
    def create_widget_configuration_with_http_info(view_id, widget_configuration, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.create_widget_configuration ...'
      end
      # verify the required parameter 'view_id' is set
      if @api_client.config.client_side_validation && view_id.nil?
        fail ArgumentError, "Missing the required parameter 'view_id' when calling SystemAdministrationApi.create_widget_configuration"
      end
      # verify the required parameter 'widget_configuration' is set
      if @api_client.config.client_side_validation && widget_configuration.nil?
        fail ArgumentError, "Missing the required parameter 'widget_configuration' when calling SystemAdministrationApi.create_widget_configuration"
      end
      # resource path
      local_var_path = '/ui-views/{view-id}/widgetconfigurations'.sub('{' + 'view-id' + '}', view_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(widget_configuration)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'WidgetConfiguration')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#create_widget_configuration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete View
    # Delete View <br> This API is deprecated and will be unavailable in later releases.
    # @param view_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delet_view(view_id, opts = {})
      delet_view_with_http_info(view_id, opts)
      nil
    end

    # Delete View
    # Delete View &lt;br&gt; This API is deprecated and will be unavailable in later releases.
    # @param view_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delet_view_with_http_info(view_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delet_view ...'
      end
      # verify the required parameter 'view_id' is set
      if @api_client.config.client_side_validation && view_id.nil?
        fail ArgumentError, "Missing the required parameter 'view_id' when calling SystemAdministrationApi.delet_view"
      end
      # resource path
      local_var_path = '/ui-views/{view-id}'.sub('{' + 'view-id' + '}', view_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delet_view\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete the cluster configuration for the Avi Load Balancer Controller cluster configuration. If Avi Load Balancer Controllers are present delete will fail.
    # Delete the cluster configuration for Avi Load Balancer Controller cluster. This API is for VCF deployments only. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @return [nil]
    def delete_alb_controller_node_cluster_config(opts = {})
      delete_alb_controller_node_cluster_config_with_http_info(opts)
      nil
    end

    # Delete the cluster configuration for the Avi Load Balancer Controller cluster configuration. If Avi Load Balancer Controllers are present delete will fail.
    # Delete the cluster configuration for Avi Load Balancer Controller cluster. This API is for VCF deployments only. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_alb_controller_node_cluster_config_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delete_alb_controller_node_cluster_config ...'
      end
      # resource path
      local_var_path = '/alb/controller-nodes/clusterconfig'

      # query parameters
      query_params = {}
      query_params[:'clustering_id'] = opts[:'clustering_id'] if !opts[:'clustering_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delete_alb_controller_node_cluster_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Avi EnforcementPoint and the Infra Admin credentials contained by this workflow.
    # Delete Avi EnforcementPoint along with Infra Admin credentials. 
    # @param managed_by On Boarding flow managed by LCM/VCF.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_alb_on_boarding_workflow(managed_by, opts = {})
      delete_alb_on_boarding_workflow_with_http_info(managed_by, opts)
      nil
    end

    # Delete Avi EnforcementPoint and the Infra Admin credentials contained by this workflow.
    # Delete Avi EnforcementPoint along with Infra Admin credentials. 
    # @param managed_by On Boarding flow managed by LCM/VCF.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_alb_on_boarding_workflow_with_http_info(managed_by, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delete_alb_on_boarding_workflow ...'
      end
      # verify the required parameter 'managed_by' is set
      if @api_client.config.client_side_validation && managed_by.nil?
        fail ArgumentError, "Missing the required parameter 'managed_by' when calling SystemAdministrationApi.delete_alb_on_boarding_workflow"
      end
      # resource path
      local_var_path = '/infra/alb-onboarding-workflow/{managed-by}'.sub('{' + 'managed-by' + '}', managed_by.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delete_alb_on_boarding_workflow\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete user credential from Avi Load Balancer Controller cluster.
    # Use this API to delete user credentials in Avi Load Balancer Controller cluster. This API is for VCF deployments only. 
    # @param username Credentials to be deleted.
    # @param user_credential_type Type of user credential
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @return [nil]
    def delete_alb_user_credential_object(username, user_credential_type, opts = {})
      delete_alb_user_credential_object_with_http_info(username, user_credential_type, opts)
      nil
    end

    # Delete user credential from Avi Load Balancer Controller cluster.
    # Use this API to delete user credentials in Avi Load Balancer Controller cluster. This API is for VCF deployments only. 
    # @param username Credentials to be deleted.
    # @param user_credential_type Type of user credential
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_alb_user_credential_object_with_http_info(username, user_credential_type, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delete_alb_user_credential_object ...'
      end
      # verify the required parameter 'username' is set
      if @api_client.config.client_side_validation && username.nil?
        fail ArgumentError, "Missing the required parameter 'username' when calling SystemAdministrationApi.delete_alb_user_credential_object"
      end
      # verify the required parameter 'user_credential_type' is set
      if @api_client.config.client_side_validation && user_credential_type.nil?
        fail ArgumentError, "Missing the required parameter 'user_credential_type' when calling SystemAdministrationApi.delete_alb_user_credential_object"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['VCENTER_SERVICE_USER_CREDENTIAL', 'NSX_SERVICE_USER_CREDENTIAL'].include?(user_credential_type)
        fail ArgumentError, "invalid value for 'user_credential_type', must be one of VCENTER_SERVICE_USER_CREDENTIAL, NSX_SERVICE_USER_CREDENTIAL"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/user-credential/{username}'.sub('{' + 'username' + '}', username.to_s)

      # query parameters
      query_params = {}
      query_params[:'user_credential_type'] = user_credential_type
      query_params[:'clustering_id'] = opts[:'clustering_id'] if !opts[:'clustering_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delete_alb_user_credential_object\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete all stale role assignments
    # Delete all stale role assignments
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :identity_source_id Identity source ID
    # @option opts [String] :identity_source_type Identity source type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :name User/Group name
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :path Exact path of the context
    # @option opts [String] :role Role ID
    # @option opts [String] :root_path Prefix path of the context
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type
    # @return [nil]
    def delete_all_stale_role_bindings(opts = {})
      delete_all_stale_role_bindings_with_http_info(opts)
      nil
    end

    # Delete all stale role assignments
    # Delete all stale role assignments
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :identity_source_id Identity source ID
    # @option opts [String] :identity_source_type Identity source type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :name User/Group name
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :path Exact path of the context
    # @option opts [String] :role Role ID
    # @option opts [String] :root_path Prefix path of the context
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_all_stale_role_bindings_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delete_all_stale_role_bindings ...'
      end
      if @api_client.config.client_side_validation && opts[:'identity_source_type'] && !['VIDM', 'LDAP', 'OIDC'].include?(opts[:'identity_source_type'])
        fail ArgumentError, 'invalid value for "identity_source_type", must be one of VIDM, LDAP, OIDC'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.delete_all_stale_role_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.delete_all_stale_role_bindings, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['remote_user', 'remote_group', 'local_user', 'principal_identity'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of remote_user, remote_group, local_user, principal_identity'
      end
      # resource path
      local_var_path = '/aaa/role-bindings?action=delete_stale_bindings'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'identity_source_id'] = opts[:'identity_source_id'] if !opts[:'identity_source_id'].nil?
      query_params[:'identity_source_type'] = opts[:'identity_source_type'] if !opts[:'identity_source_type'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'path'] = opts[:'path'] if !opts[:'path'].nil?
      query_params[:'role'] = opts[:'role'] if !opts[:'role'].nil?
      query_params[:'root_path'] = opts[:'root_path'] if !opts[:'root_path'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delete_all_stale_role_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Attempt to delete an auto-deployed Avi Load Balancer Controller node
    # Attempts to unregister and undeploy a specified auto-deployed cluster node. If it is a member of a cluster, then the node will be automatically detached from the cluster before being unregistered and undeployed. Alternatively, if the original deployment attempt failed or the node is not found, cleans up the deployment information associated with the deployment attempt. Note: If a node has been successfully auto-deployed, then the associated deployment information will not be deleted unless and until the node is successfully deleted. 
    # @param node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :force_delete Delete by force
    # @option opts [String] :inaccessible Delete when controller is inaccessible
    # @return [nil]
    def delete_auto_deployed_alb_controller_node_vm(node_id, opts = {})
      delete_auto_deployed_alb_controller_node_vm_with_http_info(node_id, opts)
      nil
    end

    # Attempt to delete an auto-deployed Avi Load Balancer Controller node
    # Attempts to unregister and undeploy a specified auto-deployed cluster node. If it is a member of a cluster, then the node will be automatically detached from the cluster before being unregistered and undeployed. Alternatively, if the original deployment attempt failed or the node is not found, cleans up the deployment information associated with the deployment attempt. Note: If a node has been successfully auto-deployed, then the associated deployment information will not be deleted unless and until the node is successfully deleted. 
    # @param node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :force_delete Delete by force
    # @option opts [String] :inaccessible Delete when controller is inaccessible
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_auto_deployed_alb_controller_node_vm_with_http_info(node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delete_auto_deployed_alb_controller_node_vm ...'
      end
      # verify the required parameter 'node_id' is set
      if @api_client.config.client_side_validation && node_id.nil?
        fail ArgumentError, "Missing the required parameter 'node_id' when calling SystemAdministrationApi.delete_auto_deployed_alb_controller_node_vm"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/deployments/{node-id}?action=delete'.sub('{' + 'node-id' + '}', node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'force_delete'] = opts[:'force_delete'] if !opts[:'force_delete'].nil?
      query_params[:'inaccessible'] = opts[:'inaccessible'] if !opts[:'inaccessible'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delete_auto_deployed_alb_controller_node_vm\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a Cluster Control Plane Node
    # Delete a Cluster Control Plane Node
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :cascade Flag to indicate if force delete cluster references from the firewall security policies. (default to false)
    # @return [nil]
    def delete_cluster_control_plane(site_id, enforcementpoint_id, cluster_control_plane_id, opts = {})
      delete_cluster_control_plane_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, opts)
      nil
    end

    # Delete a Cluster Control Plane Node
    # Delete a Cluster Control Plane Node
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :cascade Flag to indicate if force delete cluster references from the firewall security policies.
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_cluster_control_plane_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delete_cluster_control_plane ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.delete_cluster_control_plane"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.delete_cluster_control_plane"
      end
      # verify the required parameter 'cluster_control_plane_id' is set
      if @api_client.config.client_side_validation && cluster_control_plane_id.nil?
        fail ArgumentError, "Missing the required parameter 'cluster_control_plane_id' when calling SystemAdministrationApi.delete_cluster_control_plane"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/cluster-control-planes/{cluster-control-plane-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'cluster-control-plane-id' + '}', cluster_control_plane_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cascade'] = opts[:'cascade'] if !opts[:'cascade'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delete_cluster_control_plane\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete deployment information.
    # This is an API called by VCF to delete deployment information. 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_deployment_info(opts = {})
      delete_deployment_info_with_http_info(opts)
      nil
    end

    # Delete deployment information.
    # This is an API called by VCF to delete deployment information. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_deployment_info_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delete_deployment_info ...'
      end
      # resource path
      local_var_path = '/watermark'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delete_deployment_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a Transport Node
    # Deletes the specified transport node. Query param force can be used to force delete the host nodes. Force delete is not supported if transport node is part of a cluster on which Transport node profile is applied.  It also removes the specified host node from system. If unprepare_host option is set to false, then host will be deleted without uninstalling the NSX components from the host. If transport node delete is called with query param force not being set or set to false and uninstall of NSX components in the host fails, TransportNodeState object will be retained. If transport node delete is called with query param force set to true and uninstall of NSX components in the host fails, TransportNodeState object will be deleted. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :force Force delete the resource even if it is being used somewhere  (default to false)
    # @option opts [BOOLEAN] :unprepare_host Uninstall NSX components from host while deleting (default to true)
    # @return [nil]
    def delete_host_transport_node(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      delete_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      nil
    end

    # Delete a Transport Node
    # Deletes the specified transport node. Query param force can be used to force delete the host nodes. Force delete is not supported if transport node is part of a cluster on which Transport node profile is applied.  It also removes the specified host node from system. If unprepare_host option is set to false, then host will be deleted without uninstalling the NSX components from the host. If transport node delete is called with query param force not being set or set to false and uninstall of NSX components in the host fails, TransportNodeState object will be retained. If transport node delete is called with query param force set to true and uninstall of NSX components in the host fails, TransportNodeState object will be deleted. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :force Force delete the resource even if it is being used somewhere 
    # @option opts [BOOLEAN] :unprepare_host Uninstall NSX components from host while deleting
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delete_host_transport_node ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.delete_host_transport_node"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.delete_host_transport_node"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling SystemAdministrationApi.delete_host_transport_node"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'force'] = opts[:'force'] if !opts[:'force'].nil?
      query_params[:'unprepare_host'] = opts[:'unprepare_host'] if !opts[:'unprepare_host'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delete_host_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Detach transport node profile from compute collection.
    # By deleting transport node collection, we are detaching the transport node profile(TNP) from the compute collection. It has no effect on existing transport nodes. However, new hosts added to the compute collection will no longer be automatically converted to NSX transport node. Detaching TNP from compute collection does not delete TNP. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_host_transport_node_collection(site_id, enforcementpoint_id, transport_node_collection_id, opts = {})
      delete_host_transport_node_collection_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, opts)
      nil
    end

    # Detach transport node profile from compute collection.
    # By deleting transport node collection, we are detaching the transport node profile(TNP) from the compute collection. It has no effect on existing transport nodes. However, new hosts added to the compute collection will no longer be automatically converted to NSX transport node. Detaching TNP from compute collection does not delete TNP. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_host_transport_node_collection_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delete_host_transport_node_collection ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.delete_host_transport_node_collection"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.delete_host_transport_node_collection"
      end
      # verify the required parameter 'transport_node_collection_id' is set
      if @api_client.config.client_side_validation && transport_node_collection_id.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_collection_id' when calling SystemAdministrationApi.delete_host_transport_node_collection"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/transport-node-collections/{transport-node-collection-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'transport-node-collection-id' + '}', transport_node_collection_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delete_host_transport_node_collection\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete an LDAP identity source
    # Delete an LDAP identity source. Users defined in that source will no longer be able to access NSX.
    # @param ldap_identity_source_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_ldap_identity_source(ldap_identity_source_id, opts = {})
      delete_ldap_identity_source_with_http_info(ldap_identity_source_id, opts)
      nil
    end

    # Delete an LDAP identity source
    # Delete an LDAP identity source. Users defined in that source will no longer be able to access NSX.
    # @param ldap_identity_source_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_ldap_identity_source_with_http_info(ldap_identity_source_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delete_ldap_identity_source ...'
      end
      # verify the required parameter 'ldap_identity_source_id' is set
      if @api_client.config.client_side_validation && ldap_identity_source_id.nil?
        fail ArgumentError, "Missing the required parameter 'ldap_identity_source_id' when calling SystemAdministrationApi.delete_ldap_identity_source"
      end
      # resource path
      local_var_path = '/aaa/ldap-identity-sources/{ldap-identity-source-id}'.sub('{' + 'ldap-identity-source-id' + '}', ldap_identity_source_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delete_ldap_identity_source\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Remove service deployment
    # Remove the service deployment. This will remove all the Service VMs that were created as part of this deployment on the specified cluster. User can optionally set force delete option which will force remove the deployment, but should be used only when the regular delete is not working. Regular delete will ensure proper cleanup of Service VMs and related objects. Directly calling this API without trying regular undeploy will result in unexpected results, and orphan objects. 
    # @param compute_collection_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :force Force delete the resource even if it is being used somewhere  (default to false)
    # @return [nil]
    def delete_mps_service_deployment(compute_collection_id, opts = {})
      delete_mps_service_deployment_with_http_info(compute_collection_id, opts)
      nil
    end

    # Remove service deployment
    # Remove the service deployment. This will remove all the Service VMs that were created as part of this deployment on the specified cluster. User can optionally set force delete option which will force remove the deployment, but should be used only when the regular delete is not working. Regular delete will ensure proper cleanup of Service VMs and related objects. Directly calling this API without trying regular undeploy will result in unexpected results, and orphan objects. 
    # @param compute_collection_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :force Force delete the resource even if it is being used somewhere 
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_mps_service_deployment_with_http_info(compute_collection_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delete_mps_service_deployment ...'
      end
      # verify the required parameter 'compute_collection_id' is set
      if @api_client.config.client_side_validation && compute_collection_id.nil?
        fail ArgumentError, "Missing the required parameter 'compute_collection_id' when calling SystemAdministrationApi.delete_mps_service_deployment"
      end
      # resource path
      local_var_path = '/malware-prevention/compute-collection/{compute-collection-id}/svm-deployment'.sub('{' + 'compute-collection-id' + '}', compute_collection_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'force'] = opts[:'force'] if !opts[:'force'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delete_mps_service_deployment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete object-permissions entries
    # Delete object-permissions entries
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [BOOLEAN] :inheritance_disabled Does children of this object inherit this rule (default to false)
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :path_prefix Path prefix
    # @option opts [String] :role_name Role name
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [nil]
    def delete_object_permissions(opts = {})
      delete_object_permissions_with_http_info(opts)
      nil
    end

    # Delete object-permissions entries
    # Delete object-permissions entries
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [BOOLEAN] :inheritance_disabled Does children of this object inherit this rule
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :path_prefix Path prefix
    # @option opts [String] :role_name Role name
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_object_permissions_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delete_object_permissions ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.delete_object_permissions, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.delete_object_permissions, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/aaa/object-permissions'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'inheritance_disabled'] = opts[:'inheritance_disabled'] if !opts[:'inheritance_disabled'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'path_prefix'] = opts[:'path_prefix'] if !opts[:'path_prefix'].nil?
      query_params[:'role_name'] = opts[:'role_name'] if !opts[:'role_name'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delete_object_permissions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a Hostswitch Profile
    # Deletes a specified hostswitch profile.
    # @param host_switch_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_policy_host_switch_profile(host_switch_profile_id, opts = {})
      delete_policy_host_switch_profile_with_http_info(host_switch_profile_id, opts)
      nil
    end

    # Delete a Hostswitch Profile
    # Deletes a specified hostswitch profile.
    # @param host_switch_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_policy_host_switch_profile_with_http_info(host_switch_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delete_policy_host_switch_profile ...'
      end
      # verify the required parameter 'host_switch_profile_id' is set
      if @api_client.config.client_side_validation && host_switch_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_switch_profile_id' when calling SystemAdministrationApi.delete_policy_host_switch_profile"
      end
      # resource path
      local_var_path = '/infra/host-switch-profiles/{host-switch-profile-id}'.sub('{' + 'host-switch-profile-id' + '}', host_switch_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delete_policy_host_switch_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a Host Transport Node Profile
    # Deletes the specified host transport node profile. A host transport node profile can be deleted only when it is not attached to any compute collection. 
    # @param transport_node_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_policy_host_transport_node_profile(transport_node_profile_id, opts = {})
      delete_policy_host_transport_node_profile_with_http_info(transport_node_profile_id, opts)
      nil
    end

    # Delete a Host Transport Node Profile
    # Deletes the specified host transport node profile. A host transport node profile can be deleted only when it is not attached to any compute collection. 
    # @param transport_node_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_policy_host_transport_node_profile_with_http_info(transport_node_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delete_policy_host_transport_node_profile ...'
      end
      # verify the required parameter 'transport_node_profile_id' is set
      if @api_client.config.client_side_validation && transport_node_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_profile_id' when calling SystemAdministrationApi.delete_policy_host_transport_node_profile"
      end
      # resource path
      local_var_path = '/infra/host-transport-node-profiles/{transport-node-profile-id}'.sub('{' + 'transport-node-profile-id' + '}', transport_node_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delete_policy_host_transport_node_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete registration access token
    # Delete registration access token <br> Use API POST /api/v1/aaa/registration-token/delete
    # @param token Registration token
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_registration_token(token, opts = {})
      delete_registration_token_with_http_info(token, opts)
      nil
    end

    # Delete registration access token
    # Delete registration access token &lt;br&gt; Use API POST /api/v1/aaa/registration-token/delete
    # @param token Registration token
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_registration_token_with_http_info(token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delete_registration_token ...'
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling SystemAdministrationApi.delete_registration_token"
      end
      # resource path
      local_var_path = '/aaa/registration-token/{token}'.sub('{' + 'token' + '}', token.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delete_registration_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete custom role
    # If a role is assigned to a role binding then the deletion of the role is not allowed. Precanned roles cannot be deleted. 
    # @param role Custom role id
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_role(role, opts = {})
      delete_role_with_http_info(role, opts)
      nil
    end

    # Delete custom role
    # If a role is assigned to a role binding then the deletion of the role is not allowed. Precanned roles cannot be deleted. 
    # @param role Custom role id
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_role_with_http_info(role, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delete_role ...'
      end
      # verify the required parameter 'role' is set
      if @api_client.config.client_side_validation && role.nil?
        fail ArgumentError, "Missing the required parameter 'role' when calling SystemAdministrationApi.delete_role"
      end
      # resource path
      local_var_path = '/aaa/roles/{role}'.sub('{' + 'role' + '}', role.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delete_role\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete user/group's roles assignment
    # Delete the user/group's role assignment. If the path is provided then deletes only the roles_for_paths that matches the path. If path is provided for the last roles_for_paths then the whole role binding is deleted provided it is not that of a local user. For deleting multiple paths, please provide semi-colon ';' separated paths in the request parameter. 
    # @param binding_id User/Group&#39;s id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :identity_source_id Identity source ID
    # @option opts [String] :identity_source_type Identity source type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :name User/Group name
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :path Exact path of the context
    # @option opts [String] :role Role ID
    # @option opts [String] :root_path Prefix path of the context
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type
    # @return [nil]
    def delete_role_binding(binding_id, opts = {})
      delete_role_binding_with_http_info(binding_id, opts)
      nil
    end

    # Delete user/group&#39;s roles assignment
    # Delete the user/group&#39;s role assignment. If the path is provided then deletes only the roles_for_paths that matches the path. If path is provided for the last roles_for_paths then the whole role binding is deleted provided it is not that of a local user. For deleting multiple paths, please provide semi-colon &#39;;&#39; separated paths in the request parameter. 
    # @param binding_id User/Group&#39;s id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :identity_source_id Identity source ID
    # @option opts [String] :identity_source_type Identity source type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :name User/Group name
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :path Exact path of the context
    # @option opts [String] :role Role ID
    # @option opts [String] :root_path Prefix path of the context
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_role_binding_with_http_info(binding_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delete_role_binding ...'
      end
      # verify the required parameter 'binding_id' is set
      if @api_client.config.client_side_validation && binding_id.nil?
        fail ArgumentError, "Missing the required parameter 'binding_id' when calling SystemAdministrationApi.delete_role_binding"
      end
      if @api_client.config.client_side_validation && opts[:'identity_source_type'] && !['VIDM', 'LDAP', 'OIDC'].include?(opts[:'identity_source_type'])
        fail ArgumentError, 'invalid value for "identity_source_type", must be one of VIDM, LDAP, OIDC'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.delete_role_binding, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.delete_role_binding, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['remote_user', 'remote_group', 'local_user', 'principal_identity'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of remote_user, remote_group, local_user, principal_identity'
      end
      # resource path
      local_var_path = '/aaa/role-bindings/{binding-id}'.sub('{' + 'binding-id' + '}', binding_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'identity_source_id'] = opts[:'identity_source_id'] if !opts[:'identity_source_id'].nil?
      query_params[:'identity_source_type'] = opts[:'identity_source_type'] if !opts[:'identity_source_type'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'path'] = opts[:'path'] if !opts[:'path'].nil?
      query_params[:'role'] = opts[:'role'] if !opts[:'role'].nil?
      query_params[:'root_path'] = opts[:'root_path'] if !opts[:'root_path'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delete_role_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete user/group's roles assignment
    # Delete the user/group's role assignment on CSP. If the path is provided then deletes only the roles_for_paths that matches the path. If path is provided for the last roles_for_paths then the whole role binding is deleted provided it is not that of a local user. 
    # @param org_id 
    # @param project_id 
    # @param binding_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :identity_source_id Identity source ID
    # @option opts [String] :identity_source_type Identity source type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :name User/Group name
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :path Exact path of the context
    # @option opts [String] :role Role ID
    # @option opts [String] :root_path Prefix path of the context
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type
    # @return [nil]
    def delete_role_binding_multitenancy_project(org_id, project_id, binding_id, opts = {})
      delete_role_binding_multitenancy_project_with_http_info(org_id, project_id, binding_id, opts)
      nil
    end

    # Delete user/group&#39;s roles assignment
    # Delete the user/group&#39;s role assignment on CSP. If the path is provided then deletes only the roles_for_paths that matches the path. If path is provided for the last roles_for_paths then the whole role binding is deleted provided it is not that of a local user. 
    # @param org_id 
    # @param project_id 
    # @param binding_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :identity_source_id Identity source ID
    # @option opts [String] :identity_source_type Identity source type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :name User/Group name
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :path Exact path of the context
    # @option opts [String] :role Role ID
    # @option opts [String] :root_path Prefix path of the context
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_role_binding_multitenancy_project_with_http_info(org_id, project_id, binding_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delete_role_binding_multitenancy_project ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SystemAdministrationApi.delete_role_binding_multitenancy_project"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SystemAdministrationApi.delete_role_binding_multitenancy_project"
      end
      # verify the required parameter 'binding_id' is set
      if @api_client.config.client_side_validation && binding_id.nil?
        fail ArgumentError, "Missing the required parameter 'binding_id' when calling SystemAdministrationApi.delete_role_binding_multitenancy_project"
      end
      if @api_client.config.client_side_validation && opts[:'identity_source_type'] && !['VIDM', 'LDAP', 'OIDC'].include?(opts[:'identity_source_type'])
        fail ArgumentError, 'invalid value for "identity_source_type", must be one of VIDM, LDAP, OIDC'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.delete_role_binding_multitenancy_project, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.delete_role_binding_multitenancy_project, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['remote_user', 'remote_group', 'local_user', 'principal_identity'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of remote_user, remote_group, local_user, principal_identity'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/aaa/role-bindings/{binding-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'binding-id' + '}', binding_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'identity_source_id'] = opts[:'identity_source_id'] if !opts[:'identity_source_id'].nil?
      query_params[:'identity_source_type'] = opts[:'identity_source_type'] if !opts[:'identity_source_type'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'path'] = opts[:'path'] if !opts[:'path'].nil?
      query_params[:'role'] = opts[:'role'] if !opts[:'role'].nil?
      query_params[:'root_path'] = opts[:'root_path'] if !opts[:'root_path'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delete_role_binding_multitenancy_project\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete user/group's roles assignment
    # Delete the user/group's role assignment on CSP. If the path is provided then deletes only the roles_for_paths that matches the path. If path is provided for the last roles_for_paths then the whole role binding is deleted provided it is not that of a local user. 
    # @param org_id 
    # @param project_id 
    # @param vpc_id 
    # @param binding_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :identity_source_id Identity source ID
    # @option opts [String] :identity_source_type Identity source type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :name User/Group name
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :path Exact path of the context
    # @option opts [String] :role Role ID
    # @option opts [String] :root_path Prefix path of the context
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type
    # @return [nil]
    def delete_role_binding_multitenancy_vpc(org_id, project_id, vpc_id, binding_id, opts = {})
      delete_role_binding_multitenancy_vpc_with_http_info(org_id, project_id, vpc_id, binding_id, opts)
      nil
    end

    # Delete user/group&#39;s roles assignment
    # Delete the user/group&#39;s role assignment on CSP. If the path is provided then deletes only the roles_for_paths that matches the path. If path is provided for the last roles_for_paths then the whole role binding is deleted provided it is not that of a local user. 
    # @param org_id 
    # @param project_id 
    # @param vpc_id 
    # @param binding_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :identity_source_id Identity source ID
    # @option opts [String] :identity_source_type Identity source type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :name User/Group name
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :path Exact path of the context
    # @option opts [String] :role Role ID
    # @option opts [String] :root_path Prefix path of the context
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_role_binding_multitenancy_vpc_with_http_info(org_id, project_id, vpc_id, binding_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delete_role_binding_multitenancy_vpc ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SystemAdministrationApi.delete_role_binding_multitenancy_vpc"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SystemAdministrationApi.delete_role_binding_multitenancy_vpc"
      end
      # verify the required parameter 'vpc_id' is set
      if @api_client.config.client_side_validation && vpc_id.nil?
        fail ArgumentError, "Missing the required parameter 'vpc_id' when calling SystemAdministrationApi.delete_role_binding_multitenancy_vpc"
      end
      # verify the required parameter 'binding_id' is set
      if @api_client.config.client_side_validation && binding_id.nil?
        fail ArgumentError, "Missing the required parameter 'binding_id' when calling SystemAdministrationApi.delete_role_binding_multitenancy_vpc"
      end
      if @api_client.config.client_side_validation && opts[:'identity_source_type'] && !['VIDM', 'LDAP', 'OIDC'].include?(opts[:'identity_source_type'])
        fail ArgumentError, 'invalid value for "identity_source_type", must be one of VIDM, LDAP, OIDC'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.delete_role_binding_multitenancy_vpc, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.delete_role_binding_multitenancy_vpc, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['remote_user', 'remote_group', 'local_user', 'principal_identity'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of remote_user, remote_group, local_user, principal_identity'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/vpcs/{vpc-id}/aaa/role-bindings/{binding-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'vpc-id' + '}', vpc_id.to_s).sub('{' + 'binding-id' + '}', binding_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'identity_source_id'] = opts[:'identity_source_id'] if !opts[:'identity_source_id'].nil?
      query_params[:'identity_source_type'] = opts[:'identity_source_type'] if !opts[:'identity_source_type'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'path'] = opts[:'path'] if !opts[:'path'].nil?
      query_params[:'role'] = opts[:'role'] if !opts[:'role'].nil?
      query_params[:'root_path'] = opts[:'root_path'] if !opts[:'root_path'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delete_role_binding_multitenancy_vpc\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a Sub-Cluster
    # Delete a Sub-Cluster. Deletion will not be allowed if sub-cluster contains discovered nodes. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param subcluster_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_sub_cluster(site_id, enforcementpoint_id, subcluster_id, opts = {})
      delete_sub_cluster_with_http_info(site_id, enforcementpoint_id, subcluster_id, opts)
      nil
    end

    # Delete a Sub-Cluster
    # Delete a Sub-Cluster. Deletion will not be allowed if sub-cluster contains discovered nodes. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param subcluster_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_sub_cluster_with_http_info(site_id, enforcementpoint_id, subcluster_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delete_sub_cluster ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.delete_sub_cluster"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.delete_sub_cluster"
      end
      # verify the required parameter 'subcluster_id' is set
      if @api_client.config.client_side_validation && subcluster_id.nil?
        fail ArgumentError, "Missing the required parameter 'subcluster_id' when calling SystemAdministrationApi.delete_sub_cluster"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/sub-clusters/{subcluster-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'subcluster-id' + '}', subcluster_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delete_sub_cluster\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Widget Configuration
    # Detaches widget from a given view. If the widget is no longer part of any view, then it will be purged.  <br> This API is deprecated and will be unavailable in later releases.
    # @param view_id 
    # @param widgetconfiguration_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_widget_configuration(view_id, widgetconfiguration_id, opts = {})
      delete_widget_configuration_with_http_info(view_id, widgetconfiguration_id, opts)
      nil
    end

    # Delete Widget Configuration
    # Detaches widget from a given view. If the widget is no longer part of any view, then it will be purged.  &lt;br&gt; This API is deprecated and will be unavailable in later releases.
    # @param view_id 
    # @param widgetconfiguration_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_widget_configuration_with_http_info(view_id, widgetconfiguration_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.delete_widget_configuration ...'
      end
      # verify the required parameter 'view_id' is set
      if @api_client.config.client_side_validation && view_id.nil?
        fail ArgumentError, "Missing the required parameter 'view_id' when calling SystemAdministrationApi.delete_widget_configuration"
      end
      # verify the required parameter 'widgetconfiguration_id' is set
      if @api_client.config.client_side_validation && widgetconfiguration_id.nil?
        fail ArgumentError, "Missing the required parameter 'widgetconfiguration_id' when calling SystemAdministrationApi.delete_widget_configuration"
      end
      # resource path
      local_var_path = '/ui-views/{view-id}/widgetconfigurations/{widgetconfiguration-id}'.sub('{' + 'view-id' + '}', view_id.to_s).sub('{' + 'widgetconfiguration-id' + '}', widgetconfiguration_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#delete_widget_configuration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Deploys a the Malware Prevention Service on the specified compute-collection
    # This will deploy the Malware Prevention Service on a given cluster. Internally OVF will be deployed on each host that is part of the cluster. If there are no issues in the parameters, the call returns immediately, and the service VMs will be deployed asynchronously. To get the overall status of the deployment or to get the status of individual service vm, please use the MPS deployment status APIs. 
    # @param compute_collection_id 
    # @param mps_svm_deployment_spec 
    # @param [Hash] opts the optional parameters
    # @return [MpsSvmDeploymentSpec]
    def deploy_mps_service(compute_collection_id, mps_svm_deployment_spec, opts = {})
      data, _status_code, _headers = deploy_mps_service_with_http_info(compute_collection_id, mps_svm_deployment_spec, opts)
      data
    end

    # Deploys a the Malware Prevention Service on the specified compute-collection
    # This will deploy the Malware Prevention Service on a given cluster. Internally OVF will be deployed on each host that is part of the cluster. If there are no issues in the parameters, the call returns immediately, and the service VMs will be deployed asynchronously. To get the overall status of the deployment or to get the status of individual service vm, please use the MPS deployment status APIs. 
    # @param compute_collection_id 
    # @param mps_svm_deployment_spec 
    # @param [Hash] opts the optional parameters
    # @return [Array<(MpsSvmDeploymentSpec, Fixnum, Hash)>] MpsSvmDeploymentSpec data, response status code and response headers
    def deploy_mps_service_with_http_info(compute_collection_id, mps_svm_deployment_spec, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.deploy_mps_service ...'
      end
      # verify the required parameter 'compute_collection_id' is set
      if @api_client.config.client_side_validation && compute_collection_id.nil?
        fail ArgumentError, "Missing the required parameter 'compute_collection_id' when calling SystemAdministrationApi.deploy_mps_service"
      end
      # verify the required parameter 'mps_svm_deployment_spec' is set
      if @api_client.config.client_side_validation && mps_svm_deployment_spec.nil?
        fail ArgumentError, "Missing the required parameter 'mps_svm_deployment_spec' when calling SystemAdministrationApi.deploy_mps_service"
      end
      # resource path
      local_var_path = '/malware-prevention/compute-collection/{compute-collection-id}/svm-deployment'.sub('{' + 'compute-collection-id' + '}', compute_collection_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(mps_svm_deployment_spec)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MpsSvmDeploymentSpec')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#deploy_mps_service\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Synchronize VCF licenses from all registered vCenters 
    # Synchronize VCF licenses from all registered vCenters and update licenses in NSX. This API will not return synchronized VCF licenses and just update them in NSX. 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def deprecated_sync_vcf_licenses(opts = {})
      deprecated_sync_vcf_licenses_with_http_info(opts)
      nil
    end

    # Synchronize VCF licenses from all registered vCenters 
    # Synchronize VCF licenses from all registered vCenters and update licenses in NSX. This API will not return synchronized VCF licenses and just update them in NSX. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def deprecated_sync_vcf_licenses_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.deprecated_sync_vcf_licenses ...'
      end
      # resource path
      local_var_path = '/licenses/vcf-licenses'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#deprecated_sync_vcf_licenses\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Fetch the server certificate of an LDAP server
    # Attempt to connect to an LDAP server and retrieve the server certificate it presents.
    # @param identity_source_ldap_server_endpoint 
    # @param [Hash] opts the optional parameters
    # @return [PeerCertificateChain]
    def fetch_identity_source_ldap_server_certificate(identity_source_ldap_server_endpoint, opts = {})
      data, _status_code, _headers = fetch_identity_source_ldap_server_certificate_with_http_info(identity_source_ldap_server_endpoint, opts)
      data
    end

    # Fetch the server certificate of an LDAP server
    # Attempt to connect to an LDAP server and retrieve the server certificate it presents.
    # @param identity_source_ldap_server_endpoint 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PeerCertificateChain, Fixnum, Hash)>] PeerCertificateChain data, response status code and response headers
    def fetch_identity_source_ldap_server_certificate_with_http_info(identity_source_ldap_server_endpoint, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.fetch_identity_source_ldap_server_certificate ...'
      end
      # verify the required parameter 'identity_source_ldap_server_endpoint' is set
      if @api_client.config.client_side_validation && identity_source_ldap_server_endpoint.nil?
        fail ArgumentError, "Missing the required parameter 'identity_source_ldap_server_endpoint' when calling SystemAdministrationApi.fetch_identity_source_ldap_server_certificate"
      end
      # resource path
      local_var_path = '/aaa/ldap-identity-sources?action=fetch_certificate'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(identity_source_ldap_server_endpoint)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PeerCertificateChain')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#fetch_identity_source_ldap_server_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Auth Token API call to Avi Controller.
    # Passthorugh API calls to Avi controller using the Auth of policy API request send to this API will be passthrough to Avi controller and Avi controller response will be embedded for this API. 
    # @param alb_auth_token 
    # @param [Hash] opts the optional parameters
    # @return [ALBAuthToken]
    def get_alb_auth_token(alb_auth_token, opts = {})
      data, _status_code, _headers = get_alb_auth_token_with_http_info(alb_auth_token, opts)
      data
    end

    # Auth Token API call to Avi Controller.
    # Passthorugh API calls to Avi controller using the Auth of policy API request send to this API will be passthrough to Avi controller and Avi controller response will be embedded for this API. 
    # @param alb_auth_token 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ALBAuthToken, Fixnum, Hash)>] ALBAuthToken data, response status code and response headers
    def get_alb_auth_token_with_http_info(alb_auth_token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_alb_auth_token ...'
      end
      # verify the required parameter 'alb_auth_token' is set
      if @api_client.config.client_side_validation && alb_auth_token.nil?
        fail ArgumentError, "Missing the required parameter 'alb_auth_token' when calling SystemAdministrationApi.get_alb_auth_token"
      end
      # resource path
      local_var_path = '/infra/alb-auth-token'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(alb_auth_token)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBAuthToken')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_alb_auth_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get all users and groups with their roles
    # Get all users and groups with their roles. If the root_path is provided then only return role bindings that start-with or are sub-trees of the provided root path. Also filter the roles_for_paths such that only those roles_for_paths appear that start-with or are sub-tree of the provided root path. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :identity_source_id Identity source ID
    # @option opts [String] :identity_source_type Identity source type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :name User/Group name
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :path Exact path of the context
    # @option opts [String] :role Role ID
    # @option opts [String] :root_path Prefix path of the context
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type
    # @return [RoleBindingListResult]
    def get_all_role_bindings(opts = {})
      data, _status_code, _headers = get_all_role_bindings_with_http_info(opts)
      data
    end

    # Get all users and groups with their roles
    # Get all users and groups with their roles. If the root_path is provided then only return role bindings that start-with or are sub-trees of the provided root path. Also filter the roles_for_paths such that only those roles_for_paths appear that start-with or are sub-tree of the provided root path. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :identity_source_id Identity source ID
    # @option opts [String] :identity_source_type Identity source type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :name User/Group name
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :path Exact path of the context
    # @option opts [String] :role Role ID
    # @option opts [String] :root_path Prefix path of the context
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type
    # @return [Array<(RoleBindingListResult, Fixnum, Hash)>] RoleBindingListResult data, response status code and response headers
    def get_all_role_bindings_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_all_role_bindings ...'
      end
      if @api_client.config.client_side_validation && opts[:'identity_source_type'] && !['VIDM', 'LDAP', 'OIDC'].include?(opts[:'identity_source_type'])
        fail ArgumentError, 'invalid value for "identity_source_type", must be one of VIDM, LDAP, OIDC'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_all_role_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_all_role_bindings, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['remote_user', 'remote_group', 'local_user', 'principal_identity'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of remote_user, remote_group, local_user, principal_identity'
      end
      # resource path
      local_var_path = '/aaa/role-bindings'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'identity_source_id'] = opts[:'identity_source_id'] if !opts[:'identity_source_id'].nil?
      query_params[:'identity_source_type'] = opts[:'identity_source_type'] if !opts[:'identity_source_type'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'path'] = opts[:'path'] if !opts[:'path'].nil?
      query_params[:'role'] = opts[:'role'] if !opts[:'role'].nil?
      query_params[:'root_path'] = opts[:'root_path'] if !opts[:'root_path'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoleBindingListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_all_role_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get information about all roles
    # Get information about all roles
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :scope List only the roles which are applicable for this scope.
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [RoleListResult]
    def get_all_roles_info(opts = {})
      data, _status_code, _headers = get_all_roles_info_with_http_info(opts)
      data
    end

    # Get information about all roles
    # Get information about all roles
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :scope List only the roles which are applicable for this scope.
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(RoleListResult, Fixnum, Hash)>] RoleListResult data, response status code and response headers
    def get_all_roles_info_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_all_roles_info ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_all_roles_info, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_all_roles_info, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'scope'] && !['ROOT', 'ORG', 'PROJECT', 'VPC'].include?(opts[:'scope'])
        fail ArgumentError, 'invalid value for "scope", must be one of ROOT, ORG, PROJECT, VPC'
      end
      # resource path
      local_var_path = '/aaa/roles'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'scope'] = opts[:'scope'] if !opts[:'scope'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoleListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_all_roles_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read API service properties
    # Read the configuration of the NSX API service. 
    # @param [Hash] opts the optional parameters
    # @return [ApiServiceConfig]
    def get_api_service_config(opts = {})
      data, _status_code, _headers = get_api_service_config_with_http_info(opts)
      data
    end

    # Read API service properties
    # Read the configuration of the NSX API service. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiServiceConfig, Fixnum, Hash)>] ApiServiceConfig data, response status code and response headers
    def get_api_service_config_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_api_service_config ...'
      end
      # resource path
      local_var_path = '/cluster/api-service'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ApiServiceConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_api_service_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get status of asynchronous query operation
    # Get status of asynchronous VCF licenses query operation. 
    # @param [Hash] opts the optional parameters
    # @return [AsyncOperationStatus]
    def get_async_vcf_licenses_status(opts = {})
      data, _status_code, _headers = get_async_vcf_licenses_status_with_http_info(opts)
      data
    end

    # Get status of asynchronous query operation
    # Get status of asynchronous VCF licenses query operation. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(AsyncOperationStatus, Fixnum, Hash)>] AsyncOperationStatus data, response status code and response headers
    def get_async_vcf_licenses_status_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_async_vcf_licenses_status ...'
      end
      # resource path
      local_var_path = '/licenses/vcf/action/async/status'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AsyncOperationStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_async_vcf_licenses_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Fetch the auto enable gateway firewall configuration value.
    # Read Configuration values for auto-enable-gateway-firewall. 
    # @param [Hash] opts the optional parameters
    # @return [AutoEnableGatewayFirewallConfig]
    def get_auto_enable_gateway_firewall_config(opts = {})
      data, _status_code, _headers = get_auto_enable_gateway_firewall_config_with_http_info(opts)
      data
    end

    # Fetch the auto enable gateway firewall configuration value.
    # Read Configuration values for auto-enable-gateway-firewall. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(AutoEnableGatewayFirewallConfig, Fixnum, Hash)>] AutoEnableGatewayFirewallConfig data, response status code and response headers
    def get_auto_enable_gateway_firewall_config_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_auto_enable_gateway_firewall_config ...'
      end
      # resource path
      local_var_path = '/system-config/auto-enable-gateway-firewall'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AutoEnableGatewayFirewallConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_auto_enable_gateway_firewall_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get backup configuration
    # Get a configuration of a file server and timers for automated backup. Fields that contain secrets (password, passphrase) are not returned. 
    # @param [Hash] opts the optional parameters
    # @return [BackupConfiguration]
    def get_backup_config(opts = {})
      data, _status_code, _headers = get_backup_config_with_http_info(opts)
      data
    end

    # Get backup configuration
    # Get a configuration of a file server and timers for automated backup. Fields that contain secrets (password, passphrase) are not returned. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BackupConfiguration, Fixnum, Hash)>] BackupConfiguration data, response status code and response headers
    def get_backup_config_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_backup_config ...'
      end
      # resource path
      local_var_path = '/cluster/backups/config'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BackupConfiguration')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_backup_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get backup history
    # Get history of previous backup operations 
    # @param [Hash] opts the optional parameters
    # @return [BackupOperationHistory]
    def get_backup_history(opts = {})
      data, _status_code, _headers = get_backup_history_with_http_info(opts)
      data
    end

    # Get backup history
    # Get history of previous backup operations 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BackupOperationHistory, Fixnum, Hash)>] BackupOperationHistory data, response status code and response headers
    def get_backup_history_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_backup_history ...'
      end
      # resource path
      local_var_path = '/cluster/backups/history'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BackupOperationHistory')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_backup_history\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get all backup related information for a site
    # Get a configuration of a file server, timers for automated backup, latest backup status, backups list for a site. Fields that contain secrets (password, passphrase) are not returned. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :frame_type Frame type (default to LOCAL_LOCAL_MANAGER)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :show_backups_list Need a list of backups (default to true)
    # @option opts [String] :site_id UUID of the site (default to localhost)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [BackupOverview]
    def get_backup_overview(opts = {})
      data, _status_code, _headers = get_backup_overview_with_http_info(opts)
      data
    end

    # Get all backup related information for a site
    # Get a configuration of a file server, timers for automated backup, latest backup status, backups list for a site. Fields that contain secrets (password, passphrase) are not returned. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :frame_type Frame type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :show_backups_list Need a list of backups
    # @option opts [String] :site_id UUID of the site
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(BackupOverview, Fixnum, Hash)>] BackupOverview data, response status code and response headers
    def get_backup_overview_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_backup_overview ...'
      end
      if @api_client.config.client_side_validation && opts[:'frame_type'] && !['GLOBAL_MANAGER', 'LOCAL_MANAGER', 'LOCAL_LOCAL_MANAGER', 'NSX_INTELLIGENCE'].include?(opts[:'frame_type'])
        fail ArgumentError, 'invalid value for "frame_type", must be one of GLOBAL_MANAGER, LOCAL_MANAGER, LOCAL_LOCAL_MANAGER, NSX_INTELLIGENCE'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_backup_overview, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_backup_overview, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/cluster/backups/overview'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'frame_type'] = opts[:'frame_type'] if !opts[:'frame_type'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'show_backups_list'] = opts[:'show_backups_list'] if !opts[:'show_backups_list'].nil?
      query_params[:'site_id'] = opts[:'site_id'] if !opts[:'site_id'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BackupOverview')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_backup_overview\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get backup status
    # Get status of active backup operations 
    # @param [Hash] opts the optional parameters
    # @return [CurrentBackupOperationStatus]
    def get_backup_status(opts = {})
      data, _status_code, _headers = get_backup_status_with_http_info(opts)
      data
    end

    # Get backup status
    # Get status of active backup operations 
    # @param [Hash] opts the optional parameters
    # @return [Array<(CurrentBackupOperationStatus, Fixnum, Hash)>] CurrentBackupOperationStatus data, response status code and response headers
    def get_backup_status_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_backup_status ...'
      end
      # resource path
      local_var_path = '/cluster/backups/status'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'CurrentBackupOperationStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_backup_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get a Cluster Control Plane
    # Returns information about a specified Cluster Control Plane .
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param [Hash] opts the optional parameters
    # @return [ClusterControlPlane]
    def get_cluster_control_plane(site_id, enforcementpoint_id, cluster_control_plane_id, opts = {})
      data, _status_code, _headers = get_cluster_control_plane_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, opts)
      data
    end

    # Get a Cluster Control Plane
    # Returns information about a specified Cluster Control Plane .
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ClusterControlPlane, Fixnum, Hash)>] ClusterControlPlane data, response status code and response headers
    def get_cluster_control_plane_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_cluster_control_plane ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.get_cluster_control_plane"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.get_cluster_control_plane"
      end
      # verify the required parameter 'cluster_control_plane_id' is set
      if @api_client.config.client_side_validation && cluster_control_plane_id.nil?
        fail ArgumentError, "Missing the required parameter 'cluster_control_plane_id' when calling SystemAdministrationApi.get_cluster_control_plane"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/cluster-control-planes/{cluster-control-plane-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'cluster-control-plane-id' + '}', cluster_control_plane_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ClusterControlPlane')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_cluster_control_plane\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get the name and role information of the user.
    # This API will return the name and role information of the user invoking this API request. This API is available for all NSX users no matter their authentication method (Local account, VIDM, LDAP etc). The permissions parameter of the NsxRole has been deprecated. The request parameter root_path has been introduced for multi-tenancy to get user's role at any path that the user desires. The response will contain the roles_for_paths to indicate roles at various paths. 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :provide_flat_listing Whether the output provides flat listing of all roles at each level or not (default to false)
    # @option opts [String] :root_path Prefix path of the context
    # @return [UserInfo]
    def get_current_user_info(opts = {})
      data, _status_code, _headers = get_current_user_info_with_http_info(opts)
      data
    end

    # Get the name and role information of the user.
    # This API will return the name and role information of the user invoking this API request. This API is available for all NSX users no matter their authentication method (Local account, VIDM, LDAP etc). The permissions parameter of the NsxRole has been deprecated. The request parameter root_path has been introduced for multi-tenancy to get user&#39;s role at any path that the user desires. The response will contain the roles_for_paths to indicate roles at various paths. 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :provide_flat_listing Whether the output provides flat listing of all roles at each level or not
    # @option opts [String] :root_path Prefix path of the context
    # @return [Array<(UserInfo, Fixnum, Hash)>] UserInfo data, response status code and response headers
    def get_current_user_info_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_current_user_info ...'
      end
      # resource path
      local_var_path = '/aaa/user-info'

      # query parameters
      query_params = {}
      query_params[:'provide_flat_listing'] = opts[:'provide_flat_listing'] if !opts[:'provide_flat_listing'].nil?
      query_params[:'root_path'] = opts[:'root_path'] if !opts[:'root_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'UserInfo')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_current_user_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get deployment information.
    # This is an API called by VCF to get deployment information. 
    # @param [Hash] opts the optional parameters
    # @return [NSXManagerDeploymentInfo]
    def get_deployment_info(opts = {})
      data, _status_code, _headers = get_deployment_info_with_http_info(opts)
      data
    end

    # Get deployment information.
    # This is an API called by VCF to get deployment information. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(NSXManagerDeploymentInfo, Fixnum, Hash)>] NSXManagerDeploymentInfo data, response status code and response headers
    def get_deployment_info_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_deployment_info ...'
      end
      # resource path
      local_var_path = '/watermark'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'NSXManagerDeploymentInfo')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_deployment_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Fetches metadata about the given error_id
    # Returns some metadata about the given error_id. This includes information of whether there is a resolver present for the given error_id and its associated user input data 
    # @param error_id 
    # @param [Hash] opts the optional parameters
    # @return [ErrorResolverInfo]
    def get_error_resolver_info(error_id, opts = {})
      data, _status_code, _headers = get_error_resolver_info_with_http_info(error_id, opts)
      data
    end

    # Fetches metadata about the given error_id
    # Returns some metadata about the given error_id. This includes information of whether there is a resolver present for the given error_id and its associated user input data 
    # @param error_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ErrorResolverInfo, Fixnum, Hash)>] ErrorResolverInfo data, response status code and response headers
    def get_error_resolver_info_with_http_info(error_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_error_resolver_info ...'
      end
      # verify the required parameter 'error_id' is set
      if @api_client.config.client_side_validation && error_id.nil?
        fail ArgumentError, "Missing the required parameter 'error_id' when calling SystemAdministrationApi.get_error_resolver_info"
      end
      # resource path
      local_var_path = '/error-resolver/{error_id}'.sub('{' + 'error_id' + '}', error_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ErrorResolverInfo')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_error_resolver_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Return the acceptance status of end user license agreement 
    # Return the acceptance status of end user license agreement 
    # @param [Hash] opts the optional parameters
    # @return [EULAAcceptance]
    def get_eula_acceptance(opts = {})
      data, _status_code, _headers = get_eula_acceptance_with_http_info(opts)
      data
    end

    # Return the acceptance status of end user license agreement 
    # Return the acceptance status of end user license agreement 
    # @param [Hash] opts the optional parameters
    # @return [Array<(EULAAcceptance, Fixnum, Hash)>] EULAAcceptance data, response status code and response headers
    def get_eula_acceptance_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_eula_acceptance ...'
      end
      # resource path
      local_var_path = '/eula/acceptance'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EULAAcceptance')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_eula_acceptance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Return the content of end user license agreement 
    # Return the content of end user license agreement in the specified format. By default, it's pure string without line break 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :value_format End User License Agreement content output format
    # @return [EULAContent]
    def get_eula_content(opts = {})
      data, _status_code, _headers = get_eula_content_with_http_info(opts)
      data
    end

    # Return the content of end user license agreement 
    # Return the content of end user license agreement in the specified format. By default, it&#39;s pure string without line break 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :value_format End User License Agreement content output format
    # @return [Array<(EULAContent, Fixnum, Hash)>] EULAContent data, response status code and response headers
    def get_eula_content_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_eula_content ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_eula_content, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_eula_content, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/eula/content'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'value_format'] = opts[:'value_format'] if !opts[:'value_format'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EULAContent')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_eula_content\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get the module details of a host transport node 
    # Get the module details of a host transport node 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [SoftwareModuleResult]
    def get_fabric_node_modules_of_host_transport_node(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      data, _status_code, _headers = get_fabric_node_modules_of_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      data
    end

    # Get the module details of a host transport node 
    # Get the module details of a host transport node 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SoftwareModuleResult, Fixnum, Hash)>] SoftwareModuleResult data, response status code and response headers
    def get_fabric_node_modules_of_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_fabric_node_modules_of_host_transport_node ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.get_fabric_node_modules_of_host_transport_node"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.get_fabric_node_modules_of_host_transport_node"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling SystemAdministrationApi.get_fabric_node_modules_of_host_transport_node"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}/modules'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SoftwareModuleResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_fabric_node_modules_of_host_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get all the User Groups where vIDM display name matches the search key case insensitively. The search key is checked to be a substring of display name. This is a non paginated API. This API will return as many results that vIDM returns to NSX during the search query. vIDM may not send all results at once so to zero in on the group of interest more characters need to be entered.
    # Get all the User Groups where vIDM display name matches the search key case insensitively. The search key is checked to be a substring of display name. This is a non paginated API. This API will return as many results that vIDM returns to NSX during the search query. vIDM may not send all results at once so to zero in on the group of interest more characters need to be entered. <br> vIDM is deprecated by vIDB.  Use API POST /api/v1/trust-management/oidc-uris/{id}/search.
    # @param search_string Search string to search for. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [VidmInfoListResult]
    def get_group_vidm_search_result(search_string, opts = {})
      data, _status_code, _headers = get_group_vidm_search_result_with_http_info(search_string, opts)
      data
    end

    # Get all the User Groups where vIDM display name matches the search key case insensitively. The search key is checked to be a substring of display name. This is a non paginated API. This API will return as many results that vIDM returns to NSX during the search query. vIDM may not send all results at once so to zero in on the group of interest more characters need to be entered.
    # Get all the User Groups where vIDM display name matches the search key case insensitively. The search key is checked to be a substring of display name. This is a non paginated API. This API will return as many results that vIDM returns to NSX during the search query. vIDM may not send all results at once so to zero in on the group of interest more characters need to be entered. &lt;br&gt; vIDM is deprecated by vIDB.  Use API POST /api/v1/trust-management/oidc-uris/{id}/search.
    # @param search_string Search string to search for. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(VidmInfoListResult, Fixnum, Hash)>] VidmInfoListResult data, response status code and response headers
    def get_group_vidm_search_result_with_http_info(search_string, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_group_vidm_search_result ...'
      end
      # verify the required parameter 'search_string' is set
      if @api_client.config.client_side_validation && search_string.nil?
        fail ArgumentError, "Missing the required parameter 'search_string' when calling SystemAdministrationApi.get_group_vidm_search_result"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_group_vidm_search_result, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_group_vidm_search_result, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/aaa/vidm/groups'

      # query parameters
      query_params = {}
      query_params[:'search_string'] = search_string
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'VidmInfoListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_group_vidm_search_result\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get a Host Transport Node
    # Returns information about a specified transport node.
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [HostTransportNode]
    def get_host_transport_node(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      data, _status_code, _headers = get_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      data
    end

    # Get a Host Transport Node
    # Returns information about a specified transport node.
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(HostTransportNode, Fixnum, Hash)>] HostTransportNode data, response status code and response headers
    def get_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_host_transport_node ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.get_host_transport_node"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.get_host_transport_node"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling SystemAdministrationApi.get_host_transport_node"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'HostTransportNode')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_host_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Transport Node collection by id
    # Returns transport node collection by id
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [HostTransportNodeCollection]
    def get_host_transport_node_collection(site_id, enforcementpoint_id, transport_node_collection_id, opts = {})
      data, _status_code, _headers = get_host_transport_node_collection_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, opts)
      data
    end

    # Get Transport Node collection by id
    # Returns transport node collection by id
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(HostTransportNodeCollection, Fixnum, Hash)>] HostTransportNodeCollection data, response status code and response headers
    def get_host_transport_node_collection_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_host_transport_node_collection ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.get_host_transport_node_collection"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.get_host_transport_node_collection"
      end
      # verify the required parameter 'transport_node_collection_id' is set
      if @api_client.config.client_side_validation && transport_node_collection_id.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_collection_id' when calling SystemAdministrationApi.get_host_transport_node_collection"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/transport-node-collections/{transport-node-collection-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'transport-node-collection-id' + '}', transport_node_collection_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'HostTransportNodeCollection')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_host_transport_node_collection\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Transport Node collection application state
    # Returns the state of transport node collection based on the states of transport nodes of the hosts which are part of compute collection. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [TransportNodeCollectionState]
    def get_host_transport_node_collection_state(site_id, enforcementpoint_id, transport_node_collection_id, opts = {})
      data, _status_code, _headers = get_host_transport_node_collection_state_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, opts)
      data
    end

    # Get Transport Node collection application state
    # Returns the state of transport node collection based on the states of transport nodes of the hosts which are part of compute collection. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransportNodeCollectionState, Fixnum, Hash)>] TransportNodeCollectionState data, response status code and response headers
    def get_host_transport_node_collection_state_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_host_transport_node_collection_state ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.get_host_transport_node_collection_state"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.get_host_transport_node_collection_state"
      end
      # verify the required parameter 'transport_node_collection_id' is set
      if @api_client.config.client_side_validation && transport_node_collection_id.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_collection_id' when calling SystemAdministrationApi.get_host_transport_node_collection_state"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/transport-node-collections/{transport-node-collection-id}/state'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'transport-node-collection-id' + '}', transport_node_collection_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNodeCollectionState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_host_transport_node_collection_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get a Host Transport Node's State
    # Returns information about the current state of the transport node configuration and information about the associated hostswitch. Change introduced in 4.1.2 for ESX Transport node - The vib details will not be retrieved in every state API call. It will be retrieved by periodical polling on the host. Therefore the nsx vib version mismatch or nsx vib absence will be reported by this API only after subsequent polling takes place. Currently, the poll frequency is 10 minutes. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [TransportNodeState]
    def get_host_transport_node_state(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      data, _status_code, _headers = get_host_transport_node_state_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      data
    end

    # Get a Host Transport Node&#39;s State
    # Returns information about the current state of the transport node configuration and information about the associated hostswitch. Change introduced in 4.1.2 for ESX Transport node - The vib details will not be retrieved in every state API call. It will be retrieved by periodical polling on the host. Therefore the nsx vib version mismatch or nsx vib absence will be reported by this API only after subsequent polling takes place. Currently, the poll frequency is 10 minutes. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransportNodeState, Fixnum, Hash)>] TransportNodeState data, response status code and response headers
    def get_host_transport_node_state_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_host_transport_node_state ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.get_host_transport_node_state"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.get_host_transport_node_state"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling SystemAdministrationApi.get_host_transport_node_state"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}/state'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNodeState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_host_transport_node_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get status for MPS Compute collection.
    # Returns current status of the deployment of MPS Service on a given cluster. 
    # @param compute_collection_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [MpsComputeCollectionStatus]
    def get_mps_compute_collection_status(compute_collection_id, opts = {})
      data, _status_code, _headers = get_mps_compute_collection_status_with_http_info(compute_collection_id, opts)
      data
    end

    # Get status for MPS Compute collection.
    # Returns current status of the deployment of MPS Service on a given cluster. 
    # @param compute_collection_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(MpsComputeCollectionStatus, Fixnum, Hash)>] MpsComputeCollectionStatus data, response status code and response headers
    def get_mps_compute_collection_status_with_http_info(compute_collection_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_mps_compute_collection_status ...'
      end
      # verify the required parameter 'compute_collection_id' is set
      if @api_client.config.client_side_validation && compute_collection_id.nil?
        fail ArgumentError, "Missing the required parameter 'compute_collection_id' when calling SystemAdministrationApi.get_mps_compute_collection_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/malware-prevention/compute-collection/{compute-collection-id}/status'.sub('{' + 'compute-collection-id' + '}', compute_collection_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MpsComputeCollectionStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_mps_compute_collection_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List OVF specifications
    # List OVF specifications
    # @param [Hash] opts the optional parameters
    # @return [MpsOvfSpecListResult]
    def get_mps_deployment_spec(opts = {})
      data, _status_code, _headers = get_mps_deployment_spec_with_http_info(opts)
      data
    end

    # List OVF specifications
    # List OVF specifications
    # @param [Hash] opts the optional parameters
    # @return [Array<(MpsOvfSpecListResult, Fixnum, Hash)>] MpsOvfSpecListResult data, response status code and response headers
    def get_mps_deployment_spec_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_mps_deployment_spec ...'
      end
      # resource path
      local_var_path = '/malware-prevention/ovf-spec'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MpsOvfSpecListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_mps_deployment_spec\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get the Malware Prevention Service deployment on the specified compute-collection
    # Returns detail of the Malware Prevention Service deployment. 
    # @param compute_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [MpsSvmDeploymentSpec]
    def get_mps_service_deployment(compute_collection_id, opts = {})
      data, _status_code, _headers = get_mps_service_deployment_with_http_info(compute_collection_id, opts)
      data
    end

    # Get the Malware Prevention Service deployment on the specified compute-collection
    # Returns detail of the Malware Prevention Service deployment. 
    # @param compute_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(MpsSvmDeploymentSpec, Fixnum, Hash)>] MpsSvmDeploymentSpec data, response status code and response headers
    def get_mps_service_deployment_with_http_info(compute_collection_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_mps_service_deployment ...'
      end
      # verify the required parameter 'compute_collection_id' is set
      if @api_client.config.client_side_validation && compute_collection_id.nil?
        fail ArgumentError, "Missing the required parameter 'compute_collection_id' when calling SystemAdministrationApi.get_mps_service_deployment"
      end
      # resource path
      local_var_path = '/malware-prevention/compute-collection/{compute-collection-id}/svm-deployment'.sub('{' + 'compute-collection-id' + '}', compute_collection_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MpsSvmDeploymentSpec')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_mps_service_deployment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get status for MPS Transport Node.
    # Returns current status of the deployment of MPS Service on a transport node. 
    # @param transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [MpsTransportNodeStatus]
    def get_mps_transport_node_status(transport_node_id, opts = {})
      data, _status_code, _headers = get_mps_transport_node_status_with_http_info(transport_node_id, opts)
      data
    end

    # Get status for MPS Transport Node.
    # Returns current status of the deployment of MPS Service on a transport node. 
    # @param transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(MpsTransportNodeStatus, Fixnum, Hash)>] MpsTransportNodeStatus data, response status code and response headers
    def get_mps_transport_node_status_with_http_info(transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_mps_transport_node_status ...'
      end
      # verify the required parameter 'transport_node_id' is set
      if @api_client.config.client_side_validation && transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_id' when calling SystemAdministrationApi.get_mps_transport_node_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/malware-prevention/transport-node/{transport-node-id}/status'.sub('{' + 'transport-node-id' + '}', transport_node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MpsTransportNodeStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_mps_transport_node_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get the name and role information of the user.
    # This API will return the name and role information of the user invoking this API request on the particular project. The permissions parameter of the NsxRole has been deprecated. The response will contain the roles_for_paths to indicate roles of the user at various paths . 
    # @param org_id 
    # @param project_id 
    # @param [Hash] opts the optional parameters
    # @return [UserInfo]
    def get_multitenant_current_user_info(org_id, project_id, opts = {})
      data, _status_code, _headers = get_multitenant_current_user_info_with_http_info(org_id, project_id, opts)
      data
    end

    # Get the name and role information of the user.
    # This API will return the name and role information of the user invoking this API request on the particular project. The permissions parameter of the NsxRole has been deprecated. The response will contain the roles_for_paths to indicate roles of the user at various paths . 
    # @param org_id 
    # @param project_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(UserInfo, Fixnum, Hash)>] UserInfo data, response status code and response headers
    def get_multitenant_current_user_info_with_http_info(org_id, project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_multitenant_current_user_info ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SystemAdministrationApi.get_multitenant_current_user_info"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SystemAdministrationApi.get_multitenant_current_user_info"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/aaa/user-info'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'UserInfo')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_multitenant_current_user_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get the name and role information of the user.
    # This API will return the name and role information of the user invoking this API request on the particular project. The permissions parameter of the NsxRole has been deprecated. The response will contain the roles_for_paths to indicate roles of the user at various paths . 
    # @param org_id 
    # @param project_id 
    # @param vpc_id 
    # @param [Hash] opts the optional parameters
    # @return [UserInfo]
    def get_multitenant_current_user_info_vpc(org_id, project_id, vpc_id, opts = {})
      data, _status_code, _headers = get_multitenant_current_user_info_vpc_with_http_info(org_id, project_id, vpc_id, opts)
      data
    end

    # Get the name and role information of the user.
    # This API will return the name and role information of the user invoking this API request on the particular project. The permissions parameter of the NsxRole has been deprecated. The response will contain the roles_for_paths to indicate roles of the user at various paths . 
    # @param org_id 
    # @param project_id 
    # @param vpc_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(UserInfo, Fixnum, Hash)>] UserInfo data, response status code and response headers
    def get_multitenant_current_user_info_vpc_with_http_info(org_id, project_id, vpc_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_multitenant_current_user_info_vpc ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SystemAdministrationApi.get_multitenant_current_user_info_vpc"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SystemAdministrationApi.get_multitenant_current_user_info_vpc"
      end
      # verify the required parameter 'vpc_id' is set
      if @api_client.config.client_side_validation && vpc_id.nil?
        fail ArgumentError, "Missing the required parameter 'vpc_id' when calling SystemAdministrationApi.get_multitenant_current_user_info_vpc"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/vpcs/{vpc-id}/aaa/user-info'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'vpc-id' + '}', vpc_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'UserInfo')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_multitenant_current_user_info_vpc\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get list of Object-level RBAC entries.
    # Get list of Object-level RBAC entries.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [BOOLEAN] :inheritance_disabled Does children of this object inherit this rule (default to false)
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :path_prefix Path prefix
    # @option opts [String] :role_name Role name
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [ObjectRolePermissionGroupListResult]
    def get_object_permissions(opts = {})
      data, _status_code, _headers = get_object_permissions_with_http_info(opts)
      data
    end

    # Get list of Object-level RBAC entries.
    # Get list of Object-level RBAC entries.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [BOOLEAN] :inheritance_disabled Does children of this object inherit this rule
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :path_prefix Path prefix
    # @option opts [String] :role_name Role name
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(ObjectRolePermissionGroupListResult, Fixnum, Hash)>] ObjectRolePermissionGroupListResult data, response status code and response headers
    def get_object_permissions_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_object_permissions ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_object_permissions, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_object_permissions, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/aaa/object-permissions'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'inheritance_disabled'] = opts[:'inheritance_disabled'] if !opts[:'inheritance_disabled'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'path_prefix'] = opts[:'path_prefix'] if !opts[:'path_prefix'].nil?
      query_params[:'role_name'] = opts[:'role_name'] if !opts[:'role_name'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ObjectRolePermissionGroupListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_object_permissions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get the counter values for realtime datapath statistics.
    # Get the counter values for realtime datapath statistics. Support multiple types in one query.  Query types should be declared inside query parameters. By default the query type is packet_stats. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :type type
    # @return [ObservabilityCounterDebugQueryResult]
    def get_observability_debug_statics(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      data, _status_code, _headers = get_observability_debug_statics_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      data
    end

    # Get the counter values for realtime datapath statistics.
    # Get the counter values for realtime datapath statistics. Support multiple types in one query.  Query types should be declared inside query parameters. By default the query type is packet_stats. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :type type
    # @return [Array<(ObservabilityCounterDebugQueryResult, Fixnum, Hash)>] ObservabilityCounterDebugQueryResult data, response status code and response headers
    def get_observability_debug_statics_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_observability_debug_statics ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.get_observability_debug_statics"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.get_observability_debug_statics"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling SystemAdministrationApi.get_observability_debug_statics"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}/statistics/debug'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ObservabilityCounterDebugQueryResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_observability_debug_statics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get the counter values for cached datapath statistics.
    # Get the counter values for cached datapath statistics. Support multiple types in one query.  Query types should be declared inside query parameters. By default the query type is packet_stats. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :type type
    # @return [ObservabilityCounterMonitorQueryResult]
    def get_observability_monitor_statics(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      data, _status_code, _headers = get_observability_monitor_statics_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      data
    end

    # Get the counter values for cached datapath statistics.
    # Get the counter values for cached datapath statistics. Support multiple types in one query.  Query types should be declared inside query parameters. By default the query type is packet_stats. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :type type
    # @return [Array<(ObservabilityCounterMonitorQueryResult, Fixnum, Hash)>] ObservabilityCounterMonitorQueryResult data, response status code and response headers
    def get_observability_monitor_statics_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_observability_monitor_statics ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.get_observability_monitor_statics"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.get_observability_monitor_statics"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling SystemAdministrationApi.get_observability_monitor_statics"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}/statistics/monitor'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ObservabilityCounterMonitorQueryResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_observability_monitor_statics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Fetch the policy partial patch configuration value.
    # Read Configuration values for nsx-partial-patch. By default partial patch is deactivated (i.e false). Please refer to the description of PartialPatchConfig for more information. 
    # @param [Hash] opts the optional parameters
    # @return [PartialPatchConfig]
    def get_partial_patch_configuration(opts = {})
      data, _status_code, _headers = get_partial_patch_configuration_with_http_info(opts)
      data
    end

    # Fetch the policy partial patch configuration value.
    # Read Configuration values for nsx-partial-patch. By default partial patch is deactivated (i.e false). Please refer to the description of PartialPatchConfig for more information. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PartialPatchConfig, Fixnum, Hash)>] PartialPatchConfig data, response status code and response headers
    def get_partial_patch_configuration_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_partial_patch_configuration ...'
      end
      # resource path
      local_var_path = '/system-config/nsx-partial-patch-config'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PartialPatchConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_partial_patch_configuration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get a Hostswitch Profile by ID
    # Returns information about a specified hostswitch profile.
    # @param host_switch_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [PolicyBaseHostSwitchProfile]
    def get_policy_host_switch_profile(host_switch_profile_id, opts = {})
      data, _status_code, _headers = get_policy_host_switch_profile_with_http_info(host_switch_profile_id, opts)
      data
    end

    # Get a Hostswitch Profile by ID
    # Returns information about a specified hostswitch profile.
    # @param host_switch_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PolicyBaseHostSwitchProfile, Fixnum, Hash)>] PolicyBaseHostSwitchProfile data, response status code and response headers
    def get_policy_host_switch_profile_with_http_info(host_switch_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_policy_host_switch_profile ...'
      end
      # verify the required parameter 'host_switch_profile_id' is set
      if @api_client.config.client_side_validation && host_switch_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_switch_profile_id' when calling SystemAdministrationApi.get_policy_host_switch_profile"
      end
      # resource path
      local_var_path = '/infra/host-switch-profiles/{host-switch-profile-id}'.sub('{' + 'host-switch-profile-id' + '}', host_switch_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyBaseHostSwitchProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_policy_host_switch_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get a Transport Node
    # Returns information about a specified host transport node profile.
    # @param host_transport_node_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [PolicyHostTransportNodeProfile]
    def get_policy_host_transport_node_profile(host_transport_node_profile_id, opts = {})
      data, _status_code, _headers = get_policy_host_transport_node_profile_with_http_info(host_transport_node_profile_id, opts)
      data
    end

    # Get a Transport Node
    # Returns information about a specified host transport node profile.
    # @param host_transport_node_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PolicyHostTransportNodeProfile, Fixnum, Hash)>] PolicyHostTransportNodeProfile data, response status code and response headers
    def get_policy_host_transport_node_profile_with_http_info(host_transport_node_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_policy_host_transport_node_profile ...'
      end
      # verify the required parameter 'host_transport_node_profile_id' is set
      if @api_client.config.client_side_validation && host_transport_node_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_profile_id' when calling SystemAdministrationApi.get_policy_host_transport_node_profile"
      end
      # resource path
      local_var_path = '/infra/host-transport-node-profiles/{host-transport-node-profile-id}'.sub('{' + 'host-transport-node-profile-id' + '}', host_transport_node_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyHostTransportNodeProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_policy_host_transport_node_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get registration access token
    # Get registration access token <br> Use API POST /api/v1/aaa/registration-token/retrieve
    # @param token Registration token
    # @param [Hash] opts the optional parameters
    # @return [RegistrationToken]
    def get_registration_token(token, opts = {})
      data, _status_code, _headers = get_registration_token_with_http_info(token, opts)
      data
    end

    # Get registration access token
    # Get registration access token &lt;br&gt; Use API POST /api/v1/aaa/registration-token/retrieve
    # @param token Registration token
    # @param [Hash] opts the optional parameters
    # @return [Array<(RegistrationToken, Fixnum, Hash)>] RegistrationToken data, response status code and response headers
    def get_registration_token_with_http_info(token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_registration_token ...'
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling SystemAdministrationApi.get_registration_token"
      end
      # resource path
      local_var_path = '/aaa/registration-token/{token}'.sub('{' + 'token' + '}', token.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RegistrationToken')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_registration_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Restore configuration
    # Get configuration information for the file server used to store backed-up files. Fields that contain secrets (password, passphrase) are not returned.  <br> Deprecated. Please use API /cluster/backups/config, to get remote file server(where backed-up files are stored) details durign restore. 
    # @param [Hash] opts the optional parameters
    # @return [RestoreConfiguration]
    def get_restore_config(opts = {})
      data, _status_code, _headers = get_restore_config_with_http_info(opts)
      data
    end

    # Get Restore configuration
    # Get configuration information for the file server used to store backed-up files. Fields that contain secrets (password, passphrase) are not returned.  &lt;br&gt; Deprecated. Please use API /cluster/backups/config, to get remote file server(where backed-up files are stored) details durign restore. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(RestoreConfiguration, Fixnum, Hash)>] RestoreConfiguration data, response status code and response headers
    def get_restore_config_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_restore_config ...'
      end
      # resource path
      local_var_path = '/cluster/restore/config'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RestoreConfiguration')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_restore_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get user/group's role information
    # Get user/group's role information
    # @param binding_id User/Group&#39;s id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :identity_source_id Identity source ID
    # @option opts [String] :identity_source_type Identity source type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :name User/Group name
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :path Exact path of the context
    # @option opts [String] :role Role ID
    # @option opts [String] :root_path Prefix path of the context
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type
    # @return [RoleBinding]
    def get_role_binding(binding_id, opts = {})
      data, _status_code, _headers = get_role_binding_with_http_info(binding_id, opts)
      data
    end

    # Get user/group&#39;s role information
    # Get user/group&#39;s role information
    # @param binding_id User/Group&#39;s id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :identity_source_id Identity source ID
    # @option opts [String] :identity_source_type Identity source type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :name User/Group name
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :path Exact path of the context
    # @option opts [String] :role Role ID
    # @option opts [String] :root_path Prefix path of the context
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type
    # @return [Array<(RoleBinding, Fixnum, Hash)>] RoleBinding data, response status code and response headers
    def get_role_binding_with_http_info(binding_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_role_binding ...'
      end
      # verify the required parameter 'binding_id' is set
      if @api_client.config.client_side_validation && binding_id.nil?
        fail ArgumentError, "Missing the required parameter 'binding_id' when calling SystemAdministrationApi.get_role_binding"
      end
      if @api_client.config.client_side_validation && opts[:'identity_source_type'] && !['VIDM', 'LDAP', 'OIDC'].include?(opts[:'identity_source_type'])
        fail ArgumentError, 'invalid value for "identity_source_type", must be one of VIDM, LDAP, OIDC'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_role_binding, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_role_binding, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['remote_user', 'remote_group', 'local_user', 'principal_identity'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of remote_user, remote_group, local_user, principal_identity'
      end
      # resource path
      local_var_path = '/aaa/role-bindings/{binding-id}'.sub('{' + 'binding-id' + '}', binding_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'identity_source_id'] = opts[:'identity_source_id'] if !opts[:'identity_source_id'].nil?
      query_params[:'identity_source_type'] = opts[:'identity_source_type'] if !opts[:'identity_source_type'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'path'] = opts[:'path'] if !opts[:'path'].nil?
      query_params[:'role'] = opts[:'role'] if !opts[:'role'].nil?
      query_params[:'root_path'] = opts[:'root_path'] if !opts[:'root_path'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoleBinding')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_role_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get user/group's role information from CSP
    # Get user/group's role information from CSP
    # @param org_id 
    # @param project_id 
    # @param binding_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :identity_source_id Identity source ID
    # @option opts [String] :identity_source_type Identity source type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :name User/Group name
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :path Exact path of the context
    # @option opts [String] :role Role ID
    # @option opts [String] :root_path Prefix path of the context
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type
    # @return [RoleBinding]
    def get_role_binding_multitenancy_project(org_id, project_id, binding_id, opts = {})
      data, _status_code, _headers = get_role_binding_multitenancy_project_with_http_info(org_id, project_id, binding_id, opts)
      data
    end

    # Get user/group&#39;s role information from CSP
    # Get user/group&#39;s role information from CSP
    # @param org_id 
    # @param project_id 
    # @param binding_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :identity_source_id Identity source ID
    # @option opts [String] :identity_source_type Identity source type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :name User/Group name
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :path Exact path of the context
    # @option opts [String] :role Role ID
    # @option opts [String] :root_path Prefix path of the context
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type
    # @return [Array<(RoleBinding, Fixnum, Hash)>] RoleBinding data, response status code and response headers
    def get_role_binding_multitenancy_project_with_http_info(org_id, project_id, binding_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_role_binding_multitenancy_project ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SystemAdministrationApi.get_role_binding_multitenancy_project"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SystemAdministrationApi.get_role_binding_multitenancy_project"
      end
      # verify the required parameter 'binding_id' is set
      if @api_client.config.client_side_validation && binding_id.nil?
        fail ArgumentError, "Missing the required parameter 'binding_id' when calling SystemAdministrationApi.get_role_binding_multitenancy_project"
      end
      if @api_client.config.client_side_validation && opts[:'identity_source_type'] && !['VIDM', 'LDAP', 'OIDC'].include?(opts[:'identity_source_type'])
        fail ArgumentError, 'invalid value for "identity_source_type", must be one of VIDM, LDAP, OIDC'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_role_binding_multitenancy_project, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_role_binding_multitenancy_project, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['remote_user', 'remote_group', 'local_user', 'principal_identity'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of remote_user, remote_group, local_user, principal_identity'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/aaa/role-bindings/{binding-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'binding-id' + '}', binding_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'identity_source_id'] = opts[:'identity_source_id'] if !opts[:'identity_source_id'].nil?
      query_params[:'identity_source_type'] = opts[:'identity_source_type'] if !opts[:'identity_source_type'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'path'] = opts[:'path'] if !opts[:'path'].nil?
      query_params[:'role'] = opts[:'role'] if !opts[:'role'].nil?
      query_params[:'root_path'] = opts[:'root_path'] if !opts[:'root_path'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoleBinding')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_role_binding_multitenancy_project\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get user/group's role information from CSP
    # Get user/group's role information from CSP
    # @param org_id 
    # @param project_id 
    # @param vpc_id 
    # @param binding_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :identity_source_id Identity source ID
    # @option opts [String] :identity_source_type Identity source type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :name User/Group name
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :path Exact path of the context
    # @option opts [String] :role Role ID
    # @option opts [String] :root_path Prefix path of the context
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type
    # @return [RoleBinding]
    def get_role_binding_multitenancy_vpc(org_id, project_id, vpc_id, binding_id, opts = {})
      data, _status_code, _headers = get_role_binding_multitenancy_vpc_with_http_info(org_id, project_id, vpc_id, binding_id, opts)
      data
    end

    # Get user/group&#39;s role information from CSP
    # Get user/group&#39;s role information from CSP
    # @param org_id 
    # @param project_id 
    # @param vpc_id 
    # @param binding_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :identity_source_id Identity source ID
    # @option opts [String] :identity_source_type Identity source type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :name User/Group name
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :path Exact path of the context
    # @option opts [String] :role Role ID
    # @option opts [String] :root_path Prefix path of the context
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type
    # @return [Array<(RoleBinding, Fixnum, Hash)>] RoleBinding data, response status code and response headers
    def get_role_binding_multitenancy_vpc_with_http_info(org_id, project_id, vpc_id, binding_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_role_binding_multitenancy_vpc ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SystemAdministrationApi.get_role_binding_multitenancy_vpc"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SystemAdministrationApi.get_role_binding_multitenancy_vpc"
      end
      # verify the required parameter 'vpc_id' is set
      if @api_client.config.client_side_validation && vpc_id.nil?
        fail ArgumentError, "Missing the required parameter 'vpc_id' when calling SystemAdministrationApi.get_role_binding_multitenancy_vpc"
      end
      # verify the required parameter 'binding_id' is set
      if @api_client.config.client_side_validation && binding_id.nil?
        fail ArgumentError, "Missing the required parameter 'binding_id' when calling SystemAdministrationApi.get_role_binding_multitenancy_vpc"
      end
      if @api_client.config.client_side_validation && opts[:'identity_source_type'] && !['VIDM', 'LDAP', 'OIDC'].include?(opts[:'identity_source_type'])
        fail ArgumentError, 'invalid value for "identity_source_type", must be one of VIDM, LDAP, OIDC'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_role_binding_multitenancy_vpc, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_role_binding_multitenancy_vpc, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['remote_user', 'remote_group', 'local_user', 'principal_identity'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of remote_user, remote_group, local_user, principal_identity'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/vpcs/{vpc-id}/aaa/role-bindings/{binding-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'vpc-id' + '}', vpc_id.to_s).sub('{' + 'binding-id' + '}', binding_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'identity_source_id'] = opts[:'identity_source_id'] if !opts[:'identity_source_id'].nil?
      query_params[:'identity_source_type'] = opts[:'identity_source_type'] if !opts[:'identity_source_type'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'path'] = opts[:'path'] if !opts[:'path'].nil?
      query_params[:'role'] = opts[:'role'] if !opts[:'role'].nil?
      query_params[:'root_path'] = opts[:'root_path'] if !opts[:'root_path'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoleBinding')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_role_binding_multitenancy_vpc\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get role information
    # Get role information
    # @param role Role id
    # @param [Hash] opts the optional parameters
    # @return [RoleWithFeatures]
    def get_role_info(role, opts = {})
      data, _status_code, _headers = get_role_info_with_http_info(role, opts)
      data
    end

    # Get role information
    # Get role information
    # @param role Role id
    # @param [Hash] opts the optional parameters
    # @return [Array<(RoleWithFeatures, Fixnum, Hash)>] RoleWithFeatures data, response status code and response headers
    def get_role_info_with_http_info(role, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_role_info ...'
      end
      # verify the required parameter 'role' is set
      if @api_client.config.client_side_validation && role.nil?
        fail ArgumentError, "Missing the required parameter 'role' when calling SystemAdministrationApi.get_role_info"
      end
      # resource path
      local_var_path = '/aaa/roles/{role}'.sub('{' + 'role' + '}', role.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoleWithFeatures')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_role_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get ssh fingerprint of remote(backup) server
    # Get SHA256 fingerprint of ECDSA key of remote server. The caller should independently verify that the key is trusted. 
    # @param remote_server_fingerprint_request 
    # @param [Hash] opts the optional parameters
    # @return [RemoteServerFingerprint]
    def get_ssh_fingerprint_of_server(remote_server_fingerprint_request, opts = {})
      data, _status_code, _headers = get_ssh_fingerprint_of_server_with_http_info(remote_server_fingerprint_request, opts)
      data
    end

    # Get ssh fingerprint of remote(backup) server
    # Get SHA256 fingerprint of ECDSA key of remote server. The caller should independently verify that the key is trusted. 
    # @param remote_server_fingerprint_request 
    # @param [Hash] opts the optional parameters
    # @return [Array<(RemoteServerFingerprint, Fixnum, Hash)>] RemoteServerFingerprint data, response status code and response headers
    def get_ssh_fingerprint_of_server_with_http_info(remote_server_fingerprint_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_ssh_fingerprint_of_server ...'
      end
      # verify the required parameter 'remote_server_fingerprint_request' is set
      if @api_client.config.client_side_validation && remote_server_fingerprint_request.nil?
        fail ArgumentError, "Missing the required parameter 'remote_server_fingerprint_request' when calling SystemAdministrationApi.get_ssh_fingerprint_of_server"
      end
      # resource path
      local_var_path = '/cluster/backups?action=retrieve_ssh_fingerprint'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(remote_server_fingerprint_request)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RemoteServerFingerprint')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_ssh_fingerprint_of_server\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get all the users from vIDM whose userName, givenName or familyName matches the search key case insensitively. The search key is checked to be a substring of name or given name or family name. This is a non paginated API. This API will return as many results that vIDM returns to NSX during the search query. vIDM may not send all results at once so to zero in on the user of interest more characters need to be entered.
    # Get all the users from vIDM whose userName, givenName or familyName matches the search key case insensitively. The search key is checked to be a substring of name or given name or family name. This is a non paginated API. This API will return as many results that vIDM returns to NSX during the search query. vIDM may not send all results at once so to zero in on the user of interest more characters need to be entered. <br> vIDM is deprecated by vIDB.  Use API POST /api/v1/trust-management/oidc-uris/{id}/search.
    # @param search_string Search string to search for. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [VidmInfoListResult]
    def get_user_vidm_search_result(search_string, opts = {})
      data, _status_code, _headers = get_user_vidm_search_result_with_http_info(search_string, opts)
      data
    end

    # Get all the users from vIDM whose userName, givenName or familyName matches the search key case insensitively. The search key is checked to be a substring of name or given name or family name. This is a non paginated API. This API will return as many results that vIDM returns to NSX during the search query. vIDM may not send all results at once so to zero in on the user of interest more characters need to be entered.
    # Get all the users from vIDM whose userName, givenName or familyName matches the search key case insensitively. The search key is checked to be a substring of name or given name or family name. This is a non paginated API. This API will return as many results that vIDM returns to NSX during the search query. vIDM may not send all results at once so to zero in on the user of interest more characters need to be entered. &lt;br&gt; vIDM is deprecated by vIDB.  Use API POST /api/v1/trust-management/oidc-uris/{id}/search.
    # @param search_string Search string to search for. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(VidmInfoListResult, Fixnum, Hash)>] VidmInfoListResult data, response status code and response headers
    def get_user_vidm_search_result_with_http_info(search_string, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_user_vidm_search_result ...'
      end
      # verify the required parameter 'search_string' is set
      if @api_client.config.client_side_validation && search_string.nil?
        fail ArgumentError, "Missing the required parameter 'search_string' when calling SystemAdministrationApi.get_user_vidm_search_result"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_user_vidm_search_result, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_user_vidm_search_result, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/aaa/vidm/users'

      # query parameters
      query_params = {}
      query_params[:'search_string'] = search_string
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'VidmInfoListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_user_vidm_search_result\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get the version whitelist
    # Get whitelist of versions for different components
    # @param [Hash] opts the optional parameters
    # @return [AcceptableComponentVersionList]
    def get_version_whitelist(opts = {})
      data, _status_code, _headers = get_version_whitelist_with_http_info(opts)
      data
    end

    # Get the version whitelist
    # Get whitelist of versions for different components
    # @param [Hash] opts the optional parameters
    # @return [Array<(AcceptableComponentVersionList, Fixnum, Hash)>] AcceptableComponentVersionList data, response status code and response headers
    def get_version_whitelist_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_version_whitelist ...'
      end
      # resource path
      local_var_path = '/upgrade/version-whitelist'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AcceptableComponentVersionList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_version_whitelist\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get the version whitelist for the specified component
    # Get whitelist of versions for a component. Component can include HOST, EDGE, CCP, MP
    # @param component_type 
    # @param [Hash] opts the optional parameters
    # @return [AcceptableComponentVersion]
    def get_version_whitelist_by_component(component_type, opts = {})
      data, _status_code, _headers = get_version_whitelist_by_component_with_http_info(component_type, opts)
      data
    end

    # Get the version whitelist for the specified component
    # Get whitelist of versions for a component. Component can include HOST, EDGE, CCP, MP
    # @param component_type 
    # @param [Hash] opts the optional parameters
    # @return [Array<(AcceptableComponentVersion, Fixnum, Hash)>] AcceptableComponentVersion data, response status code and response headers
    def get_version_whitelist_by_component_with_http_info(component_type, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_version_whitelist_by_component ...'
      end
      # verify the required parameter 'component_type' is set
      if @api_client.config.client_side_validation && component_type.nil?
        fail ArgumentError, "Missing the required parameter 'component_type' when calling SystemAdministrationApi.get_version_whitelist_by_component"
      end
      # resource path
      local_var_path = '/upgrade/version-whitelist/{component_type}'.sub('{' + 'component_type' + '}', component_type.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AcceptableComponentVersion')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_version_whitelist_by_component\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get all the users and groups from vIDM matching the search key case insensitively. The search key is checked to be a substring of name or given name or family name of user and display name of group. This is a non paginated API. This API will return as many results that vIDM returns to NSX during the search query. vIDM may not send all results at once so to zero in on the user/group of interest more characters need to be entered.
    # Get all the users and groups from vIDM matching the search key case insensitively. The search key is checked to be a substring of name or given name or family name of user and display name of group. This is a non paginated API. This API will return as many results that vIDM returns to NSX during the search query. vIDM may not send all results at once so to zero in on the user/group of interest more characters need to be entered. <br> vIDM is deprecated by vIDB.  Use API POST /api/v1/trust-management/oidc-uris/{id}/search.
    # @param search_string Search string to search for. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [VidmInfoListResult]
    def get_vidm_search_result(search_string, opts = {})
      data, _status_code, _headers = get_vidm_search_result_with_http_info(search_string, opts)
      data
    end

    # Get all the users and groups from vIDM matching the search key case insensitively. The search key is checked to be a substring of name or given name or family name of user and display name of group. This is a non paginated API. This API will return as many results that vIDM returns to NSX during the search query. vIDM may not send all results at once so to zero in on the user/group of interest more characters need to be entered.
    # Get all the users and groups from vIDM matching the search key case insensitively. The search key is checked to be a substring of name or given name or family name of user and display name of group. This is a non paginated API. This API will return as many results that vIDM returns to NSX during the search query. vIDM may not send all results at once so to zero in on the user/group of interest more characters need to be entered. &lt;br&gt; vIDM is deprecated by vIDB.  Use API POST /api/v1/trust-management/oidc-uris/{id}/search.
    # @param search_string Search string to search for. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(VidmInfoListResult, Fixnum, Hash)>] VidmInfoListResult data, response status code and response headers
    def get_vidm_search_result_with_http_info(search_string, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_vidm_search_result ...'
      end
      # verify the required parameter 'search_string' is set
      if @api_client.config.client_side_validation && search_string.nil?
        fail ArgumentError, "Missing the required parameter 'search_string' when calling SystemAdministrationApi.get_vidm_search_result"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_vidm_search_result, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.get_vidm_search_result, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/aaa/vidm/search'

      # query parameters
      query_params = {}
      query_params[:'search_string'] = search_string
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'VidmInfoListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_vidm_search_result\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns View Information
    # Returns Information about a specific View.  <br> This API is deprecated and will be unavailable in later releases.
    # @param view_id 
    # @param [Hash] opts the optional parameters
    # @return [View]
    def get_view(view_id, opts = {})
      data, _status_code, _headers = get_view_with_http_info(view_id, opts)
      data
    end

    # Returns View Information
    # Returns Information about a specific View.  &lt;br&gt; This API is deprecated and will be unavailable in later releases.
    # @param view_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(View, Fixnum, Hash)>] View data, response status code and response headers
    def get_view_with_http_info(view_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_view ...'
      end
      # verify the required parameter 'view_id' is set
      if @api_client.config.client_side_validation && view_id.nil?
        fail ArgumentError, "Missing the required parameter 'view_id' when calling SystemAdministrationApi.get_view"
      end
      # resource path
      local_var_path = '/ui-views/{view-id}'.sub('{' + 'view-id' + '}', view_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'View')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_view\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns Widget Configuration Information
    # Returns Information about a specific Widget Configuration.  <br> This API is deprecated and will be unavailable in later releases.
    # @param view_id 
    # @param widgetconfiguration_id 
    # @param [Hash] opts the optional parameters
    # @return [WidgetConfiguration]
    def get_widget_configuration(view_id, widgetconfiguration_id, opts = {})
      data, _status_code, _headers = get_widget_configuration_with_http_info(view_id, widgetconfiguration_id, opts)
      data
    end

    # Returns Widget Configuration Information
    # Returns Information about a specific Widget Configuration.  &lt;br&gt; This API is deprecated and will be unavailable in later releases.
    # @param view_id 
    # @param widgetconfiguration_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(WidgetConfiguration, Fixnum, Hash)>] WidgetConfiguration data, response status code and response headers
    def get_widget_configuration_with_http_info(view_id, widgetconfiguration_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.get_widget_configuration ...'
      end
      # verify the required parameter 'view_id' is set
      if @api_client.config.client_side_validation && view_id.nil?
        fail ArgumentError, "Missing the required parameter 'view_id' when calling SystemAdministrationApi.get_widget_configuration"
      end
      # verify the required parameter 'widgetconfiguration_id' is set
      if @api_client.config.client_side_validation && widgetconfiguration_id.nil?
        fail ArgumentError, "Missing the required parameter 'widgetconfiguration_id' when calling SystemAdministrationApi.get_widget_configuration"
      end
      # resource path
      local_var_path = '/ui-views/{view-id}/widgetconfigurations/{widgetconfiguration-id}'.sub('{' + 'view-id' + '}', view_id.to_s).sub('{' + 'widgetconfiguration-id' + '}', widgetconfiguration_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'WidgetConfiguration')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#get_widget_configuration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # This is Post Avi Controller Deployment Workflow. It will create role if not exist Create Service User Set System Configuration Create Enforcement Point Save Infra-Admin Creds to DB.
    # Set the post deployment cluster configuration for Avi Load Balancer Controller cluster. 
    # @param alb_controller_configuration 
    # @param [Hash] opts the optional parameters
    # @return [EnforcementPoint]
    def initiate_alb_on_boarding_workflow(alb_controller_configuration, opts = {})
      data, _status_code, _headers = initiate_alb_on_boarding_workflow_with_http_info(alb_controller_configuration, opts)
      data
    end

    # This is Post Avi Controller Deployment Workflow. It will create role if not exist Create Service User Set System Configuration Create Enforcement Point Save Infra-Admin Creds to DB.
    # Set the post deployment cluster configuration for Avi Load Balancer Controller cluster. 
    # @param alb_controller_configuration 
    # @param [Hash] opts the optional parameters
    # @return [Array<(EnforcementPoint, Fixnum, Hash)>] EnforcementPoint data, response status code and response headers
    def initiate_alb_on_boarding_workflow_with_http_info(alb_controller_configuration, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.initiate_alb_on_boarding_workflow ...'
      end
      # verify the required parameter 'alb_controller_configuration' is set
      if @api_client.config.client_side_validation && alb_controller_configuration.nil?
        fail ArgumentError, "Missing the required parameter 'alb_controller_configuration' when calling SystemAdministrationApi.initiate_alb_on_boarding_workflow"
      end
      # resource path
      local_var_path = '/infra/alb-onboarding-workflow'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(alb_controller_configuration)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EnforcementPoint')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#initiate_alb_on_boarding_workflow\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Initiate a restore operation
    # Start the restore of an NSX cluster, from some previously backed-up configuration. This operation is only valid when a GET cluster/restore/status returns a status with value NOT_STARTED. Otherwise, a 409 response is returned. 
    # @param initiate_cluster_restore_request 
    # @param [Hash] opts the optional parameters
    # @return [ClusterRestoreStatus]
    def initiate_cluster_restore(initiate_cluster_restore_request, opts = {})
      data, _status_code, _headers = initiate_cluster_restore_with_http_info(initiate_cluster_restore_request, opts)
      data
    end

    # Initiate a restore operation
    # Start the restore of an NSX cluster, from some previously backed-up configuration. This operation is only valid when a GET cluster/restore/status returns a status with value NOT_STARTED. Otherwise, a 409 response is returned. 
    # @param initiate_cluster_restore_request 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ClusterRestoreStatus, Fixnum, Hash)>] ClusterRestoreStatus data, response status code and response headers
    def initiate_cluster_restore_with_http_info(initiate_cluster_restore_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.initiate_cluster_restore ...'
      end
      # verify the required parameter 'initiate_cluster_restore_request' is set
      if @api_client.config.client_side_validation && initiate_cluster_restore_request.nil?
        fail ArgumentError, "Missing the required parameter 'initiate_cluster_restore_request' when calling SystemAdministrationApi.initiate_cluster_restore"
      end
      # resource path
      local_var_path = '/cluster/restore?action=start'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(initiate_cluster_restore_request)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ClusterRestoreStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#initiate_cluster_restore\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Install and update portal certificate in Avi Load Balancer Controller.
    # Use this API to install and update portal certificate in Avi Load Balancer Controller. 
    # @param alb_controller_certificate 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :ca_only Add given CA certificate to NSX Truststore
    # @return [ALBControllerCertificate]
    def install_alb_portal_certificate(alb_controller_certificate, opts = {})
      data, _status_code, _headers = install_alb_portal_certificate_with_http_info(alb_controller_certificate, opts)
      data
    end

    # Install and update portal certificate in Avi Load Balancer Controller.
    # Use this API to install and update portal certificate in Avi Load Balancer Controller. 
    # @param alb_controller_certificate 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :ca_only Add given CA certificate to NSX Truststore
    # @return [Array<(ALBControllerCertificate, Fixnum, Hash)>] ALBControllerCertificate data, response status code and response headers
    def install_alb_portal_certificate_with_http_info(alb_controller_certificate, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.install_alb_portal_certificate ...'
      end
      # verify the required parameter 'alb_controller_certificate' is set
      if @api_client.config.client_side_validation && alb_controller_certificate.nil?
        fail ArgumentError, "Missing the required parameter 'alb_controller_certificate' when calling SystemAdministrationApi.install_alb_portal_certificate"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/certificate/install'

      # query parameters
      query_params = {}
      query_params[:'ca_only'] = opts[:'ca_only'] if !opts[:'ca_only'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(alb_controller_certificate)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#install_alb_portal_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns information for Avi Load Balancer Controller cluster.
    # Returns information about Avi Load Balancer Controller cluster status 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @return [ALBControllerClusterInfo]
    def list_alb_controller_cluster_info(opts = {})
      data, _status_code, _headers = list_alb_controller_cluster_info_with_http_info(opts)
      data
    end

    # Returns information for Avi Load Balancer Controller cluster.
    # Returns information about Avi Load Balancer Controller cluster status 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @return [Array<(ALBControllerClusterInfo, Fixnum, Hash)>] ALBControllerClusterInfo data, response status code and response headers
    def list_alb_controller_cluster_info_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_alb_controller_cluster_info ...'
      end
      # resource path
      local_var_path = '/alb/controller-nodes/cluster'

      # query parameters
      query_params = {}
      query_params[:'clustering_id'] = opts[:'clustering_id'] if !opts[:'clustering_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerClusterInfo')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_alb_controller_cluster_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List available Avi Load Balancer Controller form factors
    # Returns information about all form factors available for Avi Load Balancer Controller nodes. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :alb_major_version Major release version of Avi Load Balancer Controller for which form factor details will be returned.
    # @return [ALBControllerNodeFormFactors]
    def list_alb_controller_form_factors(opts = {})
      data, _status_code, _headers = list_alb_controller_form_factors_with_http_info(opts)
      data
    end

    # List available Avi Load Balancer Controller form factors
    # Returns information about all form factors available for Avi Load Balancer Controller nodes. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :alb_major_version Major release version of Avi Load Balancer Controller for which form factor details will be returned.
    # @return [Array<(ALBControllerNodeFormFactors, Fixnum, Hash)>] ALBControllerNodeFormFactors data, response status code and response headers
    def list_alb_controller_form_factors_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_alb_controller_form_factors ...'
      end
      # resource path
      local_var_path = '/alb/controller-nodes/form-factors'

      # query parameters
      query_params = {}
      query_params[:'alb_major_version'] = opts[:'alb_major_version'] if !opts[:'alb_major_version'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerNodeFormFactors')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_alb_controller_form_factors\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns info for all Avi Load Balancer cluster node auto-deployment attempts
    # Returns request information for every attempted deployment of a Avi Load Balancer cluster node. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @option opts [String] :state The current state of the Avi Load Balancer Controller node deployment
    # @return [ALBControllerNodeVMDeploymentRequestList]
    def list_alb_controller_node_vm_deployment_requests(opts = {})
      data, _status_code, _headers = list_alb_controller_node_vm_deployment_requests_with_http_info(opts)
      data
    end

    # Returns info for all Avi Load Balancer cluster node auto-deployment attempts
    # Returns request information for every attempted deployment of a Avi Load Balancer cluster node. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @option opts [String] :state The current state of the Avi Load Balancer Controller node deployment
    # @return [Array<(ALBControllerNodeVMDeploymentRequestList, Fixnum, Hash)>] ALBControllerNodeVMDeploymentRequestList data, response status code and response headers
    def list_alb_controller_node_vm_deployment_requests_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_alb_controller_node_vm_deployment_requests ...'
      end
      if @api_client.config.client_side_validation && opts[:'state'] && !['DEPLOYED', 'PENDING'].include?(opts[:'state'])
        fail ArgumentError, 'invalid value for "state", must be one of DEPLOYED, PENDING'
      end
      # resource path
      local_var_path = '/alb/controller-nodes/deployments'

      # query parameters
      query_params = {}
      query_params[:'clustering_id'] = opts[:'clustering_id'] if !opts[:'clustering_id'].nil?
      query_params[:'state'] = opts[:'state'] if !opts[:'state'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerNodeVMDeploymentRequestList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_alb_controller_node_vm_deployment_requests\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read Antrea cluster heartbeat config list
    # Paginated list of all Antrea cluster heartbeat config
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [AntreaHeartbeatConfigListResult]
    def list_antrea_heartbeat_config(site_id, enforcementpoint_id, opts = {})
      data, _status_code, _headers = list_antrea_heartbeat_config_with_http_info(site_id, enforcementpoint_id, opts)
      data
    end

    # Read Antrea cluster heartbeat config list
    # Paginated list of all Antrea cluster heartbeat config
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(AntreaHeartbeatConfigListResult, Fixnum, Hash)>] AntreaHeartbeatConfigListResult data, response status code and response headers
    def list_antrea_heartbeat_config_with_http_info(site_id, enforcementpoint_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_antrea_heartbeat_config ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.list_antrea_heartbeat_config"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.list_antrea_heartbeat_config"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_antrea_heartbeat_config, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_antrea_heartbeat_config, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/cluster-control-planes-heartbeat-config'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AntreaHeartbeatConfigListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_antrea_heartbeat_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read Antrea cluster status list
    # Paginated list of all Antrea cluster status
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [AntreaClusterListResult]
    def list_antrea_status(site_id, enforcementpoint_id, opts = {})
      data, _status_code, _headers = list_antrea_status_with_http_info(site_id, enforcementpoint_id, opts)
      data
    end

    # Read Antrea cluster status list
    # Paginated list of all Antrea cluster status
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(AntreaClusterListResult, Fixnum, Hash)>] AntreaClusterListResult data, response status code and response headers
    def list_antrea_status_with_http_info(site_id, enforcementpoint_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_antrea_status ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.list_antrea_status"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.list_antrea_status"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_antrea_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_antrea_status, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/cluster-control-planes-status'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AntreaClusterListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_antrea_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read BMC cluster status list
    # Paginated list of all BMC cluster status
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [BMCClusterListResult]
    def list_bmc_status(site_id, enforcementpoint_id, opts = {})
      data, _status_code, _headers = list_bmc_status_with_http_info(site_id, enforcementpoint_id, opts)
      data
    end

    # Read BMC cluster status list
    # Paginated list of all BMC cluster status
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(BMCClusterListResult, Fixnum, Hash)>] BMCClusterListResult data, response status code and response headers
    def list_bmc_status_with_http_info(site_id, enforcementpoint_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_bmc_status ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.list_bmc_status"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.list_bmc_status"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_bmc_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_bmc_status, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/bm-ccpn-status'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BMCClusterListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_bmc_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List timestamps of all available Cluster Backups.
    # Returns timestamps for all backup files that are available on the SFTP server. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [ClusterBackupInfoListResult]
    def list_cluster_backup_timestamps(opts = {})
      data, _status_code, _headers = list_cluster_backup_timestamps_with_http_info(opts)
      data
    end

    # List timestamps of all available Cluster Backups.
    # Returns timestamps for all backup files that are available on the SFTP server. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(ClusterBackupInfoListResult, Fixnum, Hash)>] ClusterBackupInfoListResult data, response status code and response headers
    def list_cluster_backup_timestamps_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_cluster_backup_timestamps ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_cluster_backup_timestamps, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_cluster_backup_timestamps, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/cluster/restore/backuptimestamps'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ClusterBackupInfoListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_cluster_backup_timestamps\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Cluster Control Plane
    # list all Cluster Control Planes 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [ClusterControlPlaneListResult]
    def list_cluster_control_plane(site_id, enforcementpoint_id, opts = {})
      data, _status_code, _headers = list_cluster_control_plane_with_http_info(site_id, enforcementpoint_id, opts)
      data
    end

    # List Cluster Control Plane
    # list all Cluster Control Planes 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(ClusterControlPlaneListResult, Fixnum, Hash)>] ClusterControlPlaneListResult data, response status code and response headers
    def list_cluster_control_plane_with_http_info(site_id, enforcementpoint_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_cluster_control_plane ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.list_cluster_control_plane"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.list_cluster_control_plane"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_cluster_control_plane, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_cluster_control_plane, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/cluster-control-planes'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ClusterControlPlaneListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_cluster_control_plane\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Fetches a list of metadata for all the registered error resolvers
    # Returns a list of metadata for all the error resolvers registered. 
    # @param [Hash] opts the optional parameters
    # @return [ErrorResolverInfoList]
    def list_error_resolver_info(opts = {})
      data, _status_code, _headers = list_error_resolver_info_with_http_info(opts)
      data
    end

    # Fetches a list of metadata for all the registered error resolvers
    # Returns a list of metadata for all the error resolvers registered. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ErrorResolverInfoList, Fixnum, Hash)>] ErrorResolverInfoList data, response status code and response headers
    def list_error_resolver_info_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_error_resolver_info ...'
      end
      # resource path
      local_var_path = '/error-resolver'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ErrorResolverInfoList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_error_resolver_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List RBAC features
    # List all the RBAC features and their properties. 
    # @param [Hash] opts the optional parameters
    # @return [FeaturePermissionListResult]
    def list_features(opts = {})
      data, _status_code, _headers = list_features_with_http_info(opts)
      data
    end

    # List RBAC features
    # List all the RBAC features and their properties. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(FeaturePermissionListResult, Fixnum, Hash)>] FeaturePermissionListResult data, response status code and response headers
    def list_features_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_features ...'
      end
      # resource path
      local_var_path = '/aaa/features-with-properties'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'FeaturePermissionListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_features\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Transport Node collections
    # Returns all Transport Node collections
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cluster_moid Managed object ID of cluster in VC
    # @option opts [String] :compute_collection_id Compute collection id
    # @option opts [String] :vc_instance_uuid UUID for VC deployment
    # @return [HostTransportNodeCollectionListResult]
    def list_host_transport_node_collections(site_id, enforcementpoint_id, opts = {})
      data, _status_code, _headers = list_host_transport_node_collections_with_http_info(site_id, enforcementpoint_id, opts)
      data
    end

    # List Transport Node collections
    # Returns all Transport Node collections
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cluster_moid Managed object ID of cluster in VC
    # @option opts [String] :compute_collection_id Compute collection id
    # @option opts [String] :vc_instance_uuid UUID for VC deployment
    # @return [Array<(HostTransportNodeCollectionListResult, Fixnum, Hash)>] HostTransportNodeCollectionListResult data, response status code and response headers
    def list_host_transport_node_collections_with_http_info(site_id, enforcementpoint_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_host_transport_node_collections ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.list_host_transport_node_collections"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.list_host_transport_node_collections"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/transport-node-collections'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cluster_moid'] = opts[:'cluster_moid'] if !opts[:'cluster_moid'].nil?
      query_params[:'compute_collection_id'] = opts[:'compute_collection_id'] if !opts[:'compute_collection_id'].nil?
      query_params[:'vc_instance_uuid'] = opts[:'vc_instance_uuid'] if !opts[:'vc_instance_uuid'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'HostTransportNodeCollectionListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_host_transport_node_collections\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Host Transport Nodes
    # Returns information about all host transport nodes along with underlying host details. A transport node is a host that contains hostswitches. A hostswitch can have virtual machines connected to them.  Because each transport node has hostswitches, transport nodes can also have virtual tunnel endpoints, which means that they can be part of the overlay. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :discovered_node_id discovered node id
    # @option opts [BOOLEAN] :in_maintenance_mode maintenance mode flag
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_ip Transport node IP address
    # @option opts [String] :node_types a list of node types separated by comma or a single type
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :transport_zone_path Transport zone path
    # @return [HostTransportNodeListResult]
    def list_host_transport_nodes(site_id, enforcementpoint_id, opts = {})
      data, _status_code, _headers = list_host_transport_nodes_with_http_info(site_id, enforcementpoint_id, opts)
      data
    end

    # List Host Transport Nodes
    # Returns information about all host transport nodes along with underlying host details. A transport node is a host that contains hostswitches. A hostswitch can have virtual machines connected to them.  Because each transport node has hostswitches, transport nodes can also have virtual tunnel endpoints, which means that they can be part of the overlay. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :discovered_node_id discovered node id
    # @option opts [BOOLEAN] :in_maintenance_mode maintenance mode flag
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_ip Transport node IP address
    # @option opts [String] :node_types a list of node types separated by comma or a single type
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :transport_zone_path Transport zone path
    # @return [Array<(HostTransportNodeListResult, Fixnum, Hash)>] HostTransportNodeListResult data, response status code and response headers
    def list_host_transport_nodes_with_http_info(site_id, enforcementpoint_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_host_transport_nodes ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.list_host_transport_nodes"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.list_host_transport_nodes"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_host_transport_nodes, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_host_transport_nodes, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'discovered_node_id'] = opts[:'discovered_node_id'] if !opts[:'discovered_node_id'].nil?
      query_params[:'in_maintenance_mode'] = opts[:'in_maintenance_mode'] if !opts[:'in_maintenance_mode'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'node_ip'] = opts[:'node_ip'] if !opts[:'node_ip'].nil?
      query_params[:'node_types'] = opts[:'node_types'] if !opts[:'node_types'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'transport_zone_path'] = opts[:'transport_zone_path'] if !opts[:'transport_zone_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'HostTransportNodeListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_host_transport_nodes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List transport nodes by realized state
    # Returns a list of transport node states that have realized state as provided as query parameter. If this API is called multiple times in parallel then it will fail with error indicating that another request is already in progress. In such case, try the API on another NSX manager instance (if exists) or try again after some time. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :mm_state maintenance mode state
    # @option opts [String] :status Realized state of transport nodes
    # @option opts [String] :vtep_ip Virtual tunnel endpoint ip address of transport node
    # @return [TransportNodeStateListResult]
    def list_host_transport_nodes_by_state(site_id, enforcementpoint_id, opts = {})
      data, _status_code, _headers = list_host_transport_nodes_by_state_with_http_info(site_id, enforcementpoint_id, opts)
      data
    end

    # List transport nodes by realized state
    # Returns a list of transport node states that have realized state as provided as query parameter. If this API is called multiple times in parallel then it will fail with error indicating that another request is already in progress. In such case, try the API on another NSX manager instance (if exists) or try again after some time. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :mm_state maintenance mode state
    # @option opts [String] :status Realized state of transport nodes
    # @option opts [String] :vtep_ip Virtual tunnel endpoint ip address of transport node
    # @return [Array<(TransportNodeStateListResult, Fixnum, Hash)>] TransportNodeStateListResult data, response status code and response headers
    def list_host_transport_nodes_by_state_with_http_info(site_id, enforcementpoint_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_host_transport_nodes_by_state ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.list_host_transport_nodes_by_state"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.list_host_transport_nodes_by_state"
      end
      if @api_client.config.client_side_validation && opts[:'mm_state'] && !['ENTERING', 'ENABLED', 'EXITING', 'DISABLED'].include?(opts[:'mm_state'])
        fail ArgumentError, 'invalid value for "mm_state", must be one of ENTERING, ENABLED, EXITING, DISABLED'
      end
      if @api_client.config.client_side_validation && opts[:'status'] && !['PENDING', 'IN_PROGRESS', 'SUCCESS', 'PARTIAL_SUCCESS', 'FAILED', 'ORPHANED'].include?(opts[:'status'])
        fail ArgumentError, 'invalid value for "status", must be one of PENDING, IN_PROGRESS, SUCCESS, PARTIAL_SUCCESS, FAILED, ORPHANED'
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/state'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'mm_state'] = opts[:'mm_state'] if !opts[:'mm_state'].nil?
      query_params[:'status'] = opts[:'status'] if !opts[:'status'].nil?
      query_params[:'vtep_ip'] = opts[:'vtep_ip'] if !opts[:'vtep_ip'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNodeStateListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_host_transport_nodes_by_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List LDAP identity sources
    # Return a list of all configured LDAP identity sources.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [LdapIdentitySourceListResult]
    def list_ldap_identity_sources(opts = {})
      data, _status_code, _headers = list_ldap_identity_sources_with_http_info(opts)
      data
    end

    # List LDAP identity sources
    # Return a list of all configured LDAP identity sources.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(LdapIdentitySourceListResult, Fixnum, Hash)>] LdapIdentitySourceListResult data, response status code and response headers
    def list_ldap_identity_sources_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_ldap_identity_sources ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_ldap_identity_sources, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_ldap_identity_sources, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/aaa/ldap-identity-sources'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LdapIdentitySourceListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_ldap_identity_sources\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Hostswitch Profiles
    # Returns information about the configured hostswitch profiles. Hostswitch profiles define networking policies for hostswitches (sometimes referred to as bridges in OVS). Currently, following profiles are supported. UplinkHostSwitchProfile, LldpHostSwitchProfile, NiocProfile & ExtraConfigHostSwitchProfile. Uplink profile - teaming defined in this profile allows NSX to load balance traffic across different physical NICs (PNICs) on the hypervisor hosts. Multiple teaming policies are supported, including LACP active, LACP passive, load balancing based on source ID, and failover order. Lldp profile - Activate or deactivate sending LLDP packets NiocProfile - Network I/O Control settings: defines limits, shares and reservations for various host traffic types. ExtraConfig - Vendor specific configuration on HostSwitch, logical switch or logical port 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :deployment_type Supported edge deployment type.
    # @option opts [String] :hostswitch_profile_type Supported HostSwitch profiles.
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [BOOLEAN] :include_system_owned Whether the list result contains system resources (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :max_active_uplink_count Filter uplink profiles by number of active links in teaming policy.
    # @option opts [String] :node_type Fabric node type for which uplink profiles are to be listed
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :uplink_teaming_policy_name The host switch profile&#39;s uplink teaming policy name
    # @return [PolicyHostSwitchProfilesListResult]
    def list_policy_host_switch_profiles(opts = {})
      data, _status_code, _headers = list_policy_host_switch_profiles_with_http_info(opts)
      data
    end

    # List Hostswitch Profiles
    # Returns information about the configured hostswitch profiles. Hostswitch profiles define networking policies for hostswitches (sometimes referred to as bridges in OVS). Currently, following profiles are supported. UplinkHostSwitchProfile, LldpHostSwitchProfile, NiocProfile &amp; ExtraConfigHostSwitchProfile. Uplink profile - teaming defined in this profile allows NSX to load balance traffic across different physical NICs (PNICs) on the hypervisor hosts. Multiple teaming policies are supported, including LACP active, LACP passive, load balancing based on source ID, and failover order. Lldp profile - Activate or deactivate sending LLDP packets NiocProfile - Network I/O Control settings: defines limits, shares and reservations for various host traffic types. ExtraConfig - Vendor specific configuration on HostSwitch, logical switch or logical port 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :deployment_type Supported edge deployment type.
    # @option opts [String] :hostswitch_profile_type Supported HostSwitch profiles.
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [BOOLEAN] :include_system_owned Whether the list result contains system resources
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :max_active_uplink_count Filter uplink profiles by number of active links in teaming policy.
    # @option opts [String] :node_type Fabric node type for which uplink profiles are to be listed
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :uplink_teaming_policy_name The host switch profile&#39;s uplink teaming policy name
    # @return [Array<(PolicyHostSwitchProfilesListResult, Fixnum, Hash)>] PolicyHostSwitchProfilesListResult data, response status code and response headers
    def list_policy_host_switch_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_policy_host_switch_profiles ...'
      end
      if @api_client.config.client_side_validation && opts[:'deployment_type'] && !['VIRTUAL_MACHINE', 'PHYSICAL_MACHINE', 'UNKNOWN'].include?(opts[:'deployment_type'])
        fail ArgumentError, 'invalid value for "deployment_type", must be one of VIRTUAL_MACHINE, PHYSICAL_MACHINE, UNKNOWN'
      end
      if @api_client.config.client_side_validation && opts[:'hostswitch_profile_type'] && !['PolicyUplinkHostSwitchProfile', 'PolicyLldpHostSwitchProfile', 'PolicyNiocProfile', 'PolicyExtraConfigHostSwitchProfile', 'PolicyVtepHAHostSwitchProfile', 'PolicyHighPerformanceHostSwitchProfile'].include?(opts[:'hostswitch_profile_type'])
        fail ArgumentError, 'invalid value for "hostswitch_profile_type", must be one of PolicyUplinkHostSwitchProfile, PolicyLldpHostSwitchProfile, PolicyNiocProfile, PolicyExtraConfigHostSwitchProfile, PolicyVtepHAHostSwitchProfile, PolicyHighPerformanceHostSwitchProfile'
      end
      if @api_client.config.client_side_validation && opts[:'node_type'] && !['EdgeNode', 'PublicCloudGatewayNode'].include?(opts[:'node_type'])
        fail ArgumentError, 'invalid value for "node_type", must be one of EdgeNode, PublicCloudGatewayNode'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_policy_host_switch_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_policy_host_switch_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/host-switch-profiles'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'deployment_type'] = opts[:'deployment_type'] if !opts[:'deployment_type'].nil?
      query_params[:'hostswitch_profile_type'] = opts[:'hostswitch_profile_type'] if !opts[:'hostswitch_profile_type'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'include_system_owned'] = opts[:'include_system_owned'] if !opts[:'include_system_owned'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'max_active_uplink_count'] = opts[:'max_active_uplink_count'] if !opts[:'max_active_uplink_count'].nil?
      query_params[:'node_type'] = opts[:'node_type'] if !opts[:'node_type'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'uplink_teaming_policy_name'] = opts[:'uplink_teaming_policy_name'] if !opts[:'uplink_teaming_policy_name'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyHostSwitchProfilesListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_policy_host_switch_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Host Transport Nodes
    # Returns information about all host transport node profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PolicyHostTransportNodeProfileListResult]
    def list_policy_host_transport_node_profiles(opts = {})
      data, _status_code, _headers = list_policy_host_transport_node_profiles_with_http_info(opts)
      data
    end

    # List Host Transport Nodes
    # Returns information about all host transport node profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PolicyHostTransportNodeProfileListResult, Fixnum, Hash)>] PolicyHostTransportNodeProfileListResult data, response status code and response headers
    def list_policy_host_transport_node_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_policy_host_transport_node_profiles ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_policy_host_transport_node_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_policy_host_transport_node_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/host-transport-node-profiles'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyHostTransportNodeProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_policy_host_transport_node_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List resources for a given instruction, to be shown to/executed by users. 
    # For restore operations requiring user input e.g. performing an action, accepting/rejecting an action, etc. the information to be conveyed to users is provided in this call. 
    # @param instruction_id Id of the instruction set whose instructions are to be returned
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [ActionableResourceListResult]
    def list_restore_instruction_resources(instruction_id, opts = {})
      data, _status_code, _headers = list_restore_instruction_resources_with_http_info(instruction_id, opts)
      data
    end

    # List resources for a given instruction, to be shown to/executed by users. 
    # For restore operations requiring user input e.g. performing an action, accepting/rejecting an action, etc. the information to be conveyed to users is provided in this call. 
    # @param instruction_id Id of the instruction set whose instructions are to be returned
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(ActionableResourceListResult, Fixnum, Hash)>] ActionableResourceListResult data, response status code and response headers
    def list_restore_instruction_resources_with_http_info(instruction_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_restore_instruction_resources ...'
      end
      # verify the required parameter 'instruction_id' is set
      if @api_client.config.client_side_validation && instruction_id.nil?
        fail ArgumentError, "Missing the required parameter 'instruction_id' when calling SystemAdministrationApi.list_restore_instruction_resources"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_restore_instruction_resources, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_restore_instruction_resources, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/cluster/restore/instruction-resources'

      # query parameters
      query_params = {}
      query_params[:'instruction_id'] = instruction_id
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ActionableResourceListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_restore_instruction_resources\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get all users and groups with their roles
    # Get all users and groups with their roles from CSP. If the root_path is provided then only return role bindings that start-with or are sub-trees of the provided root path. Also filter the roles_for_paths such that only those roles_for_paths appear that start-with or are sub-tree of the provided root path. 
    # @param org_id 
    # @param project_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :identity_source_id Identity source ID
    # @option opts [String] :identity_source_type Identity source type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :name User/Group name
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :path Exact path of the context
    # @option opts [String] :role Role ID
    # @option opts [String] :root_path Prefix path of the context
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type
    # @return [RoleBindingListResult]
    def list_role_bindings_multitenancy_project(org_id, project_id, opts = {})
      data, _status_code, _headers = list_role_bindings_multitenancy_project_with_http_info(org_id, project_id, opts)
      data
    end

    # Get all users and groups with their roles
    # Get all users and groups with their roles from CSP. If the root_path is provided then only return role bindings that start-with or are sub-trees of the provided root path. Also filter the roles_for_paths such that only those roles_for_paths appear that start-with or are sub-tree of the provided root path. 
    # @param org_id 
    # @param project_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :identity_source_id Identity source ID
    # @option opts [String] :identity_source_type Identity source type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :name User/Group name
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :path Exact path of the context
    # @option opts [String] :role Role ID
    # @option opts [String] :root_path Prefix path of the context
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type
    # @return [Array<(RoleBindingListResult, Fixnum, Hash)>] RoleBindingListResult data, response status code and response headers
    def list_role_bindings_multitenancy_project_with_http_info(org_id, project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_role_bindings_multitenancy_project ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SystemAdministrationApi.list_role_bindings_multitenancy_project"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SystemAdministrationApi.list_role_bindings_multitenancy_project"
      end
      if @api_client.config.client_side_validation && opts[:'identity_source_type'] && !['VIDM', 'LDAP', 'OIDC'].include?(opts[:'identity_source_type'])
        fail ArgumentError, 'invalid value for "identity_source_type", must be one of VIDM, LDAP, OIDC'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_role_bindings_multitenancy_project, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_role_bindings_multitenancy_project, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['remote_user', 'remote_group', 'local_user', 'principal_identity'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of remote_user, remote_group, local_user, principal_identity'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/aaa/role-bindings'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'identity_source_id'] = opts[:'identity_source_id'] if !opts[:'identity_source_id'].nil?
      query_params[:'identity_source_type'] = opts[:'identity_source_type'] if !opts[:'identity_source_type'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'path'] = opts[:'path'] if !opts[:'path'].nil?
      query_params[:'role'] = opts[:'role'] if !opts[:'role'].nil?
      query_params[:'root_path'] = opts[:'root_path'] if !opts[:'root_path'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoleBindingListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_role_bindings_multitenancy_project\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get all users and groups with their roles
    # Get all users and groups with their roles from CSP. If the root_path is provided then only return role bindings that start-with or are sub-trees of the provided root path. Also filter the roles_for_paths such that only those roles_for_paths appear that start-with or are sub-tree of the provided root path. 
    # @param org_id 
    # @param project_id 
    # @param vpc_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :identity_source_id Identity source ID
    # @option opts [String] :identity_source_type Identity source type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :name User/Group name
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :path Exact path of the context
    # @option opts [String] :role Role ID
    # @option opts [String] :root_path Prefix path of the context
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type
    # @return [RoleBindingListResult]
    def list_role_bindings_multitenancy_vpc(org_id, project_id, vpc_id, opts = {})
      data, _status_code, _headers = list_role_bindings_multitenancy_vpc_with_http_info(org_id, project_id, vpc_id, opts)
      data
    end

    # Get all users and groups with their roles
    # Get all users and groups with their roles from CSP. If the root_path is provided then only return role bindings that start-with or are sub-trees of the provided root path. Also filter the roles_for_paths such that only those roles_for_paths appear that start-with or are sub-tree of the provided root path. 
    # @param org_id 
    # @param project_id 
    # @param vpc_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :identity_source_id Identity source ID
    # @option opts [String] :identity_source_type Identity source type
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :name User/Group name
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :path Exact path of the context
    # @option opts [String] :role Role ID
    # @option opts [String] :root_path Prefix path of the context
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type
    # @return [Array<(RoleBindingListResult, Fixnum, Hash)>] RoleBindingListResult data, response status code and response headers
    def list_role_bindings_multitenancy_vpc_with_http_info(org_id, project_id, vpc_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_role_bindings_multitenancy_vpc ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SystemAdministrationApi.list_role_bindings_multitenancy_vpc"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SystemAdministrationApi.list_role_bindings_multitenancy_vpc"
      end
      # verify the required parameter 'vpc_id' is set
      if @api_client.config.client_side_validation && vpc_id.nil?
        fail ArgumentError, "Missing the required parameter 'vpc_id' when calling SystemAdministrationApi.list_role_bindings_multitenancy_vpc"
      end
      if @api_client.config.client_side_validation && opts[:'identity_source_type'] && !['VIDM', 'LDAP', 'OIDC'].include?(opts[:'identity_source_type'])
        fail ArgumentError, 'invalid value for "identity_source_type", must be one of VIDM, LDAP, OIDC'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_role_bindings_multitenancy_vpc, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_role_bindings_multitenancy_vpc, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['remote_user', 'remote_group', 'local_user', 'principal_identity'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of remote_user, remote_group, local_user, principal_identity'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/vpcs/{vpc-id}/aaa/role-bindings'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'vpc-id' + '}', vpc_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'identity_source_id'] = opts[:'identity_source_id'] if !opts[:'identity_source_id'].nil?
      query_params[:'identity_source_type'] = opts[:'identity_source_type'] if !opts[:'identity_source_type'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'path'] = opts[:'path'] if !opts[:'path'].nil?
      query_params[:'role'] = opts[:'role'] if !opts[:'role'].nil?
      query_params[:'root_path'] = opts[:'root_path'] if !opts[:'root_path'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoleBindingListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_role_bindings_multitenancy_vpc\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get information about all roles with features and their permissions
    # Get information about all roles with features and their permissions
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [RoleWithFeaturesListResult]
    def list_roles_info(opts = {})
      data, _status_code, _headers = list_roles_info_with_http_info(opts)
      data
    end

    # Get information about all roles with features and their permissions
    # Get information about all roles with features and their permissions
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(RoleWithFeaturesListResult, Fixnum, Hash)>] RoleWithFeaturesListResult data, response status code and response headers
    def list_roles_info_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_roles_info ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_roles_info, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_roles_info, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/aaa/roles-with-feature-permissions'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoleWithFeaturesListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_roles_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get information about all roles
    # Get information about all roles
    # @param org_id 
    # @param project_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :scope List only the roles which are applicable for this scope.
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [RoleListResult]
    def list_roles_of_org_multitenancy_project(org_id, project_id, opts = {})
      data, _status_code, _headers = list_roles_of_org_multitenancy_project_with_http_info(org_id, project_id, opts)
      data
    end

    # Get information about all roles
    # Get information about all roles
    # @param org_id 
    # @param project_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :scope List only the roles which are applicable for this scope.
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(RoleListResult, Fixnum, Hash)>] RoleListResult data, response status code and response headers
    def list_roles_of_org_multitenancy_project_with_http_info(org_id, project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_roles_of_org_multitenancy_project ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SystemAdministrationApi.list_roles_of_org_multitenancy_project"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SystemAdministrationApi.list_roles_of_org_multitenancy_project"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_roles_of_org_multitenancy_project, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_roles_of_org_multitenancy_project, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'scope'] && !['ROOT', 'ORG', 'PROJECT', 'VPC'].include?(opts[:'scope'])
        fail ArgumentError, 'invalid value for "scope", must be one of ROOT, ORG, PROJECT, VPC'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/aaa/roles'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'scope'] = opts[:'scope'] if !opts[:'scope'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoleListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_roles_of_org_multitenancy_project\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get information about all roles
    # Get information about all roles
    # @param org_id 
    # @param project_id 
    # @param vpc_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :scope List only the roles which are applicable for this scope.
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [RoleListResult]
    def list_roles_of_org_multitenancy_vpc(org_id, project_id, vpc_id, opts = {})
      data, _status_code, _headers = list_roles_of_org_multitenancy_vpc_with_http_info(org_id, project_id, vpc_id, opts)
      data
    end

    # Get information about all roles
    # Get information about all roles
    # @param org_id 
    # @param project_id 
    # @param vpc_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :scope List only the roles which are applicable for this scope.
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(RoleListResult, Fixnum, Hash)>] RoleListResult data, response status code and response headers
    def list_roles_of_org_multitenancy_vpc_with_http_info(org_id, project_id, vpc_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_roles_of_org_multitenancy_vpc ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SystemAdministrationApi.list_roles_of_org_multitenancy_vpc"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SystemAdministrationApi.list_roles_of_org_multitenancy_vpc"
      end
      # verify the required parameter 'vpc_id' is set
      if @api_client.config.client_side_validation && vpc_id.nil?
        fail ArgumentError, "Missing the required parameter 'vpc_id' when calling SystemAdministrationApi.list_roles_of_org_multitenancy_vpc"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_roles_of_org_multitenancy_vpc, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_roles_of_org_multitenancy_vpc, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'scope'] && !['ROOT', 'ORG', 'PROJECT', 'VPC'].include?(opts[:'scope'])
        fail ArgumentError, 'invalid value for "scope", must be one of ROOT, ORG, PROJECT, VPC'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/vpcs/{vpc-id}/aaa/roles'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'vpc-id' + '}', vpc_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'scope'] = opts[:'scope'] if !opts[:'scope'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoleListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_roles_of_org_multitenancy_vpc\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List sub-clusters
    # Paginated list of all sub-clusters. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SubClusterListResult]
    def list_sub_clusters(site_id, enforcementpoint_id, opts = {})
      data, _status_code, _headers = list_sub_clusters_with_http_info(site_id, enforcementpoint_id, opts)
      data
    end

    # List sub-clusters
    # Paginated list of all sub-clusters. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SubClusterListResult, Fixnum, Hash)>] SubClusterListResult data, response status code and response headers
    def list_sub_clusters_with_http_info(site_id, enforcementpoint_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_sub_clusters ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.list_sub_clusters"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.list_sub_clusters"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_sub_clusters, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_sub_clusters, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/sub-clusters'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SubClusterListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_sub_clusters\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get information about all tasks
    # Get information about all tasks
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :request_uri Request URI(s) to include in query result
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :status Status(es) to include in query result
    # @option opts [String] :user Names of users to include in query result
    # @return [TaskListResult]
    def list_tasks(opts = {})
      data, _status_code, _headers = list_tasks_with_http_info(opts)
      data
    end

    # Get information about all tasks
    # Get information about all tasks
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :request_uri Request URI(s) to include in query result
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :status Status(es) to include in query result
    # @option opts [String] :user Names of users to include in query result
    # @return [Array<(TaskListResult, Fixnum, Hash)>] TaskListResult data, response status code and response headers
    def list_tasks_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_tasks ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_tasks, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_tasks, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/tasks'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'request_uri'] = opts[:'request_uri'] if !opts[:'request_uri'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'status'] = opts[:'status'] if !opts[:'status'].nil?
      query_params[:'user'] = opts[:'user'] if !opts[:'user'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TaskListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_tasks\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all TransportNode VTEP actions' status
    # List all VTEP actions' status for a particular TransportNode. If some action status is missing in the response, that indicates the action has completed successfully. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [TransportNodeVtepActionsStatusListResult]
    def list_transport_node_vtep_actions_status(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      data, _status_code, _headers = list_transport_node_vtep_actions_status_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      data
    end

    # List all TransportNode VTEP actions&#39; status
    # List all VTEP actions&#39; status for a particular TransportNode. If some action status is missing in the response, that indicates the action has completed successfully. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransportNodeVtepActionsStatusListResult, Fixnum, Hash)>] TransportNodeVtepActionsStatusListResult data, response status code and response headers
    def list_transport_node_vtep_actions_status_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_transport_node_vtep_actions_status ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.list_transport_node_vtep_actions_status"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.list_transport_node_vtep_actions_status"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling SystemAdministrationApi.list_transport_node_vtep_actions_status"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}/vteps/actions/status'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNodeVtepActionsStatusListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_transport_node_vtep_actions_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Fetch Discovered VIF State on given TransportNode
    # For the given TransportNode, fetch all the VIF info from VC and return the corresponding state. Only host switch configured for security will be considered. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :host_switch_id VDS identifier
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :segment_id Segment identifier
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [DiscoveredVifStateListResult]
    def list_vds_vifs_on_transport_node(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      data, _status_code, _headers = list_vds_vifs_on_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      data
    end

    # Fetch Discovered VIF State on given TransportNode
    # For the given TransportNode, fetch all the VIF info from VC and return the corresponding state. Only host switch configured for security will be considered. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :host_switch_id VDS identifier
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :segment_id Segment identifier
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(DiscoveredVifStateListResult, Fixnum, Hash)>] DiscoveredVifStateListResult data, response status code and response headers
    def list_vds_vifs_on_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_vds_vifs_on_transport_node ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.list_vds_vifs_on_transport_node"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.list_vds_vifs_on_transport_node"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling SystemAdministrationApi.list_vds_vifs_on_transport_node"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_vds_vifs_on_transport_node, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SystemAdministrationApi.list_vds_vifs_on_transport_node, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}/discovered-vifs'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'host_switch_id'] = opts[:'host_switch_id'] if !opts[:'host_switch_id'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'segment_id'] = opts[:'segment_id'] if !opts[:'segment_id'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DiscoveredVifStateListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_vds_vifs_on_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns the Views based on query criteria defined in ViewQueryParameters.
    # If no query params are specified then all the views entitled for the user are returned. The views to which a user is entitled to include the views created by the user and the shared views.  <br> This API is deprecated and will be unavailable in later releases.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :tag The tag for which associated views to be queried.
    # @option opts [String] :view_ids Ids of the Views
    # @option opts [String] :widget_id Id of widget configuration
    # @return [ViewList]
    def list_views(opts = {})
      data, _status_code, _headers = list_views_with_http_info(opts)
      data
    end

    # Returns the Views based on query criteria defined in ViewQueryParameters.
    # If no query params are specified then all the views entitled for the user are returned. The views to which a user is entitled to include the views created by the user and the shared views.  &lt;br&gt; This API is deprecated and will be unavailable in later releases.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :tag The tag for which associated views to be queried.
    # @option opts [String] :view_ids Ids of the Views
    # @option opts [String] :widget_id Id of widget configuration
    # @return [Array<(ViewList, Fixnum, Hash)>] ViewList data, response status code and response headers
    def list_views_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_views ...'
      end
      if @api_client.config.client_side_validation && !opts[:'view_ids'].nil? && opts[:'view_ids'].to_s.length > 8192
        fail ArgumentError, 'invalid value for "opts[:"view_ids"]" when calling SystemAdministrationApi.list_views, the character length must be smaller than or equal to 8192.'
      end

      if @api_client.config.client_side_validation && !opts[:'widget_id'].nil? && opts[:'widget_id'].to_s.length > 255
        fail ArgumentError, 'invalid value for "opts[:"widget_id"]" when calling SystemAdministrationApi.list_views, the character length must be smaller than or equal to 255.'
      end

      # resource path
      local_var_path = '/ui-views'

      # query parameters
      query_params = {}
      query_params[:'tag'] = opts[:'tag'] if !opts[:'tag'].nil?
      query_params[:'view_ids'] = opts[:'view_ids'] if !opts[:'view_ids'].nil?
      query_params[:'widget_id'] = opts[:'widget_id'] if !opts[:'widget_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ViewList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_views\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns the Widget Configurations based on query criteria defined in WidgetQueryParameters.
    # If no query params are specified then all the Widget Configurations of the specified view are returned.  <br> This API is deprecated and will be unavailable in later releases.
    # @param view_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :container Id of the container
    # @option opts [String] :widget_ids Ids of the WidgetConfigurations
    # @return [WidgetConfigurationList]
    def list_widget_configurations(view_id, opts = {})
      data, _status_code, _headers = list_widget_configurations_with_http_info(view_id, opts)
      data
    end

    # Returns the Widget Configurations based on query criteria defined in WidgetQueryParameters.
    # If no query params are specified then all the Widget Configurations of the specified view are returned.  &lt;br&gt; This API is deprecated and will be unavailable in later releases.
    # @param view_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :container Id of the container
    # @option opts [String] :widget_ids Ids of the WidgetConfigurations
    # @return [Array<(WidgetConfigurationList, Fixnum, Hash)>] WidgetConfigurationList data, response status code and response headers
    def list_widget_configurations_with_http_info(view_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.list_widget_configurations ...'
      end
      # verify the required parameter 'view_id' is set
      if @api_client.config.client_side_validation && view_id.nil?
        fail ArgumentError, "Missing the required parameter 'view_id' when calling SystemAdministrationApi.list_widget_configurations"
      end
      if @api_client.config.client_side_validation && !opts[:'container'].nil? && opts[:'container'].to_s.length > 255
        fail ArgumentError, 'invalid value for "opts[:"container"]" when calling SystemAdministrationApi.list_widget_configurations, the character length must be smaller than or equal to 255.'
      end

      if @api_client.config.client_side_validation && !opts[:'widget_ids'].nil? && opts[:'widget_ids'].to_s.length > 8192
        fail ArgumentError, 'invalid value for "opts[:"widget_ids"]" when calling SystemAdministrationApi.list_widget_configurations, the character length must be smaller than or equal to 8192.'
      end

      # resource path
      local_var_path = '/ui-views/{view-id}/widgetconfigurations'.sub('{' + 'view-id' + '}', view_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'container'] = opts[:'container'] if !opts[:'container'].nil?
      query_params[:'widget_ids'] = opts[:'widget_ids'] if !opts[:'widget_ids'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'WidgetConfigurationList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#list_widget_configurations\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Registration status
    # Registration status.
    # @param [Hash] opts the optional parameters
    # @return [MalwarePreventionTeaserRegistrationStatus]
    def malware_prevention_teaser_check_status(opts = {})
      data, _status_code, _headers = malware_prevention_teaser_check_status_with_http_info(opts)
      data
    end

    # Registration status
    # Registration status.
    # @param [Hash] opts the optional parameters
    # @return [Array<(MalwarePreventionTeaserRegistrationStatus, Fixnum, Hash)>] MalwarePreventionTeaserRegistrationStatus data, response status code and response headers
    def malware_prevention_teaser_check_status_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.malware_prevention_teaser_check_status ...'
      end
      # resource path
      local_var_path = '/malware-prevention/teaser/status'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MalwarePreventionTeaserRegistrationStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#malware_prevention_teaser_check_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List available regions
    # List available regions.
    # @param [Hash] opts the optional parameters
    # @return [MalwarePreventionTeaserRegionsListResult]
    def malware_prevention_teaser_list_regions(opts = {})
      data, _status_code, _headers = malware_prevention_teaser_list_regions_with_http_info(opts)
      data
    end

    # List available regions
    # List available regions.
    # @param [Hash] opts the optional parameters
    # @return [Array<(MalwarePreventionTeaserRegionsListResult, Fixnum, Hash)>] MalwarePreventionTeaserRegionsListResult data, response status code and response headers
    def malware_prevention_teaser_list_regions_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.malware_prevention_teaser_list_regions ...'
      end
      # resource path
      local_var_path = '/malware-prevention/teaser/regions'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MalwarePreventionTeaserRegionsListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#malware_prevention_teaser_list_regions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get health stats for policy and the dependent services.
    # Get health stats for policy and the dependent services. 
    # @param [Hash] opts the optional parameters
    # @return [Object]
    def management_plane_health(opts = {})
      data, _status_code, _headers = management_plane_health_with_http_info(opts)
      data
    end

    # Get health stats for policy and the dependent services.
    # Get health stats for policy and the dependent services. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Object, Fixnum, Hash)>] Object data, response status code and response headers
    def management_plane_health_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.management_plane_health ...'
      end
      # resource path
      local_var_path = '/management-plane-health'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Object')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#management_plane_health\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Move host from one sub-cluster to another sub-cluster. When a node is moved from one sub-cluster to another sub-cluster, based on the TransportNodeCollection configuration appropriate sub-configuration will be applied to the node. If TransportNodeCollection does not have sub-configurations for the sub-cluster, then global configuration will be applied. 
    # Move host from one sub-cluster to another sub-cluster. When a node is moved from one sub-cluster to another sub-cluster, based on the TransportNodeCollection configuration appropriate sub-configuration will be applied to the node. If TransportNodeCollection does not have sub-configurations for the sub-cluster, then global configuration will be applied. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_movement_spec 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def move_hosts(site_id, enforcementpoint_id, host_movement_spec, opts = {})
      move_hosts_with_http_info(site_id, enforcementpoint_id, host_movement_spec, opts)
      nil
    end

    # Move host from one sub-cluster to another sub-cluster. When a node is moved from one sub-cluster to another sub-cluster, based on the TransportNodeCollection configuration appropriate sub-configuration will be applied to the node. If TransportNodeCollection does not have sub-configurations for the sub-cluster, then global configuration will be applied. 
    # Move host from one sub-cluster to another sub-cluster. When a node is moved from one sub-cluster to another sub-cluster, based on the TransportNodeCollection configuration appropriate sub-configuration will be applied to the node. If TransportNodeCollection does not have sub-configurations for the sub-cluster, then global configuration will be applied. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_movement_spec 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def move_hosts_with_http_info(site_id, enforcementpoint_id, host_movement_spec, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.move_hosts ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.move_hosts"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.move_hosts"
      end
      # verify the required parameter 'host_movement_spec' is set
      if @api_client.config.client_side_validation && host_movement_spec.nil?
        fail ArgumentError, "Missing the required parameter 'host_movement_spec' when calling SystemAdministrationApi.move_hosts"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/sub-clusters?action=move'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(host_movement_spec)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#move_hosts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Upgrade all VMs part of this service deployment to new OVF specification on the given datastore.
    # If new deployment specification is provided, the deployment will be moved to the provided specification provided that current deployment state is either UPGRADE_FAILED or DEPLOYMENT_SUCCESSFUL If same deployment specification is provided, upgrade will be done only if current deployment state is UPGRADE_FAILED If the existing data store is upgraded or changed, there is an optional parameter to supply the new storage Id during upgrade which would perform the deployment upgrade on the new data store 
    # @param compute_collection_id 
    # @param mps_svm_new_appliance_spec 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def mps_change_appliance(compute_collection_id, mps_svm_new_appliance_spec, opts = {})
      mps_change_appliance_with_http_info(compute_collection_id, mps_svm_new_appliance_spec, opts)
      nil
    end

    # Upgrade all VMs part of this service deployment to new OVF specification on the given datastore.
    # If new deployment specification is provided, the deployment will be moved to the provided specification provided that current deployment state is either UPGRADE_FAILED or DEPLOYMENT_SUCCESSFUL If same deployment specification is provided, upgrade will be done only if current deployment state is UPGRADE_FAILED If the existing data store is upgraded or changed, there is an optional parameter to supply the new storage Id during upgrade which would perform the deployment upgrade on the new data store 
    # @param compute_collection_id 
    # @param mps_svm_new_appliance_spec 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def mps_change_appliance_with_http_info(compute_collection_id, mps_svm_new_appliance_spec, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.mps_change_appliance ...'
      end
      # verify the required parameter 'compute_collection_id' is set
      if @api_client.config.client_side_validation && compute_collection_id.nil?
        fail ArgumentError, "Missing the required parameter 'compute_collection_id' when calling SystemAdministrationApi.mps_change_appliance"
      end
      # verify the required parameter 'mps_svm_new_appliance_spec' is set
      if @api_client.config.client_side_validation && mps_svm_new_appliance_spec.nil?
        fail ArgumentError, "Missing the required parameter 'mps_svm_new_appliance_spec' when calling SystemAdministrationApi.mps_change_appliance"
      end
      # resource path
      local_var_path = '/malware-prevention/compute-collection/{compute-collection-id}/svm-deployment/action/change-appliance'.sub('{' + 'compute-collection-id' + '}', compute_collection_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(mps_svm_new_appliance_spec)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#mps_change_appliance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch the Antrea heartbeat configuration
    # Patch the Antrea heartbeat configuration
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param antrea_heartbeat_config 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_antrea_heartbeat_config(site_id, enforcementpoint_id, cluster_control_plane_id, antrea_heartbeat_config, opts = {})
      patch_antrea_heartbeat_config_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, antrea_heartbeat_config, opts)
      nil
    end

    # Patch the Antrea heartbeat configuration
    # Patch the Antrea heartbeat configuration
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param antrea_heartbeat_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_antrea_heartbeat_config_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, antrea_heartbeat_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.patch_antrea_heartbeat_config ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.patch_antrea_heartbeat_config"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.patch_antrea_heartbeat_config"
      end
      # verify the required parameter 'cluster_control_plane_id' is set
      if @api_client.config.client_side_validation && cluster_control_plane_id.nil?
        fail ArgumentError, "Missing the required parameter 'cluster_control_plane_id' when calling SystemAdministrationApi.patch_antrea_heartbeat_config"
      end
      # verify the required parameter 'antrea_heartbeat_config' is set
      if @api_client.config.client_side_validation && antrea_heartbeat_config.nil?
        fail ArgumentError, "Missing the required parameter 'antrea_heartbeat_config' when calling SystemAdministrationApi.patch_antrea_heartbeat_config"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/cluster-control-planes/{cluster-control-plane-id}/heartbeat-config'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'cluster-control-plane-id' + '}', cluster_control_plane_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(antrea_heartbeat_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#patch_antrea_heartbeat_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch a Host Transport Node
    # Transport nodes are hypervisor hosts that will participate in an NSX-T overlay. For a hypervisor host, this means that it hosts VMs that will communicate over NSX-T logical switches.  This API creates transport node for a host node (hypervisor) in the transport network.  When you run this command for a host, NSX Manager attempts to install the NSX kernel modules, which are packaged as VIB, RPM, or DEB files. For the installation to succeed, you must provide the host login credentials and the host thumbprint.  To get the ESXi host thumbprint, SSH to the host and run the <b>openssl x509 -in /etc/vmware/ssl/rui.crt -fingerprint -sha256 -noout</b> command.  To generate host key thumbprint using SHA-256 algorithm please follow the steps below.  Log into the host, making sure that the connection is not vulnerable to a man in the middle attack. Check whether a public key already exists. Host public key is generally located at '/etc/ssh/ssh_host_rsa_key.pub'. If the key is not present then generate a new key by running the following command and follow the instructions.  <b>ssh-keygen -t rsa</b>  Now generate a SHA256 hash of the key using the following command. Please make sure to pass the appropriate file name if the public key is stored with a different file name other than the default 'id_rsa.pub'.  <b>awk '{print $2}' id_rsa.pub | base64 -d | sha256sum -b | sed 's/ .*$//' | xxd -r -p | base64</b>  Additional documentation on creating a transport node can be found in the NSX-T Installation Guide.  In order for the transport node to forward packets, the host_switch_spec property must be specified.  Host switches (called bridges in OVS on KVM hypervisors) are the individual switches within the host virtual switch. Virtual machines are connected to the host switches.  When creating a transport node, you need to specify if the host switches are already manually preconfigured on the node, or if NSX should create and manage the host switches. You specify this choice by the type of host switches you pass in the host_switch_spec property of the TransportNode request payload.  For a KVM host, you can preconfigure the host switch, or you can have NSX Manager perform the configuration. For an ESXi host NSX Manager always configures the host switch.  To preconfigure the host switches on a KVM host, pass an array of PreconfiguredHostSwitchSpec objects that describes those host switches. In the current NSX-T release, only one prefonfigured host switch can be specified.  See the PreconfiguredHostSwitchSpec schema definition for documentation on the properties that must be provided. Preconfigured host switches are only supported on KVM hosts, not on ESXi hosts.  To allow NSX to manage the host switch configuration on KVM hosts, ESXi hosts, pass an array of StandardHostSwitchSpec objects in the host_switch_spec property, and NSX will automatically create host switches with the properties you provide. In the current NSX-T release, up to 16 host switches can be automatically managed. See the StandardHostSwitchSpec schema definition for documentation on the properties that must be provided.  The request should provide node_deployement_info. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param host_transport_node 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :esx_mgmt_if_migration_dest The network ids to which the ESX vmk interfaces will be migrated
    # @option opts [String] :if_id The ESX vmk interfaces to migrate
    # @option opts [BOOLEAN] :override_nsx_ownership Override NSX Ownership (default to false)
    # @option opts [String] :ping_ip IP Addresses to ping right after ESX vmk interfaces were migrated.
    # @option opts [BOOLEAN] :skip_validation Whether to skip front-end validation for vmk/vnic/pnic migration (default to false)
    # @option opts [String] :vnic The ESX vmk interfaces and/or VM NIC to migrate
    # @option opts [String] :vnic_migration_dest The migration destinations of ESX vmk interfaces and/or VM NIC
    # @return [nil]
    def patch_host_transport_node(site_id, enforcementpoint_id, host_transport_node_id, host_transport_node, opts = {})
      patch_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, host_transport_node, opts)
      nil
    end

    # Patch a Host Transport Node
    # Transport nodes are hypervisor hosts that will participate in an NSX-T overlay. For a hypervisor host, this means that it hosts VMs that will communicate over NSX-T logical switches.  This API creates transport node for a host node (hypervisor) in the transport network.  When you run this command for a host, NSX Manager attempts to install the NSX kernel modules, which are packaged as VIB, RPM, or DEB files. For the installation to succeed, you must provide the host login credentials and the host thumbprint.  To get the ESXi host thumbprint, SSH to the host and run the &lt;b&gt;openssl x509 -in /etc/vmware/ssl/rui.crt -fingerprint -sha256 -noout&lt;/b&gt; command.  To generate host key thumbprint using SHA-256 algorithm please follow the steps below.  Log into the host, making sure that the connection is not vulnerable to a man in the middle attack. Check whether a public key already exists. Host public key is generally located at &#39;/etc/ssh/ssh_host_rsa_key.pub&#39;. If the key is not present then generate a new key by running the following command and follow the instructions.  &lt;b&gt;ssh-keygen -t rsa&lt;/b&gt;  Now generate a SHA256 hash of the key using the following command. Please make sure to pass the appropriate file name if the public key is stored with a different file name other than the default &#39;id_rsa.pub&#39;.  &lt;b&gt;awk &#39;{print $2}&#39; id_rsa.pub | base64 -d | sha256sum -b | sed &#39;s/ .*$//&#39; | xxd -r -p | base64&lt;/b&gt;  Additional documentation on creating a transport node can be found in the NSX-T Installation Guide.  In order for the transport node to forward packets, the host_switch_spec property must be specified.  Host switches (called bridges in OVS on KVM hypervisors) are the individual switches within the host virtual switch. Virtual machines are connected to the host switches.  When creating a transport node, you need to specify if the host switches are already manually preconfigured on the node, or if NSX should create and manage the host switches. You specify this choice by the type of host switches you pass in the host_switch_spec property of the TransportNode request payload.  For a KVM host, you can preconfigure the host switch, or you can have NSX Manager perform the configuration. For an ESXi host NSX Manager always configures the host switch.  To preconfigure the host switches on a KVM host, pass an array of PreconfiguredHostSwitchSpec objects that describes those host switches. In the current NSX-T release, only one prefonfigured host switch can be specified.  See the PreconfiguredHostSwitchSpec schema definition for documentation on the properties that must be provided. Preconfigured host switches are only supported on KVM hosts, not on ESXi hosts.  To allow NSX to manage the host switch configuration on KVM hosts, ESXi hosts, pass an array of StandardHostSwitchSpec objects in the host_switch_spec property, and NSX will automatically create host switches with the properties you provide. In the current NSX-T release, up to 16 host switches can be automatically managed. See the StandardHostSwitchSpec schema definition for documentation on the properties that must be provided.  The request should provide node_deployement_info. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param host_transport_node 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :esx_mgmt_if_migration_dest The network ids to which the ESX vmk interfaces will be migrated
    # @option opts [String] :if_id The ESX vmk interfaces to migrate
    # @option opts [BOOLEAN] :override_nsx_ownership Override NSX Ownership
    # @option opts [String] :ping_ip IP Addresses to ping right after ESX vmk interfaces were migrated.
    # @option opts [BOOLEAN] :skip_validation Whether to skip front-end validation for vmk/vnic/pnic migration
    # @option opts [String] :vnic The ESX vmk interfaces and/or VM NIC to migrate
    # @option opts [String] :vnic_migration_dest The migration destinations of ESX vmk interfaces and/or VM NIC
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, host_transport_node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.patch_host_transport_node ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.patch_host_transport_node"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.patch_host_transport_node"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling SystemAdministrationApi.patch_host_transport_node"
      end
      # verify the required parameter 'host_transport_node' is set
      if @api_client.config.client_side_validation && host_transport_node.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node' when calling SystemAdministrationApi.patch_host_transport_node"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'esx_mgmt_if_migration_dest'] = opts[:'esx_mgmt_if_migration_dest'] if !opts[:'esx_mgmt_if_migration_dest'].nil?
      query_params[:'if_id'] = opts[:'if_id'] if !opts[:'if_id'].nil?
      query_params[:'override_nsx_ownership'] = opts[:'override_nsx_ownership'] if !opts[:'override_nsx_ownership'].nil?
      query_params[:'ping_ip'] = opts[:'ping_ip'] if !opts[:'ping_ip'].nil?
      query_params[:'skip_validation'] = opts[:'skip_validation'] if !opts[:'skip_validation'].nil?
      query_params[:'vnic'] = opts[:'vnic'] if !opts[:'vnic'].nil?
      query_params[:'vnic_migration_dest'] = opts[:'vnic_migration_dest'] if !opts[:'vnic_migration_dest'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(host_transport_node)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#patch_host_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch Transport Node collection
    # Attach different transport node profile to compute collection by updating transport node collection. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param host_transport_node_collection 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_host_transport_node_collection(site_id, enforcementpoint_id, transport_node_collection_id, host_transport_node_collection, opts = {})
      patch_host_transport_node_collection_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, host_transport_node_collection, opts)
      nil
    end

    # Patch Transport Node collection
    # Attach different transport node profile to compute collection by updating transport node collection. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param host_transport_node_collection 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_host_transport_node_collection_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, host_transport_node_collection, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.patch_host_transport_node_collection ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.patch_host_transport_node_collection"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.patch_host_transport_node_collection"
      end
      # verify the required parameter 'transport_node_collection_id' is set
      if @api_client.config.client_side_validation && transport_node_collection_id.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_collection_id' when calling SystemAdministrationApi.patch_host_transport_node_collection"
      end
      # verify the required parameter 'host_transport_node_collection' is set
      if @api_client.config.client_side_validation && host_transport_node_collection.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_collection' when calling SystemAdministrationApi.patch_host_transport_node_collection"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/transport-node-collections/{transport-node-collection-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'transport-node-collection-id' + '}', transport_node_collection_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(host_transport_node_collection)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#patch_host_transport_node_collection\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create a Event Log server for Firewall Identity store
    # More than one Event Log server can be created and only one event log server is used to synchronize directory objects. If more than one Event Log server is configured, NSX will try all the servers until it is able to successfully connect to one. 
    # @param identity_firewall_store_id Firewall Identity store identifier
    # @param event_log_server_id Event Log server identifier
    # @param identity_firewall_store_event_log_server 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @return [nil]
    def patch_or_create_firewall_identity_store_event_log_server(identity_firewall_store_id, event_log_server_id, identity_firewall_store_event_log_server, opts = {})
      patch_or_create_firewall_identity_store_event_log_server_with_http_info(identity_firewall_store_id, event_log_server_id, identity_firewall_store_event_log_server, opts)
      nil
    end

    # Create a Event Log server for Firewall Identity store
    # More than one Event Log server can be created and only one event log server is used to synchronize directory objects. If more than one Event Log server is configured, NSX will try all the servers until it is able to successfully connect to one. 
    # @param identity_firewall_store_id Firewall Identity store identifier
    # @param event_log_server_id Event Log server identifier
    # @param identity_firewall_store_event_log_server 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_or_create_firewall_identity_store_event_log_server_with_http_info(identity_firewall_store_id, event_log_server_id, identity_firewall_store_event_log_server, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.patch_or_create_firewall_identity_store_event_log_server ...'
      end
      # verify the required parameter 'identity_firewall_store_id' is set
      if @api_client.config.client_side_validation && identity_firewall_store_id.nil?
        fail ArgumentError, "Missing the required parameter 'identity_firewall_store_id' when calling SystemAdministrationApi.patch_or_create_firewall_identity_store_event_log_server"
      end
      # verify the required parameter 'event_log_server_id' is set
      if @api_client.config.client_side_validation && event_log_server_id.nil?
        fail ArgumentError, "Missing the required parameter 'event_log_server_id' when calling SystemAdministrationApi.patch_or_create_firewall_identity_store_event_log_server"
      end
      # verify the required parameter 'identity_firewall_store_event_log_server' is set
      if @api_client.config.client_side_validation && identity_firewall_store_event_log_server.nil?
        fail ArgumentError, "Missing the required parameter 'identity_firewall_store_event_log_server' when calling SystemAdministrationApi.patch_or_create_firewall_identity_store_event_log_server"
      end
      # resource path
      local_var_path = '/infra/identity-firewall-stores/{identity-firewall-store-id}/event-log-servers/{event-log-server-id}'.sub('{' + 'identity-firewall-store-id' + '}', identity_firewall_store_id.to_s).sub('{' + 'event-log-server-id' + '}', event_log_server_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(identity_firewall_store_event_log_server)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#patch_or_create_firewall_identity_store_event_log_server\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a Hostswitch Profile
    # Patch a hostswitch profile. The resource_type is required and needs to be one of the following, UplinkHostSwitchProfile, LldpHostSwitchProfile, NiocProfile & ExtraConfigHostSwitchProfile. Uplink profile - For uplink profiles, the teaming and policy parameters are required. By default, the mtu is 1600 and the transport_vlan is 0. The supported MTU range is 1280 through (uplink_mtu_threshold). uplink_mtu_threshold is 9000 by default. Range can be extended by modifying (uplink_mtu_threshold) in SwitchingGlobalConfig to the required upper threshold. Teaming defined in this profile allows NSX to load balance traffic across different physical NICs (PNICs) on the hypervisor hosts. Multiple teaming policies are supported, including LACP active, LACP passive, load balancing based on source ID, and failover order. Lldp profile - Activate or deactivate sending LLDP packets NiocProfile - Network I/O Control settings: defines limits, shares and reservations for various host traffic types. ExtraConfig - Vendor specific configuration on HostSwitch, logical switch or logical port 
    # @param host_switch_profile_id 
    # @param policy_base_host_switch_profile 
    # @param [Hash] opts the optional parameters
    # @return [PolicyBaseHostSwitchProfile]
    def patch_policy_host_switch_profile(host_switch_profile_id, policy_base_host_switch_profile, opts = {})
      data, _status_code, _headers = patch_policy_host_switch_profile_with_http_info(host_switch_profile_id, policy_base_host_switch_profile, opts)
      data
    end

    # Create or update a Hostswitch Profile
    # Patch a hostswitch profile. The resource_type is required and needs to be one of the following, UplinkHostSwitchProfile, LldpHostSwitchProfile, NiocProfile &amp; ExtraConfigHostSwitchProfile. Uplink profile - For uplink profiles, the teaming and policy parameters are required. By default, the mtu is 1600 and the transport_vlan is 0. The supported MTU range is 1280 through (uplink_mtu_threshold). uplink_mtu_threshold is 9000 by default. Range can be extended by modifying (uplink_mtu_threshold) in SwitchingGlobalConfig to the required upper threshold. Teaming defined in this profile allows NSX to load balance traffic across different physical NICs (PNICs) on the hypervisor hosts. Multiple teaming policies are supported, including LACP active, LACP passive, load balancing based on source ID, and failover order. Lldp profile - Activate or deactivate sending LLDP packets NiocProfile - Network I/O Control settings: defines limits, shares and reservations for various host traffic types. ExtraConfig - Vendor specific configuration on HostSwitch, logical switch or logical port 
    # @param host_switch_profile_id 
    # @param policy_base_host_switch_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PolicyBaseHostSwitchProfile, Fixnum, Hash)>] PolicyBaseHostSwitchProfile data, response status code and response headers
    def patch_policy_host_switch_profile_with_http_info(host_switch_profile_id, policy_base_host_switch_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.patch_policy_host_switch_profile ...'
      end
      # verify the required parameter 'host_switch_profile_id' is set
      if @api_client.config.client_side_validation && host_switch_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_switch_profile_id' when calling SystemAdministrationApi.patch_policy_host_switch_profile"
      end
      # verify the required parameter 'policy_base_host_switch_profile' is set
      if @api_client.config.client_side_validation && policy_base_host_switch_profile.nil?
        fail ArgumentError, "Missing the required parameter 'policy_base_host_switch_profile' when calling SystemAdministrationApi.patch_policy_host_switch_profile"
      end
      # resource path
      local_var_path = '/infra/host-switch-profiles/{host-switch-profile-id}'.sub('{' + 'host-switch-profile-id' + '}', host_switch_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(policy_base_host_switch_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyBaseHostSwitchProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#patch_policy_host_switch_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch Sub-Cluster
    # Patch a sub-cluster under compute collection. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param subcluster_id 
    # @param sub_cluster 
    # @param [Hash] opts the optional parameters
    # @return [SubCluster]
    def patch_sub_cluster(site_id, enforcementpoint_id, subcluster_id, sub_cluster, opts = {})
      data, _status_code, _headers = patch_sub_cluster_with_http_info(site_id, enforcementpoint_id, subcluster_id, sub_cluster, opts)
      data
    end

    # Patch Sub-Cluster
    # Patch a sub-cluster under compute collection. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param subcluster_id 
    # @param sub_cluster 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SubCluster, Fixnum, Hash)>] SubCluster data, response status code and response headers
    def patch_sub_cluster_with_http_info(site_id, enforcementpoint_id, subcluster_id, sub_cluster, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.patch_sub_cluster ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.patch_sub_cluster"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.patch_sub_cluster"
      end
      # verify the required parameter 'subcluster_id' is set
      if @api_client.config.client_side_validation && subcluster_id.nil?
        fail ArgumentError, "Missing the required parameter 'subcluster_id' when calling SystemAdministrationApi.patch_sub_cluster"
      end
      # verify the required parameter 'sub_cluster' is set
      if @api_client.config.client_side_validation && sub_cluster.nil?
        fail ArgumentError, "Missing the required parameter 'sub_cluster' when calling SystemAdministrationApi.patch_sub_cluster"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/sub-clusters/{subcluster-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'subcluster-id' + '}', subcluster_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(sub_cluster)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SubCluster')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#patch_sub_cluster\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Test the configuration of an existing LDAP identity source
    # Attempt to connect to an existing LDAP identity source and report any errors encountered.
    # @param ldap_identity_source_id 
    # @param [Hash] opts the optional parameters
    # @return [LdapIdentitySourceProbeResults]
    def probe_configured_ldap_identity_source(ldap_identity_source_id, opts = {})
      data, _status_code, _headers = probe_configured_ldap_identity_source_with_http_info(ldap_identity_source_id, opts)
      data
    end

    # Test the configuration of an existing LDAP identity source
    # Attempt to connect to an existing LDAP identity source and report any errors encountered.
    # @param ldap_identity_source_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LdapIdentitySourceProbeResults, Fixnum, Hash)>] LdapIdentitySourceProbeResults data, response status code and response headers
    def probe_configured_ldap_identity_source_with_http_info(ldap_identity_source_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.probe_configured_ldap_identity_source ...'
      end
      # verify the required parameter 'ldap_identity_source_id' is set
      if @api_client.config.client_side_validation && ldap_identity_source_id.nil?
        fail ArgumentError, "Missing the required parameter 'ldap_identity_source_id' when calling SystemAdministrationApi.probe_configured_ldap_identity_source"
      end
      # resource path
      local_var_path = '/aaa/ldap-identity-sources/{ldap-identity-source-id}?action=probe'.sub('{' + 'ldap-identity-source-id' + '}', ldap_identity_source_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LdapIdentitySourceProbeResults')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#probe_configured_ldap_identity_source\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Test an LDAP server
    # Attempt to connect to an LDAP server and ensure that the server can be contacted using the given URL and authentication credentials.
    # @param identity_source_ldap_server 
    # @param [Hash] opts the optional parameters
    # @return [IdentitySourceLdapServerProbeResult]
    def probe_identity_source_ldap_server(identity_source_ldap_server, opts = {})
      data, _status_code, _headers = probe_identity_source_ldap_server_with_http_info(identity_source_ldap_server, opts)
      data
    end

    # Test an LDAP server
    # Attempt to connect to an LDAP server and ensure that the server can be contacted using the given URL and authentication credentials.
    # @param identity_source_ldap_server 
    # @param [Hash] opts the optional parameters
    # @return [Array<(IdentitySourceLdapServerProbeResult, Fixnum, Hash)>] IdentitySourceLdapServerProbeResult data, response status code and response headers
    def probe_identity_source_ldap_server_with_http_info(identity_source_ldap_server, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.probe_identity_source_ldap_server ...'
      end
      # verify the required parameter 'identity_source_ldap_server' is set
      if @api_client.config.client_side_validation && identity_source_ldap_server.nil?
        fail ArgumentError, "Missing the required parameter 'identity_source_ldap_server' when calling SystemAdministrationApi.probe_identity_source_ldap_server"
      end
      # resource path
      local_var_path = '/aaa/ldap-identity-sources?action=probe_ldap_server'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(identity_source_ldap_server)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'IdentitySourceLdapServerProbeResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#probe_identity_source_ldap_server\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Probe an LDAP identity source
    # Verify that the configuration of an LDAP identity source is correct before actually creating the source.
    # @param ldap_identity_source 
    # @param [Hash] opts the optional parameters
    # @return [LdapIdentitySourceProbeResults]
    def probe_unconfigured_ldap_identity_source(ldap_identity_source, opts = {})
      data, _status_code, _headers = probe_unconfigured_ldap_identity_source_with_http_info(ldap_identity_source, opts)
      data
    end

    # Probe an LDAP identity source
    # Verify that the configuration of an LDAP identity source is correct before actually creating the source.
    # @param ldap_identity_source 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LdapIdentitySourceProbeResults, Fixnum, Hash)>] LdapIdentitySourceProbeResults data, response status code and response headers
    def probe_unconfigured_ldap_identity_source_with_http_info(ldap_identity_source, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.probe_unconfigured_ldap_identity_source ...'
      end
      # verify the required parameter 'ldap_identity_source' is set
      if @api_client.config.client_side_validation && ldap_identity_source.nil?
        fail ArgumentError, "Missing the required parameter 'ldap_identity_source' when calling SystemAdministrationApi.probe_unconfigured_ldap_identity_source"
      end
      # resource path
      local_var_path = '/aaa/ldap-identity-sources?action=probe_identity_source'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(ldap_identity_source)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LdapIdentitySourceProbeResults')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#probe_unconfigured_ldap_identity_source\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns info for of the cluster configuration for the Avi Load Balancer Controller cluster
    # Returns cluster configuration for the Avi Load Balancer Controller cluster. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @return [ALBControllerNodeVMClusterConfig]
    def read_alb_controller_node_cluster_config(opts = {})
      data, _status_code, _headers = read_alb_controller_node_cluster_config_with_http_info(opts)
      data
    end

    # Returns info for of the cluster configuration for the Avi Load Balancer Controller cluster
    # Returns cluster configuration for the Avi Load Balancer Controller cluster. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @return [Array<(ALBControllerNodeVMClusterConfig, Fixnum, Hash)>] ALBControllerNodeVMClusterConfig data, response status code and response headers
    def read_alb_controller_node_cluster_config_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.read_alb_controller_node_cluster_config ...'
      end
      # resource path
      local_var_path = '/alb/controller-nodes/clusterconfig'

      # query parameters
      query_params = {}
      query_params[:'clustering_id'] = opts[:'clustering_id'] if !opts[:'clustering_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerNodeVMClusterConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#read_alb_controller_node_cluster_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns info for a Avi Load Balancer Controller deployment attempt
    # Returns deployment request information for a specific attempted deployment of a cluster node. 
    # @param node_id 
    # @param [Hash] opts the optional parameters
    # @return [ALBControllerNodeVMDeploymentRequest]
    def read_alb_controller_node_vm_deployment_request(node_id, opts = {})
      data, _status_code, _headers = read_alb_controller_node_vm_deployment_request_with_http_info(node_id, opts)
      data
    end

    # Returns info for a Avi Load Balancer Controller deployment attempt
    # Returns deployment request information for a specific attempted deployment of a cluster node. 
    # @param node_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ALBControllerNodeVMDeploymentRequest, Fixnum, Hash)>] ALBControllerNodeVMDeploymentRequest data, response status code and response headers
    def read_alb_controller_node_vm_deployment_request_with_http_info(node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.read_alb_controller_node_vm_deployment_request ...'
      end
      # verify the required parameter 'node_id' is set
      if @api_client.config.client_side_validation && node_id.nil?
        fail ArgumentError, "Missing the required parameter 'node_id' when calling SystemAdministrationApi.read_alb_controller_node_vm_deployment_request"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/deployments/{node-id}'.sub('{' + 'node-id' + '}', node_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerNodeVMDeploymentRequest')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#read_alb_controller_node_vm_deployment_request\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns the status of the node creation/deletion
    # Returns the current deployment or undeployment status for a node along with any other relevant current information, such as error messages. 
    # @param node_id 
    # @param [Hash] opts the optional parameters
    # @return [ALBControllerNodeVMDeploymentStatusReport]
    def read_alb_controller_node_vm_deployment_status(node_id, opts = {})
      data, _status_code, _headers = read_alb_controller_node_vm_deployment_status_with_http_info(node_id, opts)
      data
    end

    # Returns the status of the node creation/deletion
    # Returns the current deployment or undeployment status for a node along with any other relevant current information, such as error messages. 
    # @param node_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ALBControllerNodeVMDeploymentStatusReport, Fixnum, Hash)>] ALBControllerNodeVMDeploymentStatusReport data, response status code and response headers
    def read_alb_controller_node_vm_deployment_status_with_http_info(node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.read_alb_controller_node_vm_deployment_status ...'
      end
      # verify the required parameter 'node_id' is set
      if @api_client.config.client_side_validation && node_id.nil?
        fail ArgumentError, "Missing the required parameter 'node_id' when calling SystemAdministrationApi.read_alb_controller_node_vm_deployment_status"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/deployments/{node-id}/status'.sub('{' + 'node-id' + '}', node_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerNodeVMDeploymentStatusReport')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#read_alb_controller_node_vm_deployment_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read Antrea heartbeat configuration
    # Read Antrea heartbeat configuration
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param [Hash] opts the optional parameters
    # @return [AntreaHeartbeatConfig]
    def read_antrea_heartbeat_config(site_id, enforcementpoint_id, cluster_control_plane_id, opts = {})
      data, _status_code, _headers = read_antrea_heartbeat_config_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, opts)
      data
    end

    # Read Antrea heartbeat configuration
    # Read Antrea heartbeat configuration
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(AntreaHeartbeatConfig, Fixnum, Hash)>] AntreaHeartbeatConfig data, response status code and response headers
    def read_antrea_heartbeat_config_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.read_antrea_heartbeat_config ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.read_antrea_heartbeat_config"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.read_antrea_heartbeat_config"
      end
      # verify the required parameter 'cluster_control_plane_id' is set
      if @api_client.config.client_side_validation && cluster_control_plane_id.nil?
        fail ArgumentError, "Missing the required parameter 'cluster_control_plane_id' when calling SystemAdministrationApi.read_antrea_heartbeat_config"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/cluster-control-planes/{cluster-control-plane-id}/heartbeat-config'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'cluster-control-plane-id' + '}', cluster_control_plane_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AntreaHeartbeatConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#read_antrea_heartbeat_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read Antrea cluster status
    # Read Antrea cluster status for a given Antrea cluster identifier.
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param [Hash] opts the optional parameters
    # @return [AntreaClusterInfo]
    def read_antrea_status(site_id, enforcementpoint_id, cluster_control_plane_id, opts = {})
      data, _status_code, _headers = read_antrea_status_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, opts)
      data
    end

    # Read Antrea cluster status
    # Read Antrea cluster status for a given Antrea cluster identifier.
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(AntreaClusterInfo, Fixnum, Hash)>] AntreaClusterInfo data, response status code and response headers
    def read_antrea_status_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.read_antrea_status ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.read_antrea_status"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.read_antrea_status"
      end
      # verify the required parameter 'cluster_control_plane_id' is set
      if @api_client.config.client_side_validation && cluster_control_plane_id.nil?
        fail ArgumentError, "Missing the required parameter 'cluster_control_plane_id' when calling SystemAdministrationApi.read_antrea_status"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/cluster-control-planes/{cluster-control-plane-id}/status'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'cluster-control-plane-id' + '}', cluster_control_plane_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AntreaClusterInfo')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#read_antrea_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read BMC cluster status
    # Read BMC cluster status for a given BMC cluster identifier.
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param [Hash] opts the optional parameters
    # @return [BMCClusterInfo]
    def read_bmc_status(site_id, enforcementpoint_id, cluster_control_plane_id, opts = {})
      data, _status_code, _headers = read_bmc_status_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, opts)
      data
    end

    # Read BMC cluster status
    # Read BMC cluster status for a given BMC cluster identifier.
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BMCClusterInfo, Fixnum, Hash)>] BMCClusterInfo data, response status code and response headers
    def read_bmc_status_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.read_bmc_status ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.read_bmc_status"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.read_bmc_status"
      end
      # verify the required parameter 'cluster_control_plane_id' is set
      if @api_client.config.client_side_validation && cluster_control_plane_id.nil?
        fail ArgumentError, "Missing the required parameter 'cluster_control_plane_id' when calling SystemAdministrationApi.read_bmc_status"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/bm-ccpn/{cluster-control-plane-id}/status'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'cluster-control-plane-id' + '}', cluster_control_plane_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BMCClusterInfo')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#read_bmc_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read a single LDAP identity source
    # Return details about one LDAP identity source
    # @param ldap_identity_source_id 
    # @param [Hash] opts the optional parameters
    # @return [LdapIdentitySource]
    def read_ldap_identity_source(ldap_identity_source_id, opts = {})
      data, _status_code, _headers = read_ldap_identity_source_with_http_info(ldap_identity_source_id, opts)
      data
    end

    # Read a single LDAP identity source
    # Return details about one LDAP identity source
    # @param ldap_identity_source_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(LdapIdentitySource, Fixnum, Hash)>] LdapIdentitySource data, response status code and response headers
    def read_ldap_identity_source_with_http_info(ldap_identity_source_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.read_ldap_identity_source ...'
      end
      # verify the required parameter 'ldap_identity_source_id' is set
      if @api_client.config.client_side_validation && ldap_identity_source_id.nil?
        fail ArgumentError, "Missing the required parameter 'ldap_identity_source_id' when calling SystemAdministrationApi.read_ldap_identity_source"
      end
      # resource path
      local_var_path = '/aaa/ldap-identity-sources/{ldap-identity-source-id}'.sub('{' + 'ldap-identity-source-id' + '}', ldap_identity_source_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LdapIdentitySource')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#read_ldap_identity_source\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read NSX Management nodes global configuration.
    # Returns the NSX Management nodes global configuration. 
    # @param [Hash] opts the optional parameters
    # @return [ManagementConfig]
    def read_management_config(opts = {})
      data, _status_code, _headers = read_management_config_with_http_info(opts)
      data
    end

    # Read NSX Management nodes global configuration.
    # Returns the NSX Management nodes global configuration. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ManagementConfig, Fixnum, Hash)>] ManagementConfig data, response status code and response headers
    def read_management_config_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.read_management_config ...'
      end
      # resource path
      local_var_path = '/configs/management'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ManagementConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#read_management_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read a Sub-cluster configuration
    # Read a Sub-cluster configuration. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param subcluster_id 
    # @param [Hash] opts the optional parameters
    # @return [SubCluster]
    def read_sub_cluster(site_id, enforcementpoint_id, subcluster_id, opts = {})
      data, _status_code, _headers = read_sub_cluster_with_http_info(site_id, enforcementpoint_id, subcluster_id, opts)
      data
    end

    # Read a Sub-cluster configuration
    # Read a Sub-cluster configuration. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param subcluster_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SubCluster, Fixnum, Hash)>] SubCluster data, response status code and response headers
    def read_sub_cluster_with_http_info(site_id, enforcementpoint_id, subcluster_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.read_sub_cluster ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.read_sub_cluster"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.read_sub_cluster"
      end
      # verify the required parameter 'subcluster_id' is set
      if @api_client.config.client_side_validation && subcluster_id.nil?
        fail ArgumentError, "Missing the required parameter 'subcluster_id' when calling SystemAdministrationApi.read_sub_cluster"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/sub-clusters/{subcluster-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'subcluster-id' + '}', subcluster_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SubCluster')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#read_sub_cluster\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get information about the specified task
    # Get information about the specified task
    # @param task_id ID of task to read
    # @param [Hash] opts the optional parameters
    # @return [TaskProperties]
    def read_task_properties(task_id, opts = {})
      data, _status_code, _headers = read_task_properties_with_http_info(task_id, opts)
      data
    end

    # Get information about the specified task
    # Get information about the specified task
    # @param task_id ID of task to read
    # @param [Hash] opts the optional parameters
    # @return [Array<(TaskProperties, Fixnum, Hash)>] TaskProperties data, response status code and response headers
    def read_task_properties_with_http_info(task_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.read_task_properties ...'
      end
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        fail ArgumentError, "Missing the required parameter 'task_id' when calling SystemAdministrationApi.read_task_properties"
      end
      # resource path
      local_var_path = '/tasks/{task-id}'.sub('{' + 'task-id' + '}', task_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TaskProperties')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#read_task_properties\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get the response of a task
    # Get the response of a task
    # @param task_id ID of task to read
    # @param [Hash] opts the optional parameters
    # @return [Object]
    def read_task_result(task_id, opts = {})
      data, _status_code, _headers = read_task_result_with_http_info(task_id, opts)
      data
    end

    # Get the response of a task
    # Get the response of a task
    # @param task_id ID of task to read
    # @param [Hash] opts the optional parameters
    # @return [Array<(Object, Fixnum, Hash)>] Object data, response status code and response headers
    def read_task_result_with_http_info(task_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.read_task_result ...'
      end
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        fail ArgumentError, "Missing the required parameter 'task_id' when calling SystemAdministrationApi.read_task_result"
      end
      # resource path
      local_var_path = '/tasks/{task-id}/response'.sub('{' + 'task-id' + '}', task_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Object')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#read_task_result\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Register a Collection of API Calls at a Single End Point
    # Enables you to make multiple API requests using a single request. The batch API takes in an array of logical HTTP requests represented as JSON arrays. Each request has a method (GET, PUT, POST, or DELETE), a relative_url (the portion of the URL after https://&lt;nsx-mgr&gt;/api/), optional headers array (corresponding to HTTP headers) and an optional body (for POST and PUT requests). The batch API returns an array of logical HTTP responses represented as JSON arrays. Each response has a status code, an optional headers array and an optional body (which is a JSON-encoded string). The batch API is not supported for any of the policy multi-tenancy related APIs. The multi-tenancy APIs start with the path /orgs/<org-id>/projects/<project-id>/ This API is deprecated. Instead, use the hierarchical API in the NSX-T policy API.  <br> Support for batched operations will be removed from a future NSX release. For policy APIs, use the hierarchical API to submit a set of updates as a single operation. For other APIs, submit the operations as individual REST API calls.
    # @param batch_request 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :atomic Ignored (transactional atomicity flag) (default to false)
    # @return [BatchResponse]
    def register_batch_request(batch_request, opts = {})
      data, _status_code, _headers = register_batch_request_with_http_info(batch_request, opts)
      data
    end

    # Register a Collection of API Calls at a Single End Point
    # Enables you to make multiple API requests using a single request. The batch API takes in an array of logical HTTP requests represented as JSON arrays. Each request has a method (GET, PUT, POST, or DELETE), a relative_url (the portion of the URL after https://&amp;lt;nsx-mgr&amp;gt;/api/), optional headers array (corresponding to HTTP headers) and an optional body (for POST and PUT requests). The batch API returns an array of logical HTTP responses represented as JSON arrays. Each response has a status code, an optional headers array and an optional body (which is a JSON-encoded string). The batch API is not supported for any of the policy multi-tenancy related APIs. The multi-tenancy APIs start with the path /orgs/&lt;org-id&gt;/projects/&lt;project-id&gt;/ This API is deprecated. Instead, use the hierarchical API in the NSX-T policy API.  &lt;br&gt; Support for batched operations will be removed from a future NSX release. For policy APIs, use the hierarchical API to submit a set of updates as a single operation. For other APIs, submit the operations as individual REST API calls.
    # @param batch_request 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :atomic Ignored (transactional atomicity flag)
    # @return [Array<(BatchResponse, Fixnum, Hash)>] BatchResponse data, response status code and response headers
    def register_batch_request_with_http_info(batch_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.register_batch_request ...'
      end
      # verify the required parameter 'batch_request' is set
      if @api_client.config.client_side_validation && batch_request.nil?
        fail ArgumentError, "Missing the required parameter 'batch_request' when calling SystemAdministrationApi.register_batch_request"
      end
      # resource path
      local_var_path = '/batch'

      # query parameters
      query_params = {}
      query_params[:'atomic'] = opts[:'atomic'] if !opts[:'atomic'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(batch_request)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BatchResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#register_batch_request\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Uninstall NSX from the specified Transport Node Collection
    # This API uninstalls NSX applied to the Transport Node Collection with the ID corresponding to the one specified in the request.
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def remove_nsxon_transport_node_collection(site_id, enforcementpoint_id, transport_node_collection_id, opts = {})
      remove_nsxon_transport_node_collection_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, opts)
      nil
    end

    # Uninstall NSX from the specified Transport Node Collection
    # This API uninstalls NSX applied to the Transport Node Collection with the ID corresponding to the one specified in the request.
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def remove_nsxon_transport_node_collection_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.remove_nsxon_transport_node_collection ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.remove_nsxon_transport_node_collection"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.remove_nsxon_transport_node_collection"
      end
      # verify the required parameter 'transport_node_collection_id' is set
      if @api_client.config.client_side_validation && transport_node_collection_id.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_collection_id' when calling SystemAdministrationApi.remove_nsxon_transport_node_collection"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/transport-node-collections/{transport-node-collection-id}?action=remove_nsx'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'transport-node-collection-id' + '}', transport_node_collection_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#remove_nsxon_transport_node_collection\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete registration access token
    # Delete registration access token
    # @param reg_token_query 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def remove_registration_token(reg_token_query, opts = {})
      remove_registration_token_with_http_info(reg_token_query, opts)
      nil
    end

    # Delete registration access token
    # Delete registration access token
    # @param reg_token_query 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def remove_registration_token_with_http_info(reg_token_query, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.remove_registration_token ...'
      end
      # verify the required parameter 'reg_token_query' is set
      if @api_client.config.client_side_validation && reg_token_query.nil?
        fail ArgumentError, "Missing the required parameter 'reg_token_query' when calling SystemAdministrationApi.remove_registration_token"
      end
      # resource path
      local_var_path = '/aaa/registration-token/delete'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(reg_token_query)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#remove_registration_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Request one-time backup
    # Request one-time backup. The backup will be uploaded using the same server configuration as for automatic backup. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :frame_type Frame type (default to LOCAL_LOCAL_MANAGER)
    # @option opts [String] :site_id Site ID (default to localhost)
    # @return [nil]
    def request_onetime_backup(opts = {})
      request_onetime_backup_with_http_info(opts)
      nil
    end

    # Request one-time backup
    # Request one-time backup. The backup will be uploaded using the same server configuration as for automatic backup. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :frame_type Frame type
    # @option opts [String] :site_id Site ID
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def request_onetime_backup_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.request_onetime_backup ...'
      end
      if @api_client.config.client_side_validation && opts[:'frame_type'] && !['GLOBAL_MANAGER', 'LOCAL_MANAGER', 'LOCAL_LOCAL_MANAGER', 'NSX_INTELLIGENCE'].include?(opts[:'frame_type'])
        fail ArgumentError, 'invalid value for "frame_type", must be one of GLOBAL_MANAGER, LOCAL_MANAGER, LOCAL_LOCAL_MANAGER, NSX_INTELLIGENCE'
      end
      # resource path
      local_var_path = '/cluster?action=backup_to_remote'

      # query parameters
      query_params = {}
      query_params[:'frame_type'] = opts[:'frame_type'] if !opts[:'frame_type'].nil?
      query_params[:'site_id'] = opts[:'site_id'] if !opts[:'site_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#request_onetime_backup\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Request one-time inventory summary.
    # Request one-time inventory summary. The backup will be uploaded using the same server configuration as for an automatic backup. 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def request_onetime_inventory_summary(opts = {})
      request_onetime_inventory_summary_with_http_info(opts)
      nil
    end

    # Request one-time inventory summary.
    # Request one-time inventory summary. The backup will be uploaded using the same server configuration as for an automatic backup. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def request_onetime_inventory_summary_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.request_onetime_inventory_summary ...'
      end
      # resource path
      local_var_path = '/cluster?action=summarize_inventory_to_remote'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#request_onetime_inventory_summary\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Resolves the error
    # Invokes the corresponding error resolver for the given error(s) present in the payload 
    # @param error_resolver_metadata_list 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def resolve_error(error_resolver_metadata_list, opts = {})
      resolve_error_with_http_info(error_resolver_metadata_list, opts)
      nil
    end

    # Resolves the error
    # Invokes the corresponding error resolver for the given error(s) present in the payload 
    # @param error_resolver_metadata_list 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def resolve_error_with_http_info(error_resolver_metadata_list, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.resolve_error ...'
      end
      # verify the required parameter 'error_resolver_metadata_list' is set
      if @api_client.config.client_side_validation && error_resolver_metadata_list.nil?
        fail ArgumentError, "Missing the required parameter 'error_resolver_metadata_list' when calling SystemAdministrationApi.resolve_error"
      end
      # resource path
      local_var_path = '/error-resolver?action=resolve_error'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(error_resolver_metadata_list)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#resolve_error\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Apply cluster level Transport Node Profile on overridden host
    # A host can be overridden to have different configuration than Transport Node Profile(TNP) on cluster. This action will restore such overridden host back to cluster level TNP.  This API can be used in other case. When TNP is applied to a cluster, if any validation fails (e.g. VMs running on host) then existing transport node (TN) is not updated. In that case after the issue is resolved manually (e.g. VMs powered off), you can call this API to update TN as per cluster level TNP. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def restore_parent_cluster_configuration_on_host_transport_node(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      restore_parent_cluster_configuration_on_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      nil
    end

    # Apply cluster level Transport Node Profile on overridden host
    # A host can be overridden to have different configuration than Transport Node Profile(TNP) on cluster. This action will restore such overridden host back to cluster level TNP.  This API can be used in other case. When TNP is applied to a cluster, if any validation fails (e.g. VMs running on host) then existing transport node (TN) is not updated. In that case after the issue is resolved manually (e.g. VMs powered off), you can call this API to update TN as per cluster level TNP. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def restore_parent_cluster_configuration_on_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.restore_parent_cluster_configuration_on_host_transport_node ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.restore_parent_cluster_configuration_on_host_transport_node"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.restore_parent_cluster_configuration_on_host_transport_node"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling SystemAdministrationApi.restore_parent_cluster_configuration_on_host_transport_node"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}?action=restore_cluster_config'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#restore_parent_cluster_configuration_on_host_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Resync a Host Transport Node
    # Resync the TransportNode configuration on a host. It is similar to updating the TransportNode with existing configuration, but force synce these configurations to the host (no backend optimizations). 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def resync_host_transport_node(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      resync_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      nil
    end

    # Resync a Host Transport Node
    # Resync the TransportNode configuration on a host. It is similar to updating the TransportNode with existing configuration, but force synce these configurations to the host (no backend optimizations). 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def resync_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.resync_host_transport_node ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.resync_host_transport_node"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.resync_host_transport_node"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling SystemAdministrationApi.resync_host_transport_node"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}?action=resync_host_config'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#resync_host_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get registration access token
    # Get the roles associated with the given registration token
    # @param reg_token_query 
    # @param [Hash] opts the optional parameters
    # @return [RegistrationToken]
    def retrieve_registration_token(reg_token_query, opts = {})
      data, _status_code, _headers = retrieve_registration_token_with_http_info(reg_token_query, opts)
      data
    end

    # Get registration access token
    # Get the roles associated with the given registration token
    # @param reg_token_query 
    # @param [Hash] opts the optional parameters
    # @return [Array<(RegistrationToken, Fixnum, Hash)>] RegistrationToken data, response status code and response headers
    def retrieve_registration_token_with_http_info(reg_token_query, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.retrieve_registration_token ...'
      end
      # verify the required parameter 'reg_token_query' is set
      if @api_client.config.client_side_validation && reg_token_query.nil?
        fail ArgumentError, "Missing the required parameter 'reg_token_query' when calling SystemAdministrationApi.retrieve_registration_token"
      end
      # resource path
      local_var_path = '/aaa/registration-token/retrieve'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(reg_token_query)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RegistrationToken')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#retrieve_registration_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Re-trigger clustering for Avi Load Balancer Controller Nodes.
    # Re-trigger clustering for Avi Load Balancer Controller Nodes. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @return [ALBControllerClusterTrigger]
    def retrigger_clustering(opts = {})
      data, _status_code, _headers = retrigger_clustering_with_http_info(opts)
      data
    end

    # Re-trigger clustering for Avi Load Balancer Controller Nodes.
    # Re-trigger clustering for Avi Load Balancer Controller Nodes. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @return [Array<(ALBControllerClusterTrigger, Fixnum, Hash)>] ALBControllerClusterTrigger data, response status code and response headers
    def retrigger_clustering_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.retrigger_clustering ...'
      end
      # resource path
      local_var_path = '/alb/controller-nodes/cluster'

      # query parameters
      query_params = {}
      query_params[:'clustering_id'] = opts[:'clustering_id'] if !opts[:'clustering_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerClusterTrigger')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#retrigger_clustering\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Retry any failed restore operation
    # Retry any currently in-progress, failed restore operation. Only the last step of the multi-step restore operation would have failed,and only that step is retried. This operation is only valid when a GET cluster/restore/status returns a status with value FAILED. Otherwise, a 409 response is returned. 
    # @param [Hash] opts the optional parameters
    # @return [ClusterRestoreStatus]
    def retry_cluster_restore(opts = {})
      data, _status_code, _headers = retry_cluster_restore_with_http_info(opts)
      data
    end

    # Retry any failed restore operation
    # Retry any currently in-progress, failed restore operation. Only the last step of the multi-step restore operation would have failed,and only that step is retried. This operation is only valid when a GET cluster/restore/status returns a status with value FAILED. Otherwise, a 409 response is returned. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ClusterRestoreStatus, Fixnum, Hash)>] ClusterRestoreStatus data, response status code and response headers
    def retry_cluster_restore_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.retry_cluster_restore ...'
      end
      # resource path
      local_var_path = '/cluster/restore?action=retry'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ClusterRestoreStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#retry_cluster_restore\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Retry any failed restore operation
    # Retry currently failed restore operation due to incorrect passphrase. User needs to call this api after passphrase is corrected in Backup config. This operation is only valid when a GET cluster/restore/status returns a status with value FAILED. Otherwise, a 409 response is returned. Calling this api without passphrase update will result in restore failure due to bad passphrase. 
    # @param [Hash] opts the optional parameters
    # @return [ClusterRestoreStatus]
    def retry_cluster_restore_with_updated_config(opts = {})
      data, _status_code, _headers = retry_cluster_restore_with_updated_config_with_http_info(opts)
      data
    end

    # Retry any failed restore operation
    # Retry currently failed restore operation due to incorrect passphrase. User needs to call this api after passphrase is corrected in Backup config. This operation is only valid when a GET cluster/restore/status returns a status with value FAILED. Otherwise, a 409 response is returned. Calling this api without passphrase update will result in restore failure due to bad passphrase. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ClusterRestoreStatus, Fixnum, Hash)>] ClusterRestoreStatus data, response status code and response headers
    def retry_cluster_restore_with_updated_config_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.retry_cluster_restore_with_updated_config ...'
      end
      # resource path
      local_var_path = '/cluster/restore/action/retry_with_updated_config'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ClusterRestoreStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#retry_cluster_restore_with_updated_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Retry the process on applying transport node profile
    # This API is relevant for compute collection on which vLCM is enabled. This API should be invoked to retry the realization of transport node profile on the compute collection. This is useful when profile realization had failed because of error in vLCM. This API has no effect if vLCM is not enabled on the computer collection.
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def retry_host_transport_node_collection_realization(site_id, enforcementpoint_id, transport_node_collection_id, opts = {})
      retry_host_transport_node_collection_realization_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, opts)
      nil
    end

    # Retry the process on applying transport node profile
    # This API is relevant for compute collection on which vLCM is enabled. This API should be invoked to retry the realization of transport node profile on the compute collection. This is useful when profile realization had failed because of error in vLCM. This API has no effect if vLCM is not enabled on the computer collection.
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def retry_host_transport_node_collection_realization_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.retry_host_transport_node_collection_realization ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.retry_host_transport_node_collection_realization"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.retry_host_transport_node_collection_realization"
      end
      # verify the required parameter 'transport_node_collection_id' is set
      if @api_client.config.client_side_validation && transport_node_collection_id.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_collection_id' when calling SystemAdministrationApi.retry_host_transport_node_collection_realization"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/transport-node-collections/{transport-node-collection-id}?action=retry_profile_realization'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'transport-node-collection-id' + '}', transport_node_collection_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#retry_host_transport_node_collection_realization\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Search the LDAP identity source
    # Search the LDAP identity source for users and groups that match the given filter_value. In most cases, the LDAP source performs a case-insensitive search.
    # @param ldap_identity_source_id 
    # @param filter_value Search filter value
    # @param [Hash] opts the optional parameters
    # @return [LdapIdentitySourceSearchResultList]
    def search_ldap_identity_source(ldap_identity_source_id, filter_value, opts = {})
      data, _status_code, _headers = search_ldap_identity_source_with_http_info(ldap_identity_source_id, filter_value, opts)
      data
    end

    # Search the LDAP identity source
    # Search the LDAP identity source for users and groups that match the given filter_value. In most cases, the LDAP source performs a case-insensitive search.
    # @param ldap_identity_source_id 
    # @param filter_value Search filter value
    # @param [Hash] opts the optional parameters
    # @return [Array<(LdapIdentitySourceSearchResultList, Fixnum, Hash)>] LdapIdentitySourceSearchResultList data, response status code and response headers
    def search_ldap_identity_source_with_http_info(ldap_identity_source_id, filter_value, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.search_ldap_identity_source ...'
      end
      # verify the required parameter 'ldap_identity_source_id' is set
      if @api_client.config.client_side_validation && ldap_identity_source_id.nil?
        fail ArgumentError, "Missing the required parameter 'ldap_identity_source_id' when calling SystemAdministrationApi.search_ldap_identity_source"
      end
      # verify the required parameter 'filter_value' is set
      if @api_client.config.client_side_validation && filter_value.nil?
        fail ArgumentError, "Missing the required parameter 'filter_value' when calling SystemAdministrationApi.search_ldap_identity_source"
      end
      # resource path
      local_var_path = '/aaa/ldap-identity-sources/{ldap-identity-source-id}/search'.sub('{' + 'ldap-identity-source-id' + '}', ldap_identity_source_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'filter_value'] = filter_value

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'LdapIdentitySourceSearchResultList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#search_ldap_identity_source\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Submit a new TransportNode VTEP action
    # Submit a new VTEP action for a particular TransportNode. The status of submitted actions could be retrieved using the ListTransportNodeVtepActionsStatus API. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param transport_node_vtep_action 
    # @param [Hash] opts the optional parameters
    # @return [TransportNodeVtepActionReference]
    def submit_transport_node_vtep_action(site_id, enforcementpoint_id, host_transport_node_id, transport_node_vtep_action, opts = {})
      data, _status_code, _headers = submit_transport_node_vtep_action_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, transport_node_vtep_action, opts)
      data
    end

    # Submit a new TransportNode VTEP action
    # Submit a new VTEP action for a particular TransportNode. The status of submitted actions could be retrieved using the ListTransportNodeVtepActionsStatus API. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param transport_node_vtep_action 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransportNodeVtepActionReference, Fixnum, Hash)>] TransportNodeVtepActionReference data, response status code and response headers
    def submit_transport_node_vtep_action_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, transport_node_vtep_action, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.submit_transport_node_vtep_action ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.submit_transport_node_vtep_action"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.submit_transport_node_vtep_action"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling SystemAdministrationApi.submit_transport_node_vtep_action"
      end
      # verify the required parameter 'transport_node_vtep_action' is set
      if @api_client.config.client_side_validation && transport_node_vtep_action.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_vtep_action' when calling SystemAdministrationApi.submit_transport_node_vtep_action"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}/vteps/actions'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(transport_node_vtep_action)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNodeVtepActionReference')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#submit_transport_node_vtep_action\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Suspend any running restore operation
    # Suspend any currently running restore operation. The restore operation is made up of a number of steps. When this call is issued, any currently running step is allowed to finish (successfully or with errors), and the next step (and therefore the entire restore operation) is suspended until a subsequent resume or cancel call is issued. This operation is only valid when a GET cluster/restore/status returns a status with value RUNNING. Otherwise, a 409 response is returned. 
    # @param [Hash] opts the optional parameters
    # @return [ClusterRestoreStatus]
    def suspend_cluster_restore(opts = {})
      data, _status_code, _headers = suspend_cluster_restore_with_http_info(opts)
      data
    end

    # Suspend any running restore operation
    # Suspend any currently running restore operation. The restore operation is made up of a number of steps. When this call is issued, any currently running step is allowed to finish (successfully or with errors), and the next step (and therefore the entire restore operation) is suspended until a subsequent resume or cancel call is issued. This operation is only valid when a GET cluster/restore/status returns a status with value RUNNING. Otherwise, a 409 response is returned. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ClusterRestoreStatus, Fixnum, Hash)>] ClusterRestoreStatus data, response status code and response headers
    def suspend_cluster_restore_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.suspend_cluster_restore ...'
      end
      # resource path
      local_var_path = '/cluster/restore?action=suspend'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ClusterRestoreStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#suspend_cluster_restore\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Synchronize VCF licenses from all registered vCenters 
    # Synchronize VCF licenses from all registered vCenters and update licenses in NSX. This API will not return synchronized VCF licenses and just update them in NSX. 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def sync_vcf_licenses(opts = {})
      sync_vcf_licenses_with_http_info(opts)
      nil
    end

    # Synchronize VCF licenses from all registered vCenters 
    # Synchronize VCF licenses from all registered vCenters and update licenses in NSX. This API will not return synchronized VCF licenses and just update them in NSX. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def sync_vcf_licenses_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.sync_vcf_licenses ...'
      end
      # resource path
      local_var_path = '/licenses/vcf/action/sync'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#sync_vcf_licenses\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update a Avi Load Balancer Controller cluster node. Only updating password, ntp and dns servers are supported. If controller is in a cluster then all nodes in the cluster are updated with the provided values
    # Update Avi Load Balancer Controller node details 
    # @param node_id 
    # @param alb_controller_node_vm_deployment_request 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :running_config Update Avi Load Balancer Controller runtime config as well
    # @return [ALBControllerNodeVMDeploymentRequest]
    def update_alb_controller_node_vm_deployment_request(node_id, alb_controller_node_vm_deployment_request, opts = {})
      data, _status_code, _headers = update_alb_controller_node_vm_deployment_request_with_http_info(node_id, alb_controller_node_vm_deployment_request, opts)
      data
    end

    # Update a Avi Load Balancer Controller cluster node. Only updating password, ntp and dns servers are supported. If controller is in a cluster then all nodes in the cluster are updated with the provided values
    # Update Avi Load Balancer Controller node details 
    # @param node_id 
    # @param alb_controller_node_vm_deployment_request 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :running_config Update Avi Load Balancer Controller runtime config as well
    # @return [Array<(ALBControllerNodeVMDeploymentRequest, Fixnum, Hash)>] ALBControllerNodeVMDeploymentRequest data, response status code and response headers
    def update_alb_controller_node_vm_deployment_request_with_http_info(node_id, alb_controller_node_vm_deployment_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.update_alb_controller_node_vm_deployment_request ...'
      end
      # verify the required parameter 'node_id' is set
      if @api_client.config.client_side_validation && node_id.nil?
        fail ArgumentError, "Missing the required parameter 'node_id' when calling SystemAdministrationApi.update_alb_controller_node_vm_deployment_request"
      end
      # verify the required parameter 'alb_controller_node_vm_deployment_request' is set
      if @api_client.config.client_side_validation && alb_controller_node_vm_deployment_request.nil?
        fail ArgumentError, "Missing the required parameter 'alb_controller_node_vm_deployment_request' when calling SystemAdministrationApi.update_alb_controller_node_vm_deployment_request"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/deployments/{node-id}'.sub('{' + 'node-id' + '}', node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'running_config'] = opts[:'running_config'] if !opts[:'running_config'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(alb_controller_node_vm_deployment_request)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerNodeVMDeploymentRequest')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#update_alb_controller_node_vm_deployment_request\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update DNS, NTP and Backup server config in Avi Load Balancer Controller.
    # Use this API to update DNS, NTP and Backup server config in Avi Load Balancer Controller. This API is for VCF deployments only. 
    # @param alb_controller_system_configuration 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :running_config Update Avi Load Balancer Controller runtime config as well
    # @return [ALBControllerSystemConfigurationResponse]
    def update_alb_system_configuration(alb_controller_system_configuration, opts = {})
      data, _status_code, _headers = update_alb_system_configuration_with_http_info(alb_controller_system_configuration, opts)
      data
    end

    # Update DNS, NTP and Backup server config in Avi Load Balancer Controller.
    # Use this API to update DNS, NTP and Backup server config in Avi Load Balancer Controller. This API is for VCF deployments only. 
    # @param alb_controller_system_configuration 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :running_config Update Avi Load Balancer Controller runtime config as well
    # @return [Array<(ALBControllerSystemConfigurationResponse, Fixnum, Hash)>] ALBControllerSystemConfigurationResponse data, response status code and response headers
    def update_alb_system_configuration_with_http_info(alb_controller_system_configuration, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.update_alb_system_configuration ...'
      end
      # verify the required parameter 'alb_controller_system_configuration' is set
      if @api_client.config.client_side_validation && alb_controller_system_configuration.nil?
        fail ArgumentError, "Missing the required parameter 'alb_controller_system_configuration' when calling SystemAdministrationApi.update_alb_system_configuration"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/system-configuration'

      # query parameters
      query_params = {}
      query_params[:'running_config'] = opts[:'running_config'] if !opts[:'running_config'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(alb_controller_system_configuration)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerSystemConfigurationResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#update_alb_system_configuration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update admin user or service user object password in Avi Load Balancer Controller.
    # Use this API to update admin user password or service user object password in Avi Load Balancer Controller. This API is for VCF deployments only. 
    # @param alb_controller_user_credential 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :running_config Update Avi Load Balancer Controller runtime config as well
    # @return [ALBControllerUserCredentialResponse]
    def update_alb_user_credential_object(alb_controller_user_credential, opts = {})
      data, _status_code, _headers = update_alb_user_credential_object_with_http_info(alb_controller_user_credential, opts)
      data
    end

    # Update admin user or service user object password in Avi Load Balancer Controller.
    # Use this API to update admin user password or service user object password in Avi Load Balancer Controller. This API is for VCF deployments only. 
    # @param alb_controller_user_credential 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :running_config Update Avi Load Balancer Controller runtime config as well
    # @return [Array<(ALBControllerUserCredentialResponse, Fixnum, Hash)>] ALBControllerUserCredentialResponse data, response status code and response headers
    def update_alb_user_credential_object_with_http_info(alb_controller_user_credential, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.update_alb_user_credential_object ...'
      end
      # verify the required parameter 'alb_controller_user_credential' is set
      if @api_client.config.client_side_validation && alb_controller_user_credential.nil?
        fail ArgumentError, "Missing the required parameter 'alb_controller_user_credential' when calling SystemAdministrationApi.update_alb_user_credential_object"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/user-credential'

      # query parameters
      query_params = {}
      query_params[:'running_config'] = opts[:'running_config'] if !opts[:'running_config'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(alb_controller_user_credential)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerUserCredentialResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#update_alb_user_credential_object\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update the Antrea heartbeat configuration
    # Update the Antrea heartbeat configuration
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param antrea_heartbeat_config 
    # @param [Hash] opts the optional parameters
    # @return [AntreaHeartbeatConfig]
    def update_antrea_heartbeat_config(site_id, enforcementpoint_id, cluster_control_plane_id, antrea_heartbeat_config, opts = {})
      data, _status_code, _headers = update_antrea_heartbeat_config_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, antrea_heartbeat_config, opts)
      data
    end

    # Update the Antrea heartbeat configuration
    # Update the Antrea heartbeat configuration
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param antrea_heartbeat_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(AntreaHeartbeatConfig, Fixnum, Hash)>] AntreaHeartbeatConfig data, response status code and response headers
    def update_antrea_heartbeat_config_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, antrea_heartbeat_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.update_antrea_heartbeat_config ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.update_antrea_heartbeat_config"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.update_antrea_heartbeat_config"
      end
      # verify the required parameter 'cluster_control_plane_id' is set
      if @api_client.config.client_side_validation && cluster_control_plane_id.nil?
        fail ArgumentError, "Missing the required parameter 'cluster_control_plane_id' when calling SystemAdministrationApi.update_antrea_heartbeat_config"
      end
      # verify the required parameter 'antrea_heartbeat_config' is set
      if @api_client.config.client_side_validation && antrea_heartbeat_config.nil?
        fail ArgumentError, "Missing the required parameter 'antrea_heartbeat_config' when calling SystemAdministrationApi.update_antrea_heartbeat_config"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/cluster-control-planes/{cluster-control-plane-id}/heartbeat-config'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'cluster-control-plane-id' + '}', cluster_control_plane_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(antrea_heartbeat_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AntreaHeartbeatConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#update_antrea_heartbeat_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update API service properties
    # Update the configuration of the NSX API service. Changes are applied to all nodes in the cluster. The API service on each node will restart after it is updated using this API. There may be a delay of up to a minute or so between the time this API call completes and when the new configuration goes into effect.
    # @param api_service_config 
    # @param [Hash] opts the optional parameters
    # @return [ApiServiceConfig]
    def update_api_service_config(api_service_config, opts = {})
      data, _status_code, _headers = update_api_service_config_with_http_info(api_service_config, opts)
      data
    end

    # Update API service properties
    # Update the configuration of the NSX API service. Changes are applied to all nodes in the cluster. The API service on each node will restart after it is updated using this API. There may be a delay of up to a minute or so between the time this API call completes and when the new configuration goes into effect.
    # @param api_service_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiServiceConfig, Fixnum, Hash)>] ApiServiceConfig data, response status code and response headers
    def update_api_service_config_with_http_info(api_service_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.update_api_service_config ...'
      end
      # verify the required parameter 'api_service_config' is set
      if @api_client.config.client_side_validation && api_service_config.nil?
        fail ArgumentError, "Missing the required parameter 'api_service_config' when calling SystemAdministrationApi.update_api_service_config"
      end
      # resource path
      local_var_path = '/cluster/api-service'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(api_service_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ApiServiceConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#update_api_service_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Saves the configuration for auto enable gateway firewall config
    # Update auto enable gateway firewall configuration value 
    # @param auto_enable_gateway_firewall_config 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def update_auto_enable_gateway_firewall_config(auto_enable_gateway_firewall_config, opts = {})
      update_auto_enable_gateway_firewall_config_with_http_info(auto_enable_gateway_firewall_config, opts)
      nil
    end

    # Saves the configuration for auto enable gateway firewall config
    # Update auto enable gateway firewall configuration value 
    # @param auto_enable_gateway_firewall_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def update_auto_enable_gateway_firewall_config_with_http_info(auto_enable_gateway_firewall_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.update_auto_enable_gateway_firewall_config ...'
      end
      # verify the required parameter 'auto_enable_gateway_firewall_config' is set
      if @api_client.config.client_side_validation && auto_enable_gateway_firewall_config.nil?
        fail ArgumentError, "Missing the required parameter 'auto_enable_gateway_firewall_config' when calling SystemAdministrationApi.update_auto_enable_gateway_firewall_config"
      end
      # resource path
      local_var_path = '/system-config/auto-enable-gateway-firewall'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(auto_enable_gateway_firewall_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#update_auto_enable_gateway_firewall_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update NSX Management nodes global configuration
    # Modifies the NSX Management nodes global configuration.
    # @param management_config 
    # @param [Hash] opts the optional parameters
    # @return [ManagementConfig]
    def update_management_config(management_config, opts = {})
      data, _status_code, _headers = update_management_config_with_http_info(management_config, opts)
      data
    end

    # Update NSX Management nodes global configuration
    # Modifies the NSX Management nodes global configuration.
    # @param management_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ManagementConfig, Fixnum, Hash)>] ManagementConfig data, response status code and response headers
    def update_management_config_with_http_info(management_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.update_management_config ...'
      end
      # verify the required parameter 'management_config' is set
      if @api_client.config.client_side_validation && management_config.nil?
        fail ArgumentError, "Missing the required parameter 'management_config' when calling SystemAdministrationApi.update_management_config"
      end
      # resource path
      local_var_path = '/configs/management'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(management_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ManagementConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#update_management_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create/update object permission mappings
    # Create/update object permission mappings
    # @param object_role_permission_group 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def update_object_permissions(object_role_permission_group, opts = {})
      update_object_permissions_with_http_info(object_role_permission_group, opts)
      nil
    end

    # Create/update object permission mappings
    # Create/update object permission mappings
    # @param object_role_permission_group 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def update_object_permissions_with_http_info(object_role_permission_group, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.update_object_permissions ...'
      end
      # verify the required parameter 'object_role_permission_group' is set
      if @api_client.config.client_side_validation && object_role_permission_group.nil?
        fail ArgumentError, "Missing the required parameter 'object_role_permission_group' when calling SystemAdministrationApi.update_object_permissions"
      end
      # resource path
      local_var_path = '/aaa/object-permissions'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(object_role_permission_group)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#update_object_permissions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Saves the configuration for policy partial patch
    # Update partial patch configuration values. Only boolean value is allowed for enable_partial_patch. Please refer to the description of PartialPatchConfig for more information. 
    # @param partial_patch_config 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def update_partial_patch_config(partial_patch_config, opts = {})
      update_partial_patch_config_with_http_info(partial_patch_config, opts)
      nil
    end

    # Saves the configuration for policy partial patch
    # Update partial patch configuration values. Only boolean value is allowed for enable_partial_patch. Please refer to the description of PartialPatchConfig for more information. 
    # @param partial_patch_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def update_partial_patch_config_with_http_info(partial_patch_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.update_partial_patch_config ...'
      end
      # verify the required parameter 'partial_patch_config' is set
      if @api_client.config.client_side_validation && partial_patch_config.nil?
        fail ArgumentError, "Missing the required parameter 'partial_patch_config' when calling SystemAdministrationApi.update_partial_patch_config"
      end
      # resource path
      local_var_path = '/system-config/nsx-partial-patch-config'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(partial_patch_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#update_partial_patch_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update transport node maintenance mode
    # Put transport node into maintenance mode or exit from maintenance mode. When HostTransportNode is in maintenance mode no configuration changes are allowed
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :action 
    # @return [nil]
    def update_policy_host_transport_node_maintenance_mode(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      update_policy_host_transport_node_maintenance_mode_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      nil
    end

    # Update transport node maintenance mode
    # Put transport node into maintenance mode or exit from maintenance mode. When HostTransportNode is in maintenance mode no configuration changes are allowed
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :action 
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def update_policy_host_transport_node_maintenance_mode_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.update_policy_host_transport_node_maintenance_mode ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SystemAdministrationApi.update_policy_host_transport_node_maintenance_mode"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling SystemAdministrationApi.update_policy_host_transport_node_maintenance_mode"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling SystemAdministrationApi.update_policy_host_transport_node_maintenance_mode"
      end
      if @api_client.config.client_side_validation && opts[:'action'] && !['enter_maintenance_mode', 'forced_enter_maintenance_mode', 'exit_maintenance_mode'].include?(opts[:'action'])
        fail ArgumentError, 'invalid value for "action", must be one of enter_maintenance_mode, forced_enter_maintenance_mode, exit_maintenance_mode'
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'action'] = opts[:'action'] if !opts[:'action'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#update_policy_host_transport_node_maintenance_mode\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Set role assignment permission configuration
    # Provides a means to allow or disallow project administrators and VPC administrators to assign roles to other users on projects and VPCs. 
    # @param role role id (either \&quot;project_admin\&quot; or \&quot;vpc_admin\&quot;)
    # @param role_assignment_permission_config 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def update_role_assignment_config(role, role_assignment_permission_config, opts = {})
      update_role_assignment_config_with_http_info(role, role_assignment_permission_config, opts)
      nil
    end

    # Set role assignment permission configuration
    # Provides a means to allow or disallow project administrators and VPC administrators to assign roles to other users on projects and VPCs. 
    # @param role role id (either \&quot;project_admin\&quot; or \&quot;vpc_admin\&quot;)
    # @param role_assignment_permission_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def update_role_assignment_config_with_http_info(role, role_assignment_permission_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.update_role_assignment_config ...'
      end
      # verify the required parameter 'role' is set
      if @api_client.config.client_side_validation && role.nil?
        fail ArgumentError, "Missing the required parameter 'role' when calling SystemAdministrationApi.update_role_assignment_config"
      end
      # verify the required parameter 'role_assignment_permission_config' is set
      if @api_client.config.client_side_validation && role_assignment_permission_config.nil?
        fail ArgumentError, "Missing the required parameter 'role_assignment_permission_config' when calling SystemAdministrationApi.update_role_assignment_config"
      end
      # resource path
      local_var_path = '/aaa/roles/{role}/role-assignment-permission-config'.sub('{' + 'role' + '}', role.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(role_assignment_permission_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#update_role_assignment_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update User or Group's roles
    # This API is used to update a user/group any role(s) of choice. It is recommended to use the new property roles_for_paths instead of roles. When using the roles_for_paths, set the read_roles_for_paths as true. User has union of all the roles assigned to it on a particular path and its sub-tree. User name is dealt case-insensitively. This API will merge the existing roles_for_paths with the newly provided roles_for_paths excluding roles_for_paths those are marked for deletion. 
    # @param binding_id User/Group&#39;s id
    # @param role_binding 
    # @param [Hash] opts the optional parameters
    # @return [RoleBinding]
    def update_role_binding(binding_id, role_binding, opts = {})
      data, _status_code, _headers = update_role_binding_with_http_info(binding_id, role_binding, opts)
      data
    end

    # Update User or Group&#39;s roles
    # This API is used to update a user/group any role(s) of choice. It is recommended to use the new property roles_for_paths instead of roles. When using the roles_for_paths, set the read_roles_for_paths as true. User has union of all the roles assigned to it on a particular path and its sub-tree. User name is dealt case-insensitively. This API will merge the existing roles_for_paths with the newly provided roles_for_paths excluding roles_for_paths those are marked for deletion. 
    # @param binding_id User/Group&#39;s id
    # @param role_binding 
    # @param [Hash] opts the optional parameters
    # @return [Array<(RoleBinding, Fixnum, Hash)>] RoleBinding data, response status code and response headers
    def update_role_binding_with_http_info(binding_id, role_binding, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.update_role_binding ...'
      end
      # verify the required parameter 'binding_id' is set
      if @api_client.config.client_side_validation && binding_id.nil?
        fail ArgumentError, "Missing the required parameter 'binding_id' when calling SystemAdministrationApi.update_role_binding"
      end
      # verify the required parameter 'role_binding' is set
      if @api_client.config.client_side_validation && role_binding.nil?
        fail ArgumentError, "Missing the required parameter 'role_binding' when calling SystemAdministrationApi.update_role_binding"
      end
      # resource path
      local_var_path = '/aaa/role-bindings/{binding-id}'.sub('{' + 'binding-id' + '}', binding_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(role_binding)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoleBinding')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#update_role_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update the version whitelist for the specified component type
    # Update the version whitelist for the specified component type (HOST, EDGE, CCP, MP).
    # @param component_type 
    # @param version_list 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def update_version_whitelist(component_type, version_list, opts = {})
      update_version_whitelist_with_http_info(component_type, version_list, opts)
      nil
    end

    # Update the version whitelist for the specified component type
    # Update the version whitelist for the specified component type (HOST, EDGE, CCP, MP).
    # @param component_type 
    # @param version_list 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def update_version_whitelist_with_http_info(component_type, version_list, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.update_version_whitelist ...'
      end
      # verify the required parameter 'component_type' is set
      if @api_client.config.client_side_validation && component_type.nil?
        fail ArgumentError, "Missing the required parameter 'component_type' when calling SystemAdministrationApi.update_version_whitelist"
      end
      # verify the required parameter 'version_list' is set
      if @api_client.config.client_side_validation && version_list.nil?
        fail ArgumentError, "Missing the required parameter 'version_list' when calling SystemAdministrationApi.update_version_whitelist"
      end
      # resource path
      local_var_path = '/upgrade/version-whitelist/{component_type}'.sub('{' + 'component_type' + '}', component_type.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(version_list)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#update_version_whitelist\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update View
    # Update View <br> This API is deprecated and will be unavailable in later releases.
    # @param view_id 
    # @param view 
    # @param [Hash] opts the optional parameters
    # @return [View]
    def update_view(view_id, view, opts = {})
      data, _status_code, _headers = update_view_with_http_info(view_id, view, opts)
      data
    end

    # Update View
    # Update View &lt;br&gt; This API is deprecated and will be unavailable in later releases.
    # @param view_id 
    # @param view 
    # @param [Hash] opts the optional parameters
    # @return [Array<(View, Fixnum, Hash)>] View data, response status code and response headers
    def update_view_with_http_info(view_id, view, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.update_view ...'
      end
      # verify the required parameter 'view_id' is set
      if @api_client.config.client_side_validation && view_id.nil?
        fail ArgumentError, "Missing the required parameter 'view_id' when calling SystemAdministrationApi.update_view"
      end
      # verify the required parameter 'view' is set
      if @api_client.config.client_side_validation && view.nil?
        fail ArgumentError, "Missing the required parameter 'view' when calling SystemAdministrationApi.update_view"
      end
      # resource path
      local_var_path = '/ui-views/{view-id}'.sub('{' + 'view-id' + '}', view_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(view)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'View')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#update_view\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Widget Configuration
    # Updates the widget at the given view. If the widget is referenced by other views, then the widget will be updated in all the views that it is part of.  <br> This API is deprecated and will be unavailable in later releases.
    # @param view_id 
    # @param widgetconfiguration_id 
    # @param widget_configuration 
    # @param [Hash] opts the optional parameters
    # @return [WidgetConfiguration]
    def update_widget_configuration(view_id, widgetconfiguration_id, widget_configuration, opts = {})
      data, _status_code, _headers = update_widget_configuration_with_http_info(view_id, widgetconfiguration_id, widget_configuration, opts)
      data
    end

    # Update Widget Configuration
    # Updates the widget at the given view. If the widget is referenced by other views, then the widget will be updated in all the views that it is part of.  &lt;br&gt; This API is deprecated and will be unavailable in later releases.
    # @param view_id 
    # @param widgetconfiguration_id 
    # @param widget_configuration 
    # @param [Hash] opts the optional parameters
    # @return [Array<(WidgetConfiguration, Fixnum, Hash)>] WidgetConfiguration data, response status code and response headers
    def update_widget_configuration_with_http_info(view_id, widgetconfiguration_id, widget_configuration, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.update_widget_configuration ...'
      end
      # verify the required parameter 'view_id' is set
      if @api_client.config.client_side_validation && view_id.nil?
        fail ArgumentError, "Missing the required parameter 'view_id' when calling SystemAdministrationApi.update_widget_configuration"
      end
      # verify the required parameter 'widgetconfiguration_id' is set
      if @api_client.config.client_side_validation && widgetconfiguration_id.nil?
        fail ArgumentError, "Missing the required parameter 'widgetconfiguration_id' when calling SystemAdministrationApi.update_widget_configuration"
      end
      # verify the required parameter 'widget_configuration' is set
      if @api_client.config.client_side_validation && widget_configuration.nil?
        fail ArgumentError, "Missing the required parameter 'widget_configuration' when calling SystemAdministrationApi.update_widget_configuration"
      end
      # resource path
      local_var_path = '/ui-views/{view-id}/widgetconfigurations/{widgetconfiguration-id}'.sub('{' + 'view-id' + '}', view_id.to_s).sub('{' + 'widgetconfiguration-id' + '}', widgetconfiguration_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(widget_configuration)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'WidgetConfiguration')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#update_widget_configuration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Validate a new feature permission set
    # Validate the permissions of an incoming role. Also, recommend the permissions which need to be corrected. 
    # @param feature_permission_array 
    # @param [Hash] opts the optional parameters
    # @return [RecommendedFeaturePermissionListResult]
    def validate_and_recommend_permissions(feature_permission_array, opts = {})
      data, _status_code, _headers = validate_and_recommend_permissions_with_http_info(feature_permission_array, opts)
      data
    end

    # Validate a new feature permission set
    # Validate the permissions of an incoming role. Also, recommend the permissions which need to be corrected. 
    # @param feature_permission_array 
    # @param [Hash] opts the optional parameters
    # @return [Array<(RecommendedFeaturePermissionListResult, Fixnum, Hash)>] RecommendedFeaturePermissionListResult data, response status code and response headers
    def validate_and_recommend_permissions_with_http_info(feature_permission_array, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemAdministrationApi.validate_and_recommend_permissions ...'
      end
      # verify the required parameter 'feature_permission_array' is set
      if @api_client.config.client_side_validation && feature_permission_array.nil?
        fail ArgumentError, "Missing the required parameter 'feature_permission_array' when calling SystemAdministrationApi.validate_and_recommend_permissions"
      end
      # resource path
      local_var_path = '/aaa/roles?action=validate'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(feature_permission_array)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RecommendedFeaturePermissionListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemAdministrationApi#validate_and_recommend_permissions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
