=begin
#NSX Policy API

#VMware NSX Policy REST API

OpenAPI spec version: 9.0.0.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.4.46

=end

require 'uri'

module Nsxt9PolicyClient
  class RoutingApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Create or update a BGP neighbor config
    # If BGP neighbor config with the neighbor-id is not already present, create a new neighbor config. If it already exists, replace the BGP neighbor config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param bgp_neighbor_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [BgpNeighborConfig]
    def create_or_replace_bgp_neighbor_config(tier_0_id, locale_service_id, neighbor_id, bgp_neighbor_config, opts = {})
      data, _status_code, _headers = create_or_replace_bgp_neighbor_config_with_http_info(tier_0_id, locale_service_id, neighbor_id, bgp_neighbor_config, opts)
      data
    end

    # Create or update a BGP neighbor config
    # If BGP neighbor config with the neighbor-id is not already present, create a new neighbor config. If it already exists, replace the BGP neighbor config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param bgp_neighbor_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(BgpNeighborConfig, Fixnum, Hash)>] BgpNeighborConfig data, response status code and response headers
    def create_or_replace_bgp_neighbor_config_with_http_info(tier_0_id, locale_service_id, neighbor_id, bgp_neighbor_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.create_or_replace_bgp_neighbor_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.create_or_replace_bgp_neighbor_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.create_or_replace_bgp_neighbor_config"
      end
      # verify the required parameter 'neighbor_id' is set
      if @api_client.config.client_side_validation && neighbor_id.nil?
        fail ArgumentError, "Missing the required parameter 'neighbor_id' when calling RoutingApi.create_or_replace_bgp_neighbor_config"
      end
      # verify the required parameter 'bgp_neighbor_config' is set
      if @api_client.config.client_side_validation && bgp_neighbor_config.nil?
        fail ArgumentError, "Missing the required parameter 'bgp_neighbor_config' when calling RoutingApi.create_or_replace_bgp_neighbor_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/neighbors/{neighbor-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'neighbor-id' + '}', neighbor_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(bgp_neighbor_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpNeighborConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#create_or_replace_bgp_neighbor_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a BGP routing config
    # If BGP routing config is not already present, create BGP routing config. If it already exists, replace the BGP routing config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param bgp_routing_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [BgpRoutingConfig]
    def create_or_replace_bgp_routing_config(tier_0_id, locale_service_id, bgp_routing_config, opts = {})
      data, _status_code, _headers = create_or_replace_bgp_routing_config_with_http_info(tier_0_id, locale_service_id, bgp_routing_config, opts)
      data
    end

    # Create or update a BGP routing config
    # If BGP routing config is not already present, create BGP routing config. If it already exists, replace the BGP routing config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param bgp_routing_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(BgpRoutingConfig, Fixnum, Hash)>] BgpRoutingConfig data, response status code and response headers
    def create_or_replace_bgp_routing_config_with_http_info(tier_0_id, locale_service_id, bgp_routing_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.create_or_replace_bgp_routing_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.create_or_replace_bgp_routing_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.create_or_replace_bgp_routing_config"
      end
      # verify the required parameter 'bgp_routing_config' is set
      if @api_client.config.client_side_validation && bgp_routing_config.nil?
        fail ArgumentError, "Missing the required parameter 'bgp_routing_config' when calling RoutingApi.create_or_replace_bgp_routing_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(bgp_routing_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpRoutingConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#create_or_replace_bgp_routing_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a BGP troubleshoot config
    # If BGP troubleshoot config is not present in BGP configuration, create a new BGP troubleshoot config with default value. If it already exists, update the BGP troubleshoot config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param bgp_troubleshoot_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [BgpTroubleshootConfig]
    def create_or_replace_bgp_troubleshoot_config(tier_0_id, locale_service_id, bgp_troubleshoot_config, opts = {})
      data, _status_code, _headers = create_or_replace_bgp_troubleshoot_config_with_http_info(tier_0_id, locale_service_id, bgp_troubleshoot_config, opts)
      data
    end

    # Create or update a BGP troubleshoot config
    # If BGP troubleshoot config is not present in BGP configuration, create a new BGP troubleshoot config with default value. If it already exists, update the BGP troubleshoot config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param bgp_troubleshoot_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(BgpTroubleshootConfig, Fixnum, Hash)>] BgpTroubleshootConfig data, response status code and response headers
    def create_or_replace_bgp_troubleshoot_config_with_http_info(tier_0_id, locale_service_id, bgp_troubleshoot_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.create_or_replace_bgp_troubleshoot_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.create_or_replace_bgp_troubleshoot_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.create_or_replace_bgp_troubleshoot_config"
      end
      # verify the required parameter 'bgp_troubleshoot_config' is set
      if @api_client.config.client_side_validation && bgp_troubleshoot_config.nil?
        fail ArgumentError, "Missing the required parameter 'bgp_troubleshoot_config' when calling RoutingApi.create_or_replace_bgp_troubleshoot_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/troubleshoot'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(bgp_troubleshoot_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpTroubleshootConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#create_or_replace_bgp_troubleshoot_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a BGP community list
    # If a community list with the community-list-id is not already present, create a new community list. If it already exists, replace the community list instance with the new object. 
    # @param tier_0_id 
    # @param community_list_id 
    # @param community_list 
    # @param [Hash] opts the optional parameters
    # @return [CommunityList]
    def create_or_replace_community_list(tier_0_id, community_list_id, community_list, opts = {})
      data, _status_code, _headers = create_or_replace_community_list_with_http_info(tier_0_id, community_list_id, community_list, opts)
      data
    end

    # Create or update a BGP community list
    # If a community list with the community-list-id is not already present, create a new community list. If it already exists, replace the community list instance with the new object. 
    # @param tier_0_id 
    # @param community_list_id 
    # @param community_list 
    # @param [Hash] opts the optional parameters
    # @return [Array<(CommunityList, Fixnum, Hash)>] CommunityList data, response status code and response headers
    def create_or_replace_community_list_with_http_info(tier_0_id, community_list_id, community_list, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.create_or_replace_community_list ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.create_or_replace_community_list"
      end
      # verify the required parameter 'community_list_id' is set
      if @api_client.config.client_side_validation && community_list_id.nil?
        fail ArgumentError, "Missing the required parameter 'community_list_id' when calling RoutingApi.create_or_replace_community_list"
      end
      # verify the required parameter 'community_list' is set
      if @api_client.config.client_side_validation && community_list.nil?
        fail ArgumentError, "Missing the required parameter 'community_list' when calling RoutingApi.create_or_replace_community_list"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/community-lists/{community-list-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'community-list-id' + '}', community_list_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(community_list)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'CommunityList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#create_or_replace_community_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a prefix list
    # If prefix list for prefix-list-id is not already present, create a prefix list. If it already exists, replace the prefix list for prefix-list-id. Note:    Updating existing prefixes require order to be  preserved to avoid traffic impact. During PATCH operation,    reordering of existing prefixes may impact routes and eventually datapath.    Order here is crucial and it all depends upon action. If action for every prefix is PERMIT then order may    not impact but if there is DENY prefix then change in ordering could lead to traffic impact. 
    # @param prefix_list_id 
    # @param prefix_list 
    # @param [Hash] opts the optional parameters
    # @return [PrefixList]
    def create_or_replace_infra_prefix_list(prefix_list_id, prefix_list, opts = {})
      data, _status_code, _headers = create_or_replace_infra_prefix_list_with_http_info(prefix_list_id, prefix_list, opts)
      data
    end

    # Create or update a prefix list
    # If prefix list for prefix-list-id is not already present, create a prefix list. If it already exists, replace the prefix list for prefix-list-id. Note:    Updating existing prefixes require order to be  preserved to avoid traffic impact. During PATCH operation,    reordering of existing prefixes may impact routes and eventually datapath.    Order here is crucial and it all depends upon action. If action for every prefix is PERMIT then order may    not impact but if there is DENY prefix then change in ordering could lead to traffic impact. 
    # @param prefix_list_id 
    # @param prefix_list 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PrefixList, Fixnum, Hash)>] PrefixList data, response status code and response headers
    def create_or_replace_infra_prefix_list_with_http_info(prefix_list_id, prefix_list, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.create_or_replace_infra_prefix_list ...'
      end
      # verify the required parameter 'prefix_list_id' is set
      if @api_client.config.client_side_validation && prefix_list_id.nil?
        fail ArgumentError, "Missing the required parameter 'prefix_list_id' when calling RoutingApi.create_or_replace_infra_prefix_list"
      end
      # verify the required parameter 'prefix_list' is set
      if @api_client.config.client_side_validation && prefix_list.nil?
        fail ArgumentError, "Missing the required parameter 'prefix_list' when calling RoutingApi.create_or_replace_infra_prefix_list"
      end
      # resource path
      local_var_path = '/infra/routing-config/prefix-lists/{prefix-list-id}'.sub('{' + 'prefix-list-id' + '}', prefix_list_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(prefix_list)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PrefixList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#create_or_replace_infra_prefix_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a OSPF Area config
    # If OSPF Area config is not already present, create OSPF Area config. If it already exists, replace the OSPF Area config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param area_id 
    # @param ospf_area_config 
    # @param [Hash] opts the optional parameters
    # @return [OspfAreaConfig]
    def create_or_replace_ospf_area_config(tier_0_id, locale_service_id, area_id, ospf_area_config, opts = {})
      data, _status_code, _headers = create_or_replace_ospf_area_config_with_http_info(tier_0_id, locale_service_id, area_id, ospf_area_config, opts)
      data
    end

    # Create or update a OSPF Area config
    # If OSPF Area config is not already present, create OSPF Area config. If it already exists, replace the OSPF Area config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param area_id 
    # @param ospf_area_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(OspfAreaConfig, Fixnum, Hash)>] OspfAreaConfig data, response status code and response headers
    def create_or_replace_ospf_area_config_with_http_info(tier_0_id, locale_service_id, area_id, ospf_area_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.create_or_replace_ospf_area_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.create_or_replace_ospf_area_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.create_or_replace_ospf_area_config"
      end
      # verify the required parameter 'area_id' is set
      if @api_client.config.client_side_validation && area_id.nil?
        fail ArgumentError, "Missing the required parameter 'area_id' when calling RoutingApi.create_or_replace_ospf_area_config"
      end
      # verify the required parameter 'ospf_area_config' is set
      if @api_client.config.client_side_validation && ospf_area_config.nil?
        fail ArgumentError, "Missing the required parameter 'ospf_area_config' when calling RoutingApi.create_or_replace_ospf_area_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/ospf/areas/{area-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'area-id' + '}', area_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(ospf_area_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'OspfAreaConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#create_or_replace_ospf_area_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a OSPF routing config
    # If OSPF routing config is not already present, create OSPF routing config. If it already exists, replace the OSPF routing config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param ospf_routing_config 
    # @param [Hash] opts the optional parameters
    # @return [OspfRoutingConfig]
    def create_or_replace_ospf_routing_config(tier_0_id, locale_service_id, ospf_routing_config, opts = {})
      data, _status_code, _headers = create_or_replace_ospf_routing_config_with_http_info(tier_0_id, locale_service_id, ospf_routing_config, opts)
      data
    end

    # Create or update a OSPF routing config
    # If OSPF routing config is not already present, create OSPF routing config. If it already exists, replace the OSPF routing config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param ospf_routing_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(OspfRoutingConfig, Fixnum, Hash)>] OspfRoutingConfig data, response status code and response headers
    def create_or_replace_ospf_routing_config_with_http_info(tier_0_id, locale_service_id, ospf_routing_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.create_or_replace_ospf_routing_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.create_or_replace_ospf_routing_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.create_or_replace_ospf_routing_config"
      end
      # verify the required parameter 'ospf_routing_config' is set
      if @api_client.config.client_side_validation && ospf_routing_config.nil?
        fail ArgumentError, "Missing the required parameter 'ospf_routing_config' when calling RoutingApi.create_or_replace_ospf_routing_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/ospf'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(ospf_routing_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'OspfRoutingConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#create_or_replace_ospf_routing_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a prefix list
    # If prefix list for prefix-list-id is not already present, create a prefix list. If it already exists, replace the prefix list for prefix-list-id. Note:    Updating existing prefixes require order to be  preserved to avoid traffic impact. During PATCH operation,    reordering of existing prefixes may impact routes and eventually datapath.    Order here is crucial and it all depends upon action. If action for every prefix is PERMIT then order may    not impact but if there is DENY prefix then change in ordering could lead to traffic impact. 
    # @param tier_0_id Tier-0 ID
    # @param prefix_list_id Prefix List ID
    # @param prefix_list 
    # @param [Hash] opts the optional parameters
    # @return [PrefixList]
    def create_or_replace_prefix_list(tier_0_id, prefix_list_id, prefix_list, opts = {})
      data, _status_code, _headers = create_or_replace_prefix_list_with_http_info(tier_0_id, prefix_list_id, prefix_list, opts)
      data
    end

    # Create or update a prefix list
    # If prefix list for prefix-list-id is not already present, create a prefix list. If it already exists, replace the prefix list for prefix-list-id. Note:    Updating existing prefixes require order to be  preserved to avoid traffic impact. During PATCH operation,    reordering of existing prefixes may impact routes and eventually datapath.    Order here is crucial and it all depends upon action. If action for every prefix is PERMIT then order may    not impact but if there is DENY prefix then change in ordering could lead to traffic impact. 
    # @param tier_0_id Tier-0 ID
    # @param prefix_list_id Prefix List ID
    # @param prefix_list 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PrefixList, Fixnum, Hash)>] PrefixList data, response status code and response headers
    def create_or_replace_prefix_list_with_http_info(tier_0_id, prefix_list_id, prefix_list, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.create_or_replace_prefix_list ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.create_or_replace_prefix_list"
      end
      # verify the required parameter 'prefix_list_id' is set
      if @api_client.config.client_side_validation && prefix_list_id.nil?
        fail ArgumentError, "Missing the required parameter 'prefix_list_id' when calling RoutingApi.create_or_replace_prefix_list"
      end
      # verify the required parameter 'prefix_list' is set
      if @api_client.config.client_side_validation && prefix_list.nil?
        fail ArgumentError, "Missing the required parameter 'prefix_list' when calling RoutingApi.create_or_replace_prefix_list"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/prefix-lists/{prefix-list-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'prefix-list-id' + '}', prefix_list_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(prefix_list)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PrefixList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#create_or_replace_prefix_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a route map
    # If a route map with the route-map-id is not already present, create a new route map. If it already exists, replace the route map instance with the new object. 
    # @param tier_0_id 
    # @param route_map_id 
    # @param tier0_route_map 
    # @param [Hash] opts the optional parameters
    # @return [Tier0RouteMap]
    def create_or_replace_route_map(tier_0_id, route_map_id, tier0_route_map, opts = {})
      data, _status_code, _headers = create_or_replace_route_map_with_http_info(tier_0_id, route_map_id, tier0_route_map, opts)
      data
    end

    # Create or update a route map
    # If a route map with the route-map-id is not already present, create a new route map. If it already exists, replace the route map instance with the new object. 
    # @param tier_0_id 
    # @param route_map_id 
    # @param tier0_route_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Tier0RouteMap, Fixnum, Hash)>] Tier0RouteMap data, response status code and response headers
    def create_or_replace_route_map_with_http_info(tier_0_id, route_map_id, tier0_route_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.create_or_replace_route_map ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.create_or_replace_route_map"
      end
      # verify the required parameter 'route_map_id' is set
      if @api_client.config.client_side_validation && route_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_map_id' when calling RoutingApi.create_or_replace_route_map"
      end
      # verify the required parameter 'tier0_route_map' is set
      if @api_client.config.client_side_validation && tier0_route_map.nil?
        fail ArgumentError, "Missing the required parameter 'tier0_route_map' when calling RoutingApi.create_or_replace_route_map"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/route-maps/{route-map-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'route-map-id' + '}', route_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tier0_route_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Tier0RouteMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#create_or_replace_route_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a StaticRouteBfdTroubleshootConfig
    # If a StaticRouteBfdTroubleshootConfig is not already present, create a new StaticRouteBfdTroubleshootConfig. If it already exists, update the StaticRouteBfdTroubleshootConfig. This operation will fully replace the object. 
    # @param tier_0_id Tier-0 ID
    # @param static_route_bfd_troubleshoot_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [StaticRouteBfdTroubleshootConfig]
    def create_or_replace_static_route_bfd_troubleshoot_config(tier_0_id, static_route_bfd_troubleshoot_config, opts = {})
      data, _status_code, _headers = create_or_replace_static_route_bfd_troubleshoot_config_with_http_info(tier_0_id, static_route_bfd_troubleshoot_config, opts)
      data
    end

    # Create or update a StaticRouteBfdTroubleshootConfig
    # If a StaticRouteBfdTroubleshootConfig is not already present, create a new StaticRouteBfdTroubleshootConfig. If it already exists, update the StaticRouteBfdTroubleshootConfig. This operation will fully replace the object. 
    # @param tier_0_id Tier-0 ID
    # @param static_route_bfd_troubleshoot_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(StaticRouteBfdTroubleshootConfig, Fixnum, Hash)>] StaticRouteBfdTroubleshootConfig data, response status code and response headers
    def create_or_replace_static_route_bfd_troubleshoot_config_with_http_info(tier_0_id, static_route_bfd_troubleshoot_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.create_or_replace_static_route_bfd_troubleshoot_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.create_or_replace_static_route_bfd_troubleshoot_config"
      end
      # verify the required parameter 'static_route_bfd_troubleshoot_config' is set
      if @api_client.config.client_side_validation && static_route_bfd_troubleshoot_config.nil?
        fail ArgumentError, "Missing the required parameter 'static_route_bfd_troubleshoot_config' when calling RoutingApi.create_or_replace_static_route_bfd_troubleshoot_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/static-routes/bfd-peers/troubleshoot'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(static_route_bfd_troubleshoot_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRouteBfdTroubleshootConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#create_or_replace_static_route_bfd_troubleshoot_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a Tier-0 static routes
    # If static routes for route-id are not already present, create static routes. If it already exists, replace the static routes for route-id. 
    # @param tier_0_id 
    # @param route_id 
    # @param static_routes 
    # @param [Hash] opts the optional parameters
    # @return [StaticRoutes]
    def create_or_replace_tier0_static_routes(tier_0_id, route_id, static_routes, opts = {})
      data, _status_code, _headers = create_or_replace_tier0_static_routes_with_http_info(tier_0_id, route_id, static_routes, opts)
      data
    end

    # Create or update a Tier-0 static routes
    # If static routes for route-id are not already present, create static routes. If it already exists, replace the static routes for route-id. 
    # @param tier_0_id 
    # @param route_id 
    # @param static_routes 
    # @param [Hash] opts the optional parameters
    # @return [Array<(StaticRoutes, Fixnum, Hash)>] StaticRoutes data, response status code and response headers
    def create_or_replace_tier0_static_routes_with_http_info(tier_0_id, route_id, static_routes, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.create_or_replace_tier0_static_routes ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.create_or_replace_tier0_static_routes"
      end
      # verify the required parameter 'route_id' is set
      if @api_client.config.client_side_validation && route_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_id' when calling RoutingApi.create_or_replace_tier0_static_routes"
      end
      # verify the required parameter 'static_routes' is set
      if @api_client.config.client_side_validation && static_routes.nil?
        fail ArgumentError, "Missing the required parameter 'static_routes' when calling RoutingApi.create_or_replace_tier0_static_routes"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/static-routes/{route-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'route-id' + '}', route_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(static_routes)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRoutes')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#create_or_replace_tier0_static_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a Tier-1 static routes
    # If static routes for route-id are not already present, create static routes. If it already exists, replace the static routes for route-id. 
    # @param tier_1_id 
    # @param route_id 
    # @param static_routes 
    # @param [Hash] opts the optional parameters
    # @return [StaticRoutes]
    def create_or_replace_tier1_static_routes(tier_1_id, route_id, static_routes, opts = {})
      data, _status_code, _headers = create_or_replace_tier1_static_routes_with_http_info(tier_1_id, route_id, static_routes, opts)
      data
    end

    # Create or update a Tier-1 static routes
    # If static routes for route-id are not already present, create static routes. If it already exists, replace the static routes for route-id. 
    # @param tier_1_id 
    # @param route_id 
    # @param static_routes 
    # @param [Hash] opts the optional parameters
    # @return [Array<(StaticRoutes, Fixnum, Hash)>] StaticRoutes data, response status code and response headers
    def create_or_replace_tier1_static_routes_with_http_info(tier_1_id, route_id, static_routes, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.create_or_replace_tier1_static_routes ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.create_or_replace_tier1_static_routes"
      end
      # verify the required parameter 'route_id' is set
      if @api_client.config.client_side_validation && route_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_id' when calling RoutingApi.create_or_replace_tier1_static_routes"
      end
      # verify the required parameter 'static_routes' is set
      if @api_client.config.client_side_validation && static_routes.nil?
        fail ArgumentError, "Missing the required parameter 'static_routes' when calling RoutingApi.create_or_replace_tier1_static_routes"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/static-routes/{route-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'route-id' + '}', route_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(static_routes)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRoutes')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#create_or_replace_tier1_static_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete BGP neighbor config
    # Delete BGP neighbor config
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def delete_bgp_neighbor_config(tier_0_id, locale_service_id, neighbor_id, opts = {})
      delete_bgp_neighbor_config_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts)
      nil
    end

    # Delete BGP neighbor config
    # Delete BGP neighbor config
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_bgp_neighbor_config_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.delete_bgp_neighbor_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.delete_bgp_neighbor_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.delete_bgp_neighbor_config"
      end
      # verify the required parameter 'neighbor_id' is set
      if @api_client.config.client_side_validation && neighbor_id.nil?
        fail ArgumentError, "Missing the required parameter 'neighbor_id' when calling RoutingApi.delete_bgp_neighbor_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/neighbors/{neighbor-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'neighbor-id' + '}', neighbor_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#delete_bgp_neighbor_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a BGP community list
    # Delete a BGP community list
    # @param tier_0_id 
    # @param community_list_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_community_list(tier_0_id, community_list_id, opts = {})
      delete_community_list_with_http_info(tier_0_id, community_list_id, opts)
      nil
    end

    # Delete a BGP community list
    # Delete a BGP community list
    # @param tier_0_id 
    # @param community_list_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_community_list_with_http_info(tier_0_id, community_list_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.delete_community_list ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.delete_community_list"
      end
      # verify the required parameter 'community_list_id' is set
      if @api_client.config.client_side_validation && community_list_id.nil?
        fail ArgumentError, "Missing the required parameter 'community_list_id' when calling RoutingApi.delete_community_list"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/community-lists/{community-list-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'community-list-id' + '}', community_list_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#delete_community_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a prefix list
    # Delete a prefix list
    # @param prefix_list_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_infra_prefix_list(prefix_list_id, opts = {})
      delete_infra_prefix_list_with_http_info(prefix_list_id, opts)
      nil
    end

    # Delete a prefix list
    # Delete a prefix list
    # @param prefix_list_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_infra_prefix_list_with_http_info(prefix_list_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.delete_infra_prefix_list ...'
      end
      # verify the required parameter 'prefix_list_id' is set
      if @api_client.config.client_side_validation && prefix_list_id.nil?
        fail ArgumentError, "Missing the required parameter 'prefix_list_id' when calling RoutingApi.delete_infra_prefix_list"
      end
      # resource path
      local_var_path = '/infra/routing-config/prefix-lists/{prefix-list-id}'.sub('{' + 'prefix-list-id' + '}', prefix_list_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#delete_infra_prefix_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete OSPF Area config
    # Delete OSPF Area config 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param area_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_ospf_area_config(tier_0_id, locale_service_id, area_id, opts = {})
      delete_ospf_area_config_with_http_info(tier_0_id, locale_service_id, area_id, opts)
      nil
    end

    # Delete OSPF Area config
    # Delete OSPF Area config 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param area_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_ospf_area_config_with_http_info(tier_0_id, locale_service_id, area_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.delete_ospf_area_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.delete_ospf_area_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.delete_ospf_area_config"
      end
      # verify the required parameter 'area_id' is set
      if @api_client.config.client_side_validation && area_id.nil?
        fail ArgumentError, "Missing the required parameter 'area_id' when calling RoutingApi.delete_ospf_area_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/ospf/areas/{area-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'area-id' + '}', area_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#delete_ospf_area_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete overridden BGP routing config
    # Deletes the specified overridden BgpRoutingConfig. If the BgpRoutingConfig is not overridden, it won't get deleted. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def delete_overridden_bgp_routing_config(tier_0_id, locale_service_id, opts = {})
      delete_overridden_bgp_routing_config_with_http_info(tier_0_id, locale_service_id, opts)
      nil
    end

    # Delete overridden BGP routing config
    # Deletes the specified overridden BgpRoutingConfig. If the BgpRoutingConfig is not overridden, it won&#39;t get deleted. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_overridden_bgp_routing_config_with_http_info(tier_0_id, locale_service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.delete_overridden_bgp_routing_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.delete_overridden_bgp_routing_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.delete_overridden_bgp_routing_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#delete_overridden_bgp_routing_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete inter-vrf routing config
    # Delete inter-vrf routing config.
    # @param tier_0_id 
    # @param inter_vrf_routing_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_policy_inter_vrf_routing_config(tier_0_id, inter_vrf_routing_id, opts = {})
      delete_policy_inter_vrf_routing_config_with_http_info(tier_0_id, inter_vrf_routing_id, opts)
      nil
    end

    # Delete inter-vrf routing config
    # Delete inter-vrf routing config.
    # @param tier_0_id 
    # @param inter_vrf_routing_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_policy_inter_vrf_routing_config_with_http_info(tier_0_id, inter_vrf_routing_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.delete_policy_inter_vrf_routing_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.delete_policy_inter_vrf_routing_config"
      end
      # verify the required parameter 'inter_vrf_routing_id' is set
      if @api_client.config.client_side_validation && inter_vrf_routing_id.nil?
        fail ArgumentError, "Missing the required parameter 'inter_vrf_routing_id' when calling RoutingApi.delete_policy_inter_vrf_routing_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/inter-vrf-routing/{inter-vrf-routing-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'inter-vrf-routing-id' + '}', inter_vrf_routing_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#delete_policy_inter_vrf_routing_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a prefix list
    # Delete a prefix list
    # @param tier_0_id 
    # @param prefix_list_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_prefix_list(tier_0_id, prefix_list_id, opts = {})
      delete_prefix_list_with_http_info(tier_0_id, prefix_list_id, opts)
      nil
    end

    # Delete a prefix list
    # Delete a prefix list
    # @param tier_0_id 
    # @param prefix_list_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_prefix_list_with_http_info(tier_0_id, prefix_list_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.delete_prefix_list ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.delete_prefix_list"
      end
      # verify the required parameter 'prefix_list_id' is set
      if @api_client.config.client_side_validation && prefix_list_id.nil?
        fail ArgumentError, "Missing the required parameter 'prefix_list_id' when calling RoutingApi.delete_prefix_list"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/prefix-lists/{prefix-list-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'prefix-list-id' + '}', prefix_list_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#delete_prefix_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a route filter
    # Delete a route filter
    # @param route_filter_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_project_route_filter(route_filter_id, opts = {})
      delete_project_route_filter_with_http_info(route_filter_id, opts)
      nil
    end

    # Delete a route filter
    # Delete a route filter
    # @param route_filter_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_project_route_filter_with_http_info(route_filter_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.delete_project_route_filter ...'
      end
      # verify the required parameter 'route_filter_id' is set
      if @api_client.config.client_side_validation && route_filter_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_filter_id' when calling RoutingApi.delete_project_route_filter"
      end
      # resource path
      local_var_path = '/infra/routing-config/project-route-filters/{route-filter-id}'.sub('{' + 'route-filter-id' + '}', route_filter_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#delete_project_route_filter\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete this StaticRouteBfdPeer and all the entities contained by it.
    # Delete this StaticRouteBfdPeer and all the entities contained by it.
    # @param tier_0_id Tier-0 ID
    # @param bfd_peer_id BFD peer ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_static_route_bfd_peer(tier_0_id, bfd_peer_id, opts = {})
      delete_static_route_bfd_peer_with_http_info(tier_0_id, bfd_peer_id, opts)
      nil
    end

    # Delete this StaticRouteBfdPeer and all the entities contained by it.
    # Delete this StaticRouteBfdPeer and all the entities contained by it.
    # @param tier_0_id Tier-0 ID
    # @param bfd_peer_id BFD peer ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_static_route_bfd_peer_with_http_info(tier_0_id, bfd_peer_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.delete_static_route_bfd_peer ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.delete_static_route_bfd_peer"
      end
      # verify the required parameter 'bfd_peer_id' is set
      if @api_client.config.client_side_validation && bfd_peer_id.nil?
        fail ArgumentError, "Missing the required parameter 'bfd_peer_id' when calling RoutingApi.delete_static_route_bfd_peer"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/static-routes/bfd-peers/{bfd-peer-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'bfd-peer-id' + '}', bfd_peer_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#delete_static_route_bfd_peer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Tier-0 static routes
    # Delete Tier-0 static routes
    # @param tier_0_id 
    # @param route_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_tier0_static_routes(tier_0_id, route_id, opts = {})
      delete_tier0_static_routes_with_http_info(tier_0_id, route_id, opts)
      nil
    end

    # Delete Tier-0 static routes
    # Delete Tier-0 static routes
    # @param tier_0_id 
    # @param route_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_tier0_static_routes_with_http_info(tier_0_id, route_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.delete_tier0_static_routes ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.delete_tier0_static_routes"
      end
      # verify the required parameter 'route_id' is set
      if @api_client.config.client_side_validation && route_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_id' when calling RoutingApi.delete_tier0_static_routes"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/static-routes/{route-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'route-id' + '}', route_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#delete_tier0_static_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Tier-1 static routes
    # Delete Tier-1 static routes
    # @param tier_1_id 
    # @param route_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_tier1_static_routes(tier_1_id, route_id, opts = {})
      delete_tier1_static_routes_with_http_info(tier_1_id, route_id, opts)
      nil
    end

    # Delete Tier-1 static routes
    # Delete Tier-1 static routes
    # @param tier_1_id 
    # @param route_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_tier1_static_routes_with_http_info(tier_1_id, route_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.delete_tier1_static_routes ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.delete_tier1_static_routes"
      end
      # verify the required parameter 'route_id' is set
      if @api_client.config.client_side_validation && route_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_id' when calling RoutingApi.delete_tier1_static_routes"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/static-routes/{route-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'route-id' + '}', route_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#delete_tier1_static_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Recover of Tier0 and linked tier1 gateway(s).
    # API to recover specified Tier0 gateway and linked tier1 gateway from primary site path to new primary site path. This will update intent of affected Tier-0 and Tier-1 gateway. 
    # @param gateway_site_failover_action_config 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def gateway_site_failover_action(gateway_site_failover_action_config, opts = {})
      gateway_site_failover_action_with_http_info(gateway_site_failover_action_config, opts)
      nil
    end

    # Recover of Tier0 and linked tier1 gateway(s).
    # API to recover specified Tier0 gateway and linked tier1 gateway from primary site path to new primary site path. This will update intent of affected Tier-0 and Tier-1 gateway. 
    # @param gateway_site_failover_action_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def gateway_site_failover_action_with_http_info(gateway_site_failover_action_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.gateway_site_failover_action ...'
      end
      # verify the required parameter 'gateway_site_failover_action_config' is set
      if @api_client.config.client_side_validation && gateway_site_failover_action_config.nil?
        fail ArgumentError, "Missing the required parameter 'gateway_site_failover_action_config' when calling RoutingApi.gateway_site_failover_action"
      end
      # resource path
      local_var_path = '/infra/tier-0s?action=site_failover'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(gateway_site_failover_action_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#gateway_site_failover_action\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List advertised networks
    # Returns information about all networks which advertised to TIER0 LR. 
    # @param tier_0_id 
    # @param inter_vrf_routing_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PolicyAdvertisedNetworksListResult]
    def get_advertised_networks(tier_0_id, inter_vrf_routing_id, opts = {})
      data, _status_code, _headers = get_advertised_networks_with_http_info(tier_0_id, inter_vrf_routing_id, opts)
      data
    end

    # List advertised networks
    # Returns information about all networks which advertised to TIER0 LR. 
    # @param tier_0_id 
    # @param inter_vrf_routing_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PolicyAdvertisedNetworksListResult, Fixnum, Hash)>] PolicyAdvertisedNetworksListResult data, response status code and response headers
    def get_advertised_networks_with_http_info(tier_0_id, inter_vrf_routing_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_advertised_networks ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.get_advertised_networks"
      end
      # verify the required parameter 'inter_vrf_routing_id' is set
      if @api_client.config.client_side_validation && inter_vrf_routing_id.nil?
        fail ArgumentError, "Missing the required parameter 'inter_vrf_routing_id' when calling RoutingApi.get_advertised_networks"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_advertised_networks, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_advertised_networks, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/inter-vrf-routing/{inter-vrf-routing-id}/advertised-networks'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'inter-vrf-routing-id' + '}', inter_vrf_routing_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyAdvertisedNetworksListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_advertised_networks\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List advertised networks in CSV format
    # List advertised networks in CSV format. 
    # @param tier_0_id 
    # @param inter_vrf_routing_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PolicyAdvertisedNetworkInCsvFormat]
    def get_advertised_networks_in_csv_format(tier_0_id, inter_vrf_routing_id, opts = {})
      data, _status_code, _headers = get_advertised_networks_in_csv_format_with_http_info(tier_0_id, inter_vrf_routing_id, opts)
      data
    end

    # List advertised networks in CSV format
    # List advertised networks in CSV format. 
    # @param tier_0_id 
    # @param inter_vrf_routing_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PolicyAdvertisedNetworkInCsvFormat, Fixnum, Hash)>] PolicyAdvertisedNetworkInCsvFormat data, response status code and response headers
    def get_advertised_networks_in_csv_format_with_http_info(tier_0_id, inter_vrf_routing_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_advertised_networks_in_csv_format ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.get_advertised_networks_in_csv_format"
      end
      # verify the required parameter 'inter_vrf_routing_id' is set
      if @api_client.config.client_side_validation && inter_vrf_routing_id.nil?
        fail ArgumentError, "Missing the required parameter 'inter_vrf_routing_id' when calling RoutingApi.get_advertised_networks_in_csv_format"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_advertised_networks_in_csv_format, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_advertised_networks_in_csv_format, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/inter-vrf-routing/{inter-vrf-routing-id}/advertised-networks?format=csv'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'inter-vrf-routing-id' + '}', inter_vrf_routing_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyAdvertisedNetworkInCsvFormat')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_advertised_networks_in_csv_format\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get OSPF database information
    # Get OSPF database information. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :area_id OSPF area identifier
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PolicyOspfDatabaseListResult]
    def get_ospf_database(tier_0_id, locale_service_id, opts = {})
      data, _status_code, _headers = get_ospf_database_with_http_info(tier_0_id, locale_service_id, opts)
      data
    end

    # Get OSPF database information
    # Get OSPF database information. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :area_id OSPF area identifier
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PolicyOspfDatabaseListResult, Fixnum, Hash)>] PolicyOspfDatabaseListResult data, response status code and response headers
    def get_ospf_database_with_http_info(tier_0_id, locale_service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_ospf_database ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.get_ospf_database"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.get_ospf_database"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_ospf_database, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_ospf_database, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/ospf/database'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'area_id'] = opts[:'area_id'] if !opts[:'area_id'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyOspfDatabaseListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_ospf_database\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get OSPF Database information in CSV format
    # Get OSPF Database information in CSV format. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :area_id OSPF area identifier
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [OspfDatabaseListResultInCsvFormat]
    def get_ospf_database_in_csv_format(tier_0_id, locale_service_id, opts = {})
      data, _status_code, _headers = get_ospf_database_in_csv_format_with_http_info(tier_0_id, locale_service_id, opts)
      data
    end

    # Get OSPF Database information in CSV format
    # Get OSPF Database information in CSV format. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :area_id OSPF area identifier
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(OspfDatabaseListResultInCsvFormat, Fixnum, Hash)>] OspfDatabaseListResultInCsvFormat data, response status code and response headers
    def get_ospf_database_in_csv_format_with_http_info(tier_0_id, locale_service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_ospf_database_in_csv_format ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.get_ospf_database_in_csv_format"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.get_ospf_database_in_csv_format"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_ospf_database_in_csv_format, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_ospf_database_in_csv_format, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/ospf/database?format=csv'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'area_id'] = opts[:'area_id'] if !opts[:'area_id'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'OspfDatabaseListResultInCsvFormat')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_ospf_database_in_csv_format\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get OSPF neighbor information
    # Get OSPF neighbor information. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :neighbor_address IPv4 or IPv6 address
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [OspfNeighborsStatusListResult]
    def get_ospf_neighbors(tier_0_id, locale_service_id, opts = {})
      data, _status_code, _headers = get_ospf_neighbors_with_http_info(tier_0_id, locale_service_id, opts)
      data
    end

    # Get OSPF neighbor information
    # Get OSPF neighbor information. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :neighbor_address IPv4 or IPv6 address
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(OspfNeighborsStatusListResult, Fixnum, Hash)>] OspfNeighborsStatusListResult data, response status code and response headers
    def get_ospf_neighbors_with_http_info(tier_0_id, locale_service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_ospf_neighbors ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.get_ospf_neighbors"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.get_ospf_neighbors"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_ospf_neighbors, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_ospf_neighbors, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/ospf/neighbors'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'neighbor_address'] = opts[:'neighbor_address'] if !opts[:'neighbor_address'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'OspfNeighborsStatusListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_ospf_neighbors\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get OSPF route information
    # Get OSPF route information. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix CIDR network address
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [OspfRoutesListResult]
    def get_ospf_routes(tier_0_id, locale_service_id, opts = {})
      data, _status_code, _headers = get_ospf_routes_with_http_info(tier_0_id, locale_service_id, opts)
      data
    end

    # Get OSPF route information
    # Get OSPF route information. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix CIDR network address
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(OspfRoutesListResult, Fixnum, Hash)>] OspfRoutesListResult data, response status code and response headers
    def get_ospf_routes_with_http_info(tier_0_id, locale_service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_ospf_routes ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.get_ospf_routes"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.get_ospf_routes"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_ospf_routes, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_ospf_routes, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/ospf/routes'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'network_prefix'] = opts[:'network_prefix'] if !opts[:'network_prefix'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'OspfRoutesListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_ospf_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get OSPF route information in CSV format
    # Get OSPF route information in CSV format. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix CIDR network address
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [OspfRoutesListResultInCsvFormat]
    def get_ospf_routes_in_csv_format(tier_0_id, locale_service_id, opts = {})
      data, _status_code, _headers = get_ospf_routes_in_csv_format_with_http_info(tier_0_id, locale_service_id, opts)
      data
    end

    # Get OSPF route information in CSV format
    # Get OSPF route information in CSV format. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix CIDR network address
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(OspfRoutesListResultInCsvFormat, Fixnum, Hash)>] OspfRoutesListResultInCsvFormat data, response status code and response headers
    def get_ospf_routes_in_csv_format_with_http_info(tier_0_id, locale_service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_ospf_routes_in_csv_format ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.get_ospf_routes_in_csv_format"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.get_ospf_routes_in_csv_format"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_ospf_routes_in_csv_format, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_ospf_routes_in_csv_format, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/ospf/routes?format=csv'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'network_prefix'] = opts[:'network_prefix'] if !opts[:'network_prefix'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'OspfRoutesListResultInCsvFormat')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_ospf_routes_in_csv_format\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read a route map
    # Read a route map
    # @param tier_0_id 
    # @param route_map_id 
    # @param [Hash] opts the optional parameters
    # @return [Tier0RouteMap]
    def get_route_map(tier_0_id, route_map_id, opts = {})
      data, _status_code, _headers = get_route_map_with_http_info(tier_0_id, route_map_id, opts)
      data
    end

    # Read a route map
    # Read a route map
    # @param tier_0_id 
    # @param route_map_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Tier0RouteMap, Fixnum, Hash)>] Tier0RouteMap data, response status code and response headers
    def get_route_map_with_http_info(tier_0_id, route_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_route_map ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.get_route_map"
      end
      # verify the required parameter 'route_map_id' is set
      if @api_client.config.client_side_validation && route_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_map_id' when calling RoutingApi.get_route_map"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/route-maps/{route-map-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'route-map-id' + '}', route_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Tier0RouteMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_route_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get BGP neighbor advertised routes
    # Returns routes advertised by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled. The query parameter \"source=cached\" is not supported. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :count Number of routes to retrieve (default to 1000)
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [BgpNeighborRoutesListResult]
    def get_tier0_bgp_neighbor_advertised_routes(tier_0_id, locale_service_id, neighbor_id, opts = {})
      data, _status_code, _headers = get_tier0_bgp_neighbor_advertised_routes_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts)
      data
    end

    # Get BGP neighbor advertised routes
    # Returns routes advertised by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled. The query parameter \&quot;source&#x3D;cached\&quot; is not supported. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :count Number of routes to retrieve
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(BgpNeighborRoutesListResult, Fixnum, Hash)>] BgpNeighborRoutesListResult data, response status code and response headers
    def get_tier0_bgp_neighbor_advertised_routes_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_tier0_bgp_neighbor_advertised_routes ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.get_tier0_bgp_neighbor_advertised_routes"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.get_tier0_bgp_neighbor_advertised_routes"
      end
      # verify the required parameter 'neighbor_id' is set
      if @api_client.config.client_side_validation && neighbor_id.nil?
        fail ArgumentError, "Missing the required parameter 'neighbor_id' when calling RoutingApi.get_tier0_bgp_neighbor_advertised_routes"
      end
      if @api_client.config.client_side_validation && !opts[:'count'].nil? && opts[:'count'] < 1
        fail ArgumentError, 'invalid value for "opts[:"count"]" when calling RoutingApi.get_tier0_bgp_neighbor_advertised_routes, must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier0_bgp_neighbor_advertised_routes, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier0_bgp_neighbor_advertised_routes, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/neighbors/{neighbor-id}/advertised-routes'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'neighbor-id' + '}', neighbor_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'count'] = opts[:'count'] if !opts[:'count'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpNeighborRoutesListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_tier0_bgp_neighbor_advertised_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get BGP neighbor advertised routes in CSV format
    # Returns routes advertised by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled in CSV format. Routes from all enforcement points are returned. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :count Number of routes to retrieve (default to 1000)
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [BgpNeighborRouteDetailsInCsvFormat]
    def get_tier0_bgp_neighbor_advertised_routes_in_csv_format(tier_0_id, locale_service_id, neighbor_id, opts = {})
      data, _status_code, _headers = get_tier0_bgp_neighbor_advertised_routes_in_csv_format_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts)
      data
    end

    # Get BGP neighbor advertised routes in CSV format
    # Returns routes advertised by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled in CSV format. Routes from all enforcement points are returned. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :count Number of routes to retrieve
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(BgpNeighborRouteDetailsInCsvFormat, Fixnum, Hash)>] BgpNeighborRouteDetailsInCsvFormat data, response status code and response headers
    def get_tier0_bgp_neighbor_advertised_routes_in_csv_format_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_tier0_bgp_neighbor_advertised_routes_in_csv_format ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.get_tier0_bgp_neighbor_advertised_routes_in_csv_format"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.get_tier0_bgp_neighbor_advertised_routes_in_csv_format"
      end
      # verify the required parameter 'neighbor_id' is set
      if @api_client.config.client_side_validation && neighbor_id.nil?
        fail ArgumentError, "Missing the required parameter 'neighbor_id' when calling RoutingApi.get_tier0_bgp_neighbor_advertised_routes_in_csv_format"
      end
      if @api_client.config.client_side_validation && !opts[:'count'].nil? && opts[:'count'] < 1
        fail ArgumentError, 'invalid value for "opts[:"count"]" when calling RoutingApi.get_tier0_bgp_neighbor_advertised_routes_in_csv_format, must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier0_bgp_neighbor_advertised_routes_in_csv_format, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier0_bgp_neighbor_advertised_routes_in_csv_format, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/neighbors/{neighbor-id}/advertised-routes?format=csv'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'neighbor-id' + '}', neighbor_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'count'] = opts[:'count'] if !opts[:'count'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpNeighborRouteDetailsInCsvFormat')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_tier0_bgp_neighbor_advertised_routes_in_csv_format\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get routes learned by BGP neighbor
    # Returns routes learned by BGP neighbor from all edge nodes on which this neighbor is currently enabled. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :count Number of routes to retrieve (default to 1000)
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [BgpNeighborRoutesListResult]
    def get_tier0_bgp_neighbor_routes(tier_0_id, locale_service_id, neighbor_id, opts = {})
      data, _status_code, _headers = get_tier0_bgp_neighbor_routes_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts)
      data
    end

    # Get routes learned by BGP neighbor
    # Returns routes learned by BGP neighbor from all edge nodes on which this neighbor is currently enabled. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :count Number of routes to retrieve
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(BgpNeighborRoutesListResult, Fixnum, Hash)>] BgpNeighborRoutesListResult data, response status code and response headers
    def get_tier0_bgp_neighbor_routes_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_tier0_bgp_neighbor_routes ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.get_tier0_bgp_neighbor_routes"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.get_tier0_bgp_neighbor_routes"
      end
      # verify the required parameter 'neighbor_id' is set
      if @api_client.config.client_side_validation && neighbor_id.nil?
        fail ArgumentError, "Missing the required parameter 'neighbor_id' when calling RoutingApi.get_tier0_bgp_neighbor_routes"
      end
      if @api_client.config.client_side_validation && !opts[:'count'].nil? && opts[:'count'] < 1
        fail ArgumentError, 'invalid value for "opts[:"count"]" when calling RoutingApi.get_tier0_bgp_neighbor_routes, must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier0_bgp_neighbor_routes, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier0_bgp_neighbor_routes, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/neighbors/{neighbor-id}/routes'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'neighbor-id' + '}', neighbor_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'count'] = opts[:'count'] if !opts[:'count'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpNeighborRoutesListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_tier0_bgp_neighbor_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get routes learned by BGP neighbor in CSV format
    # Returns routes learned by BGP neighbor from all edge nodes on which this neighbor is currently enabled. Routes from all enforcement points are returned. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :count Number of routes to retrieve (default to 1000)
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [BgpNeighborRouteDetailsInCsvFormat]
    def get_tier0_bgp_neighbor_routes_in_csv_format(tier_0_id, locale_service_id, neighbor_id, opts = {})
      data, _status_code, _headers = get_tier0_bgp_neighbor_routes_in_csv_format_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts)
      data
    end

    # Get routes learned by BGP neighbor in CSV format
    # Returns routes learned by BGP neighbor from all edge nodes on which this neighbor is currently enabled. Routes from all enforcement points are returned. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :count Number of routes to retrieve
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(BgpNeighborRouteDetailsInCsvFormat, Fixnum, Hash)>] BgpNeighborRouteDetailsInCsvFormat data, response status code and response headers
    def get_tier0_bgp_neighbor_routes_in_csv_format_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_tier0_bgp_neighbor_routes_in_csv_format ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.get_tier0_bgp_neighbor_routes_in_csv_format"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.get_tier0_bgp_neighbor_routes_in_csv_format"
      end
      # verify the required parameter 'neighbor_id' is set
      if @api_client.config.client_side_validation && neighbor_id.nil?
        fail ArgumentError, "Missing the required parameter 'neighbor_id' when calling RoutingApi.get_tier0_bgp_neighbor_routes_in_csv_format"
      end
      if @api_client.config.client_side_validation && !opts[:'count'].nil? && opts[:'count'] < 1
        fail ArgumentError, 'invalid value for "opts[:"count"]" when calling RoutingApi.get_tier0_bgp_neighbor_routes_in_csv_format, must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier0_bgp_neighbor_routes_in_csv_format, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier0_bgp_neighbor_routes_in_csv_format, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/neighbors/{neighbor-id}/routes?format=csv'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'neighbor-id' + '}', neighbor_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'count'] = opts[:'count'] if !opts[:'count'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpNeighborRouteDetailsInCsvFormat')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_tier0_bgp_neighbor_routes_in_csv_format\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get BGP neighbor status for the Tier0
    # Returns the status of all the BGP neighbors for the given Tier0. To get BGP neighbor status for a particular enforcement point, parameter \"enforcement_point_path=&lt;enforcement_point_path&gt;\" needs to be specified. If an enforcement_point is unspecified, then bgp neighbor status for all enforcement points is fetched. To get BGP neighbors status for the logical router from particular edge node, parameter \"edge_path=&lt;edge_path&gt;\" needs to be specified. If an edge_path is unspecified, then bgp neighbor status for all edges is fetched. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [PolicyBgpNeighborsStatusListResult]
    def get_tier0_bgp_neighbors_status(tier_0_id, locale_service_id, opts = {})
      data, _status_code, _headers = get_tier0_bgp_neighbors_status_with_http_info(tier_0_id, locale_service_id, opts)
      data
    end

    # Get BGP neighbor status for the Tier0
    # Returns the status of all the BGP neighbors for the given Tier0. To get BGP neighbor status for a particular enforcement point, parameter \&quot;enforcement_point_path&#x3D;&amp;lt;enforcement_point_path&amp;gt;\&quot; needs to be specified. If an enforcement_point is unspecified, then bgp neighbor status for all enforcement points is fetched. To get BGP neighbors status for the logical router from particular edge node, parameter \&quot;edge_path&#x3D;&amp;lt;edge_path&amp;gt;\&quot; needs to be specified. If an edge_path is unspecified, then bgp neighbor status for all edges is fetched. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(PolicyBgpNeighborsStatusListResult, Fixnum, Hash)>] PolicyBgpNeighborsStatusListResult data, response status code and response headers
    def get_tier0_bgp_neighbors_status_with_http_info(tier_0_id, locale_service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_tier0_bgp_neighbors_status ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.get_tier0_bgp_neighbors_status"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.get_tier0_bgp_neighbors_status"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier0_bgp_neighbors_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier0_bgp_neighbors_status, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/neighbors/status'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyBgpNeighborsStatusListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_tier0_bgp_neighbors_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get forwarding table from tier-0
    # Get forwarding table from tier-0 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [RoutingTableListResult]
    def get_tier0_forwarding_table(tier_0_id, opts = {})
      data, _status_code, _headers = get_tier0_forwarding_table_with_http_info(tier_0_id, opts)
      data
    end

    # Get forwarding table from tier-0
    # Get forwarding table from tier-0 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(RoutingTableListResult, Fixnum, Hash)>] RoutingTableListResult data, response status code and response headers
    def get_tier0_forwarding_table_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_tier0_forwarding_table ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.get_tier0_forwarding_table"
      end
      if @api_client.config.client_side_validation && opts[:'component_type'] && !['DR_ROUTES'].include?(opts[:'component_type'])
        fail ArgumentError, 'invalid value for "component_type", must be one of DR_ROUTES'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier0_forwarding_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier0_forwarding_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'route_source'] && !['BGP', 'STATIC', 'CONNECTED', 'OSPF'].include?(opts[:'route_source'])
        fail ArgumentError, 'invalid value for "route_source", must be one of BGP, STATIC, CONNECTED, OSPF'
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/forwarding-table'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'component_type'] = opts[:'component_type'] if !opts[:'component_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_id'] = opts[:'edge_id'] if !opts[:'edge_id'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'network_prefix'] = opts[:'network_prefix'] if !opts[:'network_prefix'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'route_source'] = opts[:'route_source'] if !opts[:'route_source'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoutingTableListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_tier0_forwarding_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get forwarding table from tier-0 in CSV format
    # Get forwarding table from tier-0 gateway in CSV format. 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [GatewayRouteTableInCsvFormat]
    def get_tier0_forwarding_table_csv(tier_0_id, opts = {})
      data, _status_code, _headers = get_tier0_forwarding_table_csv_with_http_info(tier_0_id, opts)
      data
    end

    # Get forwarding table from tier-0 in CSV format
    # Get forwarding table from tier-0 gateway in CSV format. 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(GatewayRouteTableInCsvFormat, Fixnum, Hash)>] GatewayRouteTableInCsvFormat data, response status code and response headers
    def get_tier0_forwarding_table_csv_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_tier0_forwarding_table_csv ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.get_tier0_forwarding_table_csv"
      end
      if @api_client.config.client_side_validation && opts[:'component_type'] && !['DR_ROUTES'].include?(opts[:'component_type'])
        fail ArgumentError, 'invalid value for "component_type", must be one of DR_ROUTES'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier0_forwarding_table_csv, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier0_forwarding_table_csv, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'route_source'] && !['BGP', 'STATIC', 'CONNECTED', 'OSPF'].include?(opts[:'route_source'])
        fail ArgumentError, 'invalid value for "route_source", must be one of BGP, STATIC, CONNECTED, OSPF'
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/forwarding-table?format=csv'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'component_type'] = opts[:'component_type'] if !opts[:'component_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_id'] = opts[:'edge_id'] if !opts[:'edge_id'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'network_prefix'] = opts[:'network_prefix'] if !opts[:'network_prefix'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'route_source'] = opts[:'route_source'] if !opts[:'route_source'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'GatewayRouteTableInCsvFormat')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_tier0_forwarding_table_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get total number of IPv4 or IPv6 routes on a Tier0
    # Get total number of IPv4 or IPv6 routes on a Tier0 
    # @param tier_0_id 
    # @param edge_path Policy path of edge node
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_child_vrf Count all the child VRF routes or not.
    # @return [Tier0NumberOfRoutesResult]
    def get_tier0_number_of_routes(tier_0_id, edge_path, opts = {})
      data, _status_code, _headers = get_tier0_number_of_routes_with_http_info(tier_0_id, edge_path, opts)
      data
    end

    # Get total number of IPv4 or IPv6 routes on a Tier0
    # Get total number of IPv4 or IPv6 routes on a Tier0 
    # @param tier_0_id 
    # @param edge_path Policy path of edge node
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_child_vrf Count all the child VRF routes or not.
    # @return [Array<(Tier0NumberOfRoutesResult, Fixnum, Hash)>] Tier0NumberOfRoutesResult data, response status code and response headers
    def get_tier0_number_of_routes_with_http_info(tier_0_id, edge_path, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_tier0_number_of_routes ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.get_tier0_number_of_routes"
      end
      # verify the required parameter 'edge_path' is set
      if @api_client.config.client_side_validation && edge_path.nil?
        fail ArgumentError, "Missing the required parameter 'edge_path' when calling RoutingApi.get_tier0_number_of_routes"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/number-of-routes'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'edge_path'] = edge_path
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_child_vrf'] = opts[:'include_child_vrf'] if !opts[:'include_child_vrf'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Tier0NumberOfRoutesResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_tier0_number_of_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get routing table from tier-0
    # Get routing table from tier-0 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [RoutingTableListResult]
    def get_tier0_routes(tier_0_id, opts = {})
      data, _status_code, _headers = get_tier0_routes_with_http_info(tier_0_id, opts)
      data
    end

    # Get routing table from tier-0
    # Get routing table from tier-0 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(RoutingTableListResult, Fixnum, Hash)>] RoutingTableListResult data, response status code and response headers
    def get_tier0_routes_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_tier0_routes ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.get_tier0_routes"
      end
      if @api_client.config.client_side_validation && opts[:'component_type'] && !['DR_ROUTES'].include?(opts[:'component_type'])
        fail ArgumentError, 'invalid value for "component_type", must be one of DR_ROUTES'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier0_routes, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier0_routes, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'route_source'] && !['BGP', 'STATIC', 'CONNECTED', 'OSPF'].include?(opts[:'route_source'])
        fail ArgumentError, 'invalid value for "route_source", must be one of BGP, STATIC, CONNECTED, OSPF'
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/routing-table'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'component_type'] = opts[:'component_type'] if !opts[:'component_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_id'] = opts[:'edge_id'] if !opts[:'edge_id'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'network_prefix'] = opts[:'network_prefix'] if !opts[:'network_prefix'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'route_source'] = opts[:'route_source'] if !opts[:'route_source'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoutingTableListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_tier0_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get routing table from tier-0 in CSV format
    # Get routing table from tier-0 gateway in CSV format. 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [GatewayRouteTableInCsvFormat]
    def get_tier0_routes_csv(tier_0_id, opts = {})
      data, _status_code, _headers = get_tier0_routes_csv_with_http_info(tier_0_id, opts)
      data
    end

    # Get routing table from tier-0 in CSV format
    # Get routing table from tier-0 gateway in CSV format. 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(GatewayRouteTableInCsvFormat, Fixnum, Hash)>] GatewayRouteTableInCsvFormat data, response status code and response headers
    def get_tier0_routes_csv_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_tier0_routes_csv ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.get_tier0_routes_csv"
      end
      if @api_client.config.client_side_validation && opts[:'component_type'] && !['DR_ROUTES'].include?(opts[:'component_type'])
        fail ArgumentError, 'invalid value for "component_type", must be one of DR_ROUTES'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier0_routes_csv, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier0_routes_csv, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'route_source'] && !['BGP', 'STATIC', 'CONNECTED', 'OSPF'].include?(opts[:'route_source'])
        fail ArgumentError, 'invalid value for "route_source", must be one of BGP, STATIC, CONNECTED, OSPF'
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/routing-table?format=csv'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'component_type'] = opts[:'component_type'] if !opts[:'component_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_id'] = opts[:'edge_id'] if !opts[:'edge_id'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'network_prefix'] = opts[:'network_prefix'] if !opts[:'network_prefix'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'route_source'] = opts[:'route_source'] if !opts[:'route_source'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'GatewayRouteTableInCsvFormat')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_tier0_routes_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tier0 state
    # Returns 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :interface_path Interface path for interface specific state such as IPv6 DAD state
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :type Returns specific information based on the value specified.
    # @return [Tier0GatewayState]
    def get_tier0_state(tier_0_id, opts = {})
      data, _status_code, _headers = get_tier0_state_with_http_info(tier_0_id, opts)
      data
    end

    # Get Tier0 state
    # Returns 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :interface_path Interface path for interface specific state such as IPv6 DAD state
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :type Returns specific information based on the value specified.
    # @return [Array<(Tier0GatewayState, Fixnum, Hash)>] Tier0GatewayState data, response status code and response headers
    def get_tier0_state_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_tier0_state ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.get_tier0_state"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier0_state, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier0_state, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'type'] && !['GATEWAY_STATE', 'GATEWAY_STATUS', 'IPV6_STATUS', 'RD_PER_EDGE_MAPPING'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of GATEWAY_STATE, GATEWAY_STATUS, IPV6_STATUS, RD_PER_EDGE_MAPPING'
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/state'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'interface_path'] = opts[:'interface_path'] if !opts[:'interface_path'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Tier0GatewayState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_tier0_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List advertised networks
    # Return networks which are advertised to connected TIER0 gateway. 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PolicyAdvertisedNetworksListResult]
    def get_tier1_advertised_networks(tier_1_id, opts = {})
      data, _status_code, _headers = get_tier1_advertised_networks_with_http_info(tier_1_id, opts)
      data
    end

    # List advertised networks
    # Return networks which are advertised to connected TIER0 gateway. 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PolicyAdvertisedNetworksListResult, Fixnum, Hash)>] PolicyAdvertisedNetworksListResult data, response status code and response headers
    def get_tier1_advertised_networks_with_http_info(tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_tier1_advertised_networks ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.get_tier1_advertised_networks"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier1_advertised_networks, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier1_advertised_networks, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/advertised-networks'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyAdvertisedNetworksListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_tier1_advertised_networks\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List advertised networks in CSV format
    # Return networks which are advertised to connected TIER0 gateway in CSV format. 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PolicyAdvertisedNetworkInCsvFormat]
    def get_tier1_advertised_networks_in_csv_format(tier_1_id, opts = {})
      data, _status_code, _headers = get_tier1_advertised_networks_in_csv_format_with_http_info(tier_1_id, opts)
      data
    end

    # List advertised networks in CSV format
    # Return networks which are advertised to connected TIER0 gateway in CSV format. 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PolicyAdvertisedNetworkInCsvFormat, Fixnum, Hash)>] PolicyAdvertisedNetworkInCsvFormat data, response status code and response headers
    def get_tier1_advertised_networks_in_csv_format_with_http_info(tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_tier1_advertised_networks_in_csv_format ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.get_tier1_advertised_networks_in_csv_format"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier1_advertised_networks_in_csv_format, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier1_advertised_networks_in_csv_format, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/advertised-networks/csv'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyAdvertisedNetworkInCsvFormat')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_tier1_advertised_networks_in_csv_format\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get forwarding table from tier-1
    # Get forwarding table from tier-1 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [RoutingTableListResult]
    def get_tier1_forwarding_table(tier_1_id, opts = {})
      data, _status_code, _headers = get_tier1_forwarding_table_with_http_info(tier_1_id, opts)
      data
    end

    # Get forwarding table from tier-1
    # Get forwarding table from tier-1 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(RoutingTableListResult, Fixnum, Hash)>] RoutingTableListResult data, response status code and response headers
    def get_tier1_forwarding_table_with_http_info(tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_tier1_forwarding_table ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.get_tier1_forwarding_table"
      end
      if @api_client.config.client_side_validation && opts[:'component_type'] && !['DR_ROUTES'].include?(opts[:'component_type'])
        fail ArgumentError, 'invalid value for "component_type", must be one of DR_ROUTES'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier1_forwarding_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier1_forwarding_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'route_source'] && !['BGP', 'STATIC', 'CONNECTED', 'OSPF'].include?(opts[:'route_source'])
        fail ArgumentError, 'invalid value for "route_source", must be one of BGP, STATIC, CONNECTED, OSPF'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/forwarding-table'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'component_type'] = opts[:'component_type'] if !opts[:'component_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_id'] = opts[:'edge_id'] if !opts[:'edge_id'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'network_prefix'] = opts[:'network_prefix'] if !opts[:'network_prefix'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'route_source'] = opts[:'route_source'] if !opts[:'route_source'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoutingTableListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_tier1_forwarding_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get forwarding table from tier-1 in CSV format
    # Get forwarding table from tier-1 gateway in CSV format. 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [GatewayRouteTableInCsvFormat]
    def get_tier1_forwarding_table_csv(tier_1_id, opts = {})
      data, _status_code, _headers = get_tier1_forwarding_table_csv_with_http_info(tier_1_id, opts)
      data
    end

    # Get forwarding table from tier-1 in CSV format
    # Get forwarding table from tier-1 gateway in CSV format. 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(GatewayRouteTableInCsvFormat, Fixnum, Hash)>] GatewayRouteTableInCsvFormat data, response status code and response headers
    def get_tier1_forwarding_table_csv_with_http_info(tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_tier1_forwarding_table_csv ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.get_tier1_forwarding_table_csv"
      end
      if @api_client.config.client_side_validation && opts[:'component_type'] && !['DR_ROUTES'].include?(opts[:'component_type'])
        fail ArgumentError, 'invalid value for "component_type", must be one of DR_ROUTES'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier1_forwarding_table_csv, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier1_forwarding_table_csv, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'route_source'] && !['BGP', 'STATIC', 'CONNECTED', 'OSPF'].include?(opts[:'route_source'])
        fail ArgumentError, 'invalid value for "route_source", must be one of BGP, STATIC, CONNECTED, OSPF'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/forwarding-table?format=csv'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'component_type'] = opts[:'component_type'] if !opts[:'component_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_id'] = opts[:'edge_id'] if !opts[:'edge_id'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'network_prefix'] = opts[:'network_prefix'] if !opts[:'network_prefix'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'route_source'] = opts[:'route_source'] if !opts[:'route_source'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'GatewayRouteTableInCsvFormat')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_tier1_forwarding_table_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tier1 state
    # Returns 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :interface_path Interface path for interface specific state such as IPv6 DAD state
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :type Returns specific information based on the value specified.
    # @return [Tier1GatewayState]
    def get_tier1_state(tier_1_id, opts = {})
      data, _status_code, _headers = get_tier1_state_with_http_info(tier_1_id, opts)
      data
    end

    # Get Tier1 state
    # Returns 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :interface_path Interface path for interface specific state such as IPv6 DAD state
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :type Returns specific information based on the value specified.
    # @return [Array<(Tier1GatewayState, Fixnum, Hash)>] Tier1GatewayState data, response status code and response headers
    def get_tier1_state_with_http_info(tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.get_tier1_state ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.get_tier1_state"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier1_state, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.get_tier1_state, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'type'] && !['GATEWAY_STATE', 'GATEWAY_STATUS', 'IPV6_STATUS'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of GATEWAY_STATE, GATEWAY_STATUS, IPV6_STATUS'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/state'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'interface_path'] = opts[:'interface_path'] if !opts[:'interface_path'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Tier1GatewayState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#get_tier1_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a BGP neighbor config
    # If BGP neighbor config with the neighbor-id is not already present, create a new neighbor config. If it already exists, replace the BGP neighbor config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param bgp_neighbor_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [BgpNeighborConfig]
    def global_infra_create_or_replace_bgp_neighbor_config(tier_0_id, locale_service_id, neighbor_id, bgp_neighbor_config, opts = {})
      data, _status_code, _headers = global_infra_create_or_replace_bgp_neighbor_config_with_http_info(tier_0_id, locale_service_id, neighbor_id, bgp_neighbor_config, opts)
      data
    end

    # Create or update a BGP neighbor config
    # If BGP neighbor config with the neighbor-id is not already present, create a new neighbor config. If it already exists, replace the BGP neighbor config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param bgp_neighbor_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(BgpNeighborConfig, Fixnum, Hash)>] BgpNeighborConfig data, response status code and response headers
    def global_infra_create_or_replace_bgp_neighbor_config_with_http_info(tier_0_id, locale_service_id, neighbor_id, bgp_neighbor_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_create_or_replace_bgp_neighbor_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_create_or_replace_bgp_neighbor_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.global_infra_create_or_replace_bgp_neighbor_config"
      end
      # verify the required parameter 'neighbor_id' is set
      if @api_client.config.client_side_validation && neighbor_id.nil?
        fail ArgumentError, "Missing the required parameter 'neighbor_id' when calling RoutingApi.global_infra_create_or_replace_bgp_neighbor_config"
      end
      # verify the required parameter 'bgp_neighbor_config' is set
      if @api_client.config.client_side_validation && bgp_neighbor_config.nil?
        fail ArgumentError, "Missing the required parameter 'bgp_neighbor_config' when calling RoutingApi.global_infra_create_or_replace_bgp_neighbor_config"
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/neighbors/{neighbor-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'neighbor-id' + '}', neighbor_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(bgp_neighbor_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpNeighborConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_create_or_replace_bgp_neighbor_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a BGP routing config
    # If BGP routing config is not already present, create BGP routing config. If it already exists, replace the BGP routing config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param bgp_routing_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [BgpRoutingConfig]
    def global_infra_create_or_replace_bgp_routing_config(tier_0_id, locale_service_id, bgp_routing_config, opts = {})
      data, _status_code, _headers = global_infra_create_or_replace_bgp_routing_config_with_http_info(tier_0_id, locale_service_id, bgp_routing_config, opts)
      data
    end

    # Create or update a BGP routing config
    # If BGP routing config is not already present, create BGP routing config. If it already exists, replace the BGP routing config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param bgp_routing_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(BgpRoutingConfig, Fixnum, Hash)>] BgpRoutingConfig data, response status code and response headers
    def global_infra_create_or_replace_bgp_routing_config_with_http_info(tier_0_id, locale_service_id, bgp_routing_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_create_or_replace_bgp_routing_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_create_or_replace_bgp_routing_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.global_infra_create_or_replace_bgp_routing_config"
      end
      # verify the required parameter 'bgp_routing_config' is set
      if @api_client.config.client_side_validation && bgp_routing_config.nil?
        fail ArgumentError, "Missing the required parameter 'bgp_routing_config' when calling RoutingApi.global_infra_create_or_replace_bgp_routing_config"
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(bgp_routing_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpRoutingConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_create_or_replace_bgp_routing_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a BGP troubleshoot config
    # If BGP troubleshoot config is not present in BGP configuration, create a new BGP troubleshoot config with default value. If it already exists, update the BGP troubleshoot config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param bgp_troubleshoot_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [BgpTroubleshootConfig]
    def global_infra_create_or_replace_bgp_troubleshoot_config(tier_0_id, locale_service_id, bgp_troubleshoot_config, opts = {})
      data, _status_code, _headers = global_infra_create_or_replace_bgp_troubleshoot_config_with_http_info(tier_0_id, locale_service_id, bgp_troubleshoot_config, opts)
      data
    end

    # Create or update a BGP troubleshoot config
    # If BGP troubleshoot config is not present in BGP configuration, create a new BGP troubleshoot config with default value. If it already exists, update the BGP troubleshoot config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param bgp_troubleshoot_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(BgpTroubleshootConfig, Fixnum, Hash)>] BgpTroubleshootConfig data, response status code and response headers
    def global_infra_create_or_replace_bgp_troubleshoot_config_with_http_info(tier_0_id, locale_service_id, bgp_troubleshoot_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_create_or_replace_bgp_troubleshoot_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_create_or_replace_bgp_troubleshoot_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.global_infra_create_or_replace_bgp_troubleshoot_config"
      end
      # verify the required parameter 'bgp_troubleshoot_config' is set
      if @api_client.config.client_side_validation && bgp_troubleshoot_config.nil?
        fail ArgumentError, "Missing the required parameter 'bgp_troubleshoot_config' when calling RoutingApi.global_infra_create_or_replace_bgp_troubleshoot_config"
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/troubleshoot'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(bgp_troubleshoot_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpTroubleshootConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_create_or_replace_bgp_troubleshoot_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a StaticRouteBfdTroubleshootConfig
    # If a StaticRouteBfdTroubleshootConfig is not already present, create a new StaticRouteBfdTroubleshootConfig. If it already exists, update the StaticRouteBfdTroubleshootConfig. This operation will fully replace the object. 
    # @param tier_0_id Tier-0 ID
    # @param static_route_bfd_troubleshoot_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [StaticRouteBfdTroubleshootConfig]
    def global_infra_create_or_replace_static_route_bfd_troubleshoot_config(tier_0_id, static_route_bfd_troubleshoot_config, opts = {})
      data, _status_code, _headers = global_infra_create_or_replace_static_route_bfd_troubleshoot_config_with_http_info(tier_0_id, static_route_bfd_troubleshoot_config, opts)
      data
    end

    # Create or update a StaticRouteBfdTroubleshootConfig
    # If a StaticRouteBfdTroubleshootConfig is not already present, create a new StaticRouteBfdTroubleshootConfig. If it already exists, update the StaticRouteBfdTroubleshootConfig. This operation will fully replace the object. 
    # @param tier_0_id Tier-0 ID
    # @param static_route_bfd_troubleshoot_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(StaticRouteBfdTroubleshootConfig, Fixnum, Hash)>] StaticRouteBfdTroubleshootConfig data, response status code and response headers
    def global_infra_create_or_replace_static_route_bfd_troubleshoot_config_with_http_info(tier_0_id, static_route_bfd_troubleshoot_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_create_or_replace_static_route_bfd_troubleshoot_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_create_or_replace_static_route_bfd_troubleshoot_config"
      end
      # verify the required parameter 'static_route_bfd_troubleshoot_config' is set
      if @api_client.config.client_side_validation && static_route_bfd_troubleshoot_config.nil?
        fail ArgumentError, "Missing the required parameter 'static_route_bfd_troubleshoot_config' when calling RoutingApi.global_infra_create_or_replace_static_route_bfd_troubleshoot_config"
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/static-routes/bfd-peers/troubleshoot'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(static_route_bfd_troubleshoot_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRouteBfdTroubleshootConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_create_or_replace_static_route_bfd_troubleshoot_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a Tier-0 static routes
    # If static routes for route-id are not already present, create static routes. If it already exists, replace the static routes for route-id. 
    # @param tier_0_id 
    # @param route_id 
    # @param static_routes 
    # @param [Hash] opts the optional parameters
    # @return [StaticRoutes]
    def global_infra_create_or_replace_tier0_static_routes(tier_0_id, route_id, static_routes, opts = {})
      data, _status_code, _headers = global_infra_create_or_replace_tier0_static_routes_with_http_info(tier_0_id, route_id, static_routes, opts)
      data
    end

    # Create or update a Tier-0 static routes
    # If static routes for route-id are not already present, create static routes. If it already exists, replace the static routes for route-id. 
    # @param tier_0_id 
    # @param route_id 
    # @param static_routes 
    # @param [Hash] opts the optional parameters
    # @return [Array<(StaticRoutes, Fixnum, Hash)>] StaticRoutes data, response status code and response headers
    def global_infra_create_or_replace_tier0_static_routes_with_http_info(tier_0_id, route_id, static_routes, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_create_or_replace_tier0_static_routes ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_create_or_replace_tier0_static_routes"
      end
      # verify the required parameter 'route_id' is set
      if @api_client.config.client_side_validation && route_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_id' when calling RoutingApi.global_infra_create_or_replace_tier0_static_routes"
      end
      # verify the required parameter 'static_routes' is set
      if @api_client.config.client_side_validation && static_routes.nil?
        fail ArgumentError, "Missing the required parameter 'static_routes' when calling RoutingApi.global_infra_create_or_replace_tier0_static_routes"
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/static-routes/{route-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'route-id' + '}', route_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(static_routes)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRoutes')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_create_or_replace_tier0_static_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete BGP neighbor config
    # Delete BGP neighbor config
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def global_infra_delete_bgp_neighbor_config(tier_0_id, locale_service_id, neighbor_id, opts = {})
      global_infra_delete_bgp_neighbor_config_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts)
      nil
    end

    # Delete BGP neighbor config
    # Delete BGP neighbor config
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_delete_bgp_neighbor_config_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_delete_bgp_neighbor_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_delete_bgp_neighbor_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.global_infra_delete_bgp_neighbor_config"
      end
      # verify the required parameter 'neighbor_id' is set
      if @api_client.config.client_side_validation && neighbor_id.nil?
        fail ArgumentError, "Missing the required parameter 'neighbor_id' when calling RoutingApi.global_infra_delete_bgp_neighbor_config"
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/neighbors/{neighbor-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'neighbor-id' + '}', neighbor_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_delete_bgp_neighbor_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete overridden BGP routing config
    # Deletes the specified overridden BgpRoutingConfig. If the BgpRoutingConfig is not overridden, it won't get deleted. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def global_infra_delete_overridden_bgp_routing_config(tier_0_id, locale_service_id, opts = {})
      global_infra_delete_overridden_bgp_routing_config_with_http_info(tier_0_id, locale_service_id, opts)
      nil
    end

    # Delete overridden BGP routing config
    # Deletes the specified overridden BgpRoutingConfig. If the BgpRoutingConfig is not overridden, it won&#39;t get deleted. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_delete_overridden_bgp_routing_config_with_http_info(tier_0_id, locale_service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_delete_overridden_bgp_routing_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_delete_overridden_bgp_routing_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.global_infra_delete_overridden_bgp_routing_config"
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_delete_overridden_bgp_routing_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read a route map
    # Read a route map
    # @param tier_0_id 
    # @param route_map_id 
    # @param [Hash] opts the optional parameters
    # @return [Tier0RouteMap]
    def global_infra_get_route_map(tier_0_id, route_map_id, opts = {})
      data, _status_code, _headers = global_infra_get_route_map_with_http_info(tier_0_id, route_map_id, opts)
      data
    end

    # Read a route map
    # Read a route map
    # @param tier_0_id 
    # @param route_map_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Tier0RouteMap, Fixnum, Hash)>] Tier0RouteMap data, response status code and response headers
    def global_infra_get_route_map_with_http_info(tier_0_id, route_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_get_route_map ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_get_route_map"
      end
      # verify the required parameter 'route_map_id' is set
      if @api_client.config.client_side_validation && route_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_map_id' when calling RoutingApi.global_infra_get_route_map"
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/route-maps/{route-map-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'route-map-id' + '}', route_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Tier0RouteMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_get_route_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get BGP neighbor advertised routes
    # Returns routes advertised by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled. The query parameter \"source=cached\" is not supported. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :count Number of routes to retrieve (default to 1000)
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [BgpNeighborRoutesListResult]
    def global_infra_get_tier0_bgp_neighbor_advertised_routes(tier_0_id, locale_service_id, neighbor_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier0_bgp_neighbor_advertised_routes_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts)
      data
    end

    # Get BGP neighbor advertised routes
    # Returns routes advertised by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled. The query parameter \&quot;source&#x3D;cached\&quot; is not supported. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :count Number of routes to retrieve
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(BgpNeighborRoutesListResult, Fixnum, Hash)>] BgpNeighborRoutesListResult data, response status code and response headers
    def global_infra_get_tier0_bgp_neighbor_advertised_routes_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_get_tier0_bgp_neighbor_advertised_routes ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_advertised_routes"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_advertised_routes"
      end
      # verify the required parameter 'neighbor_id' is set
      if @api_client.config.client_side_validation && neighbor_id.nil?
        fail ArgumentError, "Missing the required parameter 'neighbor_id' when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_advertised_routes"
      end
      if @api_client.config.client_side_validation && !opts[:'count'].nil? && opts[:'count'] < 1
        fail ArgumentError, 'invalid value for "opts[:"count"]" when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_advertised_routes, must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_advertised_routes, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_advertised_routes, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/neighbors/{neighbor-id}/advertised-routes'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'neighbor-id' + '}', neighbor_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'count'] = opts[:'count'] if !opts[:'count'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpNeighborRoutesListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_get_tier0_bgp_neighbor_advertised_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get BGP neighbor advertised routes in CSV format
    # Returns routes advertised by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled in CSV format. Routes from all enforcement points are returned. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :count Number of routes to retrieve (default to 1000)
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [BgpNeighborRouteDetailsInCsvFormat]
    def global_infra_get_tier0_bgp_neighbor_advertised_routes_in_csv_format(tier_0_id, locale_service_id, neighbor_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier0_bgp_neighbor_advertised_routes_in_csv_format_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts)
      data
    end

    # Get BGP neighbor advertised routes in CSV format
    # Returns routes advertised by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled in CSV format. Routes from all enforcement points are returned. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :count Number of routes to retrieve
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(BgpNeighborRouteDetailsInCsvFormat, Fixnum, Hash)>] BgpNeighborRouteDetailsInCsvFormat data, response status code and response headers
    def global_infra_get_tier0_bgp_neighbor_advertised_routes_in_csv_format_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_get_tier0_bgp_neighbor_advertised_routes_in_csv_format ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_advertised_routes_in_csv_format"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_advertised_routes_in_csv_format"
      end
      # verify the required parameter 'neighbor_id' is set
      if @api_client.config.client_side_validation && neighbor_id.nil?
        fail ArgumentError, "Missing the required parameter 'neighbor_id' when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_advertised_routes_in_csv_format"
      end
      if @api_client.config.client_side_validation && !opts[:'count'].nil? && opts[:'count'] < 1
        fail ArgumentError, 'invalid value for "opts[:"count"]" when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_advertised_routes_in_csv_format, must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_advertised_routes_in_csv_format, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_advertised_routes_in_csv_format, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/neighbors/{neighbor-id}/advertised-routes?format=csv'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'neighbor-id' + '}', neighbor_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'count'] = opts[:'count'] if !opts[:'count'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpNeighborRouteDetailsInCsvFormat')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_get_tier0_bgp_neighbor_advertised_routes_in_csv_format\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get routes learned by BGP neighbor
    # Returns routes learned by BGP neighbor from all edge nodes on which this neighbor is currently enabled. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :count Number of routes to retrieve (default to 1000)
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [BgpNeighborRoutesListResult]
    def global_infra_get_tier0_bgp_neighbor_routes(tier_0_id, locale_service_id, neighbor_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier0_bgp_neighbor_routes_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts)
      data
    end

    # Get routes learned by BGP neighbor
    # Returns routes learned by BGP neighbor from all edge nodes on which this neighbor is currently enabled. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :count Number of routes to retrieve
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(BgpNeighborRoutesListResult, Fixnum, Hash)>] BgpNeighborRoutesListResult data, response status code and response headers
    def global_infra_get_tier0_bgp_neighbor_routes_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_get_tier0_bgp_neighbor_routes ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_routes"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_routes"
      end
      # verify the required parameter 'neighbor_id' is set
      if @api_client.config.client_side_validation && neighbor_id.nil?
        fail ArgumentError, "Missing the required parameter 'neighbor_id' when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_routes"
      end
      if @api_client.config.client_side_validation && !opts[:'count'].nil? && opts[:'count'] < 1
        fail ArgumentError, 'invalid value for "opts[:"count"]" when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_routes, must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_routes, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_routes, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/neighbors/{neighbor-id}/routes'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'neighbor-id' + '}', neighbor_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'count'] = opts[:'count'] if !opts[:'count'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpNeighborRoutesListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_get_tier0_bgp_neighbor_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get routes learned by BGP neighbor in CSV format
    # Returns routes learned by BGP neighbor from all edge nodes on which this neighbor is currently enabled. Routes from all enforcement points are returned. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :count Number of routes to retrieve (default to 1000)
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [BgpNeighborRouteDetailsInCsvFormat]
    def global_infra_get_tier0_bgp_neighbor_routes_in_csv_format(tier_0_id, locale_service_id, neighbor_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier0_bgp_neighbor_routes_in_csv_format_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts)
      data
    end

    # Get routes learned by BGP neighbor in CSV format
    # Returns routes learned by BGP neighbor from all edge nodes on which this neighbor is currently enabled. Routes from all enforcement points are returned. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :count Number of routes to retrieve
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(BgpNeighborRouteDetailsInCsvFormat, Fixnum, Hash)>] BgpNeighborRouteDetailsInCsvFormat data, response status code and response headers
    def global_infra_get_tier0_bgp_neighbor_routes_in_csv_format_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_get_tier0_bgp_neighbor_routes_in_csv_format ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_routes_in_csv_format"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_routes_in_csv_format"
      end
      # verify the required parameter 'neighbor_id' is set
      if @api_client.config.client_side_validation && neighbor_id.nil?
        fail ArgumentError, "Missing the required parameter 'neighbor_id' when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_routes_in_csv_format"
      end
      if @api_client.config.client_side_validation && !opts[:'count'].nil? && opts[:'count'] < 1
        fail ArgumentError, 'invalid value for "opts[:"count"]" when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_routes_in_csv_format, must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_routes_in_csv_format, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier0_bgp_neighbor_routes_in_csv_format, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/neighbors/{neighbor-id}/routes?format=csv'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'neighbor-id' + '}', neighbor_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'count'] = opts[:'count'] if !opts[:'count'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpNeighborRouteDetailsInCsvFormat')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_get_tier0_bgp_neighbor_routes_in_csv_format\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get BGP neighbor status for the Tier0
    # Returns the status of all the BGP neighbors for the given Tier0. To get BGP neighbor status for a particular enforcement point, parameter \"enforcement_point_path=&lt;enforcement_point_path&gt;\" needs to be specified. If an enforcement_point is unspecified, then bgp neighbor status for all enforcement points is fetched. To get BGP neighbors status for the logical router from particular edge node, parameter \"edge_path=&lt;edge_path&gt;\" needs to be specified. If an edge_path is unspecified, then bgp neighbor status for all edges is fetched. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [PolicyBgpNeighborsStatusListResult]
    def global_infra_get_tier0_bgp_neighbors_status(tier_0_id, locale_service_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier0_bgp_neighbors_status_with_http_info(tier_0_id, locale_service_id, opts)
      data
    end

    # Get BGP neighbor status for the Tier0
    # Returns the status of all the BGP neighbors for the given Tier0. To get BGP neighbor status for a particular enforcement point, parameter \&quot;enforcement_point_path&#x3D;&amp;lt;enforcement_point_path&amp;gt;\&quot; needs to be specified. If an enforcement_point is unspecified, then bgp neighbor status for all enforcement points is fetched. To get BGP neighbors status for the logical router from particular edge node, parameter \&quot;edge_path&#x3D;&amp;lt;edge_path&amp;gt;\&quot; needs to be specified. If an edge_path is unspecified, then bgp neighbor status for all edges is fetched. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(PolicyBgpNeighborsStatusListResult, Fixnum, Hash)>] PolicyBgpNeighborsStatusListResult data, response status code and response headers
    def global_infra_get_tier0_bgp_neighbors_status_with_http_info(tier_0_id, locale_service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_get_tier0_bgp_neighbors_status ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_get_tier0_bgp_neighbors_status"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.global_infra_get_tier0_bgp_neighbors_status"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier0_bgp_neighbors_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier0_bgp_neighbors_status, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/neighbors/status'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyBgpNeighborsStatusListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_get_tier0_bgp_neighbors_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get forwarding table from tier-0
    # Get forwarding table from tier-0 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [RoutingTableListResult]
    def global_infra_get_tier0_forwarding_table(tier_0_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier0_forwarding_table_with_http_info(tier_0_id, opts)
      data
    end

    # Get forwarding table from tier-0
    # Get forwarding table from tier-0 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(RoutingTableListResult, Fixnum, Hash)>] RoutingTableListResult data, response status code and response headers
    def global_infra_get_tier0_forwarding_table_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_get_tier0_forwarding_table ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_get_tier0_forwarding_table"
      end
      if @api_client.config.client_side_validation && opts[:'component_type'] && !['DR_ROUTES'].include?(opts[:'component_type'])
        fail ArgumentError, 'invalid value for "component_type", must be one of DR_ROUTES'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier0_forwarding_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier0_forwarding_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'route_source'] && !['BGP', 'STATIC', 'CONNECTED', 'OSPF'].include?(opts[:'route_source'])
        fail ArgumentError, 'invalid value for "route_source", must be one of BGP, STATIC, CONNECTED, OSPF'
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/forwarding-table'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'component_type'] = opts[:'component_type'] if !opts[:'component_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_id'] = opts[:'edge_id'] if !opts[:'edge_id'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'network_prefix'] = opts[:'network_prefix'] if !opts[:'network_prefix'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'route_source'] = opts[:'route_source'] if !opts[:'route_source'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoutingTableListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_get_tier0_forwarding_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get forwarding table from tier-0 in CSV format
    # Get forwarding table from tier-0 gateway in CSV format. 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [GatewayRouteTableInCsvFormat]
    def global_infra_get_tier0_forwarding_table_csv(tier_0_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier0_forwarding_table_csv_with_http_info(tier_0_id, opts)
      data
    end

    # Get forwarding table from tier-0 in CSV format
    # Get forwarding table from tier-0 gateway in CSV format. 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(GatewayRouteTableInCsvFormat, Fixnum, Hash)>] GatewayRouteTableInCsvFormat data, response status code and response headers
    def global_infra_get_tier0_forwarding_table_csv_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_get_tier0_forwarding_table_csv ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_get_tier0_forwarding_table_csv"
      end
      if @api_client.config.client_side_validation && opts[:'component_type'] && !['DR_ROUTES'].include?(opts[:'component_type'])
        fail ArgumentError, 'invalid value for "component_type", must be one of DR_ROUTES'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier0_forwarding_table_csv, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier0_forwarding_table_csv, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'route_source'] && !['BGP', 'STATIC', 'CONNECTED', 'OSPF'].include?(opts[:'route_source'])
        fail ArgumentError, 'invalid value for "route_source", must be one of BGP, STATIC, CONNECTED, OSPF'
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/forwarding-table?format=csv'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'component_type'] = opts[:'component_type'] if !opts[:'component_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_id'] = opts[:'edge_id'] if !opts[:'edge_id'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'network_prefix'] = opts[:'network_prefix'] if !opts[:'network_prefix'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'route_source'] = opts[:'route_source'] if !opts[:'route_source'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'GatewayRouteTableInCsvFormat')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_get_tier0_forwarding_table_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get total number of IPv4 or IPv6 routes on a Tier0
    # Get total number of IPv4 or IPv6 routes on a Tier0 
    # @param tier_0_id 
    # @param edge_path Policy path of edge node
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_child_vrf Count all the child VRF routes or not.
    # @return [Tier0NumberOfRoutesResult]
    def global_infra_get_tier0_number_of_routes(tier_0_id, edge_path, opts = {})
      data, _status_code, _headers = global_infra_get_tier0_number_of_routes_with_http_info(tier_0_id, edge_path, opts)
      data
    end

    # Get total number of IPv4 or IPv6 routes on a Tier0
    # Get total number of IPv4 or IPv6 routes on a Tier0 
    # @param tier_0_id 
    # @param edge_path Policy path of edge node
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_child_vrf Count all the child VRF routes or not.
    # @return [Array<(Tier0NumberOfRoutesResult, Fixnum, Hash)>] Tier0NumberOfRoutesResult data, response status code and response headers
    def global_infra_get_tier0_number_of_routes_with_http_info(tier_0_id, edge_path, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_get_tier0_number_of_routes ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_get_tier0_number_of_routes"
      end
      # verify the required parameter 'edge_path' is set
      if @api_client.config.client_side_validation && edge_path.nil?
        fail ArgumentError, "Missing the required parameter 'edge_path' when calling RoutingApi.global_infra_get_tier0_number_of_routes"
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/number-of-routes'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'edge_path'] = edge_path
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_child_vrf'] = opts[:'include_child_vrf'] if !opts[:'include_child_vrf'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Tier0NumberOfRoutesResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_get_tier0_number_of_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get routing table from tier-0
    # Get routing table from tier-0 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [RoutingTableListResult]
    def global_infra_get_tier0_routes(tier_0_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier0_routes_with_http_info(tier_0_id, opts)
      data
    end

    # Get routing table from tier-0
    # Get routing table from tier-0 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(RoutingTableListResult, Fixnum, Hash)>] RoutingTableListResult data, response status code and response headers
    def global_infra_get_tier0_routes_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_get_tier0_routes ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_get_tier0_routes"
      end
      if @api_client.config.client_side_validation && opts[:'component_type'] && !['DR_ROUTES'].include?(opts[:'component_type'])
        fail ArgumentError, 'invalid value for "component_type", must be one of DR_ROUTES'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier0_routes, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier0_routes, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'route_source'] && !['BGP', 'STATIC', 'CONNECTED', 'OSPF'].include?(opts[:'route_source'])
        fail ArgumentError, 'invalid value for "route_source", must be one of BGP, STATIC, CONNECTED, OSPF'
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/routing-table'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'component_type'] = opts[:'component_type'] if !opts[:'component_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_id'] = opts[:'edge_id'] if !opts[:'edge_id'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'network_prefix'] = opts[:'network_prefix'] if !opts[:'network_prefix'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'route_source'] = opts[:'route_source'] if !opts[:'route_source'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoutingTableListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_get_tier0_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get routing table from tier-0 in CSV format
    # Get routing table from tier-0 gateway in CSV format. 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [GatewayRouteTableInCsvFormat]
    def global_infra_get_tier0_routes_csv(tier_0_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier0_routes_csv_with_http_info(tier_0_id, opts)
      data
    end

    # Get routing table from tier-0 in CSV format
    # Get routing table from tier-0 gateway in CSV format. 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(GatewayRouteTableInCsvFormat, Fixnum, Hash)>] GatewayRouteTableInCsvFormat data, response status code and response headers
    def global_infra_get_tier0_routes_csv_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_get_tier0_routes_csv ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_get_tier0_routes_csv"
      end
      if @api_client.config.client_side_validation && opts[:'component_type'] && !['DR_ROUTES'].include?(opts[:'component_type'])
        fail ArgumentError, 'invalid value for "component_type", must be one of DR_ROUTES'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier0_routes_csv, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier0_routes_csv, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'route_source'] && !['BGP', 'STATIC', 'CONNECTED', 'OSPF'].include?(opts[:'route_source'])
        fail ArgumentError, 'invalid value for "route_source", must be one of BGP, STATIC, CONNECTED, OSPF'
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/routing-table?format=csv'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'component_type'] = opts[:'component_type'] if !opts[:'component_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_id'] = opts[:'edge_id'] if !opts[:'edge_id'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'network_prefix'] = opts[:'network_prefix'] if !opts[:'network_prefix'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'route_source'] = opts[:'route_source'] if !opts[:'route_source'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'GatewayRouteTableInCsvFormat')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_get_tier0_routes_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tier0 state
    # Returns 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :interface_path Interface path for interface specific state such as IPv6 DAD state
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :type Returns specific information based on the value specified.
    # @return [Tier0GatewayState]
    def global_infra_get_tier0_state(tier_0_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier0_state_with_http_info(tier_0_id, opts)
      data
    end

    # Get Tier0 state
    # Returns 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :interface_path Interface path for interface specific state such as IPv6 DAD state
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :type Returns specific information based on the value specified.
    # @return [Array<(Tier0GatewayState, Fixnum, Hash)>] Tier0GatewayState data, response status code and response headers
    def global_infra_get_tier0_state_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_get_tier0_state ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_get_tier0_state"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier0_state, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier0_state, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'type'] && !['GATEWAY_STATE', 'GATEWAY_STATUS', 'IPV6_STATUS', 'RD_PER_EDGE_MAPPING'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of GATEWAY_STATE, GATEWAY_STATUS, IPV6_STATUS, RD_PER_EDGE_MAPPING'
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/state'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'interface_path'] = opts[:'interface_path'] if !opts[:'interface_path'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Tier0GatewayState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_get_tier0_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List advertised networks
    # Return networks which are advertised to connected TIER0 gateway. 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PolicyAdvertisedNetworksListResult]
    def global_infra_get_tier1_advertised_networks(tier_1_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier1_advertised_networks_with_http_info(tier_1_id, opts)
      data
    end

    # List advertised networks
    # Return networks which are advertised to connected TIER0 gateway. 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PolicyAdvertisedNetworksListResult, Fixnum, Hash)>] PolicyAdvertisedNetworksListResult data, response status code and response headers
    def global_infra_get_tier1_advertised_networks_with_http_info(tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_get_tier1_advertised_networks ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.global_infra_get_tier1_advertised_networks"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier1_advertised_networks, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier1_advertised_networks, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/advertised-networks'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyAdvertisedNetworksListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_get_tier1_advertised_networks\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List advertised networks in CSV format
    # Return networks which are advertised to connected TIER0 gateway in CSV format. 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PolicyAdvertisedNetworkInCsvFormat]
    def global_infra_get_tier1_advertised_networks_in_csv_format(tier_1_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier1_advertised_networks_in_csv_format_with_http_info(tier_1_id, opts)
      data
    end

    # List advertised networks in CSV format
    # Return networks which are advertised to connected TIER0 gateway in CSV format. 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PolicyAdvertisedNetworkInCsvFormat, Fixnum, Hash)>] PolicyAdvertisedNetworkInCsvFormat data, response status code and response headers
    def global_infra_get_tier1_advertised_networks_in_csv_format_with_http_info(tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_get_tier1_advertised_networks_in_csv_format ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.global_infra_get_tier1_advertised_networks_in_csv_format"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier1_advertised_networks_in_csv_format, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier1_advertised_networks_in_csv_format, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/advertised-networks/csv'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyAdvertisedNetworkInCsvFormat')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_get_tier1_advertised_networks_in_csv_format\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get forwarding table from tier-1
    # Get forwarding table from tier-1 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [RoutingTableListResult]
    def global_infra_get_tier1_forwarding_table(tier_1_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier1_forwarding_table_with_http_info(tier_1_id, opts)
      data
    end

    # Get forwarding table from tier-1
    # Get forwarding table from tier-1 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(RoutingTableListResult, Fixnum, Hash)>] RoutingTableListResult data, response status code and response headers
    def global_infra_get_tier1_forwarding_table_with_http_info(tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_get_tier1_forwarding_table ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.global_infra_get_tier1_forwarding_table"
      end
      if @api_client.config.client_side_validation && opts[:'component_type'] && !['DR_ROUTES'].include?(opts[:'component_type'])
        fail ArgumentError, 'invalid value for "component_type", must be one of DR_ROUTES'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier1_forwarding_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier1_forwarding_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'route_source'] && !['BGP', 'STATIC', 'CONNECTED', 'OSPF'].include?(opts[:'route_source'])
        fail ArgumentError, 'invalid value for "route_source", must be one of BGP, STATIC, CONNECTED, OSPF'
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/forwarding-table'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'component_type'] = opts[:'component_type'] if !opts[:'component_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_id'] = opts[:'edge_id'] if !opts[:'edge_id'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'network_prefix'] = opts[:'network_prefix'] if !opts[:'network_prefix'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'route_source'] = opts[:'route_source'] if !opts[:'route_source'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoutingTableListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_get_tier1_forwarding_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get forwarding table from tier-1 in CSV format
    # Get forwarding table from tier-1 gateway in CSV format. 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [GatewayRouteTableInCsvFormat]
    def global_infra_get_tier1_forwarding_table_csv(tier_1_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier1_forwarding_table_csv_with_http_info(tier_1_id, opts)
      data
    end

    # Get forwarding table from tier-1 in CSV format
    # Get forwarding table from tier-1 gateway in CSV format. 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(GatewayRouteTableInCsvFormat, Fixnum, Hash)>] GatewayRouteTableInCsvFormat data, response status code and response headers
    def global_infra_get_tier1_forwarding_table_csv_with_http_info(tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_get_tier1_forwarding_table_csv ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.global_infra_get_tier1_forwarding_table_csv"
      end
      if @api_client.config.client_side_validation && opts[:'component_type'] && !['DR_ROUTES'].include?(opts[:'component_type'])
        fail ArgumentError, 'invalid value for "component_type", must be one of DR_ROUTES'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier1_forwarding_table_csv, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier1_forwarding_table_csv, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'route_source'] && !['BGP', 'STATIC', 'CONNECTED', 'OSPF'].include?(opts[:'route_source'])
        fail ArgumentError, 'invalid value for "route_source", must be one of BGP, STATIC, CONNECTED, OSPF'
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/forwarding-table?format=csv'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'component_type'] = opts[:'component_type'] if !opts[:'component_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_id'] = opts[:'edge_id'] if !opts[:'edge_id'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'network_prefix'] = opts[:'network_prefix'] if !opts[:'network_prefix'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'route_source'] = opts[:'route_source'] if !opts[:'route_source'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'GatewayRouteTableInCsvFormat')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_get_tier1_forwarding_table_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tier1 state
    # Returns 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :interface_path Interface path for interface specific state such as IPv6 DAD state
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :type Returns specific information based on the value specified.
    # @return [Tier1GatewayState]
    def global_infra_get_tier1_state(tier_1_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier1_state_with_http_info(tier_1_id, opts)
      data
    end

    # Get Tier1 state
    # Returns 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :interface_path Interface path for interface specific state such as IPv6 DAD state
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :type Returns specific information based on the value specified.
    # @return [Array<(Tier1GatewayState, Fixnum, Hash)>] Tier1GatewayState data, response status code and response headers
    def global_infra_get_tier1_state_with_http_info(tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_get_tier1_state ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.global_infra_get_tier1_state"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier1_state, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_get_tier1_state, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'type'] && !['GATEWAY_STATE', 'GATEWAY_STATUS', 'IPV6_STATUS'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of GATEWAY_STATE, GATEWAY_STATUS, IPV6_STATUS'
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/state'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'interface_path'] = opts[:'interface_path'] if !opts[:'interface_path'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Tier1GatewayState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_get_tier1_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List route maps
    # Paginated list of all route maps under a tier-0 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Tier0RouteMapListResult]
    def global_infra_list_all_route_maps(tier_0_id, opts = {})
      data, _status_code, _headers = global_infra_list_all_route_maps_with_http_info(tier_0_id, opts)
      data
    end

    # List route maps
    # Paginated list of all route maps under a tier-0 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(Tier0RouteMapListResult, Fixnum, Hash)>] Tier0RouteMapListResult data, response status code and response headers
    def global_infra_list_all_route_maps_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_list_all_route_maps ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_list_all_route_maps"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_list_all_route_maps, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_list_all_route_maps, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/route-maps'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Tier0RouteMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_list_all_route_maps\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List BGP neighbor configurations
    # Paginated list of all BGP neighbor configurations 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [BgpNeighborConfigListResult]
    def global_infra_list_bgp_neighbor_configs(tier_0_id, locale_service_id, opts = {})
      data, _status_code, _headers = global_infra_list_bgp_neighbor_configs_with_http_info(tier_0_id, locale_service_id, opts)
      data
    end

    # List BGP neighbor configurations
    # Paginated list of all BGP neighbor configurations 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(BgpNeighborConfigListResult, Fixnum, Hash)>] BgpNeighborConfigListResult data, response status code and response headers
    def global_infra_list_bgp_neighbor_configs_with_http_info(tier_0_id, locale_service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_list_bgp_neighbor_configs ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_list_bgp_neighbor_configs"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.global_infra_list_bgp_neighbor_configs"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_list_bgp_neighbor_configs, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_list_bgp_neighbor_configs, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/neighbors'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpNeighborConfigListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_list_bgp_neighbor_configs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List BGP community lists
    # Paginated list of all community lists under a tier-0 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [CommunityListListResult]
    def global_infra_list_community_list(tier_0_id, opts = {})
      data, _status_code, _headers = global_infra_list_community_list_with_http_info(tier_0_id, opts)
      data
    end

    # List BGP community lists
    # Paginated list of all community lists under a tier-0 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(CommunityListListResult, Fixnum, Hash)>] CommunityListListResult data, response status code and response headers
    def global_infra_list_community_list_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_list_community_list ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_list_community_list"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_list_community_list, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_list_community_list, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/community-lists'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'CommunityListListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_list_community_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List prefix lists
    # Paginated list of all prefix lists 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PrefixListResult]
    def global_infra_list_prefix_lists(tier_0_id, opts = {})
      data, _status_code, _headers = global_infra_list_prefix_lists_with_http_info(tier_0_id, opts)
      data
    end

    # List prefix lists
    # Paginated list of all prefix lists 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PrefixListResult, Fixnum, Hash)>] PrefixListResult data, response status code and response headers
    def global_infra_list_prefix_lists_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_list_prefix_lists ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_list_prefix_lists"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_list_prefix_lists, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_list_prefix_lists, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/prefix-lists'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PrefixListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_list_prefix_lists\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List StaticRouteBfdPeers
    # Paginated list of all StaticRouteBfdPeers. 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [StaticRouteBfdPeerListResult]
    def global_infra_list_static_route_bfd_peer(tier_0_id, opts = {})
      data, _status_code, _headers = global_infra_list_static_route_bfd_peer_with_http_info(tier_0_id, opts)
      data
    end

    # List StaticRouteBfdPeers
    # Paginated list of all StaticRouteBfdPeers. 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(StaticRouteBfdPeerListResult, Fixnum, Hash)>] StaticRouteBfdPeerListResult data, response status code and response headers
    def global_infra_list_static_route_bfd_peer_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_list_static_route_bfd_peer ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_list_static_route_bfd_peer"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_list_static_route_bfd_peer, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_list_static_route_bfd_peer, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/static-routes/bfd-peers'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRouteBfdPeerListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_list_static_route_bfd_peer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Tier-0 Static Routes
    # Paginated list of all Tier-0 Static Routes 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [StaticRoutesListResult]
    def global_infra_list_tier0_static_routes(tier_0_id, opts = {})
      data, _status_code, _headers = global_infra_list_tier0_static_routes_with_http_info(tier_0_id, opts)
      data
    end

    # List Tier-0 Static Routes
    # Paginated list of all Tier-0 Static Routes 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(StaticRoutesListResult, Fixnum, Hash)>] StaticRoutesListResult data, response status code and response headers
    def global_infra_list_tier0_static_routes_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_list_tier0_static_routes ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_list_tier0_static_routes"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_list_tier0_static_routes, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_list_tier0_static_routes, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/static-routes'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRoutesListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_list_tier0_static_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Tier-1 Static Routes
    # Paginated list of all Tier-1 Static Routes 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [StaticRoutesListResult]
    def global_infra_list_tier1_static_routes(tier_1_id, opts = {})
      data, _status_code, _headers = global_infra_list_tier1_static_routes_with_http_info(tier_1_id, opts)
      data
    end

    # List Tier-1 Static Routes
    # Paginated list of all Tier-1 Static Routes 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(StaticRoutesListResult, Fixnum, Hash)>] StaticRoutesListResult data, response status code and response headers
    def global_infra_list_tier1_static_routes_with_http_info(tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_list_tier1_static_routes ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.global_infra_list_tier1_static_routes"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_list_tier1_static_routes, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.global_infra_list_tier1_static_routes, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/static-routes'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRoutesListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_list_tier1_static_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a BGP neighbor config
    # If BGP neighbor config with the neighbor-id is not already present, create a new neighbor config. If it already exists, replace the BGP neighbor config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param bgp_neighbor_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def global_infra_patch_bgp_neighbor_config(tier_0_id, locale_service_id, neighbor_id, bgp_neighbor_config, opts = {})
      global_infra_patch_bgp_neighbor_config_with_http_info(tier_0_id, locale_service_id, neighbor_id, bgp_neighbor_config, opts)
      nil
    end

    # Create or update a BGP neighbor config
    # If BGP neighbor config with the neighbor-id is not already present, create a new neighbor config. If it already exists, replace the BGP neighbor config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param bgp_neighbor_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_patch_bgp_neighbor_config_with_http_info(tier_0_id, locale_service_id, neighbor_id, bgp_neighbor_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_patch_bgp_neighbor_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_patch_bgp_neighbor_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.global_infra_patch_bgp_neighbor_config"
      end
      # verify the required parameter 'neighbor_id' is set
      if @api_client.config.client_side_validation && neighbor_id.nil?
        fail ArgumentError, "Missing the required parameter 'neighbor_id' when calling RoutingApi.global_infra_patch_bgp_neighbor_config"
      end
      # verify the required parameter 'bgp_neighbor_config' is set
      if @api_client.config.client_side_validation && bgp_neighbor_config.nil?
        fail ArgumentError, "Missing the required parameter 'bgp_neighbor_config' when calling RoutingApi.global_infra_patch_bgp_neighbor_config"
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/neighbors/{neighbor-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'neighbor-id' + '}', neighbor_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(bgp_neighbor_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_patch_bgp_neighbor_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update BGP routing config
    # If an BGP routing config not present, create BGP routing config. If it already exists, update the routing config. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param bgp_routing_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def global_infra_patch_bgp_routing_config(tier_0_id, locale_service_id, bgp_routing_config, opts = {})
      global_infra_patch_bgp_routing_config_with_http_info(tier_0_id, locale_service_id, bgp_routing_config, opts)
      nil
    end

    # Create or update BGP routing config
    # If an BGP routing config not present, create BGP routing config. If it already exists, update the routing config. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param bgp_routing_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_patch_bgp_routing_config_with_http_info(tier_0_id, locale_service_id, bgp_routing_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_patch_bgp_routing_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_patch_bgp_routing_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.global_infra_patch_bgp_routing_config"
      end
      # verify the required parameter 'bgp_routing_config' is set
      if @api_client.config.client_side_validation && bgp_routing_config.nil?
        fail ArgumentError, "Missing the required parameter 'bgp_routing_config' when calling RoutingApi.global_infra_patch_bgp_routing_config"
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(bgp_routing_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_patch_bgp_routing_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a BGP troubleshoot config
    # If BGP troubleshoot config is not present in BGP configuration, create a new BGP troubleshoot config with default value. If it already exists, update the BGP troubleshoot config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param bgp_troubleshoot_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def global_infra_patch_bgp_troubleshoot_config(tier_0_id, locale_service_id, bgp_troubleshoot_config, opts = {})
      global_infra_patch_bgp_troubleshoot_config_with_http_info(tier_0_id, locale_service_id, bgp_troubleshoot_config, opts)
      nil
    end

    # Create or update a BGP troubleshoot config
    # If BGP troubleshoot config is not present in BGP configuration, create a new BGP troubleshoot config with default value. If it already exists, update the BGP troubleshoot config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param bgp_troubleshoot_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_patch_bgp_troubleshoot_config_with_http_info(tier_0_id, locale_service_id, bgp_troubleshoot_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_patch_bgp_troubleshoot_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_patch_bgp_troubleshoot_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.global_infra_patch_bgp_troubleshoot_config"
      end
      # verify the required parameter 'bgp_troubleshoot_config' is set
      if @api_client.config.client_side_validation && bgp_troubleshoot_config.nil?
        fail ArgumentError, "Missing the required parameter 'bgp_troubleshoot_config' when calling RoutingApi.global_infra_patch_bgp_troubleshoot_config"
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/troubleshoot'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(bgp_troubleshoot_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_patch_bgp_troubleshoot_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a StaticRouteBfdTroubleshootConfig
    # If a StaticRouteBfdTroubleshootConfig is not already present, create a new StaticRouteBfdTroubleshootConfig. If it already exists, update the StaticRouteBfdTroubleshootConfig. This is a full replace. 
    # @param tier_0_id Tier-0 ID
    # @param static_route_bfd_troubleshoot_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def global_infra_patch_static_route_bfd_troubleshoot_config(tier_0_id, static_route_bfd_troubleshoot_config, opts = {})
      global_infra_patch_static_route_bfd_troubleshoot_config_with_http_info(tier_0_id, static_route_bfd_troubleshoot_config, opts)
      nil
    end

    # Create or update a StaticRouteBfdTroubleshootConfig
    # If a StaticRouteBfdTroubleshootConfig is not already present, create a new StaticRouteBfdTroubleshootConfig. If it already exists, update the StaticRouteBfdTroubleshootConfig. This is a full replace. 
    # @param tier_0_id Tier-0 ID
    # @param static_route_bfd_troubleshoot_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_patch_static_route_bfd_troubleshoot_config_with_http_info(tier_0_id, static_route_bfd_troubleshoot_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_patch_static_route_bfd_troubleshoot_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_patch_static_route_bfd_troubleshoot_config"
      end
      # verify the required parameter 'static_route_bfd_troubleshoot_config' is set
      if @api_client.config.client_side_validation && static_route_bfd_troubleshoot_config.nil?
        fail ArgumentError, "Missing the required parameter 'static_route_bfd_troubleshoot_config' when calling RoutingApi.global_infra_patch_static_route_bfd_troubleshoot_config"
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/static-routes/bfd-peers/troubleshoot'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(static_route_bfd_troubleshoot_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_patch_static_route_bfd_troubleshoot_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read BGP neighbor config
    # Read BGP neighbor config
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @return [BgpNeighborConfig]
    def global_infra_read_bgp_neighbor_config(tier_0_id, locale_service_id, neighbor_id, opts = {})
      data, _status_code, _headers = global_infra_read_bgp_neighbor_config_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts)
      data
    end

    # Read BGP neighbor config
    # Read BGP neighbor config
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BgpNeighborConfig, Fixnum, Hash)>] BgpNeighborConfig data, response status code and response headers
    def global_infra_read_bgp_neighbor_config_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_read_bgp_neighbor_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_read_bgp_neighbor_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.global_infra_read_bgp_neighbor_config"
      end
      # verify the required parameter 'neighbor_id' is set
      if @api_client.config.client_side_validation && neighbor_id.nil?
        fail ArgumentError, "Missing the required parameter 'neighbor_id' when calling RoutingApi.global_infra_read_bgp_neighbor_config"
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/neighbors/{neighbor-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'neighbor-id' + '}', neighbor_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpNeighborConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_read_bgp_neighbor_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read BGP routing config
    # Read BGP routing config
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @return [BgpRoutingConfig]
    def global_infra_read_bgp_routing_config(tier_0_id, locale_service_id, opts = {})
      data, _status_code, _headers = global_infra_read_bgp_routing_config_with_http_info(tier_0_id, locale_service_id, opts)
      data
    end

    # Read BGP routing config
    # Read BGP routing config
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BgpRoutingConfig, Fixnum, Hash)>] BgpRoutingConfig data, response status code and response headers
    def global_infra_read_bgp_routing_config_with_http_info(tier_0_id, locale_service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_read_bgp_routing_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_read_bgp_routing_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.global_infra_read_bgp_routing_config"
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpRoutingConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_read_bgp_routing_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read BGP troubleshoot config
    # Read BGP troubleshoot config
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @return [BgpTroubleshootConfig]
    def global_infra_read_bgp_troubleshoot_config(tier_0_id, locale_service_id, opts = {})
      data, _status_code, _headers = global_infra_read_bgp_troubleshoot_config_with_http_info(tier_0_id, locale_service_id, opts)
      data
    end

    # Read BGP troubleshoot config
    # Read BGP troubleshoot config
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BgpTroubleshootConfig, Fixnum, Hash)>] BgpTroubleshootConfig data, response status code and response headers
    def global_infra_read_bgp_troubleshoot_config_with_http_info(tier_0_id, locale_service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_read_bgp_troubleshoot_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_read_bgp_troubleshoot_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.global_infra_read_bgp_troubleshoot_config"
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/troubleshoot'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpTroubleshootConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_read_bgp_troubleshoot_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read a BGP community list
    # Read a BGP community list
    # @param tier_0_id 
    # @param community_list_id 
    # @param [Hash] opts the optional parameters
    # @return [CommunityList]
    def global_infra_read_community_list(tier_0_id, community_list_id, opts = {})
      data, _status_code, _headers = global_infra_read_community_list_with_http_info(tier_0_id, community_list_id, opts)
      data
    end

    # Read a BGP community list
    # Read a BGP community list
    # @param tier_0_id 
    # @param community_list_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(CommunityList, Fixnum, Hash)>] CommunityList data, response status code and response headers
    def global_infra_read_community_list_with_http_info(tier_0_id, community_list_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_read_community_list ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_read_community_list"
      end
      # verify the required parameter 'community_list_id' is set
      if @api_client.config.client_side_validation && community_list_id.nil?
        fail ArgumentError, "Missing the required parameter 'community_list_id' when calling RoutingApi.global_infra_read_community_list"
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/community-lists/{community-list-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'community-list-id' + '}', community_list_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'CommunityList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_read_community_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read a prefix list
    # Read a prefix list
    # @param tier_0_id 
    # @param prefix_list_id 
    # @param [Hash] opts the optional parameters
    # @return [PrefixList]
    def global_infra_read_prefix_list(tier_0_id, prefix_list_id, opts = {})
      data, _status_code, _headers = global_infra_read_prefix_list_with_http_info(tier_0_id, prefix_list_id, opts)
      data
    end

    # Read a prefix list
    # Read a prefix list
    # @param tier_0_id 
    # @param prefix_list_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PrefixList, Fixnum, Hash)>] PrefixList data, response status code and response headers
    def global_infra_read_prefix_list_with_http_info(tier_0_id, prefix_list_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_read_prefix_list ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_read_prefix_list"
      end
      # verify the required parameter 'prefix_list_id' is set
      if @api_client.config.client_side_validation && prefix_list_id.nil?
        fail ArgumentError, "Missing the required parameter 'prefix_list_id' when calling RoutingApi.global_infra_read_prefix_list"
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/prefix-lists/{prefix-list-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'prefix-list-id' + '}', prefix_list_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PrefixList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_read_prefix_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read a StaticRouteBfdPeer
    # Read a StaticRouteBfdPeer with the bfd-peer-id. 
    # @param tier_0_id Tier-0 ID
    # @param bfd_peer_id BFD peer ID
    # @param [Hash] opts the optional parameters
    # @return [StaticRouteBfdPeer]
    def global_infra_read_static_route_bfd_peer(tier_0_id, bfd_peer_id, opts = {})
      data, _status_code, _headers = global_infra_read_static_route_bfd_peer_with_http_info(tier_0_id, bfd_peer_id, opts)
      data
    end

    # Read a StaticRouteBfdPeer
    # Read a StaticRouteBfdPeer with the bfd-peer-id. 
    # @param tier_0_id Tier-0 ID
    # @param bfd_peer_id BFD peer ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(StaticRouteBfdPeer, Fixnum, Hash)>] StaticRouteBfdPeer data, response status code and response headers
    def global_infra_read_static_route_bfd_peer_with_http_info(tier_0_id, bfd_peer_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_read_static_route_bfd_peer ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_read_static_route_bfd_peer"
      end
      # verify the required parameter 'bfd_peer_id' is set
      if @api_client.config.client_side_validation && bfd_peer_id.nil?
        fail ArgumentError, "Missing the required parameter 'bfd_peer_id' when calling RoutingApi.global_infra_read_static_route_bfd_peer"
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/static-routes/bfd-peers/{bfd-peer-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'bfd-peer-id' + '}', bfd_peer_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRouteBfdPeer')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_read_static_route_bfd_peer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read a StaticRouteBfdTroubleshootConfig
    # Read a StaticRouteBfdTroubleshootConfig 
    # @param tier_0_id Tier-0 ID
    # @param [Hash] opts the optional parameters
    # @return [StaticRouteBfdTroubleshootConfig]
    def global_infra_read_static_route_bfd_troubleshoot_config(tier_0_id, opts = {})
      data, _status_code, _headers = global_infra_read_static_route_bfd_troubleshoot_config_with_http_info(tier_0_id, opts)
      data
    end

    # Read a StaticRouteBfdTroubleshootConfig
    # Read a StaticRouteBfdTroubleshootConfig 
    # @param tier_0_id Tier-0 ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(StaticRouteBfdTroubleshootConfig, Fixnum, Hash)>] StaticRouteBfdTroubleshootConfig data, response status code and response headers
    def global_infra_read_static_route_bfd_troubleshoot_config_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_read_static_route_bfd_troubleshoot_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_read_static_route_bfd_troubleshoot_config"
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/static-routes/bfd-peers/troubleshoot'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRouteBfdTroubleshootConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_read_static_route_bfd_troubleshoot_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read Tier-0 static routes
    # Read Tier-0 static routes
    # @param tier_0_id 
    # @param route_id 
    # @param [Hash] opts the optional parameters
    # @return [StaticRoutes]
    def global_infra_read_tier0_static_routes(tier_0_id, route_id, opts = {})
      data, _status_code, _headers = global_infra_read_tier0_static_routes_with_http_info(tier_0_id, route_id, opts)
      data
    end

    # Read Tier-0 static routes
    # Read Tier-0 static routes
    # @param tier_0_id 
    # @param route_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(StaticRoutes, Fixnum, Hash)>] StaticRoutes data, response status code and response headers
    def global_infra_read_tier0_static_routes_with_http_info(tier_0_id, route_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_read_tier0_static_routes ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.global_infra_read_tier0_static_routes"
      end
      # verify the required parameter 'route_id' is set
      if @api_client.config.client_side_validation && route_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_id' when calling RoutingApi.global_infra_read_tier0_static_routes"
      end
      # resource path
      local_var_path = '/global-infra/tier-0s/{tier-0-id}/static-routes/{route-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'route-id' + '}', route_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRoutes')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_read_tier0_static_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read Tier-1 static routes
    # Read Tier-1 static routes
    # @param tier_1_id 
    # @param route_id 
    # @param [Hash] opts the optional parameters
    # @return [StaticRoutes]
    def global_infra_read_tier1_static_routes(tier_1_id, route_id, opts = {})
      data, _status_code, _headers = global_infra_read_tier1_static_routes_with_http_info(tier_1_id, route_id, opts)
      data
    end

    # Read Tier-1 static routes
    # Read Tier-1 static routes
    # @param tier_1_id 
    # @param route_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(StaticRoutes, Fixnum, Hash)>] StaticRoutes data, response status code and response headers
    def global_infra_read_tier1_static_routes_with_http_info(tier_1_id, route_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.global_infra_read_tier1_static_routes ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.global_infra_read_tier1_static_routes"
      end
      # verify the required parameter 'route_id' is set
      if @api_client.config.client_side_validation && route_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_id' when calling RoutingApi.global_infra_read_tier1_static_routes"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/static-routes/{route-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'route-id' + '}', route_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRoutes')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#global_infra_read_tier1_static_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List route maps
    # Paginated list of all route maps under a tier-0 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Tier0RouteMapListResult]
    def list_all_route_maps(tier_0_id, opts = {})
      data, _status_code, _headers = list_all_route_maps_with_http_info(tier_0_id, opts)
      data
    end

    # List route maps
    # Paginated list of all route maps under a tier-0 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(Tier0RouteMapListResult, Fixnum, Hash)>] Tier0RouteMapListResult data, response status code and response headers
    def list_all_route_maps_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.list_all_route_maps ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.list_all_route_maps"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_all_route_maps, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_all_route_maps, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/route-maps'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Tier0RouteMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#list_all_route_maps\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List BGP neighbor configurations
    # Paginated list of all BGP neighbor configurations 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [BgpNeighborConfigListResult]
    def list_bgp_neighbor_configs(tier_0_id, locale_service_id, opts = {})
      data, _status_code, _headers = list_bgp_neighbor_configs_with_http_info(tier_0_id, locale_service_id, opts)
      data
    end

    # List BGP neighbor configurations
    # Paginated list of all BGP neighbor configurations 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(BgpNeighborConfigListResult, Fixnum, Hash)>] BgpNeighborConfigListResult data, response status code and response headers
    def list_bgp_neighbor_configs_with_http_info(tier_0_id, locale_service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.list_bgp_neighbor_configs ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.list_bgp_neighbor_configs"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.list_bgp_neighbor_configs"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_bgp_neighbor_configs, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_bgp_neighbor_configs, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/neighbors'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpNeighborConfigListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#list_bgp_neighbor_configs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List BGP community lists
    # Paginated list of all community lists under a tier-0 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [CommunityListListResult]
    def list_community_list(tier_0_id, opts = {})
      data, _status_code, _headers = list_community_list_with_http_info(tier_0_id, opts)
      data
    end

    # List BGP community lists
    # Paginated list of all community lists under a tier-0 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(CommunityListListResult, Fixnum, Hash)>] CommunityListListResult data, response status code and response headers
    def list_community_list_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.list_community_list ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.list_community_list"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_community_list, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_community_list, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/community-lists'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'CommunityListListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#list_community_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List prefix lists
    # Paginated list of all prefix lists 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PrefixListResult]
    def list_infra_prefix_lists(opts = {})
      data, _status_code, _headers = list_infra_prefix_lists_with_http_info(opts)
      data
    end

    # List prefix lists
    # Paginated list of all prefix lists 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PrefixListResult, Fixnum, Hash)>] PrefixListResult data, response status code and response headers
    def list_infra_prefix_lists_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.list_infra_prefix_lists ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_infra_prefix_lists, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_infra_prefix_lists, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/routing-config/prefix-lists'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PrefixListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#list_infra_prefix_lists\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List inter-vrf routing configurations
    # List all inter-vrf routing configurations.
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PolicyInterVrfRoutingConfigListResult]
    def list_policy_inter_vrf_routing_config(tier_0_id, opts = {})
      data, _status_code, _headers = list_policy_inter_vrf_routing_config_with_http_info(tier_0_id, opts)
      data
    end

    # List inter-vrf routing configurations
    # List all inter-vrf routing configurations.
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PolicyInterVrfRoutingConfigListResult, Fixnum, Hash)>] PolicyInterVrfRoutingConfigListResult data, response status code and response headers
    def list_policy_inter_vrf_routing_config_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.list_policy_inter_vrf_routing_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.list_policy_inter_vrf_routing_config"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_policy_inter_vrf_routing_config, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_policy_inter_vrf_routing_config, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/inter-vrf-routing'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyInterVrfRoutingConfigListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#list_policy_inter_vrf_routing_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List OSPF area configurations
    # List all OSPF area configurations. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [OspfAreaConfigListResult]
    def list_policy_ospf_area_config(tier_0_id, locale_service_id, opts = {})
      data, _status_code, _headers = list_policy_ospf_area_config_with_http_info(tier_0_id, locale_service_id, opts)
      data
    end

    # List OSPF area configurations
    # List all OSPF area configurations. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(OspfAreaConfigListResult, Fixnum, Hash)>] OspfAreaConfigListResult data, response status code and response headers
    def list_policy_ospf_area_config_with_http_info(tier_0_id, locale_service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.list_policy_ospf_area_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.list_policy_ospf_area_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.list_policy_ospf_area_config"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_policy_ospf_area_config, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_policy_ospf_area_config, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/ospf/areas'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'OspfAreaConfigListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#list_policy_ospf_area_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List prefix lists
    # Paginated list of all prefix lists 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PrefixListResult]
    def list_prefix_lists(tier_0_id, opts = {})
      data, _status_code, _headers = list_prefix_lists_with_http_info(tier_0_id, opts)
      data
    end

    # List prefix lists
    # Paginated list of all prefix lists 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PrefixListResult, Fixnum, Hash)>] PrefixListResult data, response status code and response headers
    def list_prefix_lists_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.list_prefix_lists ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.list_prefix_lists"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_prefix_lists, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_prefix_lists, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/prefix-lists'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PrefixListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#list_prefix_lists\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List project route filter lists
    # Paginated list of all route filter lists 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [ProjectRouteFilterListResult]
    def list_project_route_filters(opts = {})
      data, _status_code, _headers = list_project_route_filters_with_http_info(opts)
      data
    end

    # List project route filter lists
    # Paginated list of all route filter lists 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(ProjectRouteFilterListResult, Fixnum, Hash)>] ProjectRouteFilterListResult data, response status code and response headers
    def list_project_route_filters_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.list_project_route_filters ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_project_route_filters, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_project_route_filters, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/routing-config/project-route-filters'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ProjectRouteFilterListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#list_project_route_filters\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List StaticRouteBfdPeers
    # Paginated list of all StaticRouteBfdPeers. 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [StaticRouteBfdPeerListResult]
    def list_static_route_bfd_peer(tier_0_id, opts = {})
      data, _status_code, _headers = list_static_route_bfd_peer_with_http_info(tier_0_id, opts)
      data
    end

    # List StaticRouteBfdPeers
    # Paginated list of all StaticRouteBfdPeers. 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(StaticRouteBfdPeerListResult, Fixnum, Hash)>] StaticRouteBfdPeerListResult data, response status code and response headers
    def list_static_route_bfd_peer_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.list_static_route_bfd_peer ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.list_static_route_bfd_peer"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_static_route_bfd_peer, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_static_route_bfd_peer, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/static-routes/bfd-peers'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRouteBfdPeerListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#list_static_route_bfd_peer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Tier-0 Static Routes
    # Paginated list of all Tier-0 Static Routes 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [StaticRoutesListResult]
    def list_tier0_static_routes(tier_0_id, opts = {})
      data, _status_code, _headers = list_tier0_static_routes_with_http_info(tier_0_id, opts)
      data
    end

    # List Tier-0 Static Routes
    # Paginated list of all Tier-0 Static Routes 
    # @param tier_0_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(StaticRoutesListResult, Fixnum, Hash)>] StaticRoutesListResult data, response status code and response headers
    def list_tier0_static_routes_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.list_tier0_static_routes ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.list_tier0_static_routes"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_tier0_static_routes, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_tier0_static_routes, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/static-routes'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRoutesListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#list_tier0_static_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Tier-1 Static Routes
    # Paginated list of all Tier-1 Static Routes 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [StaticRoutesListResult]
    def list_tier1_static_routes(tier_1_id, opts = {})
      data, _status_code, _headers = list_tier1_static_routes_with_http_info(tier_1_id, opts)
      data
    end

    # List Tier-1 Static Routes
    # Paginated list of all Tier-1 Static Routes 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(StaticRoutesListResult, Fixnum, Hash)>] StaticRoutesListResult data, response status code and response headers
    def list_tier1_static_routes_with_http_info(tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.list_tier1_static_routes ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.list_tier1_static_routes"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_tier1_static_routes, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.list_tier1_static_routes, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/static-routes'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRoutesListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#list_tier1_static_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a Tier-1 static routes
    # If static routes for route-id are not already present, create static routes. If it already exists, replace the static routes for route-id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param route_id 
    # @param static_routes 
    # @param [Hash] opts the optional parameters
    # @return [StaticRoutes]
    def orgs_org_id_projects_project_id_infra_create_or_replace_tier1_static_routes(org_id, project_id, tier_1_id, route_id, static_routes, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_create_or_replace_tier1_static_routes_with_http_info(org_id, project_id, tier_1_id, route_id, static_routes, opts)
      data
    end

    # Create or update a Tier-1 static routes
    # If static routes for route-id are not already present, create static routes. If it already exists, replace the static routes for route-id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param route_id 
    # @param static_routes 
    # @param [Hash] opts the optional parameters
    # @return [Array<(StaticRoutes, Fixnum, Hash)>] StaticRoutes data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_or_replace_tier1_static_routes_with_http_info(org_id, project_id, tier_1_id, route_id, static_routes, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.orgs_org_id_projects_project_id_infra_create_or_replace_tier1_static_routes ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_create_or_replace_tier1_static_routes"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_create_or_replace_tier1_static_routes"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_create_or_replace_tier1_static_routes"
      end
      # verify the required parameter 'route_id' is set
      if @api_client.config.client_side_validation && route_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_create_or_replace_tier1_static_routes"
      end
      # verify the required parameter 'static_routes' is set
      if @api_client.config.client_side_validation && static_routes.nil?
        fail ArgumentError, "Missing the required parameter 'static_routes' when calling RoutingApi.orgs_org_id_projects_project_id_infra_create_or_replace_tier1_static_routes"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/static-routes/{route-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'route-id' + '}', route_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(static_routes)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRoutes')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#orgs_org_id_projects_project_id_infra_create_or_replace_tier1_static_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Tier-1 static routes
    # Delete Tier-1 static routes
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param route_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_tier1_static_routes(org_id, project_id, tier_1_id, route_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_tier1_static_routes_with_http_info(org_id, project_id, tier_1_id, route_id, opts)
      nil
    end

    # Delete Tier-1 static routes
    # Delete Tier-1 static routes
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param route_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_tier1_static_routes_with_http_info(org_id, project_id, tier_1_id, route_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.orgs_org_id_projects_project_id_infra_delete_tier1_static_routes ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_delete_tier1_static_routes"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_delete_tier1_static_routes"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_delete_tier1_static_routes"
      end
      # verify the required parameter 'route_id' is set
      if @api_client.config.client_side_validation && route_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_delete_tier1_static_routes"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/static-routes/{route-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'route-id' + '}', route_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#orgs_org_id_projects_project_id_infra_delete_tier1_static_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List advertised networks
    # Return networks which are advertised to connected TIER0 gateway. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PolicyAdvertisedNetworksListResult]
    def orgs_org_id_projects_project_id_infra_get_tier1_advertised_networks(org_id, project_id, tier_1_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tier1_advertised_networks_with_http_info(org_id, project_id, tier_1_id, opts)
      data
    end

    # List advertised networks
    # Return networks which are advertised to connected TIER0 gateway. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PolicyAdvertisedNetworksListResult, Fixnum, Hash)>] PolicyAdvertisedNetworksListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tier1_advertised_networks_with_http_info(org_id, project_id, tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_advertised_networks ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_advertised_networks"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_advertised_networks"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_advertised_networks"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_advertised_networks, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_advertised_networks, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/advertised-networks'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyAdvertisedNetworksListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#orgs_org_id_projects_project_id_infra_get_tier1_advertised_networks\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List advertised networks in CSV format
    # Return networks which are advertised to connected TIER0 gateway in CSV format. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PolicyAdvertisedNetworkInCsvFormat]
    def orgs_org_id_projects_project_id_infra_get_tier1_advertised_networks_in_csv_format(org_id, project_id, tier_1_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tier1_advertised_networks_in_csv_format_with_http_info(org_id, project_id, tier_1_id, opts)
      data
    end

    # List advertised networks in CSV format
    # Return networks which are advertised to connected TIER0 gateway in CSV format. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PolicyAdvertisedNetworkInCsvFormat, Fixnum, Hash)>] PolicyAdvertisedNetworkInCsvFormat data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tier1_advertised_networks_in_csv_format_with_http_info(org_id, project_id, tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_advertised_networks_in_csv_format ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_advertised_networks_in_csv_format"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_advertised_networks_in_csv_format"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_advertised_networks_in_csv_format"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_advertised_networks_in_csv_format, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_advertised_networks_in_csv_format, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/advertised-networks/csv'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyAdvertisedNetworkInCsvFormat')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#orgs_org_id_projects_project_id_infra_get_tier1_advertised_networks_in_csv_format\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get forwarding table from tier-1
    # Get forwarding table from tier-1 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [RoutingTableListResult]
    def orgs_org_id_projects_project_id_infra_get_tier1_forwarding_table(org_id, project_id, tier_1_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tier1_forwarding_table_with_http_info(org_id, project_id, tier_1_id, opts)
      data
    end

    # Get forwarding table from tier-1
    # Get forwarding table from tier-1 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(RoutingTableListResult, Fixnum, Hash)>] RoutingTableListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tier1_forwarding_table_with_http_info(org_id, project_id, tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_forwarding_table ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_forwarding_table"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_forwarding_table"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_forwarding_table"
      end
      if @api_client.config.client_side_validation && opts[:'component_type'] && !['DR_ROUTES'].include?(opts[:'component_type'])
        fail ArgumentError, 'invalid value for "component_type", must be one of DR_ROUTES'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_forwarding_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_forwarding_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'route_source'] && !['BGP', 'STATIC', 'CONNECTED', 'OSPF'].include?(opts[:'route_source'])
        fail ArgumentError, 'invalid value for "route_source", must be one of BGP, STATIC, CONNECTED, OSPF'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/forwarding-table'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'component_type'] = opts[:'component_type'] if !opts[:'component_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_id'] = opts[:'edge_id'] if !opts[:'edge_id'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'network_prefix'] = opts[:'network_prefix'] if !opts[:'network_prefix'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'route_source'] = opts[:'route_source'] if !opts[:'route_source'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RoutingTableListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#orgs_org_id_projects_project_id_infra_get_tier1_forwarding_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get forwarding table from tier-1 in CSV format
    # Get forwarding table from tier-1 gateway in CSV format. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [GatewayRouteTableInCsvFormat]
    def orgs_org_id_projects_project_id_infra_get_tier1_forwarding_table_csv(org_id, project_id, tier_1_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tier1_forwarding_table_csv_with_http_info(org_id, project_id, tier_1_id, opts)
      data
    end

    # Get forwarding table from tier-1 in CSV format
    # Get forwarding table from tier-1 gateway in CSV format. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :component_type Define the DR routes.
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_id UUID of edge node
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :network_prefix IPAddress or CIDR Block
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :route_source Filter routes based on the source from which route is learned
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(GatewayRouteTableInCsvFormat, Fixnum, Hash)>] GatewayRouteTableInCsvFormat data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tier1_forwarding_table_csv_with_http_info(org_id, project_id, tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_forwarding_table_csv ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_forwarding_table_csv"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_forwarding_table_csv"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_forwarding_table_csv"
      end
      if @api_client.config.client_side_validation && opts[:'component_type'] && !['DR_ROUTES'].include?(opts[:'component_type'])
        fail ArgumentError, 'invalid value for "component_type", must be one of DR_ROUTES'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_forwarding_table_csv, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_forwarding_table_csv, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'route_source'] && !['BGP', 'STATIC', 'CONNECTED', 'OSPF'].include?(opts[:'route_source'])
        fail ArgumentError, 'invalid value for "route_source", must be one of BGP, STATIC, CONNECTED, OSPF'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/forwarding-table?format=csv'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'component_type'] = opts[:'component_type'] if !opts[:'component_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_id'] = opts[:'edge_id'] if !opts[:'edge_id'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'network_prefix'] = opts[:'network_prefix'] if !opts[:'network_prefix'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'route_source'] = opts[:'route_source'] if !opts[:'route_source'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'GatewayRouteTableInCsvFormat')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#orgs_org_id_projects_project_id_infra_get_tier1_forwarding_table_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tier1 state
    # Returns 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :interface_path Interface path for interface specific state such as IPv6 DAD state
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :type Returns specific information based on the value specified.
    # @return [Tier1GatewayState]
    def orgs_org_id_projects_project_id_infra_get_tier1_state(org_id, project_id, tier_1_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tier1_state_with_http_info(org_id, project_id, tier_1_id, opts)
      data
    end

    # Get Tier1 state
    # Returns 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :interface_path Interface path for interface specific state such as IPv6 DAD state
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :type Returns specific information based on the value specified.
    # @return [Array<(Tier1GatewayState, Fixnum, Hash)>] Tier1GatewayState data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tier1_state_with_http_info(org_id, project_id, tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_state ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_state"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_state"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_state"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_state, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.orgs_org_id_projects_project_id_infra_get_tier1_state, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'type'] && !['GATEWAY_STATE', 'GATEWAY_STATUS', 'IPV6_STATUS'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of GATEWAY_STATE, GATEWAY_STATUS, IPV6_STATUS'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/state'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'interface_path'] = opts[:'interface_path'] if !opts[:'interface_path'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Tier1GatewayState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#orgs_org_id_projects_project_id_infra_get_tier1_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Tier-1 Static Routes
    # Paginated list of all Tier-1 Static Routes 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [StaticRoutesListResult]
    def orgs_org_id_projects_project_id_infra_list_tier1_static_routes(org_id, project_id, tier_1_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_tier1_static_routes_with_http_info(org_id, project_id, tier_1_id, opts)
      data
    end

    # List Tier-1 Static Routes
    # Paginated list of all Tier-1 Static Routes 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(StaticRoutesListResult, Fixnum, Hash)>] StaticRoutesListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_tier1_static_routes_with_http_info(org_id, project_id, tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.orgs_org_id_projects_project_id_infra_list_tier1_static_routes ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_list_tier1_static_routes"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_list_tier1_static_routes"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_list_tier1_static_routes"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.orgs_org_id_projects_project_id_infra_list_tier1_static_routes, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling RoutingApi.orgs_org_id_projects_project_id_infra_list_tier1_static_routes, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/static-routes'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRoutesListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#orgs_org_id_projects_project_id_infra_list_tier1_static_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a Tier-1 static routes
    # If static routes for route-id are not already present, create static routes. If it already exists, update static routes for route-id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param route_id 
    # @param static_routes 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_tier1_static_routes(org_id, project_id, tier_1_id, route_id, static_routes, opts = {})
      orgs_org_id_projects_project_id_infra_patch_tier1_static_routes_with_http_info(org_id, project_id, tier_1_id, route_id, static_routes, opts)
      nil
    end

    # Create or update a Tier-1 static routes
    # If static routes for route-id are not already present, create static routes. If it already exists, update static routes for route-id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param route_id 
    # @param static_routes 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_tier1_static_routes_with_http_info(org_id, project_id, tier_1_id, route_id, static_routes, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.orgs_org_id_projects_project_id_infra_patch_tier1_static_routes ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_patch_tier1_static_routes"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_patch_tier1_static_routes"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_patch_tier1_static_routes"
      end
      # verify the required parameter 'route_id' is set
      if @api_client.config.client_side_validation && route_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_patch_tier1_static_routes"
      end
      # verify the required parameter 'static_routes' is set
      if @api_client.config.client_side_validation && static_routes.nil?
        fail ArgumentError, "Missing the required parameter 'static_routes' when calling RoutingApi.orgs_org_id_projects_project_id_infra_patch_tier1_static_routes"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/static-routes/{route-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'route-id' + '}', route_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(static_routes)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#orgs_org_id_projects_project_id_infra_patch_tier1_static_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read Tier-1 static routes
    # Read Tier-1 static routes
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param route_id 
    # @param [Hash] opts the optional parameters
    # @return [StaticRoutes]
    def orgs_org_id_projects_project_id_infra_read_tier1_static_routes(org_id, project_id, tier_1_id, route_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_read_tier1_static_routes_with_http_info(org_id, project_id, tier_1_id, route_id, opts)
      data
    end

    # Read Tier-1 static routes
    # Read Tier-1 static routes
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param route_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(StaticRoutes, Fixnum, Hash)>] StaticRoutes data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_read_tier1_static_routes_with_http_info(org_id, project_id, tier_1_id, route_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.orgs_org_id_projects_project_id_infra_read_tier1_static_routes ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_read_tier1_static_routes"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_read_tier1_static_routes"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_read_tier1_static_routes"
      end
      # verify the required parameter 'route_id' is set
      if @api_client.config.client_side_validation && route_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_id' when calling RoutingApi.orgs_org_id_projects_project_id_infra_read_tier1_static_routes"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/static-routes/{route-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'route-id' + '}', route_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRoutes')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#orgs_org_id_projects_project_id_infra_read_tier1_static_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a BGP neighbor config
    # If BGP neighbor config with the neighbor-id is not already present, create a new neighbor config. If it already exists, replace the BGP neighbor config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param bgp_neighbor_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def patch_bgp_neighbor_config(tier_0_id, locale_service_id, neighbor_id, bgp_neighbor_config, opts = {})
      patch_bgp_neighbor_config_with_http_info(tier_0_id, locale_service_id, neighbor_id, bgp_neighbor_config, opts)
      nil
    end

    # Create or update a BGP neighbor config
    # If BGP neighbor config with the neighbor-id is not already present, create a new neighbor config. If it already exists, replace the BGP neighbor config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param bgp_neighbor_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_bgp_neighbor_config_with_http_info(tier_0_id, locale_service_id, neighbor_id, bgp_neighbor_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.patch_bgp_neighbor_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.patch_bgp_neighbor_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.patch_bgp_neighbor_config"
      end
      # verify the required parameter 'neighbor_id' is set
      if @api_client.config.client_side_validation && neighbor_id.nil?
        fail ArgumentError, "Missing the required parameter 'neighbor_id' when calling RoutingApi.patch_bgp_neighbor_config"
      end
      # verify the required parameter 'bgp_neighbor_config' is set
      if @api_client.config.client_side_validation && bgp_neighbor_config.nil?
        fail ArgumentError, "Missing the required parameter 'bgp_neighbor_config' when calling RoutingApi.patch_bgp_neighbor_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/neighbors/{neighbor-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'neighbor-id' + '}', neighbor_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(bgp_neighbor_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#patch_bgp_neighbor_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update BGP routing config
    # If an BGP routing config not present, create BGP routing config. If it already exists, update the routing config. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param bgp_routing_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def patch_bgp_routing_config(tier_0_id, locale_service_id, bgp_routing_config, opts = {})
      patch_bgp_routing_config_with_http_info(tier_0_id, locale_service_id, bgp_routing_config, opts)
      nil
    end

    # Create or update BGP routing config
    # If an BGP routing config not present, create BGP routing config. If it already exists, update the routing config. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param bgp_routing_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_bgp_routing_config_with_http_info(tier_0_id, locale_service_id, bgp_routing_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.patch_bgp_routing_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.patch_bgp_routing_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.patch_bgp_routing_config"
      end
      # verify the required parameter 'bgp_routing_config' is set
      if @api_client.config.client_side_validation && bgp_routing_config.nil?
        fail ArgumentError, "Missing the required parameter 'bgp_routing_config' when calling RoutingApi.patch_bgp_routing_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(bgp_routing_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#patch_bgp_routing_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a BGP troubleshoot config
    # If BGP troubleshoot config is not present in BGP configuration, create a new BGP troubleshoot config with default value. If it already exists, update the BGP troubleshoot config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param bgp_troubleshoot_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def patch_bgp_troubleshoot_config(tier_0_id, locale_service_id, bgp_troubleshoot_config, opts = {})
      patch_bgp_troubleshoot_config_with_http_info(tier_0_id, locale_service_id, bgp_troubleshoot_config, opts)
      nil
    end

    # Create or update a BGP troubleshoot config
    # If BGP troubleshoot config is not present in BGP configuration, create a new BGP troubleshoot config with default value. If it already exists, update the BGP troubleshoot config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param bgp_troubleshoot_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_bgp_troubleshoot_config_with_http_info(tier_0_id, locale_service_id, bgp_troubleshoot_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.patch_bgp_troubleshoot_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.patch_bgp_troubleshoot_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.patch_bgp_troubleshoot_config"
      end
      # verify the required parameter 'bgp_troubleshoot_config' is set
      if @api_client.config.client_side_validation && bgp_troubleshoot_config.nil?
        fail ArgumentError, "Missing the required parameter 'bgp_troubleshoot_config' when calling RoutingApi.patch_bgp_troubleshoot_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/troubleshoot'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(bgp_troubleshoot_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#patch_bgp_troubleshoot_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a BGP community list
    # If a community list with the community-list-id is not already present, create a new community list. If it already exists, update the community list for specified attributes. 
    # @param tier_0_id 
    # @param community_list_id 
    # @param community_list 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_community_list(tier_0_id, community_list_id, community_list, opts = {})
      patch_community_list_with_http_info(tier_0_id, community_list_id, community_list, opts)
      nil
    end

    # Create or update a BGP community list
    # If a community list with the community-list-id is not already present, create a new community list. If it already exists, update the community list for specified attributes. 
    # @param tier_0_id 
    # @param community_list_id 
    # @param community_list 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_community_list_with_http_info(tier_0_id, community_list_id, community_list, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.patch_community_list ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.patch_community_list"
      end
      # verify the required parameter 'community_list_id' is set
      if @api_client.config.client_side_validation && community_list_id.nil?
        fail ArgumentError, "Missing the required parameter 'community_list_id' when calling RoutingApi.patch_community_list"
      end
      # verify the required parameter 'community_list' is set
      if @api_client.config.client_side_validation && community_list.nil?
        fail ArgumentError, "Missing the required parameter 'community_list' when calling RoutingApi.patch_community_list"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/community-lists/{community-list-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'community-list-id' + '}', community_list_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(community_list)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#patch_community_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or patch a prefix list
    # If prefix list for prefix-list-id is not already present, create a prefix list. If it already exists, patch prefix list for prefix-list-id. Note:    Patching existing prefix-list's \"prefixes\" property will overwrite the existing prefixes.    GET and PATCH is the expected set of operations to update or append new entries to the existig prefixes.    Patching existing prefixes require order to be  preserved to avoid traffic impact. During PATCH operation,    reordering of existing prefixes may impact routes and eventually datapath.    Order here is crucial and it all depends upon action. If action for every prefix is PERMIT then order may    not impact but if there is DENY prefix then change in ordering could lead to traffic impact. 
    # @param prefix_list_id 
    # @param prefix_list 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_infra_prefix_list(prefix_list_id, prefix_list, opts = {})
      patch_infra_prefix_list_with_http_info(prefix_list_id, prefix_list, opts)
      nil
    end

    # Create or patch a prefix list
    # If prefix list for prefix-list-id is not already present, create a prefix list. If it already exists, patch prefix list for prefix-list-id. Note:    Patching existing prefix-list&#39;s \&quot;prefixes\&quot; property will overwrite the existing prefixes.    GET and PATCH is the expected set of operations to update or append new entries to the existig prefixes.    Patching existing prefixes require order to be  preserved to avoid traffic impact. During PATCH operation,    reordering of existing prefixes may impact routes and eventually datapath.    Order here is crucial and it all depends upon action. If action for every prefix is PERMIT then order may    not impact but if there is DENY prefix then change in ordering could lead to traffic impact. 
    # @param prefix_list_id 
    # @param prefix_list 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_infra_prefix_list_with_http_info(prefix_list_id, prefix_list, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.patch_infra_prefix_list ...'
      end
      # verify the required parameter 'prefix_list_id' is set
      if @api_client.config.client_side_validation && prefix_list_id.nil?
        fail ArgumentError, "Missing the required parameter 'prefix_list_id' when calling RoutingApi.patch_infra_prefix_list"
      end
      # verify the required parameter 'prefix_list' is set
      if @api_client.config.client_side_validation && prefix_list.nil?
        fail ArgumentError, "Missing the required parameter 'prefix_list' when calling RoutingApi.patch_infra_prefix_list"
      end
      # resource path
      local_var_path = '/infra/routing-config/prefix-lists/{prefix-list-id}'.sub('{' + 'prefix-list-id' + '}', prefix_list_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(prefix_list)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#patch_infra_prefix_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a OSPF Area config
    # If OSPF Area config is not already present, create OSPF Area config. If it already exists, replace the OSPF Area config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param area_id 
    # @param ospf_area_config 
    # @param [Hash] opts the optional parameters
    # @return [OspfAreaConfig]
    def patch_ospf_area_config(tier_0_id, locale_service_id, area_id, ospf_area_config, opts = {})
      data, _status_code, _headers = patch_ospf_area_config_with_http_info(tier_0_id, locale_service_id, area_id, ospf_area_config, opts)
      data
    end

    # Create or update a OSPF Area config
    # If OSPF Area config is not already present, create OSPF Area config. If it already exists, replace the OSPF Area config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param area_id 
    # @param ospf_area_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(OspfAreaConfig, Fixnum, Hash)>] OspfAreaConfig data, response status code and response headers
    def patch_ospf_area_config_with_http_info(tier_0_id, locale_service_id, area_id, ospf_area_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.patch_ospf_area_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.patch_ospf_area_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.patch_ospf_area_config"
      end
      # verify the required parameter 'area_id' is set
      if @api_client.config.client_side_validation && area_id.nil?
        fail ArgumentError, "Missing the required parameter 'area_id' when calling RoutingApi.patch_ospf_area_config"
      end
      # verify the required parameter 'ospf_area_config' is set
      if @api_client.config.client_side_validation && ospf_area_config.nil?
        fail ArgumentError, "Missing the required parameter 'ospf_area_config' when calling RoutingApi.patch_ospf_area_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/ospf/areas/{area-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'area-id' + '}', area_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(ospf_area_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'OspfAreaConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#patch_ospf_area_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a OSPF routing config
    # If OSPF routing config is not already present, create OSPF routing config. If it already exists, replace the OSPF routing config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param ospf_routing_config 
    # @param [Hash] opts the optional parameters
    # @return [OspfRoutingConfig]
    def patch_ospf_routing_config(tier_0_id, locale_service_id, ospf_routing_config, opts = {})
      data, _status_code, _headers = patch_ospf_routing_config_with_http_info(tier_0_id, locale_service_id, ospf_routing_config, opts)
      data
    end

    # Create or update a OSPF routing config
    # If OSPF routing config is not already present, create OSPF routing config. If it already exists, replace the OSPF routing config with this object. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param ospf_routing_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(OspfRoutingConfig, Fixnum, Hash)>] OspfRoutingConfig data, response status code and response headers
    def patch_ospf_routing_config_with_http_info(tier_0_id, locale_service_id, ospf_routing_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.patch_ospf_routing_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.patch_ospf_routing_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.patch_ospf_routing_config"
      end
      # verify the required parameter 'ospf_routing_config' is set
      if @api_client.config.client_side_validation && ospf_routing_config.nil?
        fail ArgumentError, "Missing the required parameter 'ospf_routing_config' when calling RoutingApi.patch_ospf_routing_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/ospf'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(ospf_routing_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'OspfRoutingConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#patch_ospf_routing_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update inter-vrf routing config
    # Create or update inter-vrf routing config.
    # @param tier_0_id 
    # @param inter_vrf_routing_id 
    # @param policy_inter_vrf_routing_config 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_policy_inter_vrf_routing_config(tier_0_id, inter_vrf_routing_id, policy_inter_vrf_routing_config, opts = {})
      patch_policy_inter_vrf_routing_config_with_http_info(tier_0_id, inter_vrf_routing_id, policy_inter_vrf_routing_config, opts)
      nil
    end

    # Create or update inter-vrf routing config
    # Create or update inter-vrf routing config.
    # @param tier_0_id 
    # @param inter_vrf_routing_id 
    # @param policy_inter_vrf_routing_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_policy_inter_vrf_routing_config_with_http_info(tier_0_id, inter_vrf_routing_id, policy_inter_vrf_routing_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.patch_policy_inter_vrf_routing_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.patch_policy_inter_vrf_routing_config"
      end
      # verify the required parameter 'inter_vrf_routing_id' is set
      if @api_client.config.client_side_validation && inter_vrf_routing_id.nil?
        fail ArgumentError, "Missing the required parameter 'inter_vrf_routing_id' when calling RoutingApi.patch_policy_inter_vrf_routing_config"
      end
      # verify the required parameter 'policy_inter_vrf_routing_config' is set
      if @api_client.config.client_side_validation && policy_inter_vrf_routing_config.nil?
        fail ArgumentError, "Missing the required parameter 'policy_inter_vrf_routing_config' when calling RoutingApi.patch_policy_inter_vrf_routing_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/inter-vrf-routing/{inter-vrf-routing-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'inter-vrf-routing-id' + '}', inter_vrf_routing_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(policy_inter_vrf_routing_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#patch_policy_inter_vrf_routing_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or patch a prefix list
    # If prefix list for prefix-list-id is not already present, create a prefix list. If it already exists, patch prefix list for prefix-list-id. Note:    Patching existing prefix-list's \"prefixes\" property will overwrite the existing prefixes.    GET and PATCH is the expected set of operations to update or append new entries to the existig prefixes.    Patching existing prefixes require order to be  preserved to avoid traffic impact. During PATCH operation,    reordering of existing prefixes may impact routes and eventually datapath.    Order here is crucial and it all depends upon action. If action for every prefix is PERMIT then order may    not impact but if there is DENY prefix then change in ordering could lead to traffic impact. 
    # @param tier_0_id 
    # @param prefix_list_id 
    # @param prefix_list 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_prefix_list(tier_0_id, prefix_list_id, prefix_list, opts = {})
      patch_prefix_list_with_http_info(tier_0_id, prefix_list_id, prefix_list, opts)
      nil
    end

    # Create or patch a prefix list
    # If prefix list for prefix-list-id is not already present, create a prefix list. If it already exists, patch prefix list for prefix-list-id. Note:    Patching existing prefix-list&#39;s \&quot;prefixes\&quot; property will overwrite the existing prefixes.    GET and PATCH is the expected set of operations to update or append new entries to the existig prefixes.    Patching existing prefixes require order to be  preserved to avoid traffic impact. During PATCH operation,    reordering of existing prefixes may impact routes and eventually datapath.    Order here is crucial and it all depends upon action. If action for every prefix is PERMIT then order may    not impact but if there is DENY prefix then change in ordering could lead to traffic impact. 
    # @param tier_0_id 
    # @param prefix_list_id 
    # @param prefix_list 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_prefix_list_with_http_info(tier_0_id, prefix_list_id, prefix_list, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.patch_prefix_list ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.patch_prefix_list"
      end
      # verify the required parameter 'prefix_list_id' is set
      if @api_client.config.client_side_validation && prefix_list_id.nil?
        fail ArgumentError, "Missing the required parameter 'prefix_list_id' when calling RoutingApi.patch_prefix_list"
      end
      # verify the required parameter 'prefix_list' is set
      if @api_client.config.client_side_validation && prefix_list.nil?
        fail ArgumentError, "Missing the required parameter 'prefix_list' when calling RoutingApi.patch_prefix_list"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/prefix-lists/{prefix-list-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'prefix-list-id' + '}', prefix_list_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(prefix_list)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#patch_prefix_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or patch a route filter
    # Create or patch a route filter. This will create a mapping of projects to prefix lists. Prefix lists will be applied to all T-1 under the specified projects. 
    # @param route_filter_id 
    # @param project_route_filter 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_project_route_filter(route_filter_id, project_route_filter, opts = {})
      patch_project_route_filter_with_http_info(route_filter_id, project_route_filter, opts)
      nil
    end

    # Create or patch a route filter
    # Create or patch a route filter. This will create a mapping of projects to prefix lists. Prefix lists will be applied to all T-1 under the specified projects. 
    # @param route_filter_id 
    # @param project_route_filter 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_project_route_filter_with_http_info(route_filter_id, project_route_filter, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.patch_project_route_filter ...'
      end
      # verify the required parameter 'route_filter_id' is set
      if @api_client.config.client_side_validation && route_filter_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_filter_id' when calling RoutingApi.patch_project_route_filter"
      end
      # verify the required parameter 'project_route_filter' is set
      if @api_client.config.client_side_validation && project_route_filter.nil?
        fail ArgumentError, "Missing the required parameter 'project_route_filter' when calling RoutingApi.patch_project_route_filter"
      end
      # resource path
      local_var_path = '/infra/routing-config/project-route-filters/{route-filter-id}'.sub('{' + 'route-filter-id' + '}', route_filter_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(project_route_filter)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#patch_project_route_filter\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a route map
    # If a route map with the route-map-id is not already present, create a new route map. If it already exists, update the route map for specified attributes. 
    # @param tier_0_id 
    # @param route_map_id 
    # @param tier0_route_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_route_map(tier_0_id, route_map_id, tier0_route_map, opts = {})
      patch_route_map_with_http_info(tier_0_id, route_map_id, tier0_route_map, opts)
      nil
    end

    # Create or update a route map
    # If a route map with the route-map-id is not already present, create a new route map. If it already exists, update the route map for specified attributes. 
    # @param tier_0_id 
    # @param route_map_id 
    # @param tier0_route_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_route_map_with_http_info(tier_0_id, route_map_id, tier0_route_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.patch_route_map ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.patch_route_map"
      end
      # verify the required parameter 'route_map_id' is set
      if @api_client.config.client_side_validation && route_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_map_id' when calling RoutingApi.patch_route_map"
      end
      # verify the required parameter 'tier0_route_map' is set
      if @api_client.config.client_side_validation && tier0_route_map.nil?
        fail ArgumentError, "Missing the required parameter 'tier0_route_map' when calling RoutingApi.patch_route_map"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/route-maps/{route-map-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'route-map-id' + '}', route_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tier0_route_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#patch_route_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a StaticRouteBfdPeer
    # If a StaticRouteBfdPeer with the bfd-peer-id is not already present, create a new StaticRouteBfdPeer. If it already exists, update the StaticRouteBfdPeer. This is a full replace. 
    # @param tier_0_id Tier-0 ID
    # @param bfd_peer_id BFD peer ID
    # @param static_route_bfd_peer 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_static_route_bfd_peer(tier_0_id, bfd_peer_id, static_route_bfd_peer, opts = {})
      patch_static_route_bfd_peer_with_http_info(tier_0_id, bfd_peer_id, static_route_bfd_peer, opts)
      nil
    end

    # Create or update a StaticRouteBfdPeer
    # If a StaticRouteBfdPeer with the bfd-peer-id is not already present, create a new StaticRouteBfdPeer. If it already exists, update the StaticRouteBfdPeer. This is a full replace. 
    # @param tier_0_id Tier-0 ID
    # @param bfd_peer_id BFD peer ID
    # @param static_route_bfd_peer 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_static_route_bfd_peer_with_http_info(tier_0_id, bfd_peer_id, static_route_bfd_peer, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.patch_static_route_bfd_peer ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.patch_static_route_bfd_peer"
      end
      # verify the required parameter 'bfd_peer_id' is set
      if @api_client.config.client_side_validation && bfd_peer_id.nil?
        fail ArgumentError, "Missing the required parameter 'bfd_peer_id' when calling RoutingApi.patch_static_route_bfd_peer"
      end
      # verify the required parameter 'static_route_bfd_peer' is set
      if @api_client.config.client_side_validation && static_route_bfd_peer.nil?
        fail ArgumentError, "Missing the required parameter 'static_route_bfd_peer' when calling RoutingApi.patch_static_route_bfd_peer"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/static-routes/bfd-peers/{bfd-peer-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'bfd-peer-id' + '}', bfd_peer_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(static_route_bfd_peer)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#patch_static_route_bfd_peer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a StaticRouteBfdTroubleshootConfig
    # If a StaticRouteBfdTroubleshootConfig is not already present, create a new StaticRouteBfdTroubleshootConfig. If it already exists, update the StaticRouteBfdTroubleshootConfig. This is a full replace. 
    # @param tier_0_id Tier-0 ID
    # @param static_route_bfd_troubleshoot_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def patch_static_route_bfd_troubleshoot_config(tier_0_id, static_route_bfd_troubleshoot_config, opts = {})
      patch_static_route_bfd_troubleshoot_config_with_http_info(tier_0_id, static_route_bfd_troubleshoot_config, opts)
      nil
    end

    # Create or update a StaticRouteBfdTroubleshootConfig
    # If a StaticRouteBfdTroubleshootConfig is not already present, create a new StaticRouteBfdTroubleshootConfig. If it already exists, update the StaticRouteBfdTroubleshootConfig. This is a full replace. 
    # @param tier_0_id Tier-0 ID
    # @param static_route_bfd_troubleshoot_config 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_static_route_bfd_troubleshoot_config_with_http_info(tier_0_id, static_route_bfd_troubleshoot_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.patch_static_route_bfd_troubleshoot_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.patch_static_route_bfd_troubleshoot_config"
      end
      # verify the required parameter 'static_route_bfd_troubleshoot_config' is set
      if @api_client.config.client_side_validation && static_route_bfd_troubleshoot_config.nil?
        fail ArgumentError, "Missing the required parameter 'static_route_bfd_troubleshoot_config' when calling RoutingApi.patch_static_route_bfd_troubleshoot_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/static-routes/bfd-peers/troubleshoot'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(static_route_bfd_troubleshoot_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#patch_static_route_bfd_troubleshoot_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a Tier-0 static routes
    # If static routes for route-id are not already present, create static routes. If it already exists, update static routes for route-id. 
    # @param tier_0_id 
    # @param route_id 
    # @param static_routes 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_tier0_static_routes(tier_0_id, route_id, static_routes, opts = {})
      patch_tier0_static_routes_with_http_info(tier_0_id, route_id, static_routes, opts)
      nil
    end

    # Create or update a Tier-0 static routes
    # If static routes for route-id are not already present, create static routes. If it already exists, update static routes for route-id. 
    # @param tier_0_id 
    # @param route_id 
    # @param static_routes 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_tier0_static_routes_with_http_info(tier_0_id, route_id, static_routes, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.patch_tier0_static_routes ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.patch_tier0_static_routes"
      end
      # verify the required parameter 'route_id' is set
      if @api_client.config.client_side_validation && route_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_id' when calling RoutingApi.patch_tier0_static_routes"
      end
      # verify the required parameter 'static_routes' is set
      if @api_client.config.client_side_validation && static_routes.nil?
        fail ArgumentError, "Missing the required parameter 'static_routes' when calling RoutingApi.patch_tier0_static_routes"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/static-routes/{route-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'route-id' + '}', route_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(static_routes)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#patch_tier0_static_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a Tier-1 static routes
    # If static routes for route-id are not already present, create static routes. If it already exists, update static routes for route-id. 
    # @param tier_1_id 
    # @param route_id 
    # @param static_routes 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_tier1_static_routes(tier_1_id, route_id, static_routes, opts = {})
      patch_tier1_static_routes_with_http_info(tier_1_id, route_id, static_routes, opts)
      nil
    end

    # Create or update a Tier-1 static routes
    # If static routes for route-id are not already present, create static routes. If it already exists, update static routes for route-id. 
    # @param tier_1_id 
    # @param route_id 
    # @param static_routes 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_tier1_static_routes_with_http_info(tier_1_id, route_id, static_routes, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.patch_tier1_static_routes ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.patch_tier1_static_routes"
      end
      # verify the required parameter 'route_id' is set
      if @api_client.config.client_side_validation && route_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_id' when calling RoutingApi.patch_tier1_static_routes"
      end
      # verify the required parameter 'static_routes' is set
      if @api_client.config.client_side_validation && static_routes.nil?
        fail ArgumentError, "Missing the required parameter 'static_routes' when calling RoutingApi.patch_tier1_static_routes"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/static-routes/{route-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'route-id' + '}', route_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(static_routes)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#patch_tier1_static_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update project route filter
    # Create or update a route filter 
    # @param route_filter_id 
    # @param project_route_filter 
    # @param [Hash] opts the optional parameters
    # @return [ProjectRouteFilter]
    def put_project_route_filter(route_filter_id, project_route_filter, opts = {})
      data, _status_code, _headers = put_project_route_filter_with_http_info(route_filter_id, project_route_filter, opts)
      data
    end

    # Create or update project route filter
    # Create or update a route filter 
    # @param route_filter_id 
    # @param project_route_filter 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ProjectRouteFilter, Fixnum, Hash)>] ProjectRouteFilter data, response status code and response headers
    def put_project_route_filter_with_http_info(route_filter_id, project_route_filter, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.put_project_route_filter ...'
      end
      # verify the required parameter 'route_filter_id' is set
      if @api_client.config.client_side_validation && route_filter_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_filter_id' when calling RoutingApi.put_project_route_filter"
      end
      # verify the required parameter 'project_route_filter' is set
      if @api_client.config.client_side_validation && project_route_filter.nil?
        fail ArgumentError, "Missing the required parameter 'project_route_filter' when calling RoutingApi.put_project_route_filter"
      end
      # resource path
      local_var_path = '/infra/routing-config/project-route-filters/{route-filter-id}'.sub('{' + 'route-filter-id' + '}', route_filter_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(project_route_filter)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ProjectRouteFilter')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#put_project_route_filter\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read BGP neighbor config
    # Read BGP neighbor config
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @return [BgpNeighborConfig]
    def read_bgp_neighbor_config(tier_0_id, locale_service_id, neighbor_id, opts = {})
      data, _status_code, _headers = read_bgp_neighbor_config_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts)
      data
    end

    # Read BGP neighbor config
    # Read BGP neighbor config
    # @param tier_0_id 
    # @param locale_service_id 
    # @param neighbor_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BgpNeighborConfig, Fixnum, Hash)>] BgpNeighborConfig data, response status code and response headers
    def read_bgp_neighbor_config_with_http_info(tier_0_id, locale_service_id, neighbor_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.read_bgp_neighbor_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.read_bgp_neighbor_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.read_bgp_neighbor_config"
      end
      # verify the required parameter 'neighbor_id' is set
      if @api_client.config.client_side_validation && neighbor_id.nil?
        fail ArgumentError, "Missing the required parameter 'neighbor_id' when calling RoutingApi.read_bgp_neighbor_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/neighbors/{neighbor-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'neighbor-id' + '}', neighbor_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpNeighborConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#read_bgp_neighbor_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read BGP routing config
    # Read BGP routing config
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @return [BgpRoutingConfig]
    def read_bgp_routing_config(tier_0_id, locale_service_id, opts = {})
      data, _status_code, _headers = read_bgp_routing_config_with_http_info(tier_0_id, locale_service_id, opts)
      data
    end

    # Read BGP routing config
    # Read BGP routing config
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BgpRoutingConfig, Fixnum, Hash)>] BgpRoutingConfig data, response status code and response headers
    def read_bgp_routing_config_with_http_info(tier_0_id, locale_service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.read_bgp_routing_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.read_bgp_routing_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.read_bgp_routing_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpRoutingConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#read_bgp_routing_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read BGP troubleshoot config
    # Read BGP troubleshoot config
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @return [BgpTroubleshootConfig]
    def read_bgp_troubleshoot_config(tier_0_id, locale_service_id, opts = {})
      data, _status_code, _headers = read_bgp_troubleshoot_config_with_http_info(tier_0_id, locale_service_id, opts)
      data
    end

    # Read BGP troubleshoot config
    # Read BGP troubleshoot config
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(BgpTroubleshootConfig, Fixnum, Hash)>] BgpTroubleshootConfig data, response status code and response headers
    def read_bgp_troubleshoot_config_with_http_info(tier_0_id, locale_service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.read_bgp_troubleshoot_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.read_bgp_troubleshoot_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.read_bgp_troubleshoot_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/bgp/troubleshoot'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BgpTroubleshootConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#read_bgp_troubleshoot_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read a BGP community list
    # Read a BGP community list
    # @param tier_0_id 
    # @param community_list_id 
    # @param [Hash] opts the optional parameters
    # @return [CommunityList]
    def read_community_list(tier_0_id, community_list_id, opts = {})
      data, _status_code, _headers = read_community_list_with_http_info(tier_0_id, community_list_id, opts)
      data
    end

    # Read a BGP community list
    # Read a BGP community list
    # @param tier_0_id 
    # @param community_list_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(CommunityList, Fixnum, Hash)>] CommunityList data, response status code and response headers
    def read_community_list_with_http_info(tier_0_id, community_list_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.read_community_list ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.read_community_list"
      end
      # verify the required parameter 'community_list_id' is set
      if @api_client.config.client_side_validation && community_list_id.nil?
        fail ArgumentError, "Missing the required parameter 'community_list_id' when calling RoutingApi.read_community_list"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/community-lists/{community-list-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'community-list-id' + '}', community_list_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'CommunityList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#read_community_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read a prefix list
    # Read a prefix list
    # @param prefix_list_id 
    # @param [Hash] opts the optional parameters
    # @return [PrefixList]
    def read_infra_prefix_list(prefix_list_id, opts = {})
      data, _status_code, _headers = read_infra_prefix_list_with_http_info(prefix_list_id, opts)
      data
    end

    # Read a prefix list
    # Read a prefix list
    # @param prefix_list_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PrefixList, Fixnum, Hash)>] PrefixList data, response status code and response headers
    def read_infra_prefix_list_with_http_info(prefix_list_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.read_infra_prefix_list ...'
      end
      # verify the required parameter 'prefix_list_id' is set
      if @api_client.config.client_side_validation && prefix_list_id.nil?
        fail ArgumentError, "Missing the required parameter 'prefix_list_id' when calling RoutingApi.read_infra_prefix_list"
      end
      # resource path
      local_var_path = '/infra/routing-config/prefix-lists/{prefix-list-id}'.sub('{' + 'prefix-list-id' + '}', prefix_list_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PrefixList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#read_infra_prefix_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read OSPF Area config
    # Read OSPF Area config 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param area_id 
    # @param [Hash] opts the optional parameters
    # @return [OspfAreaConfig]
    def read_ospf_area_config(tier_0_id, locale_service_id, area_id, opts = {})
      data, _status_code, _headers = read_ospf_area_config_with_http_info(tier_0_id, locale_service_id, area_id, opts)
      data
    end

    # Read OSPF Area config
    # Read OSPF Area config 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param area_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(OspfAreaConfig, Fixnum, Hash)>] OspfAreaConfig data, response status code and response headers
    def read_ospf_area_config_with_http_info(tier_0_id, locale_service_id, area_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.read_ospf_area_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.read_ospf_area_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.read_ospf_area_config"
      end
      # verify the required parameter 'area_id' is set
      if @api_client.config.client_side_validation && area_id.nil?
        fail ArgumentError, "Missing the required parameter 'area_id' when calling RoutingApi.read_ospf_area_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/ospf/areas/{area-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'area-id' + '}', area_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'OspfAreaConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#read_ospf_area_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read OSPF routing config
    # Read OSPF routing config 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @return [OspfRoutingConfig]
    def read_ospf_routing_config(tier_0_id, locale_service_id, opts = {})
      data, _status_code, _headers = read_ospf_routing_config_with_http_info(tier_0_id, locale_service_id, opts)
      data
    end

    # Read OSPF routing config
    # Read OSPF routing config 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(OspfRoutingConfig, Fixnum, Hash)>] OspfRoutingConfig data, response status code and response headers
    def read_ospf_routing_config_with_http_info(tier_0_id, locale_service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.read_ospf_routing_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.read_ospf_routing_config"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling RoutingApi.read_ospf_routing_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/ospf'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'OspfRoutingConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#read_ospf_routing_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read inter-vrf routing config
    # Read inter-vrf routing config.
    # @param tier_0_id 
    # @param inter_vrf_routing_id 
    # @param [Hash] opts the optional parameters
    # @return [PolicyInterVrfRoutingConfig]
    def read_policy_inter_vrf_routing_config(tier_0_id, inter_vrf_routing_id, opts = {})
      data, _status_code, _headers = read_policy_inter_vrf_routing_config_with_http_info(tier_0_id, inter_vrf_routing_id, opts)
      data
    end

    # Read inter-vrf routing config
    # Read inter-vrf routing config.
    # @param tier_0_id 
    # @param inter_vrf_routing_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PolicyInterVrfRoutingConfig, Fixnum, Hash)>] PolicyInterVrfRoutingConfig data, response status code and response headers
    def read_policy_inter_vrf_routing_config_with_http_info(tier_0_id, inter_vrf_routing_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.read_policy_inter_vrf_routing_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.read_policy_inter_vrf_routing_config"
      end
      # verify the required parameter 'inter_vrf_routing_id' is set
      if @api_client.config.client_side_validation && inter_vrf_routing_id.nil?
        fail ArgumentError, "Missing the required parameter 'inter_vrf_routing_id' when calling RoutingApi.read_policy_inter_vrf_routing_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/inter-vrf-routing/{inter-vrf-routing-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'inter-vrf-routing-id' + '}', inter_vrf_routing_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyInterVrfRoutingConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#read_policy_inter_vrf_routing_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read a prefix list
    # Read a prefix list
    # @param tier_0_id 
    # @param prefix_list_id 
    # @param [Hash] opts the optional parameters
    # @return [PrefixList]
    def read_prefix_list(tier_0_id, prefix_list_id, opts = {})
      data, _status_code, _headers = read_prefix_list_with_http_info(tier_0_id, prefix_list_id, opts)
      data
    end

    # Read a prefix list
    # Read a prefix list
    # @param tier_0_id 
    # @param prefix_list_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PrefixList, Fixnum, Hash)>] PrefixList data, response status code and response headers
    def read_prefix_list_with_http_info(tier_0_id, prefix_list_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.read_prefix_list ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.read_prefix_list"
      end
      # verify the required parameter 'prefix_list_id' is set
      if @api_client.config.client_side_validation && prefix_list_id.nil?
        fail ArgumentError, "Missing the required parameter 'prefix_list_id' when calling RoutingApi.read_prefix_list"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/prefix-lists/{prefix-list-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'prefix-list-id' + '}', prefix_list_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PrefixList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#read_prefix_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read a project route filter
    # Read a project route filter
    # @param route_filter_id 
    # @param [Hash] opts the optional parameters
    # @return [ProjectRouteFilter]
    def read_project_route_filter(route_filter_id, opts = {})
      data, _status_code, _headers = read_project_route_filter_with_http_info(route_filter_id, opts)
      data
    end

    # Read a project route filter
    # Read a project route filter
    # @param route_filter_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ProjectRouteFilter, Fixnum, Hash)>] ProjectRouteFilter data, response status code and response headers
    def read_project_route_filter_with_http_info(route_filter_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.read_project_route_filter ...'
      end
      # verify the required parameter 'route_filter_id' is set
      if @api_client.config.client_side_validation && route_filter_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_filter_id' when calling RoutingApi.read_project_route_filter"
      end
      # resource path
      local_var_path = '/infra/routing-config/project-route-filters/{route-filter-id}'.sub('{' + 'route-filter-id' + '}', route_filter_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ProjectRouteFilter')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#read_project_route_filter\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read a StaticRouteBfdPeer
    # Read a StaticRouteBfdPeer with the bfd-peer-id. 
    # @param tier_0_id Tier-0 ID
    # @param bfd_peer_id BFD peer ID
    # @param [Hash] opts the optional parameters
    # @return [StaticRouteBfdPeer]
    def read_static_route_bfd_peer(tier_0_id, bfd_peer_id, opts = {})
      data, _status_code, _headers = read_static_route_bfd_peer_with_http_info(tier_0_id, bfd_peer_id, opts)
      data
    end

    # Read a StaticRouteBfdPeer
    # Read a StaticRouteBfdPeer with the bfd-peer-id. 
    # @param tier_0_id Tier-0 ID
    # @param bfd_peer_id BFD peer ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(StaticRouteBfdPeer, Fixnum, Hash)>] StaticRouteBfdPeer data, response status code and response headers
    def read_static_route_bfd_peer_with_http_info(tier_0_id, bfd_peer_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.read_static_route_bfd_peer ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.read_static_route_bfd_peer"
      end
      # verify the required parameter 'bfd_peer_id' is set
      if @api_client.config.client_side_validation && bfd_peer_id.nil?
        fail ArgumentError, "Missing the required parameter 'bfd_peer_id' when calling RoutingApi.read_static_route_bfd_peer"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/static-routes/bfd-peers/{bfd-peer-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'bfd-peer-id' + '}', bfd_peer_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRouteBfdPeer')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#read_static_route_bfd_peer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read a StaticRouteBfdTroubleshootConfig
    # Read a StaticRouteBfdTroubleshootConfig 
    # @param tier_0_id Tier-0 ID
    # @param [Hash] opts the optional parameters
    # @return [StaticRouteBfdTroubleshootConfig]
    def read_static_route_bfd_troubleshoot_config(tier_0_id, opts = {})
      data, _status_code, _headers = read_static_route_bfd_troubleshoot_config_with_http_info(tier_0_id, opts)
      data
    end

    # Read a StaticRouteBfdTroubleshootConfig
    # Read a StaticRouteBfdTroubleshootConfig 
    # @param tier_0_id Tier-0 ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(StaticRouteBfdTroubleshootConfig, Fixnum, Hash)>] StaticRouteBfdTroubleshootConfig data, response status code and response headers
    def read_static_route_bfd_troubleshoot_config_with_http_info(tier_0_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.read_static_route_bfd_troubleshoot_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.read_static_route_bfd_troubleshoot_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/static-routes/bfd-peers/troubleshoot'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRouteBfdTroubleshootConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#read_static_route_bfd_troubleshoot_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read Tier-0 static routes
    # Read Tier-0 static routes
    # @param tier_0_id 
    # @param route_id 
    # @param [Hash] opts the optional parameters
    # @return [StaticRoutes]
    def read_tier0_static_routes(tier_0_id, route_id, opts = {})
      data, _status_code, _headers = read_tier0_static_routes_with_http_info(tier_0_id, route_id, opts)
      data
    end

    # Read Tier-0 static routes
    # Read Tier-0 static routes
    # @param tier_0_id 
    # @param route_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(StaticRoutes, Fixnum, Hash)>] StaticRoutes data, response status code and response headers
    def read_tier0_static_routes_with_http_info(tier_0_id, route_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.read_tier0_static_routes ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.read_tier0_static_routes"
      end
      # verify the required parameter 'route_id' is set
      if @api_client.config.client_side_validation && route_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_id' when calling RoutingApi.read_tier0_static_routes"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/static-routes/{route-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'route-id' + '}', route_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRoutes')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#read_tier0_static_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read Tier-1 static routes
    # Read Tier-1 static routes
    # @param tier_1_id 
    # @param route_id 
    # @param [Hash] opts the optional parameters
    # @return [StaticRoutes]
    def read_tier1_static_routes(tier_1_id, route_id, opts = {})
      data, _status_code, _headers = read_tier1_static_routes_with_http_info(tier_1_id, route_id, opts)
      data
    end

    # Read Tier-1 static routes
    # Read Tier-1 static routes
    # @param tier_1_id 
    # @param route_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(StaticRoutes, Fixnum, Hash)>] StaticRoutes data, response status code and response headers
    def read_tier1_static_routes_with_http_info(tier_1_id, route_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.read_tier1_static_routes ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling RoutingApi.read_tier1_static_routes"
      end
      # verify the required parameter 'route_id' is set
      if @api_client.config.client_side_validation && route_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_id' when calling RoutingApi.read_tier1_static_routes"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/static-routes/{route-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'route-id' + '}', route_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRoutes')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#read_tier1_static_routes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a route map
    # Delete a route map
    # @param tier_0_id 
    # @param route_map_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def remove_route_map(tier_0_id, route_map_id, opts = {})
      remove_route_map_with_http_info(tier_0_id, route_map_id, opts)
      nil
    end

    # Delete a route map
    # Delete a route map
    # @param tier_0_id 
    # @param route_map_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def remove_route_map_with_http_info(tier_0_id, route_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.remove_route_map ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.remove_route_map"
      end
      # verify the required parameter 'route_map_id' is set
      if @api_client.config.client_side_validation && route_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'route_map_id' when calling RoutingApi.remove_route_map"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/route-maps/{route-map-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'route-map-id' + '}', route_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#remove_route_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update inter-vrf routing config
    # Create or update inter-vrf routing config.
    # @param tier_0_id 
    # @param inter_vrf_routing_id 
    # @param policy_inter_vrf_routing_config 
    # @param [Hash] opts the optional parameters
    # @return [PolicyInterVrfRoutingConfig]
    def update_policy_inter_vrf_routing_config(tier_0_id, inter_vrf_routing_id, policy_inter_vrf_routing_config, opts = {})
      data, _status_code, _headers = update_policy_inter_vrf_routing_config_with_http_info(tier_0_id, inter_vrf_routing_id, policy_inter_vrf_routing_config, opts)
      data
    end

    # Create or update inter-vrf routing config
    # Create or update inter-vrf routing config.
    # @param tier_0_id 
    # @param inter_vrf_routing_id 
    # @param policy_inter_vrf_routing_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PolicyInterVrfRoutingConfig, Fixnum, Hash)>] PolicyInterVrfRoutingConfig data, response status code and response headers
    def update_policy_inter_vrf_routing_config_with_http_info(tier_0_id, inter_vrf_routing_id, policy_inter_vrf_routing_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.update_policy_inter_vrf_routing_config ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.update_policy_inter_vrf_routing_config"
      end
      # verify the required parameter 'inter_vrf_routing_id' is set
      if @api_client.config.client_side_validation && inter_vrf_routing_id.nil?
        fail ArgumentError, "Missing the required parameter 'inter_vrf_routing_id' when calling RoutingApi.update_policy_inter_vrf_routing_config"
      end
      # verify the required parameter 'policy_inter_vrf_routing_config' is set
      if @api_client.config.client_side_validation && policy_inter_vrf_routing_config.nil?
        fail ArgumentError, "Missing the required parameter 'policy_inter_vrf_routing_config' when calling RoutingApi.update_policy_inter_vrf_routing_config"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/inter-vrf-routing/{inter-vrf-routing-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'inter-vrf-routing-id' + '}', inter_vrf_routing_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(policy_inter_vrf_routing_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyInterVrfRoutingConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#update_policy_inter_vrf_routing_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a StaticRouteBfdPeer
    # If a StaticRouteBfdPeer with the bfd-peer-id is not already present, create a new StaticRouteBfdPeer. If it already exists, update the StaticRouteBfdPeer. This operation will fully replace the object. 
    # @param tier_0_id Tier-0 ID
    # @param bfd_peer_id BFD peer ID
    # @param static_route_bfd_peer 
    # @param [Hash] opts the optional parameters
    # @return [StaticRouteBfdPeer]
    def update_static_route_bfd_peer(tier_0_id, bfd_peer_id, static_route_bfd_peer, opts = {})
      data, _status_code, _headers = update_static_route_bfd_peer_with_http_info(tier_0_id, bfd_peer_id, static_route_bfd_peer, opts)
      data
    end

    # Create or update a StaticRouteBfdPeer
    # If a StaticRouteBfdPeer with the bfd-peer-id is not already present, create a new StaticRouteBfdPeer. If it already exists, update the StaticRouteBfdPeer. This operation will fully replace the object. 
    # @param tier_0_id Tier-0 ID
    # @param bfd_peer_id BFD peer ID
    # @param static_route_bfd_peer 
    # @param [Hash] opts the optional parameters
    # @return [Array<(StaticRouteBfdPeer, Fixnum, Hash)>] StaticRouteBfdPeer data, response status code and response headers
    def update_static_route_bfd_peer_with_http_info(tier_0_id, bfd_peer_id, static_route_bfd_peer, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RoutingApi.update_static_route_bfd_peer ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling RoutingApi.update_static_route_bfd_peer"
      end
      # verify the required parameter 'bfd_peer_id' is set
      if @api_client.config.client_side_validation && bfd_peer_id.nil?
        fail ArgumentError, "Missing the required parameter 'bfd_peer_id' when calling RoutingApi.update_static_route_bfd_peer"
      end
      # verify the required parameter 'static_route_bfd_peer' is set
      if @api_client.config.client_side_validation && static_route_bfd_peer.nil?
        fail ArgumentError, "Missing the required parameter 'static_route_bfd_peer' when calling RoutingApi.update_static_route_bfd_peer"
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/static-routes/bfd-peers/{bfd-peer-id}'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'bfd-peer-id' + '}', bfd_peer_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(static_route_bfd_peer)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticRouteBfdPeer')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RoutingApi#update_static_route_bfd_peer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
