=begin
#NSX Policy API

#VMware NSX Policy REST API

OpenAPI spec version: 9.0.0.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.4.46

=end

require 'uri'

module Nsxt9PolicyClient
  class CertificatesApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Adds or updates a CA bundle
    # Adds or updates a new bundle of trusted CA certificates. The bundle must be a concatenation of one or more PEM-encoded certificates. The PEM-encoded bundle is replaced with the one provided in the request. 
    # @param cabundle_id ID of the CA bundle being updated
    # @param ca_bundle 
    # @param [Hash] opts the optional parameters
    # @return [CaBundle]
    def add_or_patch_ca_bundle(cabundle_id, ca_bundle, opts = {})
      data, _status_code, _headers = add_or_patch_ca_bundle_with_http_info(cabundle_id, ca_bundle, opts)
      data
    end

    # Adds or updates a CA bundle
    # Adds or updates a new bundle of trusted CA certificates. The bundle must be a concatenation of one or more PEM-encoded certificates. The PEM-encoded bundle is replaced with the one provided in the request. 
    # @param cabundle_id ID of the CA bundle being updated
    # @param ca_bundle 
    # @param [Hash] opts the optional parameters
    # @return [Array<(CaBundle, Fixnum, Hash)>] CaBundle data, response status code and response headers
    def add_or_patch_ca_bundle_with_http_info(cabundle_id, ca_bundle, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.add_or_patch_ca_bundle ...'
      end
      # verify the required parameter 'cabundle_id' is set
      if @api_client.config.client_side_validation && cabundle_id.nil?
        fail ArgumentError, "Missing the required parameter 'cabundle_id' when calling CertificatesApi.add_or_patch_ca_bundle"
      end
      # verify the required parameter 'ca_bundle' is set
      if @api_client.config.client_side_validation && ca_bundle.nil?
        fail ArgumentError, "Missing the required parameter 'ca_bundle' when calling CertificatesApi.add_or_patch_ca_bundle"
      end
      # resource path
      local_var_path = '/infra/cabundles/{cabundle-id}'.sub('{' + 'cabundle-id' + '}', cabundle_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(ca_bundle)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'CaBundle')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#add_or_patch_ca_bundle\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Adds or updates a CA bundle
    # Adds or updates a new bundle of trusted CA certificates. The bundle must be a concatenation of one or more PEM-encoded certificates. The PEM-encoded bundle is replaced with the one provided in the request. 
    # @param cabundle_id ID of the CA bundle being updated
    # @param ca_bundle 
    # @param [Hash] opts the optional parameters
    # @return [CaBundle]
    def add_or_patch_ca_bundle_0(cabundle_id, ca_bundle, opts = {})
      data, _status_code, _headers = add_or_patch_ca_bundle_0_with_http_info(cabundle_id, ca_bundle, opts)
      data
    end

    # Adds or updates a CA bundle
    # Adds or updates a new bundle of trusted CA certificates. The bundle must be a concatenation of one or more PEM-encoded certificates. The PEM-encoded bundle is replaced with the one provided in the request. 
    # @param cabundle_id ID of the CA bundle being updated
    # @param ca_bundle 
    # @param [Hash] opts the optional parameters
    # @return [Array<(CaBundle, Fixnum, Hash)>] CaBundle data, response status code and response headers
    def add_or_patch_ca_bundle_0_with_http_info(cabundle_id, ca_bundle, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.add_or_patch_ca_bundle_0 ...'
      end
      # verify the required parameter 'cabundle_id' is set
      if @api_client.config.client_side_validation && cabundle_id.nil?
        fail ArgumentError, "Missing the required parameter 'cabundle_id' when calling CertificatesApi.add_or_patch_ca_bundle_0"
      end
      # verify the required parameter 'ca_bundle' is set
      if @api_client.config.client_side_validation && ca_bundle.nil?
        fail ArgumentError, "Missing the required parameter 'ca_bundle' when calling CertificatesApi.add_or_patch_ca_bundle_0"
      end
      # resource path
      local_var_path = '/infra/cabundles/{cabundle-id}'.sub('{' + 'cabundle-id' + '}', cabundle_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(ca_bundle)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'CaBundle')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#add_or_patch_ca_bundle_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Adds or replaces a CA bundle
    # Adds or replaces a new bundle of trusted CA certificates. The bundle must be a concatenation of one or more PEM-encoded certificates. 
    # @param cabundle_id ID of the CA bundle being uploaded
    # @param ca_bundle 
    # @param [Hash] opts the optional parameters
    # @return [CaBundle]
    def add_or_replace_ca_bundle(cabundle_id, ca_bundle, opts = {})
      data, _status_code, _headers = add_or_replace_ca_bundle_with_http_info(cabundle_id, ca_bundle, opts)
      data
    end

    # Adds or replaces a CA bundle
    # Adds or replaces a new bundle of trusted CA certificates. The bundle must be a concatenation of one or more PEM-encoded certificates. 
    # @param cabundle_id ID of the CA bundle being uploaded
    # @param ca_bundle 
    # @param [Hash] opts the optional parameters
    # @return [Array<(CaBundle, Fixnum, Hash)>] CaBundle data, response status code and response headers
    def add_or_replace_ca_bundle_with_http_info(cabundle_id, ca_bundle, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.add_or_replace_ca_bundle ...'
      end
      # verify the required parameter 'cabundle_id' is set
      if @api_client.config.client_side_validation && cabundle_id.nil?
        fail ArgumentError, "Missing the required parameter 'cabundle_id' when calling CertificatesApi.add_or_replace_ca_bundle"
      end
      # verify the required parameter 'ca_bundle' is set
      if @api_client.config.client_side_validation && ca_bundle.nil?
        fail ArgumentError, "Missing the required parameter 'ca_bundle' when calling CertificatesApi.add_or_replace_ca_bundle"
      end
      # resource path
      local_var_path = '/infra/cabundles/{cabundle-id}'.sub('{' + 'cabundle-id' + '}', cabundle_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(ca_bundle)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'CaBundle')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#add_or_replace_ca_bundle\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Adds or replaces a CA bundle
    # Adds or replaces a new bundle of trusted CA certificates. The bundle must be a concatenation of one or more PEM-encoded certificates. 
    # @param cabundle_id ID of the CA bundle being uploaded
    # @param ca_bundle 
    # @param [Hash] opts the optional parameters
    # @return [CaBundle]
    def add_or_replace_ca_bundle_0(cabundle_id, ca_bundle, opts = {})
      data, _status_code, _headers = add_or_replace_ca_bundle_0_with_http_info(cabundle_id, ca_bundle, opts)
      data
    end

    # Adds or replaces a CA bundle
    # Adds or replaces a new bundle of trusted CA certificates. The bundle must be a concatenation of one or more PEM-encoded certificates. 
    # @param cabundle_id ID of the CA bundle being uploaded
    # @param ca_bundle 
    # @param [Hash] opts the optional parameters
    # @return [Array<(CaBundle, Fixnum, Hash)>] CaBundle data, response status code and response headers
    def add_or_replace_ca_bundle_0_with_http_info(cabundle_id, ca_bundle, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.add_or_replace_ca_bundle_0 ...'
      end
      # verify the required parameter 'cabundle_id' is set
      if @api_client.config.client_side_validation && cabundle_id.nil?
        fail ArgumentError, "Missing the required parameter 'cabundle_id' when calling CertificatesApi.add_or_replace_ca_bundle_0"
      end
      # verify the required parameter 'ca_bundle' is set
      if @api_client.config.client_side_validation && ca_bundle.nil?
        fail ArgumentError, "Missing the required parameter 'ca_bundle' when calling CertificatesApi.add_or_replace_ca_bundle_0"
      end
      # resource path
      local_var_path = '/infra/cabundles/{cabundle-id}'.sub('{' + 'cabundle-id' + '}', cabundle_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(ca_bundle)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'CaBundle')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#add_or_replace_ca_bundle_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Adds or replaces a CA bundle
    # Adds or replaces a new bundle of trusted CA certificates. The multipart-uploaded file must be a concatenation of one or more PEM-encoded certificates. 
    # @param cabundle_id ID of the CA bundle being uploaded
    # @param file File to be uploaded
    # @param [Hash] opts the optional parameters
    # @option opts [String] :description Description of this resource
    # @option opts [String] :display_name Identifier to use when displaying entity in logs or GUI
    # @return [CaBundle]
    def add_or_replace_ca_bundle_upload(cabundle_id, file, opts = {})
      data, _status_code, _headers = add_or_replace_ca_bundle_upload_with_http_info(cabundle_id, file, opts)
      data
    end

    # Adds or replaces a CA bundle
    # Adds or replaces a new bundle of trusted CA certificates. The multipart-uploaded file must be a concatenation of one or more PEM-encoded certificates. 
    # @param cabundle_id ID of the CA bundle being uploaded
    # @param file File to be uploaded
    # @param [Hash] opts the optional parameters
    # @option opts [String] :description Description of this resource
    # @option opts [String] :display_name Identifier to use when displaying entity in logs or GUI
    # @return [Array<(CaBundle, Fixnum, Hash)>] CaBundle data, response status code and response headers
    def add_or_replace_ca_bundle_upload_with_http_info(cabundle_id, file, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.add_or_replace_ca_bundle_upload ...'
      end
      # verify the required parameter 'cabundle_id' is set
      if @api_client.config.client_side_validation && cabundle_id.nil?
        fail ArgumentError, "Missing the required parameter 'cabundle_id' when calling CertificatesApi.add_or_replace_ca_bundle_upload"
      end
      # verify the required parameter 'file' is set
      if @api_client.config.client_side_validation && file.nil?
        fail ArgumentError, "Missing the required parameter 'file' when calling CertificatesApi.add_or_replace_ca_bundle_upload"
      end
      if @api_client.config.client_side_validation && !opts[:'description'].nil? && opts[:'description'].to_s.length > 1024
        fail ArgumentError, 'invalid value for "opts[:"description"]" when calling CertificatesApi.add_or_replace_ca_bundle_upload, the character length must be smaller than or equal to 1024.'
      end

      if @api_client.config.client_side_validation && !opts[:'display_name'].nil? && opts[:'display_name'].to_s.length > 255
        fail ArgumentError, 'invalid value for "opts[:"display_name"]" when calling CertificatesApi.add_or_replace_ca_bundle_upload, the character length must be smaller than or equal to 255.'
      end

      # resource path
      local_var_path = '/infra/cabundles/{cabundle-id}'.sub('{' + 'cabundle-id' + '}', cabundle_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'description'] = opts[:'description'] if !opts[:'description'].nil?
      query_params[:'display_name'] = opts[:'display_name'] if !opts[:'display_name'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['multipart/form-data'])

      # form parameters
      form_params = {}
      form_params['file'] = file

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'CaBundle')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#add_or_replace_ca_bundle_upload\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Adds or replaces a CA bundle
    # Adds or replaces a new bundle of trusted CA certificates. The multipart-uploaded file must be a concatenation of one or more PEM-encoded certificates. 
    # @param cabundle_id ID of the CA bundle being uploaded
    # @param file File to be uploaded
    # @param [Hash] opts the optional parameters
    # @option opts [String] :description Description of this resource
    # @option opts [String] :display_name Identifier to use when displaying entity in logs or GUI
    # @return [CaBundle]
    def add_or_replace_ca_bundle_upload_0(cabundle_id, file, opts = {})
      data, _status_code, _headers = add_or_replace_ca_bundle_upload_0_with_http_info(cabundle_id, file, opts)
      data
    end

    # Adds or replaces a CA bundle
    # Adds or replaces a new bundle of trusted CA certificates. The multipart-uploaded file must be a concatenation of one or more PEM-encoded certificates. 
    # @param cabundle_id ID of the CA bundle being uploaded
    # @param file File to be uploaded
    # @param [Hash] opts the optional parameters
    # @option opts [String] :description Description of this resource
    # @option opts [String] :display_name Identifier to use when displaying entity in logs or GUI
    # @return [Array<(CaBundle, Fixnum, Hash)>] CaBundle data, response status code and response headers
    def add_or_replace_ca_bundle_upload_0_with_http_info(cabundle_id, file, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.add_or_replace_ca_bundle_upload_0 ...'
      end
      # verify the required parameter 'cabundle_id' is set
      if @api_client.config.client_side_validation && cabundle_id.nil?
        fail ArgumentError, "Missing the required parameter 'cabundle_id' when calling CertificatesApi.add_or_replace_ca_bundle_upload_0"
      end
      # verify the required parameter 'file' is set
      if @api_client.config.client_side_validation && file.nil?
        fail ArgumentError, "Missing the required parameter 'file' when calling CertificatesApi.add_or_replace_ca_bundle_upload_0"
      end
      if @api_client.config.client_side_validation && !opts[:'description'].nil? && opts[:'description'].to_s.length > 1024
        fail ArgumentError, 'invalid value for "opts[:"description"]" when calling CertificatesApi.add_or_replace_ca_bundle_upload_0, the character length must be smaller than or equal to 1024.'
      end

      if @api_client.config.client_side_validation && !opts[:'display_name'].nil? && opts[:'display_name'].to_s.length > 255
        fail ArgumentError, 'invalid value for "opts[:"display_name"]" when calling CertificatesApi.add_or_replace_ca_bundle_upload_0, the character length must be smaller than or equal to 255.'
      end

      # resource path
      local_var_path = '/infra/cabundles/{cabundle-id}'.sub('{' + 'cabundle-id' + '}', cabundle_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'description'] = opts[:'description'] if !opts[:'description'].nil?
      query_params[:'display_name'] = opts[:'display_name'] if !opts[:'display_name'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['multipart/form-data'])

      # form parameters
      form_params = {}
      form_params['file'] = file

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'CaBundle')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#add_or_replace_ca_bundle_upload_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Add a New Certificate
    # Adds a new private-public certificate and, optionally, a private key that can be applied to one of the user-facing components (appliance management or edge). The certificate and the key should be stored in PEM format. If no private key is provided, the certificate is used as a client certificate in the trust store. A private key can be uploaded for a CA certificate only if the \"purpose\" parameter is set to \"signing-ca\". A certificate chain will not be expanded into separate certificate instances for reference, but would be pushed to the enforcement point as a single certificate. This PUT method does not modify an existing certificate. 
    # @param certificate_id 
    # @param tls_trust_data 
    # @param [Hash] opts the optional parameters
    # @return [TlsCertificate]
    def add_tls_certificate(certificate_id, tls_trust_data, opts = {})
      data, _status_code, _headers = add_tls_certificate_with_http_info(certificate_id, tls_trust_data, opts)
      data
    end

    # Add a New Certificate
    # Adds a new private-public certificate and, optionally, a private key that can be applied to one of the user-facing components (appliance management or edge). The certificate and the key should be stored in PEM format. If no private key is provided, the certificate is used as a client certificate in the trust store. A private key can be uploaded for a CA certificate only if the \&quot;purpose\&quot; parameter is set to \&quot;signing-ca\&quot;. A certificate chain will not be expanded into separate certificate instances for reference, but would be pushed to the enforcement point as a single certificate. This PUT method does not modify an existing certificate. 
    # @param certificate_id 
    # @param tls_trust_data 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TlsCertificate, Fixnum, Hash)>] TlsCertificate data, response status code and response headers
    def add_tls_certificate_with_http_info(certificate_id, tls_trust_data, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.add_tls_certificate ...'
      end
      # verify the required parameter 'certificate_id' is set
      if @api_client.config.client_side_validation && certificate_id.nil?
        fail ArgumentError, "Missing the required parameter 'certificate_id' when calling CertificatesApi.add_tls_certificate"
      end
      # verify the required parameter 'tls_trust_data' is set
      if @api_client.config.client_side_validation && tls_trust_data.nil?
        fail ArgumentError, "Missing the required parameter 'tls_trust_data' when calling CertificatesApi.add_tls_certificate"
      end
      # resource path
      local_var_path = '/infra/certificates/{certificate-id}'.sub('{' + 'certificate-id' + '}', certificate_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tls_trust_data)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#add_tls_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Add a New Certificate
    # Adds a new private-public certificate and, optionally, a private key that can be applied to one of the user-facing components (appliance management or edge). The certificate and the key should be stored in PEM format. If no private key is provided, the certificate is used as a client certificate in the trust store. A private key can be uploaded for a CA certificate only if the \"purpose\" parameter is set to \"signing-ca\". A certificate chain will not be expanded into separate certificate instances for reference, but would be pushed to the enforcement point as a single certificate. This PUT method does not modify an existing certificate. 
    # @param certificate_id 
    # @param tls_trust_data 
    # @param [Hash] opts the optional parameters
    # @return [TlsCertificate]
    def add_tls_certificate_0(certificate_id, tls_trust_data, opts = {})
      data, _status_code, _headers = add_tls_certificate_0_with_http_info(certificate_id, tls_trust_data, opts)
      data
    end

    # Add a New Certificate
    # Adds a new private-public certificate and, optionally, a private key that can be applied to one of the user-facing components (appliance management or edge). The certificate and the key should be stored in PEM format. If no private key is provided, the certificate is used as a client certificate in the trust store. A private key can be uploaded for a CA certificate only if the \&quot;purpose\&quot; parameter is set to \&quot;signing-ca\&quot;. A certificate chain will not be expanded into separate certificate instances for reference, but would be pushed to the enforcement point as a single certificate. This PUT method does not modify an existing certificate. 
    # @param certificate_id 
    # @param tls_trust_data 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TlsCertificate, Fixnum, Hash)>] TlsCertificate data, response status code and response headers
    def add_tls_certificate_0_with_http_info(certificate_id, tls_trust_data, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.add_tls_certificate_0 ...'
      end
      # verify the required parameter 'certificate_id' is set
      if @api_client.config.client_side_validation && certificate_id.nil?
        fail ArgumentError, "Missing the required parameter 'certificate_id' when calling CertificatesApi.add_tls_certificate_0"
      end
      # verify the required parameter 'tls_trust_data' is set
      if @api_client.config.client_side_validation && tls_trust_data.nil?
        fail ArgumentError, "Missing the required parameter 'tls_trust_data' when calling CertificatesApi.add_tls_certificate_0"
      end
      # resource path
      local_var_path = '/infra/certificates/{certificate-id}'.sub('{' + 'certificate-id' + '}', certificate_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tls_trust_data)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#add_tls_certificate_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or patch a Certificate Revocation List
    # Create or patch a Certificate Revocation List for the given id. The CRL is used to verify the client certificate status against the revocation lists published by the CA. For this reason, the administrator needs to add the CRL in certificate repository as well. The CRL must contain PEM data for a single CRL. A CRL can be in the PEM X.509 format (crl_type=X509) or JSON OneCRL (crl_type=OneCRL). If crl_type is not specified, it is auto-detected based on the presence of fields pem_encoded or one_crl. 
    # @param crl_id 
    # @param tls_crl 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def create_or_patch_tls_crl(crl_id, tls_crl, opts = {})
      create_or_patch_tls_crl_with_http_info(crl_id, tls_crl, opts)
      nil
    end

    # Create or patch a Certificate Revocation List
    # Create or patch a Certificate Revocation List for the given id. The CRL is used to verify the client certificate status against the revocation lists published by the CA. For this reason, the administrator needs to add the CRL in certificate repository as well. The CRL must contain PEM data for a single CRL. A CRL can be in the PEM X.509 format (crl_type&#x3D;X509) or JSON OneCRL (crl_type&#x3D;OneCRL). If crl_type is not specified, it is auto-detected based on the presence of fields pem_encoded or one_crl. 
    # @param crl_id 
    # @param tls_crl 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def create_or_patch_tls_crl_with_http_info(crl_id, tls_crl, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.create_or_patch_tls_crl ...'
      end
      # verify the required parameter 'crl_id' is set
      if @api_client.config.client_side_validation && crl_id.nil?
        fail ArgumentError, "Missing the required parameter 'crl_id' when calling CertificatesApi.create_or_patch_tls_crl"
      end
      # verify the required parameter 'tls_crl' is set
      if @api_client.config.client_side_validation && tls_crl.nil?
        fail ArgumentError, "Missing the required parameter 'tls_crl' when calling CertificatesApi.create_or_patch_tls_crl"
      end
      # resource path
      local_var_path = '/infra/crls/{crl-id}'.sub('{' + 'crl-id' + '}', crl_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tls_crl)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#create_or_patch_tls_crl\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or fully replace a Certificate Revocation List
    # Create or replace a Certificate Revocation List for the given id. The CRL is used to verify the client certificate status against the revocation lists published by the CA. For this reason, the administrator needs to add the CRL in certificate repository as well. The CRL must contain PEM data for a single CRL. Revision is required. A CRL can be in the PEM X.509 format (crl_type=X509) or JSON OneCRL (crl_type=OneCRL). If crl_type is not specified, it is auto-detected based on the presence of fields pem_encoded or one_crl. 
    # @param crl_id 
    # @param tls_crl 
    # @param [Hash] opts the optional parameters
    # @return [TlsCrl]
    def create_or_update_tls_crl(crl_id, tls_crl, opts = {})
      data, _status_code, _headers = create_or_update_tls_crl_with_http_info(crl_id, tls_crl, opts)
      data
    end

    # Create or fully replace a Certificate Revocation List
    # Create or replace a Certificate Revocation List for the given id. The CRL is used to verify the client certificate status against the revocation lists published by the CA. For this reason, the administrator needs to add the CRL in certificate repository as well. The CRL must contain PEM data for a single CRL. Revision is required. A CRL can be in the PEM X.509 format (crl_type&#x3D;X509) or JSON OneCRL (crl_type&#x3D;OneCRL). If crl_type is not specified, it is auto-detected based on the presence of fields pem_encoded or one_crl. 
    # @param crl_id 
    # @param tls_crl 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TlsCrl, Fixnum, Hash)>] TlsCrl data, response status code and response headers
    def create_or_update_tls_crl_with_http_info(crl_id, tls_crl, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.create_or_update_tls_crl ...'
      end
      # verify the required parameter 'crl_id' is set
      if @api_client.config.client_side_validation && crl_id.nil?
        fail ArgumentError, "Missing the required parameter 'crl_id' when calling CertificatesApi.create_or_update_tls_crl"
      end
      # verify the required parameter 'tls_crl' is set
      if @api_client.config.client_side_validation && tls_crl.nil?
        fail ArgumentError, "Missing the required parameter 'tls_crl' when calling CertificatesApi.create_or_update_tls_crl"
      end
      # resource path
      local_var_path = '/infra/crls/{crl-id}'.sub('{' + 'crl-id' + '}', crl_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tls_crl)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCrl')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#create_or_update_tls_crl\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create a new Certificate Revocation List
    # Adds a new certificate revocation list (CRLs). The CRL is used to verify the client certificate status against the revocation lists published by the CA. For this reason, the administrator needs to add the CRL in certificate repository as well. A CRL can be in the PEM X.509 format (crl_type=X509) or JSON OneCRL (crl_type=OneCRL). If crl_type is not specified, it is auto-detected based on the presence of fields pem_encoded or one_crl. An X.509 CRL can contain a single CRL or multiple CRLs depending on the PEM data. - Single CRL: a single CRL is created with the given id. - Composite CRL: multiple CRLs are generated. Each of the CRL is created with an id generated based on the given id. First CRL is created with crl-id, second with crl-id-1, third with crl-id-2, etc. 
    # @param crl_id 
    # @param tls_crl 
    # @param [Hash] opts the optional parameters
    # @return [TlsCrlListResult]
    def create_tls_crl(crl_id, tls_crl, opts = {})
      data, _status_code, _headers = create_tls_crl_with_http_info(crl_id, tls_crl, opts)
      data
    end

    # Create a new Certificate Revocation List
    # Adds a new certificate revocation list (CRLs). The CRL is used to verify the client certificate status against the revocation lists published by the CA. For this reason, the administrator needs to add the CRL in certificate repository as well. A CRL can be in the PEM X.509 format (crl_type&#x3D;X509) or JSON OneCRL (crl_type&#x3D;OneCRL). If crl_type is not specified, it is auto-detected based on the presence of fields pem_encoded or one_crl. An X.509 CRL can contain a single CRL or multiple CRLs depending on the PEM data. - Single CRL: a single CRL is created with the given id. - Composite CRL: multiple CRLs are generated. Each of the CRL is created with an id generated based on the given id. First CRL is created with crl-id, second with crl-id-1, third with crl-id-2, etc. 
    # @param crl_id 
    # @param tls_crl 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TlsCrlListResult, Fixnum, Hash)>] TlsCrlListResult data, response status code and response headers
    def create_tls_crl_with_http_info(crl_id, tls_crl, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.create_tls_crl ...'
      end
      # verify the required parameter 'crl_id' is set
      if @api_client.config.client_side_validation && crl_id.nil?
        fail ArgumentError, "Missing the required parameter 'crl_id' when calling CertificatesApi.create_tls_crl"
      end
      # verify the required parameter 'tls_crl' is set
      if @api_client.config.client_side_validation && tls_crl.nil?
        fail ArgumentError, "Missing the required parameter 'tls_crl' when calling CertificatesApi.create_tls_crl"
      end
      # resource path
      local_var_path = '/infra/crls/{crl-id}?action=import'.sub('{' + 'crl-id' + '}', crl_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tls_crl)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCrlListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#create_tls_crl\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Deletes CA bundle
    # Deletes the specified bundle of trusted CA certificates. 
    # @param cabundle_id ID of the CA bundle to delete
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_ca_bundle(cabundle_id, opts = {})
      delete_ca_bundle_with_http_info(cabundle_id, opts)
      nil
    end

    # Deletes CA bundle
    # Deletes the specified bundle of trusted CA certificates. 
    # @param cabundle_id ID of the CA bundle to delete
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_ca_bundle_with_http_info(cabundle_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.delete_ca_bundle ...'
      end
      # verify the required parameter 'cabundle_id' is set
      if @api_client.config.client_side_validation && cabundle_id.nil?
        fail ArgumentError, "Missing the required parameter 'cabundle_id' when calling CertificatesApi.delete_ca_bundle"
      end
      # resource path
      local_var_path = '/infra/cabundles/{cabundle-id}'.sub('{' + 'cabundle-id' + '}', cabundle_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#delete_ca_bundle\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Deletes CA bundle
    # Deletes the specified bundle of trusted CA certificates. 
    # @param cabundle_id ID of the CA bundle to delete
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_ca_bundle_0(cabundle_id, opts = {})
      delete_ca_bundle_0_with_http_info(cabundle_id, opts)
      nil
    end

    # Deletes CA bundle
    # Deletes the specified bundle of trusted CA certificates. 
    # @param cabundle_id ID of the CA bundle to delete
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_ca_bundle_0_with_http_info(cabundle_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.delete_ca_bundle_0 ...'
      end
      # verify the required parameter 'cabundle_id' is set
      if @api_client.config.client_side_validation && cabundle_id.nil?
        fail ArgumentError, "Missing the required parameter 'cabundle_id' when calling CertificatesApi.delete_ca_bundle_0"
      end
      # resource path
      local_var_path = '/infra/cabundles/{cabundle-id}'.sub('{' + 'cabundle-id' + '}', cabundle_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#delete_ca_bundle_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Certificate for the Given Certificate ID
    # Removes the specified certificate. The private key associated with the certificate is also deleted. 
    # @param certificate_id ID of certificate to delete
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_tls_certificate(certificate_id, opts = {})
      delete_tls_certificate_with_http_info(certificate_id, opts)
      nil
    end

    # Delete Certificate for the Given Certificate ID
    # Removes the specified certificate. The private key associated with the certificate is also deleted. 
    # @param certificate_id ID of certificate to delete
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_tls_certificate_with_http_info(certificate_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.delete_tls_certificate ...'
      end
      # verify the required parameter 'certificate_id' is set
      if @api_client.config.client_side_validation && certificate_id.nil?
        fail ArgumentError, "Missing the required parameter 'certificate_id' when calling CertificatesApi.delete_tls_certificate"
      end
      # resource path
      local_var_path = '/infra/certificates/{certificate-id}'.sub('{' + 'certificate-id' + '}', certificate_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#delete_tls_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Certificate for the Given Certificate ID
    # Removes the specified certificate. The private key associated with the certificate is also deleted. 
    # @param certificate_id ID of certificate to delete
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_tls_certificate_0(certificate_id, opts = {})
      delete_tls_certificate_0_with_http_info(certificate_id, opts)
      nil
    end

    # Delete Certificate for the Given Certificate ID
    # Removes the specified certificate. The private key associated with the certificate is also deleted. 
    # @param certificate_id ID of certificate to delete
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_tls_certificate_0_with_http_info(certificate_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.delete_tls_certificate_0 ...'
      end
      # verify the required parameter 'certificate_id' is set
      if @api_client.config.client_side_validation && certificate_id.nil?
        fail ArgumentError, "Missing the required parameter 'certificate_id' when calling CertificatesApi.delete_tls_certificate_0"
      end
      # resource path
      local_var_path = '/infra/certificates/{certificate-id}'.sub('{' + 'certificate-id' + '}', certificate_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#delete_tls_certificate_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a CRL
    # Deletes an existing CRL.
    # @param crl_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_tls_crl(crl_id, opts = {})
      delete_tls_crl_with_http_info(crl_id, opts)
      nil
    end

    # Delete a CRL
    # Deletes an existing CRL.
    # @param crl_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_tls_crl_with_http_info(crl_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.delete_tls_crl ...'
      end
      # verify the required parameter 'crl_id' is set
      if @api_client.config.client_side_validation && crl_id.nil?
        fail ArgumentError, "Missing the required parameter 'crl_id' when calling CertificatesApi.delete_tls_crl"
      end
      # resource path
      local_var_path = '/infra/crls/{crl-id}'.sub('{' + 'crl-id' + '}', crl_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#delete_tls_crl\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a CSR
    # Removes a specified CSR. If a CSR is not used for verification, you can delete it. Note that the CSR import and upload POST actions automatically delete the associated CSR. 
    # @param csr_id ID of CSR to delete
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_tls_csr(csr_id, opts = {})
      delete_tls_csr_with_http_info(csr_id, opts)
      nil
    end

    # Delete a CSR
    # Removes a specified CSR. If a CSR is not used for verification, you can delete it. Note that the CSR import and upload POST actions automatically delete the associated CSR. 
    # @param csr_id ID of CSR to delete
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_tls_csr_with_http_info(csr_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.delete_tls_csr ...'
      end
      # verify the required parameter 'csr_id' is set
      if @api_client.config.client_side_validation && csr_id.nil?
        fail ArgumentError, "Missing the required parameter 'csr_id' when calling CertificatesApi.delete_tls_csr"
      end
      # resource path
      local_var_path = '/infra/csrs/{csr-id}'.sub('{' + 'csr-id' + '}', csr_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#delete_tls_csr\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Generate a new self-signed certificate
    # Creates a new self-signed certificate. A private key is also created at the same time. This is convenience call that will generate a CSR and then self-sign it. The maximum validity limit for non-CA certificates is 825 days, except that values of 3,650 and 36,500 days are allowed. No limit is set for CA certificates. 
    # @param tls_csr_with_days_valid 
    # @param [Hash] opts the optional parameters
    # @return [TlsCertificate]
    def generate_self_signed_tls_certificate(tls_csr_with_days_valid, opts = {})
      data, _status_code, _headers = generate_self_signed_tls_certificate_with_http_info(tls_csr_with_days_valid, opts)
      data
    end

    # Generate a new self-signed certificate
    # Creates a new self-signed certificate. A private key is also created at the same time. This is convenience call that will generate a CSR and then self-sign it. The maximum validity limit for non-CA certificates is 825 days, except that values of 3,650 and 36,500 days are allowed. No limit is set for CA certificates. 
    # @param tls_csr_with_days_valid 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TlsCertificate, Fixnum, Hash)>] TlsCertificate data, response status code and response headers
    def generate_self_signed_tls_certificate_with_http_info(tls_csr_with_days_valid, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.generate_self_signed_tls_certificate ...'
      end
      # verify the required parameter 'tls_csr_with_days_valid' is set
      if @api_client.config.client_side_validation && tls_csr_with_days_valid.nil?
        fail ArgumentError, "Missing the required parameter 'tls_csr_with_days_valid' when calling CertificatesApi.generate_self_signed_tls_certificate"
      end
      # resource path
      local_var_path = '/infra/csrs?action=self_sign'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tls_csr_with_days_valid)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#generate_self_signed_tls_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Generate a New Certificate Signing Request
    # Creates a new certificate signing request (CSR). A CSR is encrypted text that contains information about your organization (organization name, country, and so on) and your Web server's public key, which is a public certificate the is generated on the server that can be used to forward this request to a certificate authority (CA). A private key is also usually created at the same time as the CSR. 
    # @param csr_id ID of CSR to create
    # @param tls_csr 
    # @param [Hash] opts the optional parameters
    # @return [TlsCsr]
    def generate_tls_csr(csr_id, tls_csr, opts = {})
      data, _status_code, _headers = generate_tls_csr_with_http_info(csr_id, tls_csr, opts)
      data
    end

    # Generate a New Certificate Signing Request
    # Creates a new certificate signing request (CSR). A CSR is encrypted text that contains information about your organization (organization name, country, and so on) and your Web server&#39;s public key, which is a public certificate the is generated on the server that can be used to forward this request to a certificate authority (CA). A private key is also usually created at the same time as the CSR. 
    # @param csr_id ID of CSR to create
    # @param tls_csr 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TlsCsr, Fixnum, Hash)>] TlsCsr data, response status code and response headers
    def generate_tls_csr_with_http_info(csr_id, tls_csr, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.generate_tls_csr ...'
      end
      # verify the required parameter 'csr_id' is set
      if @api_client.config.client_side_validation && csr_id.nil?
        fail ArgumentError, "Missing the required parameter 'csr_id' when calling CertificatesApi.generate_tls_csr"
      end
      # verify the required parameter 'tls_csr' is set
      if @api_client.config.client_side_validation && tls_csr.nil?
        fail ArgumentError, "Missing the required parameter 'tls_csr' when calling CertificatesApi.generate_tls_csr"
      end
      # resource path
      local_var_path = '/infra/csrs/{csr-id}?action=create'.sub('{' + 'csr-id' + '}', csr_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tls_csr)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCsr')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#generate_tls_csr\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns information about a CA bundle
    # Returns information about the specified bundle of trusted CA certificates. 
    # @param cabundle_id ID of the CA bundle to retrieve
    # @param [Hash] opts the optional parameters
    # @return [CaBundle]
    def get_ca_bundle(cabundle_id, opts = {})
      data, _status_code, _headers = get_ca_bundle_with_http_info(cabundle_id, opts)
      data
    end

    # Returns information about a CA bundle
    # Returns information about the specified bundle of trusted CA certificates. 
    # @param cabundle_id ID of the CA bundle to retrieve
    # @param [Hash] opts the optional parameters
    # @return [Array<(CaBundle, Fixnum, Hash)>] CaBundle data, response status code and response headers
    def get_ca_bundle_with_http_info(cabundle_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.get_ca_bundle ...'
      end
      # verify the required parameter 'cabundle_id' is set
      if @api_client.config.client_side_validation && cabundle_id.nil?
        fail ArgumentError, "Missing the required parameter 'cabundle_id' when calling CertificatesApi.get_ca_bundle"
      end
      # resource path
      local_var_path = '/infra/cabundles/{cabundle-id}'.sub('{' + 'cabundle-id' + '}', cabundle_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'CaBundle')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#get_ca_bundle\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns information about a CA bundle
    # Returns information about the specified bundle of trusted CA certificates. 
    # @param cabundle_id ID of the CA bundle to retrieve
    # @param [Hash] opts the optional parameters
    # @return [CaBundle]
    def get_ca_bundle_0(cabundle_id, opts = {})
      data, _status_code, _headers = get_ca_bundle_0_with_http_info(cabundle_id, opts)
      data
    end

    # Returns information about a CA bundle
    # Returns information about the specified bundle of trusted CA certificates. 
    # @param cabundle_id ID of the CA bundle to retrieve
    # @param [Hash] opts the optional parameters
    # @return [Array<(CaBundle, Fixnum, Hash)>] CaBundle data, response status code and response headers
    def get_ca_bundle_0_with_http_info(cabundle_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.get_ca_bundle_0 ...'
      end
      # verify the required parameter 'cabundle_id' is set
      if @api_client.config.client_side_validation && cabundle_id.nil?
        fail ArgumentError, "Missing the required parameter 'cabundle_id' when calling CertificatesApi.get_ca_bundle_0"
      end
      # resource path
      local_var_path = '/infra/cabundles/{cabundle-id}'.sub('{' + 'cabundle-id' + '}', cabundle_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'CaBundle')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#get_ca_bundle_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Downloads a CA bundle
    # Downloads the specified PEM-encoded bundle of trusted CA certificates. 
    # @param cabundle_id ID of the CA bundle to retrieve
    # @param [Hash] opts the optional parameters
    # @return [String]
    def get_ca_bundle_pem_file(cabundle_id, opts = {})
      data, _status_code, _headers = get_ca_bundle_pem_file_with_http_info(cabundle_id, opts)
      data
    end

    # Downloads a CA bundle
    # Downloads the specified PEM-encoded bundle of trusted CA certificates. 
    # @param cabundle_id ID of the CA bundle to retrieve
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Fixnum, Hash)>] String data, response status code and response headers
    def get_ca_bundle_pem_file_with_http_info(cabundle_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.get_ca_bundle_pem_file ...'
      end
      # verify the required parameter 'cabundle_id' is set
      if @api_client.config.client_side_validation && cabundle_id.nil?
        fail ArgumentError, "Missing the required parameter 'cabundle_id' when calling CertificatesApi.get_ca_bundle_pem_file"
      end
      # resource path
      local_var_path = '/infra/cabundles/{cabundle-id}/pem-file'.sub('{' + 'cabundle-id' + '}', cabundle_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/plain;charset=UTF-8'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'String')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#get_ca_bundle_pem_file\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Downloads a CA bundle
    # Downloads the specified PEM-encoded bundle of trusted CA certificates. 
    # @param cabundle_id ID of the CA bundle to retrieve
    # @param [Hash] opts the optional parameters
    # @return [String]
    def get_ca_bundle_pem_file_0(cabundle_id, opts = {})
      data, _status_code, _headers = get_ca_bundle_pem_file_0_with_http_info(cabundle_id, opts)
      data
    end

    # Downloads a CA bundle
    # Downloads the specified PEM-encoded bundle of trusted CA certificates. 
    # @param cabundle_id ID of the CA bundle to retrieve
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Fixnum, Hash)>] String data, response status code and response headers
    def get_ca_bundle_pem_file_0_with_http_info(cabundle_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.get_ca_bundle_pem_file_0 ...'
      end
      # verify the required parameter 'cabundle_id' is set
      if @api_client.config.client_side_validation && cabundle_id.nil?
        fail ArgumentError, "Missing the required parameter 'cabundle_id' when calling CertificatesApi.get_ca_bundle_pem_file_0"
      end
      # resource path
      local_var_path = '/infra/cabundles/{cabundle-id}/pem-file'.sub('{' + 'cabundle-id' + '}', cabundle_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/plain;charset=UTF-8'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'String')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#get_ca_bundle_pem_file_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Show Certificate Data for the Given Certificate ID
    # Returns information for the specified certificate ID, including the certificate's id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details=true modifier at the end of the request URI. 
    # @param certificate_id ID of certificate to read
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details (default to false)
    # @return [TlsCertificate]
    def get_tls_certificate(certificate_id, opts = {})
      data, _status_code, _headers = get_tls_certificate_with_http_info(certificate_id, opts)
      data
    end

    # Show Certificate Data for the Given Certificate ID
    # Returns information for the specified certificate ID, including the certificate&#39;s id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details&#x3D;true modifier at the end of the request URI. 
    # @param certificate_id ID of certificate to read
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details
    # @return [Array<(TlsCertificate, Fixnum, Hash)>] TlsCertificate data, response status code and response headers
    def get_tls_certificate_with_http_info(certificate_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.get_tls_certificate ...'
      end
      # verify the required parameter 'certificate_id' is set
      if @api_client.config.client_side_validation && certificate_id.nil?
        fail ArgumentError, "Missing the required parameter 'certificate_id' when calling CertificatesApi.get_tls_certificate"
      end
      # resource path
      local_var_path = '/infra/certificates/{certificate-id}'.sub('{' + 'certificate-id' + '}', certificate_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'details'] = opts[:'details'] if !opts[:'details'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#get_tls_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Show Certificate Data for the Given Certificate ID
    # Returns information for the specified certificate ID, including the certificate's id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details=true modifier at the end of the request URI. 
    # @param certificate_id ID of certificate to read
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details (default to false)
    # @return [TlsCertificate]
    def get_tls_certificate_0(certificate_id, opts = {})
      data, _status_code, _headers = get_tls_certificate_0_with_http_info(certificate_id, opts)
      data
    end

    # Show Certificate Data for the Given Certificate ID
    # Returns information for the specified certificate ID, including the certificate&#39;s id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details&#x3D;true modifier at the end of the request URI. 
    # @param certificate_id ID of certificate to read
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details
    # @return [Array<(TlsCertificate, Fixnum, Hash)>] TlsCertificate data, response status code and response headers
    def get_tls_certificate_0_with_http_info(certificate_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.get_tls_certificate_0 ...'
      end
      # verify the required parameter 'certificate_id' is set
      if @api_client.config.client_side_validation && certificate_id.nil?
        fail ArgumentError, "Missing the required parameter 'certificate_id' when calling CertificatesApi.get_tls_certificate_0"
      end
      # resource path
      local_var_path = '/infra/certificates/{certificate-id}'.sub('{' + 'certificate-id' + '}', certificate_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'details'] = opts[:'details'] if !opts[:'details'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#get_tls_certificate_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Show CRL Data for the Given CRL id.
    # Returns information about the specified CRL. For additional information, include the ?details=true modifier at the end of the request URI. 
    # @param crl_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details (default to false)
    # @return [TlsCrl]
    def get_tls_crl(crl_id, opts = {})
      data, _status_code, _headers = get_tls_crl_with_http_info(crl_id, opts)
      data
    end

    # Show CRL Data for the Given CRL id.
    # Returns information about the specified CRL. For additional information, include the ?details&#x3D;true modifier at the end of the request URI. 
    # @param crl_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details
    # @return [Array<(TlsCrl, Fixnum, Hash)>] TlsCrl data, response status code and response headers
    def get_tls_crl_with_http_info(crl_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.get_tls_crl ...'
      end
      # verify the required parameter 'crl_id' is set
      if @api_client.config.client_side_validation && crl_id.nil?
        fail ArgumentError, "Missing the required parameter 'crl_id' when calling CertificatesApi.get_tls_crl"
      end
      # resource path
      local_var_path = '/infra/crls/{crl-id}'.sub('{' + 'crl-id' + '}', crl_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'details'] = opts[:'details'] if !opts[:'details'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCrl')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#get_tls_crl\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Show CSR Data for the Given CSR ID
    # Returns information about the specified CSR.
    # @param csr_id ID of CSR to read
    # @param [Hash] opts the optional parameters
    # @return [TlsCsr]
    def get_tls_csr(csr_id, opts = {})
      data, _status_code, _headers = get_tls_csr_with_http_info(csr_id, opts)
      data
    end

    # Show CSR Data for the Given CSR ID
    # Returns information about the specified CSR.
    # @param csr_id ID of CSR to read
    # @param [Hash] opts the optional parameters
    # @return [Array<(TlsCsr, Fixnum, Hash)>] TlsCsr data, response status code and response headers
    def get_tls_csr_with_http_info(csr_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.get_tls_csr ...'
      end
      # verify the required parameter 'csr_id' is set
      if @api_client.config.client_side_validation && csr_id.nil?
        fail ArgumentError, "Missing the required parameter 'csr_id' when calling CertificatesApi.get_tls_csr"
      end
      # resource path
      local_var_path = '/infra/csrs/{csr-id}'.sub('{' + 'csr-id' + '}', csr_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCsr')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#get_tls_csr\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get CSR PEM File for the Given CSR ID
    # Downloads the CSR PEM file for a specified CSR. Clients must include an Accept: text/plain request header.
    # @param csr_id ID of CSR to read
    # @param [Hash] opts the optional parameters
    # @return [String]
    def get_tls_csr_pem(csr_id, opts = {})
      data, _status_code, _headers = get_tls_csr_pem_with_http_info(csr_id, opts)
      data
    end

    # Get CSR PEM File for the Given CSR ID
    # Downloads the CSR PEM file for a specified CSR. Clients must include an Accept: text/plain request header.
    # @param csr_id ID of CSR to read
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Fixnum, Hash)>] String data, response status code and response headers
    def get_tls_csr_pem_with_http_info(csr_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.get_tls_csr_pem ...'
      end
      # verify the required parameter 'csr_id' is set
      if @api_client.config.client_side_validation && csr_id.nil?
        fail ArgumentError, "Missing the required parameter 'csr_id' when calling CertificatesApi.get_tls_csr_pem"
      end
      # resource path
      local_var_path = '/infra/csrs/{csr-id}/pem-file'.sub('{' + 'csr-id' + '}', csr_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/plain;charset=UTF-8'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'String')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#get_tls_csr_pem\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Show Certificate Data for the Given Certificate ID
    # Returns information for the specified certificate ID, including the certificate's id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details=true modifier at the end of the request URI. 
    # @param certificate_id ID of certificate to read
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details (default to false)
    # @return [TlsCertificate]
    def global_infra_get_tls_certificate(certificate_id, opts = {})
      data, _status_code, _headers = global_infra_get_tls_certificate_with_http_info(certificate_id, opts)
      data
    end

    # Show Certificate Data for the Given Certificate ID
    # Returns information for the specified certificate ID, including the certificate&#39;s id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details&#x3D;true modifier at the end of the request URI. 
    # @param certificate_id ID of certificate to read
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details
    # @return [Array<(TlsCertificate, Fixnum, Hash)>] TlsCertificate data, response status code and response headers
    def global_infra_get_tls_certificate_with_http_info(certificate_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.global_infra_get_tls_certificate ...'
      end
      # verify the required parameter 'certificate_id' is set
      if @api_client.config.client_side_validation && certificate_id.nil?
        fail ArgumentError, "Missing the required parameter 'certificate_id' when calling CertificatesApi.global_infra_get_tls_certificate"
      end
      # resource path
      local_var_path = '/global-infra/certificates/{certificate-id}'.sub('{' + 'certificate-id' + '}', certificate_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'details'] = opts[:'details'] if !opts[:'details'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#global_infra_get_tls_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Show Certificate Data for the Given Certificate ID
    # Returns information for the specified certificate ID, including the certificate's id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details=true modifier at the end of the request URI. 
    # @param certificate_id ID of certificate to read
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details (default to false)
    # @return [TlsCertificate]
    def global_infra_get_tls_certificate_0(certificate_id, opts = {})
      data, _status_code, _headers = global_infra_get_tls_certificate_0_with_http_info(certificate_id, opts)
      data
    end

    # Show Certificate Data for the Given Certificate ID
    # Returns information for the specified certificate ID, including the certificate&#39;s id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details&#x3D;true modifier at the end of the request URI. 
    # @param certificate_id ID of certificate to read
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details
    # @return [Array<(TlsCertificate, Fixnum, Hash)>] TlsCertificate data, response status code and response headers
    def global_infra_get_tls_certificate_0_with_http_info(certificate_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.global_infra_get_tls_certificate_0 ...'
      end
      # verify the required parameter 'certificate_id' is set
      if @api_client.config.client_side_validation && certificate_id.nil?
        fail ArgumentError, "Missing the required parameter 'certificate_id' when calling CertificatesApi.global_infra_get_tls_certificate_0"
      end
      # resource path
      local_var_path = '/global-infra/certificates/{certificate-id}'.sub('{' + 'certificate-id' + '}', certificate_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'details'] = opts[:'details'] if !opts[:'details'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#global_infra_get_tls_certificate_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Show CRL Data for the Given CRL id.
    # Returns information about the specified CRL. For additional information, include the ?details=true modifier at the end of the request URI. 
    # @param crl_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details (default to false)
    # @return [TlsCrl]
    def global_infra_get_tls_crl(crl_id, opts = {})
      data, _status_code, _headers = global_infra_get_tls_crl_with_http_info(crl_id, opts)
      data
    end

    # Show CRL Data for the Given CRL id.
    # Returns information about the specified CRL. For additional information, include the ?details&#x3D;true modifier at the end of the request URI. 
    # @param crl_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details
    # @return [Array<(TlsCrl, Fixnum, Hash)>] TlsCrl data, response status code and response headers
    def global_infra_get_tls_crl_with_http_info(crl_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.global_infra_get_tls_crl ...'
      end
      # verify the required parameter 'crl_id' is set
      if @api_client.config.client_side_validation && crl_id.nil?
        fail ArgumentError, "Missing the required parameter 'crl_id' when calling CertificatesApi.global_infra_get_tls_crl"
      end
      # resource path
      local_var_path = '/global-infra/crls/{crl-id}'.sub('{' + 'crl-id' + '}', crl_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'details'] = opts[:'details'] if !opts[:'details'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCrl')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#global_infra_get_tls_crl\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Return All the User-Facing Components' Certificates
    # Returns all certificate information viewable by the user, including each certificate's id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details=true modifier at the end of the request URI. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [TlsCertificateList]
    def global_infra_list_tls_certificates(opts = {})
      data, _status_code, _headers = global_infra_list_tls_certificates_with_http_info(opts)
      data
    end

    # Return All the User-Facing Components&#39; Certificates
    # Returns all certificate information viewable by the user, including each certificate&#39;s id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details&#x3D;true modifier at the end of the request URI. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [Array<(TlsCertificateList, Fixnum, Hash)>] TlsCertificateList data, response status code and response headers
    def global_infra_list_tls_certificates_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.global_infra_list_tls_certificates ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.global_infra_list_tls_certificates, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.global_infra_list_tls_certificates, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['cluster_api_certificate', 'api_certificate'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of cluster_api_certificate, api_certificate'
      end
      # resource path
      local_var_path = '/global-infra/certificates'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'details'] = opts[:'details'] if !opts[:'details'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'node_id'] = opts[:'node_id'] if !opts[:'node_id'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificateList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#global_infra_list_tls_certificates\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Return All the User-Facing Components' Certificates
    # Returns all certificate information viewable by the user, including each certificate's id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details=true modifier at the end of the request URI. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [TlsCertificateList]
    def global_infra_list_tls_certificates_0(opts = {})
      data, _status_code, _headers = global_infra_list_tls_certificates_0_with_http_info(opts)
      data
    end

    # Return All the User-Facing Components&#39; Certificates
    # Returns all certificate information viewable by the user, including each certificate&#39;s id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details&#x3D;true modifier at the end of the request URI. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [Array<(TlsCertificateList, Fixnum, Hash)>] TlsCertificateList data, response status code and response headers
    def global_infra_list_tls_certificates_0_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.global_infra_list_tls_certificates_0 ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.global_infra_list_tls_certificates_0, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.global_infra_list_tls_certificates_0, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['cluster_api_certificate', 'api_certificate'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of cluster_api_certificate, api_certificate'
      end
      # resource path
      local_var_path = '/global-infra/certificates'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'details'] = opts[:'details'] if !opts[:'details'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'node_id'] = opts[:'node_id'] if !opts[:'node_id'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificateList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#global_infra_list_tls_certificates_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Return All Added CRLs
    # Returns information about all CRLs. For additional information, include the ?details=true modifier at the end of the request URI. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [TlsCrlListResult]
    def global_infra_list_tls_crls(opts = {})
      data, _status_code, _headers = global_infra_list_tls_crls_with_http_info(opts)
      data
    end

    # Return All Added CRLs
    # Returns information about all CRLs. For additional information, include the ?details&#x3D;true modifier at the end of the request URI. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [Array<(TlsCrlListResult, Fixnum, Hash)>] TlsCrlListResult data, response status code and response headers
    def global_infra_list_tls_crls_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.global_infra_list_tls_crls ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.global_infra_list_tls_crls, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.global_infra_list_tls_crls, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['cluster_api_certificate', 'api_certificate'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of cluster_api_certificate, api_certificate'
      end
      # resource path
      local_var_path = '/global-infra/crls'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'details'] = opts[:'details'] if !opts[:'details'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'node_id'] = opts[:'node_id'] if !opts[:'node_id'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCrlListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#global_infra_list_tls_crls\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Import a Certificate Associated with an Approved CSR
    # Imports a certificate authority (CA)-signed certificate for a CSR. This action links the certificate to the private key created by the CSR. The pem_encoded string in the request body is the signed certificate provided by your CA in response to the CSR that you provide to them. The import POST action automatically deletes the associated CSR. 
    # @param csr_id CSR this certificate is associated with
    # @param tls_trust_data 
    # @param [Hash] opts the optional parameters
    # @return [TlsCertificate]
    def import_signed_tls_certificate(csr_id, tls_trust_data, opts = {})
      data, _status_code, _headers = import_signed_tls_certificate_with_http_info(csr_id, tls_trust_data, opts)
      data
    end

    # Import a Certificate Associated with an Approved CSR
    # Imports a certificate authority (CA)-signed certificate for a CSR. This action links the certificate to the private key created by the CSR. The pem_encoded string in the request body is the signed certificate provided by your CA in response to the CSR that you provide to them. The import POST action automatically deletes the associated CSR. 
    # @param csr_id CSR this certificate is associated with
    # @param tls_trust_data 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TlsCertificate, Fixnum, Hash)>] TlsCertificate data, response status code and response headers
    def import_signed_tls_certificate_with_http_info(csr_id, tls_trust_data, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.import_signed_tls_certificate ...'
      end
      # verify the required parameter 'csr_id' is set
      if @api_client.config.client_side_validation && csr_id.nil?
        fail ArgumentError, "Missing the required parameter 'csr_id' when calling CertificatesApi.import_signed_tls_certificate"
      end
      # verify the required parameter 'tls_trust_data' is set
      if @api_client.config.client_side_validation && tls_trust_data.nil?
        fail ArgumentError, "Missing the required parameter 'tls_trust_data' when calling CertificatesApi.import_signed_tls_certificate"
      end
      # resource path
      local_var_path = '/infra/csrs/{csr-id}?action=import'.sub('{' + 'csr-id' + '}', csr_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tls_trust_data)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#import_signed_tls_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns information about all the CA bundles
    # Returns information about all the bundles of trusted CA certificates. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [CaBundleListResult]
    def list_ca_bundles(opts = {})
      data, _status_code, _headers = list_ca_bundles_with_http_info(opts)
      data
    end

    # Returns information about all the CA bundles
    # Returns information about all the bundles of trusted CA certificates. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [Array<(CaBundleListResult, Fixnum, Hash)>] CaBundleListResult data, response status code and response headers
    def list_ca_bundles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.list_ca_bundles ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.list_ca_bundles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.list_ca_bundles, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['cluster_api_certificate', 'api_certificate'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of cluster_api_certificate, api_certificate'
      end
      # resource path
      local_var_path = '/infra/cabundles'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'details'] = opts[:'details'] if !opts[:'details'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'node_id'] = opts[:'node_id'] if !opts[:'node_id'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'CaBundleListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#list_ca_bundles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns information about all the CA bundles
    # Returns information about all the bundles of trusted CA certificates. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [CaBundleListResult]
    def list_ca_bundles_0(opts = {})
      data, _status_code, _headers = list_ca_bundles_0_with_http_info(opts)
      data
    end

    # Returns information about all the CA bundles
    # Returns information about all the bundles of trusted CA certificates. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [Array<(CaBundleListResult, Fixnum, Hash)>] CaBundleListResult data, response status code and response headers
    def list_ca_bundles_0_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.list_ca_bundles_0 ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.list_ca_bundles_0, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.list_ca_bundles_0, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['cluster_api_certificate', 'api_certificate'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of cluster_api_certificate, api_certificate'
      end
      # resource path
      local_var_path = '/infra/cabundles'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'details'] = opts[:'details'] if !opts[:'details'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'node_id'] = opts[:'node_id'] if !opts[:'node_id'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'CaBundleListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#list_ca_bundles_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Return All the User-Facing Components' Certificates
    # Returns all certificate information viewable by the user, including each certificate's id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details=true modifier at the end of the request URI. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [TlsCertificateList]
    def list_tls_certificates(opts = {})
      data, _status_code, _headers = list_tls_certificates_with_http_info(opts)
      data
    end

    # Return All the User-Facing Components&#39; Certificates
    # Returns all certificate information viewable by the user, including each certificate&#39;s id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details&#x3D;true modifier at the end of the request URI. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [Array<(TlsCertificateList, Fixnum, Hash)>] TlsCertificateList data, response status code and response headers
    def list_tls_certificates_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.list_tls_certificates ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.list_tls_certificates, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.list_tls_certificates, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['cluster_api_certificate', 'api_certificate'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of cluster_api_certificate, api_certificate'
      end
      # resource path
      local_var_path = '/infra/certificates'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'details'] = opts[:'details'] if !opts[:'details'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'node_id'] = opts[:'node_id'] if !opts[:'node_id'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificateList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#list_tls_certificates\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Return All the User-Facing Components' Certificates
    # Returns all certificate information viewable by the user, including each certificate's id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details=true modifier at the end of the request URI. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [TlsCertificateList]
    def list_tls_certificates_0(opts = {})
      data, _status_code, _headers = list_tls_certificates_0_with_http_info(opts)
      data
    end

    # Return All the User-Facing Components&#39; Certificates
    # Returns all certificate information viewable by the user, including each certificate&#39;s id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details&#x3D;true modifier at the end of the request URI. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [Array<(TlsCertificateList, Fixnum, Hash)>] TlsCertificateList data, response status code and response headers
    def list_tls_certificates_0_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.list_tls_certificates_0 ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.list_tls_certificates_0, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.list_tls_certificates_0, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['cluster_api_certificate', 'api_certificate'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of cluster_api_certificate, api_certificate'
      end
      # resource path
      local_var_path = '/infra/certificates'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'details'] = opts[:'details'] if !opts[:'details'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'node_id'] = opts[:'node_id'] if !opts[:'node_id'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificateList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#list_tls_certificates_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Return All Added CRLs
    # Returns information about all CRLs. For additional information, include the ?details=true modifier at the end of the request URI. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [TlsCrlListResult]
    def list_tls_crls(opts = {})
      data, _status_code, _headers = list_tls_crls_with_http_info(opts)
      data
    end

    # Return All Added CRLs
    # Returns information about all CRLs. For additional information, include the ?details&#x3D;true modifier at the end of the request URI. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [Array<(TlsCrlListResult, Fixnum, Hash)>] TlsCrlListResult data, response status code and response headers
    def list_tls_crls_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.list_tls_crls ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.list_tls_crls, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.list_tls_crls, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['cluster_api_certificate', 'api_certificate'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of cluster_api_certificate, api_certificate'
      end
      # resource path
      local_var_path = '/infra/crls'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'details'] = opts[:'details'] if !opts[:'details'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'node_id'] = opts[:'node_id'] if !opts[:'node_id'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCrlListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#list_tls_crls\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Return All the Generated CSRs
    # Returns information about all of the CSRs that have been created.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [TlsCsrListResult]
    def list_tls_csrs(opts = {})
      data, _status_code, _headers = list_tls_csrs_with_http_info(opts)
      data
    end

    # Return All the Generated CSRs
    # Returns information about all of the CSRs that have been created.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(TlsCsrListResult, Fixnum, Hash)>] TlsCsrListResult data, response status code and response headers
    def list_tls_csrs_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.list_tls_csrs ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.list_tls_csrs, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.list_tls_csrs, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/csrs'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCsrListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#list_tls_csrs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Add a New Certificate
    # Adds a new private-public certificate and, optionally, a private key that can be applied to one of the user-facing components (appliance management or edge). The certificate and the key should be stored in PEM format. If no private key is provided, the certificate is used as a client certificate in the trust store. A private key can be uploaded for a CA certificate only if the \"purpose\" parameter is set to \"signing-ca\". A certificate chain will not be expanded into separate certificate instances for reference, but would be pushed to the enforcement point as a single certificate. This PUT method does not modify an existing certificate. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param certificate_id 
    # @param tls_trust_data 
    # @param [Hash] opts the optional parameters
    # @return [TlsCertificate]
    def orgs_org_id_projects_project_id_infra_add_tls_certificate(org_id, project_id, certificate_id, tls_trust_data, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_add_tls_certificate_with_http_info(org_id, project_id, certificate_id, tls_trust_data, opts)
      data
    end

    # Add a New Certificate
    # Adds a new private-public certificate and, optionally, a private key that can be applied to one of the user-facing components (appliance management or edge). The certificate and the key should be stored in PEM format. If no private key is provided, the certificate is used as a client certificate in the trust store. A private key can be uploaded for a CA certificate only if the \&quot;purpose\&quot; parameter is set to \&quot;signing-ca\&quot;. A certificate chain will not be expanded into separate certificate instances for reference, but would be pushed to the enforcement point as a single certificate. This PUT method does not modify an existing certificate. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param certificate_id 
    # @param tls_trust_data 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TlsCertificate, Fixnum, Hash)>] TlsCertificate data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_add_tls_certificate_with_http_info(org_id, project_id, certificate_id, tls_trust_data, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_add_tls_certificate ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_add_tls_certificate"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_add_tls_certificate"
      end
      # verify the required parameter 'certificate_id' is set
      if @api_client.config.client_side_validation && certificate_id.nil?
        fail ArgumentError, "Missing the required parameter 'certificate_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_add_tls_certificate"
      end
      # verify the required parameter 'tls_trust_data' is set
      if @api_client.config.client_side_validation && tls_trust_data.nil?
        fail ArgumentError, "Missing the required parameter 'tls_trust_data' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_add_tls_certificate"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/certificates/{certificate-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'certificate-id' + '}', certificate_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tls_trust_data)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_add_tls_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Add a New Certificate
    # Adds a new private-public certificate and, optionally, a private key that can be applied to one of the user-facing components (appliance management or edge). The certificate and the key should be stored in PEM format. If no private key is provided, the certificate is used as a client certificate in the trust store. A private key can be uploaded for a CA certificate only if the \"purpose\" parameter is set to \"signing-ca\". A certificate chain will not be expanded into separate certificate instances for reference, but would be pushed to the enforcement point as a single certificate. This PUT method does not modify an existing certificate. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param certificate_id 
    # @param tls_trust_data 
    # @param [Hash] opts the optional parameters
    # @return [TlsCertificate]
    def orgs_org_id_projects_project_id_infra_add_tls_certificate_0(org_id, project_id, certificate_id, tls_trust_data, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_add_tls_certificate_0_with_http_info(org_id, project_id, certificate_id, tls_trust_data, opts)
      data
    end

    # Add a New Certificate
    # Adds a new private-public certificate and, optionally, a private key that can be applied to one of the user-facing components (appliance management or edge). The certificate and the key should be stored in PEM format. If no private key is provided, the certificate is used as a client certificate in the trust store. A private key can be uploaded for a CA certificate only if the \&quot;purpose\&quot; parameter is set to \&quot;signing-ca\&quot;. A certificate chain will not be expanded into separate certificate instances for reference, but would be pushed to the enforcement point as a single certificate. This PUT method does not modify an existing certificate. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param certificate_id 
    # @param tls_trust_data 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TlsCertificate, Fixnum, Hash)>] TlsCertificate data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_add_tls_certificate_0_with_http_info(org_id, project_id, certificate_id, tls_trust_data, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_add_tls_certificate_0 ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_add_tls_certificate_0"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_add_tls_certificate_0"
      end
      # verify the required parameter 'certificate_id' is set
      if @api_client.config.client_side_validation && certificate_id.nil?
        fail ArgumentError, "Missing the required parameter 'certificate_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_add_tls_certificate_0"
      end
      # verify the required parameter 'tls_trust_data' is set
      if @api_client.config.client_side_validation && tls_trust_data.nil?
        fail ArgumentError, "Missing the required parameter 'tls_trust_data' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_add_tls_certificate_0"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/certificates/{certificate-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'certificate-id' + '}', certificate_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tls_trust_data)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_add_tls_certificate_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or patch a Certificate Revocation List
    # Create or patch a Certificate Revocation List for the given id. The CRL is used to verify the client certificate status against the revocation lists published by the CA. For this reason, the administrator needs to add the CRL in certificate repository as well. The CRL must contain PEM data for a single CRL. A CRL can be in the PEM X.509 format (crl_type=X509) or JSON OneCRL (crl_type=OneCRL). If crl_type is not specified, it is auto-detected based on the presence of fields pem_encoded or one_crl. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param crl_id 
    # @param tls_crl 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_create_or_patch_tls_crl(org_id, project_id, crl_id, tls_crl, opts = {})
      orgs_org_id_projects_project_id_infra_create_or_patch_tls_crl_with_http_info(org_id, project_id, crl_id, tls_crl, opts)
      nil
    end

    # Create or patch a Certificate Revocation List
    # Create or patch a Certificate Revocation List for the given id. The CRL is used to verify the client certificate status against the revocation lists published by the CA. For this reason, the administrator needs to add the CRL in certificate repository as well. The CRL must contain PEM data for a single CRL. A CRL can be in the PEM X.509 format (crl_type&#x3D;X509) or JSON OneCRL (crl_type&#x3D;OneCRL). If crl_type is not specified, it is auto-detected based on the presence of fields pem_encoded or one_crl. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param crl_id 
    # @param tls_crl 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_or_patch_tls_crl_with_http_info(org_id, project_id, crl_id, tls_crl, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_create_or_patch_tls_crl ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_create_or_patch_tls_crl"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_create_or_patch_tls_crl"
      end
      # verify the required parameter 'crl_id' is set
      if @api_client.config.client_side_validation && crl_id.nil?
        fail ArgumentError, "Missing the required parameter 'crl_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_create_or_patch_tls_crl"
      end
      # verify the required parameter 'tls_crl' is set
      if @api_client.config.client_side_validation && tls_crl.nil?
        fail ArgumentError, "Missing the required parameter 'tls_crl' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_create_or_patch_tls_crl"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/crls/{crl-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'crl-id' + '}', crl_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tls_crl)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_create_or_patch_tls_crl\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or fully replace a Certificate Revocation List
    # Create or replace a Certificate Revocation List for the given id. The CRL is used to verify the client certificate status against the revocation lists published by the CA. For this reason, the administrator needs to add the CRL in certificate repository as well. The CRL must contain PEM data for a single CRL. Revision is required. A CRL can be in the PEM X.509 format (crl_type=X509) or JSON OneCRL (crl_type=OneCRL). If crl_type is not specified, it is auto-detected based on the presence of fields pem_encoded or one_crl. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param crl_id 
    # @param tls_crl 
    # @param [Hash] opts the optional parameters
    # @return [TlsCrl]
    def orgs_org_id_projects_project_id_infra_create_or_update_tls_crl(org_id, project_id, crl_id, tls_crl, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_create_or_update_tls_crl_with_http_info(org_id, project_id, crl_id, tls_crl, opts)
      data
    end

    # Create or fully replace a Certificate Revocation List
    # Create or replace a Certificate Revocation List for the given id. The CRL is used to verify the client certificate status against the revocation lists published by the CA. For this reason, the administrator needs to add the CRL in certificate repository as well. The CRL must contain PEM data for a single CRL. Revision is required. A CRL can be in the PEM X.509 format (crl_type&#x3D;X509) or JSON OneCRL (crl_type&#x3D;OneCRL). If crl_type is not specified, it is auto-detected based on the presence of fields pem_encoded or one_crl. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param crl_id 
    # @param tls_crl 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TlsCrl, Fixnum, Hash)>] TlsCrl data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_or_update_tls_crl_with_http_info(org_id, project_id, crl_id, tls_crl, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_create_or_update_tls_crl ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_create_or_update_tls_crl"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_create_or_update_tls_crl"
      end
      # verify the required parameter 'crl_id' is set
      if @api_client.config.client_side_validation && crl_id.nil?
        fail ArgumentError, "Missing the required parameter 'crl_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_create_or_update_tls_crl"
      end
      # verify the required parameter 'tls_crl' is set
      if @api_client.config.client_side_validation && tls_crl.nil?
        fail ArgumentError, "Missing the required parameter 'tls_crl' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_create_or_update_tls_crl"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/crls/{crl-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'crl-id' + '}', crl_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tls_crl)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCrl')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_create_or_update_tls_crl\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create a new Certificate Revocation List
    # Adds a new certificate revocation list (CRLs). The CRL is used to verify the client certificate status against the revocation lists published by the CA. For this reason, the administrator needs to add the CRL in certificate repository as well. A CRL can be in the PEM X.509 format (crl_type=X509) or JSON OneCRL (crl_type=OneCRL). If crl_type is not specified, it is auto-detected based on the presence of fields pem_encoded or one_crl. An X.509 CRL can contain a single CRL or multiple CRLs depending on the PEM data. - Single CRL: a single CRL is created with the given id. - Composite CRL: multiple CRLs are generated. Each of the CRL is created with an id generated based on the given id. First CRL is created with crl-id, second with crl-id-1, third with crl-id-2, etc. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param crl_id 
    # @param tls_crl 
    # @param [Hash] opts the optional parameters
    # @return [TlsCrlListResult]
    def orgs_org_id_projects_project_id_infra_create_tls_crl(org_id, project_id, crl_id, tls_crl, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_create_tls_crl_with_http_info(org_id, project_id, crl_id, tls_crl, opts)
      data
    end

    # Create a new Certificate Revocation List
    # Adds a new certificate revocation list (CRLs). The CRL is used to verify the client certificate status against the revocation lists published by the CA. For this reason, the administrator needs to add the CRL in certificate repository as well. A CRL can be in the PEM X.509 format (crl_type&#x3D;X509) or JSON OneCRL (crl_type&#x3D;OneCRL). If crl_type is not specified, it is auto-detected based on the presence of fields pem_encoded or one_crl. An X.509 CRL can contain a single CRL or multiple CRLs depending on the PEM data. - Single CRL: a single CRL is created with the given id. - Composite CRL: multiple CRLs are generated. Each of the CRL is created with an id generated based on the given id. First CRL is created with crl-id, second with crl-id-1, third with crl-id-2, etc. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param crl_id 
    # @param tls_crl 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TlsCrlListResult, Fixnum, Hash)>] TlsCrlListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_tls_crl_with_http_info(org_id, project_id, crl_id, tls_crl, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_create_tls_crl ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_create_tls_crl"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_create_tls_crl"
      end
      # verify the required parameter 'crl_id' is set
      if @api_client.config.client_side_validation && crl_id.nil?
        fail ArgumentError, "Missing the required parameter 'crl_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_create_tls_crl"
      end
      # verify the required parameter 'tls_crl' is set
      if @api_client.config.client_side_validation && tls_crl.nil?
        fail ArgumentError, "Missing the required parameter 'tls_crl' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_create_tls_crl"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/crls/{crl-id}?action=import'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'crl-id' + '}', crl_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tls_crl)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCrlListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_create_tls_crl\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Certificate for the Given Certificate ID
    # Removes the specified certificate. The private key associated with the certificate is also deleted. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param certificate_id ID of certificate to delete
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_tls_certificate(org_id, project_id, certificate_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_tls_certificate_with_http_info(org_id, project_id, certificate_id, opts)
      nil
    end

    # Delete Certificate for the Given Certificate ID
    # Removes the specified certificate. The private key associated with the certificate is also deleted. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param certificate_id ID of certificate to delete
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_tls_certificate_with_http_info(org_id, project_id, certificate_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_delete_tls_certificate ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_delete_tls_certificate"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_delete_tls_certificate"
      end
      # verify the required parameter 'certificate_id' is set
      if @api_client.config.client_side_validation && certificate_id.nil?
        fail ArgumentError, "Missing the required parameter 'certificate_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_delete_tls_certificate"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/certificates/{certificate-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'certificate-id' + '}', certificate_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_delete_tls_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Certificate for the Given Certificate ID
    # Removes the specified certificate. The private key associated with the certificate is also deleted. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param certificate_id ID of certificate to delete
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_tls_certificate_0(org_id, project_id, certificate_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_tls_certificate_0_with_http_info(org_id, project_id, certificate_id, opts)
      nil
    end

    # Delete Certificate for the Given Certificate ID
    # Removes the specified certificate. The private key associated with the certificate is also deleted. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param certificate_id ID of certificate to delete
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_tls_certificate_0_with_http_info(org_id, project_id, certificate_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_delete_tls_certificate_0 ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_delete_tls_certificate_0"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_delete_tls_certificate_0"
      end
      # verify the required parameter 'certificate_id' is set
      if @api_client.config.client_side_validation && certificate_id.nil?
        fail ArgumentError, "Missing the required parameter 'certificate_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_delete_tls_certificate_0"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/certificates/{certificate-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'certificate-id' + '}', certificate_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_delete_tls_certificate_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a CRL
    # Deletes an existing CRL.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param crl_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_tls_crl(org_id, project_id, crl_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_tls_crl_with_http_info(org_id, project_id, crl_id, opts)
      nil
    end

    # Delete a CRL
    # Deletes an existing CRL.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param crl_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_tls_crl_with_http_info(org_id, project_id, crl_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_delete_tls_crl ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_delete_tls_crl"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_delete_tls_crl"
      end
      # verify the required parameter 'crl_id' is set
      if @api_client.config.client_side_validation && crl_id.nil?
        fail ArgumentError, "Missing the required parameter 'crl_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_delete_tls_crl"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/crls/{crl-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'crl-id' + '}', crl_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_delete_tls_crl\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a CSR
    # Removes a specified CSR. If a CSR is not used for verification, you can delete it. Note that the CSR import and upload POST actions automatically delete the associated CSR. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param csr_id ID of CSR to delete
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_tls_csr(org_id, project_id, csr_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_tls_csr_with_http_info(org_id, project_id, csr_id, opts)
      nil
    end

    # Delete a CSR
    # Removes a specified CSR. If a CSR is not used for verification, you can delete it. Note that the CSR import and upload POST actions automatically delete the associated CSR. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param csr_id ID of CSR to delete
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_tls_csr_with_http_info(org_id, project_id, csr_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_delete_tls_csr ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_delete_tls_csr"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_delete_tls_csr"
      end
      # verify the required parameter 'csr_id' is set
      if @api_client.config.client_side_validation && csr_id.nil?
        fail ArgumentError, "Missing the required parameter 'csr_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_delete_tls_csr"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/csrs/{csr-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'csr-id' + '}', csr_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_delete_tls_csr\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Generate a new self-signed certificate
    # Creates a new self-signed certificate. A private key is also created at the same time. This is convenience call that will generate a CSR and then self-sign it. The maximum validity limit for non-CA certificates is 825 days, except that values of 3,650 and 36,500 days are allowed. No limit is set for CA certificates. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tls_csr_with_days_valid 
    # @param [Hash] opts the optional parameters
    # @return [TlsCertificate]
    def orgs_org_id_projects_project_id_infra_generate_self_signed_tls_certificate(org_id, project_id, tls_csr_with_days_valid, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_generate_self_signed_tls_certificate_with_http_info(org_id, project_id, tls_csr_with_days_valid, opts)
      data
    end

    # Generate a new self-signed certificate
    # Creates a new self-signed certificate. A private key is also created at the same time. This is convenience call that will generate a CSR and then self-sign it. The maximum validity limit for non-CA certificates is 825 days, except that values of 3,650 and 36,500 days are allowed. No limit is set for CA certificates. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tls_csr_with_days_valid 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TlsCertificate, Fixnum, Hash)>] TlsCertificate data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_generate_self_signed_tls_certificate_with_http_info(org_id, project_id, tls_csr_with_days_valid, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_generate_self_signed_tls_certificate ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_generate_self_signed_tls_certificate"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_generate_self_signed_tls_certificate"
      end
      # verify the required parameter 'tls_csr_with_days_valid' is set
      if @api_client.config.client_side_validation && tls_csr_with_days_valid.nil?
        fail ArgumentError, "Missing the required parameter 'tls_csr_with_days_valid' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_generate_self_signed_tls_certificate"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/csrs?action=self_sign'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tls_csr_with_days_valid)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_generate_self_signed_tls_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Generate a New Certificate Signing Request
    # Creates a new certificate signing request (CSR). A CSR is encrypted text that contains information about your organization (organization name, country, and so on) and your Web server's public key, which is a public certificate the is generated on the server that can be used to forward this request to a certificate authority (CA). A private key is also usually created at the same time as the CSR. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param csr_id ID of CSR to create
    # @param tls_csr 
    # @param [Hash] opts the optional parameters
    # @return [TlsCsr]
    def orgs_org_id_projects_project_id_infra_generate_tls_csr(org_id, project_id, csr_id, tls_csr, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_generate_tls_csr_with_http_info(org_id, project_id, csr_id, tls_csr, opts)
      data
    end

    # Generate a New Certificate Signing Request
    # Creates a new certificate signing request (CSR). A CSR is encrypted text that contains information about your organization (organization name, country, and so on) and your Web server&#39;s public key, which is a public certificate the is generated on the server that can be used to forward this request to a certificate authority (CA). A private key is also usually created at the same time as the CSR. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param csr_id ID of CSR to create
    # @param tls_csr 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TlsCsr, Fixnum, Hash)>] TlsCsr data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_generate_tls_csr_with_http_info(org_id, project_id, csr_id, tls_csr, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_generate_tls_csr ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_generate_tls_csr"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_generate_tls_csr"
      end
      # verify the required parameter 'csr_id' is set
      if @api_client.config.client_side_validation && csr_id.nil?
        fail ArgumentError, "Missing the required parameter 'csr_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_generate_tls_csr"
      end
      # verify the required parameter 'tls_csr' is set
      if @api_client.config.client_side_validation && tls_csr.nil?
        fail ArgumentError, "Missing the required parameter 'tls_csr' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_generate_tls_csr"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/csrs/{csr-id}?action=create'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'csr-id' + '}', csr_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tls_csr)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCsr')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_generate_tls_csr\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Show Certificate Data for the Given Certificate ID
    # Returns information for the specified certificate ID, including the certificate's id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details=true modifier at the end of the request URI. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param certificate_id ID of certificate to read
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details (default to false)
    # @return [TlsCertificate]
    def orgs_org_id_projects_project_id_infra_get_tls_certificate(org_id, project_id, certificate_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tls_certificate_with_http_info(org_id, project_id, certificate_id, opts)
      data
    end

    # Show Certificate Data for the Given Certificate ID
    # Returns information for the specified certificate ID, including the certificate&#39;s id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details&#x3D;true modifier at the end of the request URI. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param certificate_id ID of certificate to read
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details
    # @return [Array<(TlsCertificate, Fixnum, Hash)>] TlsCertificate data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tls_certificate_with_http_info(org_id, project_id, certificate_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_get_tls_certificate ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_get_tls_certificate"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_get_tls_certificate"
      end
      # verify the required parameter 'certificate_id' is set
      if @api_client.config.client_side_validation && certificate_id.nil?
        fail ArgumentError, "Missing the required parameter 'certificate_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_get_tls_certificate"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/certificates/{certificate-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'certificate-id' + '}', certificate_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'details'] = opts[:'details'] if !opts[:'details'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_get_tls_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Show Certificate Data for the Given Certificate ID
    # Returns information for the specified certificate ID, including the certificate's id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details=true modifier at the end of the request URI. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param certificate_id ID of certificate to read
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details (default to false)
    # @return [TlsCertificate]
    def orgs_org_id_projects_project_id_infra_get_tls_certificate_0(org_id, project_id, certificate_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tls_certificate_0_with_http_info(org_id, project_id, certificate_id, opts)
      data
    end

    # Show Certificate Data for the Given Certificate ID
    # Returns information for the specified certificate ID, including the certificate&#39;s id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details&#x3D;true modifier at the end of the request URI. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param certificate_id ID of certificate to read
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details
    # @return [Array<(TlsCertificate, Fixnum, Hash)>] TlsCertificate data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tls_certificate_0_with_http_info(org_id, project_id, certificate_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_get_tls_certificate_0 ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_get_tls_certificate_0"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_get_tls_certificate_0"
      end
      # verify the required parameter 'certificate_id' is set
      if @api_client.config.client_side_validation && certificate_id.nil?
        fail ArgumentError, "Missing the required parameter 'certificate_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_get_tls_certificate_0"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/certificates/{certificate-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'certificate-id' + '}', certificate_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'details'] = opts[:'details'] if !opts[:'details'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_get_tls_certificate_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Show CRL Data for the Given CRL id.
    # Returns information about the specified CRL. For additional information, include the ?details=true modifier at the end of the request URI. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param crl_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details (default to false)
    # @return [TlsCrl]
    def orgs_org_id_projects_project_id_infra_get_tls_crl(org_id, project_id, crl_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tls_crl_with_http_info(org_id, project_id, crl_id, opts)
      data
    end

    # Show CRL Data for the Given CRL id.
    # Returns information about the specified CRL. For additional information, include the ?details&#x3D;true modifier at the end of the request URI. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param crl_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details
    # @return [Array<(TlsCrl, Fixnum, Hash)>] TlsCrl data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tls_crl_with_http_info(org_id, project_id, crl_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_get_tls_crl ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_get_tls_crl"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_get_tls_crl"
      end
      # verify the required parameter 'crl_id' is set
      if @api_client.config.client_side_validation && crl_id.nil?
        fail ArgumentError, "Missing the required parameter 'crl_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_get_tls_crl"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/crls/{crl-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'crl-id' + '}', crl_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'details'] = opts[:'details'] if !opts[:'details'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCrl')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_get_tls_crl\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Show CSR Data for the Given CSR ID
    # Returns information about the specified CSR.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param csr_id ID of CSR to read
    # @param [Hash] opts the optional parameters
    # @return [TlsCsr]
    def orgs_org_id_projects_project_id_infra_get_tls_csr(org_id, project_id, csr_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tls_csr_with_http_info(org_id, project_id, csr_id, opts)
      data
    end

    # Show CSR Data for the Given CSR ID
    # Returns information about the specified CSR.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param csr_id ID of CSR to read
    # @param [Hash] opts the optional parameters
    # @return [Array<(TlsCsr, Fixnum, Hash)>] TlsCsr data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tls_csr_with_http_info(org_id, project_id, csr_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_get_tls_csr ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_get_tls_csr"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_get_tls_csr"
      end
      # verify the required parameter 'csr_id' is set
      if @api_client.config.client_side_validation && csr_id.nil?
        fail ArgumentError, "Missing the required parameter 'csr_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_get_tls_csr"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/csrs/{csr-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'csr-id' + '}', csr_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCsr')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_get_tls_csr\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get CSR PEM File for the Given CSR ID
    # Downloads the CSR PEM file for a specified CSR. Clients must include an Accept: text/plain request header.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param csr_id ID of CSR to read
    # @param [Hash] opts the optional parameters
    # @return [String]
    def orgs_org_id_projects_project_id_infra_get_tls_csr_pem(org_id, project_id, csr_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tls_csr_pem_with_http_info(org_id, project_id, csr_id, opts)
      data
    end

    # Get CSR PEM File for the Given CSR ID
    # Downloads the CSR PEM file for a specified CSR. Clients must include an Accept: text/plain request header.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param csr_id ID of CSR to read
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Fixnum, Hash)>] String data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tls_csr_pem_with_http_info(org_id, project_id, csr_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_get_tls_csr_pem ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_get_tls_csr_pem"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_get_tls_csr_pem"
      end
      # verify the required parameter 'csr_id' is set
      if @api_client.config.client_side_validation && csr_id.nil?
        fail ArgumentError, "Missing the required parameter 'csr_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_get_tls_csr_pem"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/csrs/{csr-id}/pem-file'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'csr-id' + '}', csr_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/plain;charset=UTF-8'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'String')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_get_tls_csr_pem\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Import a Certificate Associated with an Approved CSR
    # Imports a certificate authority (CA)-signed certificate for a CSR. This action links the certificate to the private key created by the CSR. The pem_encoded string in the request body is the signed certificate provided by your CA in response to the CSR that you provide to them. The import POST action automatically deletes the associated CSR. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param csr_id CSR this certificate is associated with
    # @param tls_trust_data 
    # @param [Hash] opts the optional parameters
    # @return [TlsCertificate]
    def orgs_org_id_projects_project_id_infra_import_signed_tls_certificate(org_id, project_id, csr_id, tls_trust_data, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_import_signed_tls_certificate_with_http_info(org_id, project_id, csr_id, tls_trust_data, opts)
      data
    end

    # Import a Certificate Associated with an Approved CSR
    # Imports a certificate authority (CA)-signed certificate for a CSR. This action links the certificate to the private key created by the CSR. The pem_encoded string in the request body is the signed certificate provided by your CA in response to the CSR that you provide to them. The import POST action automatically deletes the associated CSR. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param csr_id CSR this certificate is associated with
    # @param tls_trust_data 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TlsCertificate, Fixnum, Hash)>] TlsCertificate data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_import_signed_tls_certificate_with_http_info(org_id, project_id, csr_id, tls_trust_data, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_import_signed_tls_certificate ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_import_signed_tls_certificate"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_import_signed_tls_certificate"
      end
      # verify the required parameter 'csr_id' is set
      if @api_client.config.client_side_validation && csr_id.nil?
        fail ArgumentError, "Missing the required parameter 'csr_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_import_signed_tls_certificate"
      end
      # verify the required parameter 'tls_trust_data' is set
      if @api_client.config.client_side_validation && tls_trust_data.nil?
        fail ArgumentError, "Missing the required parameter 'tls_trust_data' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_import_signed_tls_certificate"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/csrs/{csr-id}?action=import'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'csr-id' + '}', csr_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tls_trust_data)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_import_signed_tls_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Return All the User-Facing Components' Certificates
    # Returns all certificate information viewable by the user, including each certificate's id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details=true modifier at the end of the request URI. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [TlsCertificateList]
    def orgs_org_id_projects_project_id_infra_list_tls_certificates(org_id, project_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_tls_certificates_with_http_info(org_id, project_id, opts)
      data
    end

    # Return All the User-Facing Components&#39; Certificates
    # Returns all certificate information viewable by the user, including each certificate&#39;s id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details&#x3D;true modifier at the end of the request URI. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [Array<(TlsCertificateList, Fixnum, Hash)>] TlsCertificateList data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_tls_certificates_with_http_info(org_id, project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_list_tls_certificates ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_list_tls_certificates"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_list_tls_certificates"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.orgs_org_id_projects_project_id_infra_list_tls_certificates, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.orgs_org_id_projects_project_id_infra_list_tls_certificates, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['cluster_api_certificate', 'api_certificate'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of cluster_api_certificate, api_certificate'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/certificates'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'details'] = opts[:'details'] if !opts[:'details'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'node_id'] = opts[:'node_id'] if !opts[:'node_id'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificateList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_list_tls_certificates\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Return All the User-Facing Components' Certificates
    # Returns all certificate information viewable by the user, including each certificate's id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details=true modifier at the end of the request URI. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [TlsCertificateList]
    def orgs_org_id_projects_project_id_infra_list_tls_certificates_0(org_id, project_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_tls_certificates_0_with_http_info(org_id, project_id, opts)
      data
    end

    # Return All the User-Facing Components&#39; Certificates
    # Returns all certificate information viewable by the user, including each certificate&#39;s id; pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details&#x3D;true modifier at the end of the request URI. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [Array<(TlsCertificateList, Fixnum, Hash)>] TlsCertificateList data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_tls_certificates_0_with_http_info(org_id, project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_list_tls_certificates_0 ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_list_tls_certificates_0"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_list_tls_certificates_0"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.orgs_org_id_projects_project_id_infra_list_tls_certificates_0, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.orgs_org_id_projects_project_id_infra_list_tls_certificates_0, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['cluster_api_certificate', 'api_certificate'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of cluster_api_certificate, api_certificate'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/certificates'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'details'] = opts[:'details'] if !opts[:'details'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'node_id'] = opts[:'node_id'] if !opts[:'node_id'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificateList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_list_tls_certificates_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Return All Added CRLs
    # Returns information about all CRLs. For additional information, include the ?details=true modifier at the end of the request URI. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [TlsCrlListResult]
    def orgs_org_id_projects_project_id_infra_list_tls_crls(org_id, project_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_tls_crls_with_http_info(org_id, project_id, opts)
      data
    end

    # Return All Added CRLs
    # Returns information about all CRLs. For additional information, include the ?details&#x3D;true modifier at the end of the request URI. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :details whether to expand the pem data and show all its details
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_id Node ID of certificate to return
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :type Type of certificate to return
    # @return [Array<(TlsCrlListResult, Fixnum, Hash)>] TlsCrlListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_tls_crls_with_http_info(org_id, project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_list_tls_crls ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_list_tls_crls"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_list_tls_crls"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.orgs_org_id_projects_project_id_infra_list_tls_crls, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.orgs_org_id_projects_project_id_infra_list_tls_crls, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'type'] && !['cluster_api_certificate', 'api_certificate'].include?(opts[:'type'])
        fail ArgumentError, 'invalid value for "type", must be one of cluster_api_certificate, api_certificate'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/crls'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'details'] = opts[:'details'] if !opts[:'details'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'node_id'] = opts[:'node_id'] if !opts[:'node_id'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCrlListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_list_tls_crls\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Return All the Generated CSRs
    # Returns information about all of the CSRs that have been created.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [TlsCsrListResult]
    def orgs_org_id_projects_project_id_infra_list_tls_csrs(org_id, project_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_tls_csrs_with_http_info(org_id, project_id, opts)
      data
    end

    # Return All the Generated CSRs
    # Returns information about all of the CSRs that have been created.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(TlsCsrListResult, Fixnum, Hash)>] TlsCsrListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_tls_csrs_with_http_info(org_id, project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_list_tls_csrs ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_list_tls_csrs"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_list_tls_csrs"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.orgs_org_id_projects_project_id_infra_list_tls_csrs, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling CertificatesApi.orgs_org_id_projects_project_id_infra_list_tls_csrs, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/csrs'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCsrListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_list_tls_csrs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Add a New Certificate
    # Adds a new private-public certificate and, optionally, a private key that can be applied to one of the user-facing components (appliance management or edge). The certificate and the key should be stored in PEM format. If no private key is provided, the certificate is used as a client certificate in the trust store. A private key can be uploaded for a CA certificate only if the \"purpose\" parameter is set to \"signing-ca\". A certificate chain will not be expanded into separate certificate instances for reference, but would be pushed to the enforcement point as a single certificate.  This patch method does not modify an existing certificate. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param certificate_id 
    # @param tls_trust_data 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_tls_certificate(org_id, project_id, certificate_id, tls_trust_data, opts = {})
      orgs_org_id_projects_project_id_infra_patch_tls_certificate_with_http_info(org_id, project_id, certificate_id, tls_trust_data, opts)
      nil
    end

    # Add a New Certificate
    # Adds a new private-public certificate and, optionally, a private key that can be applied to one of the user-facing components (appliance management or edge). The certificate and the key should be stored in PEM format. If no private key is provided, the certificate is used as a client certificate in the trust store. A private key can be uploaded for a CA certificate only if the \&quot;purpose\&quot; parameter is set to \&quot;signing-ca\&quot;. A certificate chain will not be expanded into separate certificate instances for reference, but would be pushed to the enforcement point as a single certificate.  This patch method does not modify an existing certificate. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param certificate_id 
    # @param tls_trust_data 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_tls_certificate_with_http_info(org_id, project_id, certificate_id, tls_trust_data, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_patch_tls_certificate ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_patch_tls_certificate"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_patch_tls_certificate"
      end
      # verify the required parameter 'certificate_id' is set
      if @api_client.config.client_side_validation && certificate_id.nil?
        fail ArgumentError, "Missing the required parameter 'certificate_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_patch_tls_certificate"
      end
      # verify the required parameter 'tls_trust_data' is set
      if @api_client.config.client_side_validation && tls_trust_data.nil?
        fail ArgumentError, "Missing the required parameter 'tls_trust_data' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_patch_tls_certificate"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/certificates/{certificate-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'certificate-id' + '}', certificate_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tls_trust_data)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_patch_tls_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Add a New Certificate
    # Adds a new private-public certificate and, optionally, a private key that can be applied to one of the user-facing components (appliance management or edge). The certificate and the key should be stored in PEM format. If no private key is provided, the certificate is used as a client certificate in the trust store. A private key can be uploaded for a CA certificate only if the \"purpose\" parameter is set to \"signing-ca\". A certificate chain will not be expanded into separate certificate instances for reference, but would be pushed to the enforcement point as a single certificate.  This patch method does not modify an existing certificate. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param certificate_id 
    # @param tls_trust_data 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_tls_certificate_0(org_id, project_id, certificate_id, tls_trust_data, opts = {})
      orgs_org_id_projects_project_id_infra_patch_tls_certificate_0_with_http_info(org_id, project_id, certificate_id, tls_trust_data, opts)
      nil
    end

    # Add a New Certificate
    # Adds a new private-public certificate and, optionally, a private key that can be applied to one of the user-facing components (appliance management or edge). The certificate and the key should be stored in PEM format. If no private key is provided, the certificate is used as a client certificate in the trust store. A private key can be uploaded for a CA certificate only if the \&quot;purpose\&quot; parameter is set to \&quot;signing-ca\&quot;. A certificate chain will not be expanded into separate certificate instances for reference, but would be pushed to the enforcement point as a single certificate.  This patch method does not modify an existing certificate. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param certificate_id 
    # @param tls_trust_data 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_tls_certificate_0_with_http_info(org_id, project_id, certificate_id, tls_trust_data, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_patch_tls_certificate_0 ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_patch_tls_certificate_0"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_patch_tls_certificate_0"
      end
      # verify the required parameter 'certificate_id' is set
      if @api_client.config.client_side_validation && certificate_id.nil?
        fail ArgumentError, "Missing the required parameter 'certificate_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_patch_tls_certificate_0"
      end
      # verify the required parameter 'tls_trust_data' is set
      if @api_client.config.client_side_validation && tls_trust_data.nil?
        fail ArgumentError, "Missing the required parameter 'tls_trust_data' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_patch_tls_certificate_0"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/certificates/{certificate-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'certificate-id' + '}', certificate_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tls_trust_data)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_patch_tls_certificate_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Self-Sign the CSR
    # Self-signs the previously generated CSR. This action is similar to the import certificate action, but instead of using a public certificate signed by a CA, the self_sign POST action uses a certificate that is signed with NSX's own private key. The maximum validity limit for non-CA certificates is 825 days, except that values of 3,650 and 36,500 days are allowed. No limit is set for CA certificates. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param csr_id CSR this certificate is associated with
    # @param days_valid Number of days the certificate will be valid, default 825 days
    # @param [Hash] opts the optional parameters
    # @return [TlsCertificate]
    def orgs_org_id_projects_project_id_infra_self_sign_tls_certificate(org_id, project_id, csr_id, days_valid, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_self_sign_tls_certificate_with_http_info(org_id, project_id, csr_id, days_valid, opts)
      data
    end

    # Self-Sign the CSR
    # Self-signs the previously generated CSR. This action is similar to the import certificate action, but instead of using a public certificate signed by a CA, the self_sign POST action uses a certificate that is signed with NSX&#39;s own private key. The maximum validity limit for non-CA certificates is 825 days, except that values of 3,650 and 36,500 days are allowed. No limit is set for CA certificates. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param csr_id CSR this certificate is associated with
    # @param days_valid Number of days the certificate will be valid, default 825 days
    # @param [Hash] opts the optional parameters
    # @return [Array<(TlsCertificate, Fixnum, Hash)>] TlsCertificate data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_self_sign_tls_certificate_with_http_info(org_id, project_id, csr_id, days_valid, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_self_sign_tls_certificate ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_self_sign_tls_certificate"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_self_sign_tls_certificate"
      end
      # verify the required parameter 'csr_id' is set
      if @api_client.config.client_side_validation && csr_id.nil?
        fail ArgumentError, "Missing the required parameter 'csr_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_self_sign_tls_certificate"
      end
      # verify the required parameter 'days_valid' is set
      if @api_client.config.client_side_validation && days_valid.nil?
        fail ArgumentError, "Missing the required parameter 'days_valid' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_self_sign_tls_certificate"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/csrs/{csr-id}?action=self_sign'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'csr-id' + '}', csr_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'days_valid'] = days_valid

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_self_sign_tls_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Upload the Certificate PEM File Signed by the CA Associated with a CSR
    # Uploads the certificate authority (CA)-signed certificate. After you send the certificate request to the CA of your choice, and the CA sends back the signed certificate, you can use the upload POST action to upload the signed certificate. The upload action is similar to the import action, but the upload action allows you to directly upload the PEM-encoded file (signed certificate) provided by the CA. Like the import POST action, the upload POST action automatically deletes the associated CSR. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param csr_id ID of the CSR to read
    # @param file File to be uploaded
    # @param [Hash] opts the optional parameters
    # @option opts [String] :description Description of this resource
    # @option opts [String] :display_name Identifier to use when displaying entity in logs or GUI
    # @return [TlsCertificate]
    def orgs_org_id_projects_project_id_infra_upload_pem_signed_tls_certificate(org_id, project_id, csr_id, file, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_upload_pem_signed_tls_certificate_with_http_info(org_id, project_id, csr_id, file, opts)
      data
    end

    # Upload the Certificate PEM File Signed by the CA Associated with a CSR
    # Uploads the certificate authority (CA)-signed certificate. After you send the certificate request to the CA of your choice, and the CA sends back the signed certificate, you can use the upload POST action to upload the signed certificate. The upload action is similar to the import action, but the upload action allows you to directly upload the PEM-encoded file (signed certificate) provided by the CA. Like the import POST action, the upload POST action automatically deletes the associated CSR. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param csr_id ID of the CSR to read
    # @param file File to be uploaded
    # @param [Hash] opts the optional parameters
    # @option opts [String] :description Description of this resource
    # @option opts [String] :display_name Identifier to use when displaying entity in logs or GUI
    # @return [Array<(TlsCertificate, Fixnum, Hash)>] TlsCertificate data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_upload_pem_signed_tls_certificate_with_http_info(org_id, project_id, csr_id, file, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_upload_pem_signed_tls_certificate ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_upload_pem_signed_tls_certificate"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_upload_pem_signed_tls_certificate"
      end
      # verify the required parameter 'csr_id' is set
      if @api_client.config.client_side_validation && csr_id.nil?
        fail ArgumentError, "Missing the required parameter 'csr_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_upload_pem_signed_tls_certificate"
      end
      # verify the required parameter 'file' is set
      if @api_client.config.client_side_validation && file.nil?
        fail ArgumentError, "Missing the required parameter 'file' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_upload_pem_signed_tls_certificate"
      end
      if @api_client.config.client_side_validation && !opts[:'description'].nil? && opts[:'description'].to_s.length > 1024
        fail ArgumentError, 'invalid value for "opts[:"description"]" when calling CertificatesApi.orgs_org_id_projects_project_id_infra_upload_pem_signed_tls_certificate, the character length must be smaller than or equal to 1024.'
      end

      if @api_client.config.client_side_validation && !opts[:'display_name'].nil? && opts[:'display_name'].to_s.length > 255
        fail ArgumentError, 'invalid value for "opts[:"display_name"]" when calling CertificatesApi.orgs_org_id_projects_project_id_infra_upload_pem_signed_tls_certificate, the character length must be smaller than or equal to 255.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/csrs/{csr-id}?action=upload'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'csr-id' + '}', csr_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'description'] = opts[:'description'] if !opts[:'description'].nil?
      query_params[:'display_name'] = opts[:'display_name'] if !opts[:'display_name'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['multipart/form-data'])

      # form parameters
      form_params = {}
      form_params['file'] = file

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_upload_pem_signed_tls_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Upload a new or updated Certificate Revocation List
    # Adds or replaces a certificate revocation list (CRLs). The CRL is used to verify the client certificate status against the revocation lists published by the CA. For this reason, the administrator needs to add the CRL in certificate repository as well. A CRL can be in the PEM X.509 format (crl_type=X509) or JSON OneCRL (crl_type=OneCRL). If crl_type is not specified, it is auto-detected based on the upload content. An X.509 CRL can contain a single CRL or multiple CRLs depending on the PEM data. - Single CRL: a single CRL is created with the given id. - Composite CRL: multiple CRLs are generated. Each of the CRL is created with an id generated based on the given id. First CRL is created with crl-id, second with crl-id-1, third with crl-id-2, etc. Differently from action=import, this method allows multi-part upload of the CRL(s). The TlsCrl resource returned in the body of the response will have an empty pem_encoded field, as it may be large. Use a GET request to retrieve the PEM-encoded CRL. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param crl_id 
    # @param file File to be uploaded
    # @param [Hash] opts the optional parameters
    # @option opts [String] :crl_type Type of CRL (default to X509)
    # @option opts [String] :description Description of this resource
    # @option opts [String] :display_name Identifier to use when displaying entity in logs or GUI
    # @return [TlsCrl]
    def orgs_org_id_projects_project_id_infra_upload_tls_crl(org_id, project_id, crl_id, file, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_upload_tls_crl_with_http_info(org_id, project_id, crl_id, file, opts)
      data
    end

    # Upload a new or updated Certificate Revocation List
    # Adds or replaces a certificate revocation list (CRLs). The CRL is used to verify the client certificate status against the revocation lists published by the CA. For this reason, the administrator needs to add the CRL in certificate repository as well. A CRL can be in the PEM X.509 format (crl_type&#x3D;X509) or JSON OneCRL (crl_type&#x3D;OneCRL). If crl_type is not specified, it is auto-detected based on the upload content. An X.509 CRL can contain a single CRL or multiple CRLs depending on the PEM data. - Single CRL: a single CRL is created with the given id. - Composite CRL: multiple CRLs are generated. Each of the CRL is created with an id generated based on the given id. First CRL is created with crl-id, second with crl-id-1, third with crl-id-2, etc. Differently from action&#x3D;import, this method allows multi-part upload of the CRL(s). The TlsCrl resource returned in the body of the response will have an empty pem_encoded field, as it may be large. Use a GET request to retrieve the PEM-encoded CRL. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param crl_id 
    # @param file File to be uploaded
    # @param [Hash] opts the optional parameters
    # @option opts [String] :crl_type Type of CRL
    # @option opts [String] :description Description of this resource
    # @option opts [String] :display_name Identifier to use when displaying entity in logs or GUI
    # @return [Array<(TlsCrl, Fixnum, Hash)>] TlsCrl data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_upload_tls_crl_with_http_info(org_id, project_id, crl_id, file, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.orgs_org_id_projects_project_id_infra_upload_tls_crl ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_upload_tls_crl"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_upload_tls_crl"
      end
      # verify the required parameter 'crl_id' is set
      if @api_client.config.client_side_validation && crl_id.nil?
        fail ArgumentError, "Missing the required parameter 'crl_id' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_upload_tls_crl"
      end
      # verify the required parameter 'file' is set
      if @api_client.config.client_side_validation && file.nil?
        fail ArgumentError, "Missing the required parameter 'file' when calling CertificatesApi.orgs_org_id_projects_project_id_infra_upload_tls_crl"
      end
      if @api_client.config.client_side_validation && opts[:'crl_type'] && !['OneCRL', 'X509'].include?(opts[:'crl_type'])
        fail ArgumentError, 'invalid value for "crl_type", must be one of OneCRL, X509'
      end
      if @api_client.config.client_side_validation && !opts[:'description'].nil? && opts[:'description'].to_s.length > 1024
        fail ArgumentError, 'invalid value for "opts[:"description"]" when calling CertificatesApi.orgs_org_id_projects_project_id_infra_upload_tls_crl, the character length must be smaller than or equal to 1024.'
      end

      if @api_client.config.client_side_validation && !opts[:'display_name'].nil? && opts[:'display_name'].to_s.length > 255
        fail ArgumentError, 'invalid value for "opts[:"display_name"]" when calling CertificatesApi.orgs_org_id_projects_project_id_infra_upload_tls_crl, the character length must be smaller than or equal to 255.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/crls/{crl-id}?action=upload'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'crl-id' + '}', crl_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'crl_type'] = opts[:'crl_type'] if !opts[:'crl_type'].nil?
      query_params[:'description'] = opts[:'description'] if !opts[:'description'].nil?
      query_params[:'display_name'] = opts[:'display_name'] if !opts[:'display_name'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['multipart/form-data'])

      # form parameters
      form_params = {}
      form_params['file'] = file

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCrl')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#orgs_org_id_projects_project_id_infra_upload_tls_crl\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Add a New Certificate
    # Adds a new private-public certificate and, optionally, a private key that can be applied to one of the user-facing components (appliance management or edge). The certificate and the key should be stored in PEM format. If no private key is provided, the certificate is used as a client certificate in the trust store. A private key can be uploaded for a CA certificate only if the \"purpose\" parameter is set to \"signing-ca\". A certificate chain will not be expanded into separate certificate instances for reference, but would be pushed to the enforcement point as a single certificate.  This patch method does not modify an existing certificate. 
    # @param certificate_id 
    # @param tls_trust_data 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_tls_certificate(certificate_id, tls_trust_data, opts = {})
      patch_tls_certificate_with_http_info(certificate_id, tls_trust_data, opts)
      nil
    end

    # Add a New Certificate
    # Adds a new private-public certificate and, optionally, a private key that can be applied to one of the user-facing components (appliance management or edge). The certificate and the key should be stored in PEM format. If no private key is provided, the certificate is used as a client certificate in the trust store. A private key can be uploaded for a CA certificate only if the \&quot;purpose\&quot; parameter is set to \&quot;signing-ca\&quot;. A certificate chain will not be expanded into separate certificate instances for reference, but would be pushed to the enforcement point as a single certificate.  This patch method does not modify an existing certificate. 
    # @param certificate_id 
    # @param tls_trust_data 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_tls_certificate_with_http_info(certificate_id, tls_trust_data, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.patch_tls_certificate ...'
      end
      # verify the required parameter 'certificate_id' is set
      if @api_client.config.client_side_validation && certificate_id.nil?
        fail ArgumentError, "Missing the required parameter 'certificate_id' when calling CertificatesApi.patch_tls_certificate"
      end
      # verify the required parameter 'tls_trust_data' is set
      if @api_client.config.client_side_validation && tls_trust_data.nil?
        fail ArgumentError, "Missing the required parameter 'tls_trust_data' when calling CertificatesApi.patch_tls_certificate"
      end
      # resource path
      local_var_path = '/infra/certificates/{certificate-id}'.sub('{' + 'certificate-id' + '}', certificate_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tls_trust_data)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#patch_tls_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Add a New Certificate
    # Adds a new private-public certificate and, optionally, a private key that can be applied to one of the user-facing components (appliance management or edge). The certificate and the key should be stored in PEM format. If no private key is provided, the certificate is used as a client certificate in the trust store. A private key can be uploaded for a CA certificate only if the \"purpose\" parameter is set to \"signing-ca\". A certificate chain will not be expanded into separate certificate instances for reference, but would be pushed to the enforcement point as a single certificate.  This patch method does not modify an existing certificate. 
    # @param certificate_id 
    # @param tls_trust_data 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_tls_certificate_0(certificate_id, tls_trust_data, opts = {})
      patch_tls_certificate_0_with_http_info(certificate_id, tls_trust_data, opts)
      nil
    end

    # Add a New Certificate
    # Adds a new private-public certificate and, optionally, a private key that can be applied to one of the user-facing components (appliance management or edge). The certificate and the key should be stored in PEM format. If no private key is provided, the certificate is used as a client certificate in the trust store. A private key can be uploaded for a CA certificate only if the \&quot;purpose\&quot; parameter is set to \&quot;signing-ca\&quot;. A certificate chain will not be expanded into separate certificate instances for reference, but would be pushed to the enforcement point as a single certificate.  This patch method does not modify an existing certificate. 
    # @param certificate_id 
    # @param tls_trust_data 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_tls_certificate_0_with_http_info(certificate_id, tls_trust_data, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.patch_tls_certificate_0 ...'
      end
      # verify the required parameter 'certificate_id' is set
      if @api_client.config.client_side_validation && certificate_id.nil?
        fail ArgumentError, "Missing the required parameter 'certificate_id' when calling CertificatesApi.patch_tls_certificate_0"
      end
      # verify the required parameter 'tls_trust_data' is set
      if @api_client.config.client_side_validation && tls_trust_data.nil?
        fail ArgumentError, "Missing the required parameter 'tls_trust_data' when calling CertificatesApi.patch_tls_certificate_0"
      end
      # resource path
      local_var_path = '/infra/certificates/{certificate-id}'.sub('{' + 'certificate-id' + '}', certificate_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(tls_trust_data)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#patch_tls_certificate_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Self-Sign the CSR
    # Self-signs the previously generated CSR. This action is similar to the import certificate action, but instead of using a public certificate signed by a CA, the self_sign POST action uses a certificate that is signed with NSX's own private key. The maximum validity limit for non-CA certificates is 825 days, except that values of 3,650 and 36,500 days are allowed. No limit is set for CA certificates. 
    # @param csr_id CSR this certificate is associated with
    # @param days_valid Number of days the certificate will be valid, default 825 days
    # @param [Hash] opts the optional parameters
    # @return [TlsCertificate]
    def self_sign_tls_certificate(csr_id, days_valid, opts = {})
      data, _status_code, _headers = self_sign_tls_certificate_with_http_info(csr_id, days_valid, opts)
      data
    end

    # Self-Sign the CSR
    # Self-signs the previously generated CSR. This action is similar to the import certificate action, but instead of using a public certificate signed by a CA, the self_sign POST action uses a certificate that is signed with NSX&#39;s own private key. The maximum validity limit for non-CA certificates is 825 days, except that values of 3,650 and 36,500 days are allowed. No limit is set for CA certificates. 
    # @param csr_id CSR this certificate is associated with
    # @param days_valid Number of days the certificate will be valid, default 825 days
    # @param [Hash] opts the optional parameters
    # @return [Array<(TlsCertificate, Fixnum, Hash)>] TlsCertificate data, response status code and response headers
    def self_sign_tls_certificate_with_http_info(csr_id, days_valid, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.self_sign_tls_certificate ...'
      end
      # verify the required parameter 'csr_id' is set
      if @api_client.config.client_side_validation && csr_id.nil?
        fail ArgumentError, "Missing the required parameter 'csr_id' when calling CertificatesApi.self_sign_tls_certificate"
      end
      # verify the required parameter 'days_valid' is set
      if @api_client.config.client_side_validation && days_valid.nil?
        fail ArgumentError, "Missing the required parameter 'days_valid' when calling CertificatesApi.self_sign_tls_certificate"
      end
      # resource path
      local_var_path = '/infra/csrs/{csr-id}?action=self_sign'.sub('{' + 'csr-id' + '}', csr_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'days_valid'] = days_valid

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#self_sign_tls_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Upload the Certificate PEM File Signed by the CA Associated with a CSR
    # Uploads the certificate authority (CA)-signed certificate. After you send the certificate request to the CA of your choice, and the CA sends back the signed certificate, you can use the upload POST action to upload the signed certificate. The upload action is similar to the import action, but the upload action allows you to directly upload the PEM-encoded file (signed certificate) provided by the CA. Like the import POST action, the upload POST action automatically deletes the associated CSR. 
    # @param csr_id ID of the CSR to read
    # @param file File to be uploaded
    # @param [Hash] opts the optional parameters
    # @option opts [String] :description Description of this resource
    # @option opts [String] :display_name Identifier to use when displaying entity in logs or GUI
    # @return [TlsCertificate]
    def upload_pem_signed_tls_certificate(csr_id, file, opts = {})
      data, _status_code, _headers = upload_pem_signed_tls_certificate_with_http_info(csr_id, file, opts)
      data
    end

    # Upload the Certificate PEM File Signed by the CA Associated with a CSR
    # Uploads the certificate authority (CA)-signed certificate. After you send the certificate request to the CA of your choice, and the CA sends back the signed certificate, you can use the upload POST action to upload the signed certificate. The upload action is similar to the import action, but the upload action allows you to directly upload the PEM-encoded file (signed certificate) provided by the CA. Like the import POST action, the upload POST action automatically deletes the associated CSR. 
    # @param csr_id ID of the CSR to read
    # @param file File to be uploaded
    # @param [Hash] opts the optional parameters
    # @option opts [String] :description Description of this resource
    # @option opts [String] :display_name Identifier to use when displaying entity in logs or GUI
    # @return [Array<(TlsCertificate, Fixnum, Hash)>] TlsCertificate data, response status code and response headers
    def upload_pem_signed_tls_certificate_with_http_info(csr_id, file, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.upload_pem_signed_tls_certificate ...'
      end
      # verify the required parameter 'csr_id' is set
      if @api_client.config.client_side_validation && csr_id.nil?
        fail ArgumentError, "Missing the required parameter 'csr_id' when calling CertificatesApi.upload_pem_signed_tls_certificate"
      end
      # verify the required parameter 'file' is set
      if @api_client.config.client_side_validation && file.nil?
        fail ArgumentError, "Missing the required parameter 'file' when calling CertificatesApi.upload_pem_signed_tls_certificate"
      end
      if @api_client.config.client_side_validation && !opts[:'description'].nil? && opts[:'description'].to_s.length > 1024
        fail ArgumentError, 'invalid value for "opts[:"description"]" when calling CertificatesApi.upload_pem_signed_tls_certificate, the character length must be smaller than or equal to 1024.'
      end

      if @api_client.config.client_side_validation && !opts[:'display_name'].nil? && opts[:'display_name'].to_s.length > 255
        fail ArgumentError, 'invalid value for "opts[:"display_name"]" when calling CertificatesApi.upload_pem_signed_tls_certificate, the character length must be smaller than or equal to 255.'
      end

      # resource path
      local_var_path = '/infra/csrs/{csr-id}?action=upload'.sub('{' + 'csr-id' + '}', csr_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'description'] = opts[:'description'] if !opts[:'description'].nil?
      query_params[:'display_name'] = opts[:'display_name'] if !opts[:'display_name'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['multipart/form-data'])

      # form parameters
      form_params = {}
      form_params['file'] = file

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#upload_pem_signed_tls_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Upload a new or updated Certificate Revocation List
    # Adds or replaces a certificate revocation list (CRLs). The CRL is used to verify the client certificate status against the revocation lists published by the CA. For this reason, the administrator needs to add the CRL in certificate repository as well. A CRL can be in the PEM X.509 format (crl_type=X509) or JSON OneCRL (crl_type=OneCRL). If crl_type is not specified, it is auto-detected based on the upload content. An X.509 CRL can contain a single CRL or multiple CRLs depending on the PEM data. - Single CRL: a single CRL is created with the given id. - Composite CRL: multiple CRLs are generated. Each of the CRL is created with an id generated based on the given id. First CRL is created with crl-id, second with crl-id-1, third with crl-id-2, etc. Differently from action=import, this method allows multi-part upload of the CRL(s). The TlsCrl resource returned in the body of the response will have an empty pem_encoded field, as it may be large. Use a GET request to retrieve the PEM-encoded CRL. 
    # @param crl_id 
    # @param file File to be uploaded
    # @param [Hash] opts the optional parameters
    # @option opts [String] :crl_type Type of CRL (default to X509)
    # @option opts [String] :description Description of this resource
    # @option opts [String] :display_name Identifier to use when displaying entity in logs or GUI
    # @return [TlsCrl]
    def upload_tls_crl(crl_id, file, opts = {})
      data, _status_code, _headers = upload_tls_crl_with_http_info(crl_id, file, opts)
      data
    end

    # Upload a new or updated Certificate Revocation List
    # Adds or replaces a certificate revocation list (CRLs). The CRL is used to verify the client certificate status against the revocation lists published by the CA. For this reason, the administrator needs to add the CRL in certificate repository as well. A CRL can be in the PEM X.509 format (crl_type&#x3D;X509) or JSON OneCRL (crl_type&#x3D;OneCRL). If crl_type is not specified, it is auto-detected based on the upload content. An X.509 CRL can contain a single CRL or multiple CRLs depending on the PEM data. - Single CRL: a single CRL is created with the given id. - Composite CRL: multiple CRLs are generated. Each of the CRL is created with an id generated based on the given id. First CRL is created with crl-id, second with crl-id-1, third with crl-id-2, etc. Differently from action&#x3D;import, this method allows multi-part upload of the CRL(s). The TlsCrl resource returned in the body of the response will have an empty pem_encoded field, as it may be large. Use a GET request to retrieve the PEM-encoded CRL. 
    # @param crl_id 
    # @param file File to be uploaded
    # @param [Hash] opts the optional parameters
    # @option opts [String] :crl_type Type of CRL
    # @option opts [String] :description Description of this resource
    # @option opts [String] :display_name Identifier to use when displaying entity in logs or GUI
    # @return [Array<(TlsCrl, Fixnum, Hash)>] TlsCrl data, response status code and response headers
    def upload_tls_crl_with_http_info(crl_id, file, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CertificatesApi.upload_tls_crl ...'
      end
      # verify the required parameter 'crl_id' is set
      if @api_client.config.client_side_validation && crl_id.nil?
        fail ArgumentError, "Missing the required parameter 'crl_id' when calling CertificatesApi.upload_tls_crl"
      end
      # verify the required parameter 'file' is set
      if @api_client.config.client_side_validation && file.nil?
        fail ArgumentError, "Missing the required parameter 'file' when calling CertificatesApi.upload_tls_crl"
      end
      if @api_client.config.client_side_validation && opts[:'crl_type'] && !['OneCRL', 'X509'].include?(opts[:'crl_type'])
        fail ArgumentError, 'invalid value for "crl_type", must be one of OneCRL, X509'
      end
      if @api_client.config.client_side_validation && !opts[:'description'].nil? && opts[:'description'].to_s.length > 1024
        fail ArgumentError, 'invalid value for "opts[:"description"]" when calling CertificatesApi.upload_tls_crl, the character length must be smaller than or equal to 1024.'
      end

      if @api_client.config.client_side_validation && !opts[:'display_name'].nil? && opts[:'display_name'].to_s.length > 255
        fail ArgumentError, 'invalid value for "opts[:"display_name"]" when calling CertificatesApi.upload_tls_crl, the character length must be smaller than or equal to 255.'
      end

      # resource path
      local_var_path = '/infra/crls/{crl-id}?action=upload'.sub('{' + 'crl-id' + '}', crl_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'crl_type'] = opts[:'crl_type'] if !opts[:'crl_type'].nil?
      query_params[:'description'] = opts[:'description'] if !opts[:'description'].nil?
      query_params[:'display_name'] = opts[:'display_name'] if !opts[:'display_name'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['multipart/form-data'])

      # form parameters
      form_params = {}
      form_params['file'] = file

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TlsCrl')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CertificatesApi#upload_tls_crl\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
