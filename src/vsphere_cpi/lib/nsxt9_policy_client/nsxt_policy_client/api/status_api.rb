=begin
#NSX Policy API

#VMware NSX Policy REST API

OpenAPI spec version: 9.0.0.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.4.46

=end

require 'uri'

module Nsxt9PolicyClient
  class StatusApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Get infra segment port status information
    # Get infra segment port status information. 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentPortStatus]
    def get_infra_segment_port_status(segments_id, port_id, opts = {})
      data, _status_code, _headers = get_infra_segment_port_status_with_http_info(segments_id, port_id, opts)
      data
    end

    # Get infra segment port status information
    # Get infra segment port status information. 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentPortStatus, Fixnum, Hash)>] SegmentPortStatus data, response status code and response headers
    def get_infra_segment_port_status_with_http_info(segments_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_infra_segment_port_status ...'
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling StatusApi.get_infra_segment_port_status"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling StatusApi.get_infra_segment_port_status"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling StatusApi.get_infra_segment_port_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling StatusApi.get_infra_segment_port_status, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/infra/segments/{segments-id}/ports/{port-id}/status'.sub('{' + 'segments-id' + '}', segments_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_infra_segment_port_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get L2VPN session detailed status under Tier-0
    # - no enforcement point path specified: detailed tatus is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source=realtime: detailed tatus is fetched realtime from the enforcement point. - source=cached: cached detailed status is returned.  <br> This API is deprecated. Please use GET /infra/tier-0s/&lt;tier-0-id&gt;/l2vpn-services/&lt;service-id&gt;/ sessions/&lt;session-id&gt;/detailed-status instead. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [AggregateL2VPNSessionStatus]
    def get_l2_vpn_session_status(tier_0_id, locale_service_id, service_id, session_id, opts = {})
      data, _status_code, _headers = get_l2_vpn_session_status_with_http_info(tier_0_id, locale_service_id, service_id, session_id, opts)
      data
    end

    # Get L2VPN session detailed status under Tier-0
    # - no enforcement point path specified: detailed tatus is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source&#x3D;realtime: detailed tatus is fetched realtime from the enforcement point. - source&#x3D;cached: cached detailed status is returned.  &lt;br&gt; This API is deprecated. Please use GET /infra/tier-0s/&amp;lt;tier-0-id&amp;gt;/l2vpn-services/&amp;lt;service-id&amp;gt;/ sessions/&amp;lt;session-id&amp;gt;/detailed-status instead. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(AggregateL2VPNSessionStatus, Fixnum, Hash)>] AggregateL2VPNSessionStatus data, response status code and response headers
    def get_l2_vpn_session_status_with_http_info(tier_0_id, locale_service_id, service_id, session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_l2_vpn_session_status ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling StatusApi.get_l2_vpn_session_status"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling StatusApi.get_l2_vpn_session_status"
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling StatusApi.get_l2_vpn_session_status"
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling StatusApi.get_l2_vpn_session_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/l2vpn-services/{service-id}/sessions/{session-id}/detailed-status'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'session-id' + '}', session_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AggregateL2VPNSessionStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_l2_vpn_session_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get LBPool status information
    # Get LBPool detailed status information. - no enforcement point path specified: Information will be aggregated from each enforcement point. - {enforcement_point_path}: Information will be retrieved only from the given enforcement point.  NSX Load Balancer availability in terms of use-cases and editions is specified in NSX Feature and Edition Guide. Please review before consuming those APIs. 
    # @param lb_service_id LBService id
    # @param lb_pool_id LBPool id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [AggregateLBPoolStatus]
    def get_lb_pool_status(lb_service_id, lb_pool_id, opts = {})
      data, _status_code, _headers = get_lb_pool_status_with_http_info(lb_service_id, lb_pool_id, opts)
      data
    end

    # Get LBPool status information
    # Get LBPool detailed status information. - no enforcement point path specified: Information will be aggregated from each enforcement point. - {enforcement_point_path}: Information will be retrieved only from the given enforcement point.  NSX Load Balancer availability in terms of use-cases and editions is specified in NSX Feature and Edition Guide. Please review before consuming those APIs. 
    # @param lb_service_id LBService id
    # @param lb_pool_id LBPool id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(AggregateLBPoolStatus, Fixnum, Hash)>] AggregateLBPoolStatus data, response status code and response headers
    def get_lb_pool_status_with_http_info(lb_service_id, lb_pool_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_lb_pool_status ...'
      end
      # verify the required parameter 'lb_service_id' is set
      if @api_client.config.client_side_validation && lb_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'lb_service_id' when calling StatusApi.get_lb_pool_status"
      end
      # verify the required parameter 'lb_pool_id' is set
      if @api_client.config.client_side_validation && lb_pool_id.nil?
        fail ArgumentError, "Missing the required parameter 'lb_pool_id' when calling StatusApi.get_lb_pool_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/lb-services/{lb-service-id}/lb-pools/{lb-pool-id}/detailed-status'.sub('{' + 'lb-service-id' + '}', lb_service_id.to_s).sub('{' + 'lb-pool-id' + '}', lb_pool_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AggregateLBPoolStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_lb_pool_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get LBService status information
    # Get LBService detailed status information. - no enforcement point path specified: Information will be aggregated from each enforcement point. - {enforcement_point_path}: Information will be retrieved only from the given enforcement point.  NSX Load Balancer availability in terms of use-cases and editions is specified in NSX Feature and Edition Guide. Please review before consuming those APIs. 
    # @param lb_service_id LBService id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_instance_details Flag to indicate whether include detail information (default to false)
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_ids The UUIDs of transport nodes
    # @return [AggregateLBServiceStatus]
    def get_lb_service_status(lb_service_id, opts = {})
      data, _status_code, _headers = get_lb_service_status_with_http_info(lb_service_id, opts)
      data
    end

    # Get LBService status information
    # Get LBService detailed status information. - no enforcement point path specified: Information will be aggregated from each enforcement point. - {enforcement_point_path}: Information will be retrieved only from the given enforcement point.  NSX Load Balancer availability in terms of use-cases and editions is specified in NSX Feature and Edition Guide. Please review before consuming those APIs. 
    # @param lb_service_id LBService id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_instance_details Flag to indicate whether include detail information
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_ids The UUIDs of transport nodes
    # @return [Array<(AggregateLBServiceStatus, Fixnum, Hash)>] AggregateLBServiceStatus data, response status code and response headers
    def get_lb_service_status_with_http_info(lb_service_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_lb_service_status ...'
      end
      # verify the required parameter 'lb_service_id' is set
      if @api_client.config.client_side_validation && lb_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'lb_service_id' when calling StatusApi.get_lb_service_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/lb-services/{lb-service-id}/detailed-status'.sub('{' + 'lb-service-id' + '}', lb_service_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_instance_details'] = opts[:'include_instance_details'] if !opts[:'include_instance_details'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_ids'] = opts[:'transport_node_ids'] if !opts[:'transport_node_ids'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AggregateLBServiceStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_lb_service_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get LBVirtualServer status information
    # Get LBVirtualServer detailed status information. - no enforcement point path specified: Information will be aggregated from each enforcement point. - {enforcement_point_path}: Information will be retrieved only from the given enforcement point.  NSX Load Balancer availability in terms of use-cases and editions is specified in NSX Feature and Edition Guide. Please review before consuming those APIs. 
    # @param lb_service_id LBService id
    # @param lb_virtual_server_id LBVirtualServer id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [AggregateLBVirtualServerStatus]
    def get_lb_virtual_server_status(lb_service_id, lb_virtual_server_id, opts = {})
      data, _status_code, _headers = get_lb_virtual_server_status_with_http_info(lb_service_id, lb_virtual_server_id, opts)
      data
    end

    # Get LBVirtualServer status information
    # Get LBVirtualServer detailed status information. - no enforcement point path specified: Information will be aggregated from each enforcement point. - {enforcement_point_path}: Information will be retrieved only from the given enforcement point.  NSX Load Balancer availability in terms of use-cases and editions is specified in NSX Feature and Edition Guide. Please review before consuming those APIs. 
    # @param lb_service_id LBService id
    # @param lb_virtual_server_id LBVirtualServer id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(AggregateLBVirtualServerStatus, Fixnum, Hash)>] AggregateLBVirtualServerStatus data, response status code and response headers
    def get_lb_virtual_server_status_with_http_info(lb_service_id, lb_virtual_server_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_lb_virtual_server_status ...'
      end
      # verify the required parameter 'lb_service_id' is set
      if @api_client.config.client_side_validation && lb_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'lb_service_id' when calling StatusApi.get_lb_virtual_server_status"
      end
      # verify the required parameter 'lb_virtual_server_id' is set
      if @api_client.config.client_side_validation && lb_virtual_server_id.nil?
        fail ArgumentError, "Missing the required parameter 'lb_virtual_server_id' when calling StatusApi.get_lb_virtual_server_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/lb-services/{lb-service-id}/lb-virtual-servers/{lb-virtual-server-id}/detailed-status'.sub('{' + 'lb-service-id' + '}', lb_service_id.to_s).sub('{' + 'lb-virtual-server-id' + '}', lb_virtual_server_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AggregateLBVirtualServerStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_lb_virtual_server_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get NSX Application Platform pre/post checks execution required
    # Get NSX Application Platform pre/post checks execution required.
    # @param site_id 
    # @param form_factor Form factor types
    # @param [Hash] opts the optional parameters
    # @return [DeploymentChecksExecutionRequiredResult]
    def get_platform_deployment_checks_execution_required(site_id, form_factor, opts = {})
      data, _status_code, _headers = get_platform_deployment_checks_execution_required_with_http_info(site_id, form_factor, opts)
      data
    end

    # Get NSX Application Platform pre/post checks execution required
    # Get NSX Application Platform pre/post checks execution required.
    # @param site_id 
    # @param form_factor Form factor types
    # @param [Hash] opts the optional parameters
    # @return [Array<(DeploymentChecksExecutionRequiredResult, Fixnum, Hash)>] DeploymentChecksExecutionRequiredResult data, response status code and response headers
    def get_platform_deployment_checks_execution_required_with_http_info(site_id, form_factor, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_platform_deployment_checks_execution_required ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling StatusApi.get_platform_deployment_checks_execution_required"
      end
      # verify the required parameter 'form_factor' is set
      if @api_client.config.client_side_validation && form_factor.nil?
        fail ArgumentError, "Missing the required parameter 'form_factor' when calling StatusApi.get_platform_deployment_checks_execution_required"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['standard', 'advanced', 'evaluation'].include?(form_factor)
        fail ArgumentError, "invalid value for 'form_factor', must be one of standard, advanced, evaluation"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/napp/deployment/platform/checks/execution/required'.sub('{' + 'site-id' + '}', site_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'form_factor'] = form_factor

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DeploymentChecksExecutionRequiredResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_platform_deployment_checks_execution_required\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get NSX Application Platform pre/post checks progress status
    # Get NSX Application Platform pre/post checks progress status.
    # @param site_id 
    # @param [Hash] opts the optional parameters
    # @return [DeploymentChecksStatusResult]
    def get_platform_deployment_checks_status(site_id, opts = {})
      data, _status_code, _headers = get_platform_deployment_checks_status_with_http_info(site_id, opts)
      data
    end

    # Get NSX Application Platform pre/post checks progress status
    # Get NSX Application Platform pre/post checks progress status.
    # @param site_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(DeploymentChecksStatusResult, Fixnum, Hash)>] DeploymentChecksStatusResult data, response status code and response headers
    def get_platform_deployment_checks_status_with_http_info(site_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_platform_deployment_checks_status ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling StatusApi.get_platform_deployment_checks_status"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/napp/deployment/platform/checks/status'.sub('{' + 'site-id' + '}', site_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DeploymentChecksStatusResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_platform_deployment_checks_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get a Policy Edge Cluster allocation status  under an Enforcement Point
    # Returns the allocation details of cluster and its members. Lists the edge node members, active and standby services of each node, utilization details of configured sub-pools. These allocation details can be monitored by customers to trigger migration of certain service contexts to different edge nodes, to balance the utilization of edge node resources. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param edge_cluster_id 
    # @param [Hash] opts the optional parameters
    # @return [PolicyEdgeClusterAllocationStatus]
    def get_policy_edge_cluster_allocation_status(site_id, enforcementpoint_id, edge_cluster_id, opts = {})
      data, _status_code, _headers = get_policy_edge_cluster_allocation_status_with_http_info(site_id, enforcementpoint_id, edge_cluster_id, opts)
      data
    end

    # Get a Policy Edge Cluster allocation status  under an Enforcement Point
    # Returns the allocation details of cluster and its members. Lists the edge node members, active and standby services of each node, utilization details of configured sub-pools. These allocation details can be monitored by customers to trigger migration of certain service contexts to different edge nodes, to balance the utilization of edge node resources. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param edge_cluster_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PolicyEdgeClusterAllocationStatus, Fixnum, Hash)>] PolicyEdgeClusterAllocationStatus data, response status code and response headers
    def get_policy_edge_cluster_allocation_status_with_http_info(site_id, enforcementpoint_id, edge_cluster_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_policy_edge_cluster_allocation_status ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling StatusApi.get_policy_edge_cluster_allocation_status"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling StatusApi.get_policy_edge_cluster_allocation_status"
      end
      # verify the required parameter 'edge_cluster_id' is set
      if @api_client.config.client_side_validation && edge_cluster_id.nil?
        fail ArgumentError, "Missing the required parameter 'edge_cluster_id' when calling StatusApi.get_policy_edge_cluster_allocation_status"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/edge-clusters/{edge-cluster-id}/allocation/status'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'edge-cluster-id' + '}', edge_cluster_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyEdgeClusterAllocationStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_policy_edge_cluster_allocation_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get a Policy Edge Cluster real time status  under an Enforcement Point
    # Returns the aggregated status for the Edge cluster along with status of all edge nodes in the cluster. Query parameter \"source=realtime\" is the only supported source. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param edge_cluster_id 
    # @param source Data source type.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PolicyEdgeClusterStatus]
    def get_policy_edge_cluster_status(site_id, enforcementpoint_id, edge_cluster_id, source, opts = {})
      data, _status_code, _headers = get_policy_edge_cluster_status_with_http_info(site_id, enforcementpoint_id, edge_cluster_id, source, opts)
      data
    end

    # Get a Policy Edge Cluster real time status  under an Enforcement Point
    # Returns the aggregated status for the Edge cluster along with status of all edge nodes in the cluster. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param edge_cluster_id 
    # @param source Data source type.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PolicyEdgeClusterStatus, Fixnum, Hash)>] PolicyEdgeClusterStatus data, response status code and response headers
    def get_policy_edge_cluster_status_with_http_info(site_id, enforcementpoint_id, edge_cluster_id, source, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_policy_edge_cluster_status ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling StatusApi.get_policy_edge_cluster_status"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling StatusApi.get_policy_edge_cluster_status"
      end
      # verify the required parameter 'edge_cluster_id' is set
      if @api_client.config.client_side_validation && edge_cluster_id.nil?
        fail ArgumentError, "Missing the required parameter 'edge_cluster_id' when calling StatusApi.get_policy_edge_cluster_status"
      end
      # verify the required parameter 'source' is set
      if @api_client.config.client_side_validation && source.nil?
        fail ArgumentError, "Missing the required parameter 'source' when calling StatusApi.get_policy_edge_cluster_status"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['realtime', 'cached'].include?(source)
        fail ArgumentError, "invalid value for 'source', must be one of realtime, cached"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling StatusApi.get_policy_edge_cluster_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling StatusApi.get_policy_edge_cluster_status, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/edge-clusters/{edge-cluster-id}/status'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'edge-cluster-id' + '}', edge_cluster_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = source
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyEdgeClusterStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_policy_edge_cluster_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read counters for edge transport node interfaces.
    # This API returns the counters of the specified interface. The counters reset on reboot or redeploy of the appliance or restart of the data plane. NSX Manager polls the edge-transport-node every minute (by default) to update the data returned on this API. If you need near realtime values, use the query parameter \\\"?source=realtime\\\" to the API and it will make NSX Manager collect the statistics from the edge transport node and returns the updated counters. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param edge_transport_node_id 
    # @param interface_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [NodeInterfaceStatisticsProperties]
    def get_policy_edge_transport_node_interface_statistics(site_id, enforcementpoint_id, edge_transport_node_id, interface_id, opts = {})
      data, _status_code, _headers = get_policy_edge_transport_node_interface_statistics_with_http_info(site_id, enforcementpoint_id, edge_transport_node_id, interface_id, opts)
      data
    end

    # Read counters for edge transport node interfaces.
    # This API returns the counters of the specified interface. The counters reset on reboot or redeploy of the appliance or restart of the data plane. NSX Manager polls the edge-transport-node every minute (by default) to update the data returned on this API. If you need near realtime values, use the query parameter \\\&quot;?source&#x3D;realtime\\\&quot; to the API and it will make NSX Manager collect the statistics from the edge transport node and returns the updated counters. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param edge_transport_node_id 
    # @param interface_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(NodeInterfaceStatisticsProperties, Fixnum, Hash)>] NodeInterfaceStatisticsProperties data, response status code and response headers
    def get_policy_edge_transport_node_interface_statistics_with_http_info(site_id, enforcementpoint_id, edge_transport_node_id, interface_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_policy_edge_transport_node_interface_statistics ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling StatusApi.get_policy_edge_transport_node_interface_statistics"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling StatusApi.get_policy_edge_transport_node_interface_statistics"
      end
      # verify the required parameter 'edge_transport_node_id' is set
      if @api_client.config.client_side_validation && edge_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'edge_transport_node_id' when calling StatusApi.get_policy_edge_transport_node_interface_statistics"
      end
      # verify the required parameter 'interface_id' is set
      if @api_client.config.client_side_validation && interface_id.nil?
        fail ArgumentError, "Missing the required parameter 'interface_id' when calling StatusApi.get_policy_edge_transport_node_interface_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/edge-transport-nodes/{edge-transport-node-id}/network/interfaces/{interface-id}/statistics'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'edge-transport-node-id' + '}', edge_transport_node_id.to_s).sub('{' + 'interface-id' + '}', interface_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'NodeInterfaceStatisticsProperties')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_policy_edge_transport_node_interface_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get a Policy EdgeTransport Node's status info under an Enforcement Point
    # Returns information about the current status of the edge transport node. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param edge_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [TransportNodeStatus]
    def get_policy_edge_transport_node_status(site_id, enforcementpoint_id, edge_transport_node_id, opts = {})
      data, _status_code, _headers = get_policy_edge_transport_node_status_with_http_info(site_id, enforcementpoint_id, edge_transport_node_id, opts)
      data
    end

    # Get a Policy EdgeTransport Node&#39;s status info under an Enforcement Point
    # Returns information about the current status of the edge transport node. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param edge_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :source Data source type.
    # @return [Array<(TransportNodeStatus, Fixnum, Hash)>] TransportNodeStatus data, response status code and response headers
    def get_policy_edge_transport_node_status_with_http_info(site_id, enforcementpoint_id, edge_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_policy_edge_transport_node_status ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling StatusApi.get_policy_edge_transport_node_status"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling StatusApi.get_policy_edge_transport_node_status"
      end
      # verify the required parameter 'edge_transport_node_id' is set
      if @api_client.config.client_side_validation && edge_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'edge_transport_node_id' when calling StatusApi.get_policy_edge_transport_node_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/edge-transport-nodes/{edge-transport-node-id}/status'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'edge-transport-node-id' + '}', edge_transport_node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNodeStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_policy_edge_transport_node_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get segment port status information
    # Get tier1 segment port status information. 
    # @param tier_1_id 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentPortStatus]
    def get_segment_port_status(tier_1_id, segments_id, port_id, opts = {})
      data, _status_code, _headers = get_segment_port_status_with_http_info(tier_1_id, segments_id, port_id, opts)
      data
    end

    # Get segment port status information
    # Get tier1 segment port status information. 
    # @param tier_1_id 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentPortStatus, Fixnum, Hash)>] SegmentPortStatus data, response status code and response headers
    def get_segment_port_status_with_http_info(tier_1_id, segments_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_segment_port_status ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling StatusApi.get_segment_port_status"
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling StatusApi.get_segment_port_status"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling StatusApi.get_segment_port_status"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling StatusApi.get_segment_port_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling StatusApi.get_segment_port_status, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segments-id}/ports/{port-id}/status'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segments-id' + '}', segments_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_segment_port_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get IPSec VPN session detailed status under Tier-0
    # - no enforcement point path specified: detailed status is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source=realtime: detailed status is fetched realtime from the enforcement point. - source=cached: cached detailed status from enforcement point is returned.  <br> This API is deprecated. Please use GET /infra/tier-0s/&lt;tier-0-id&gt;/ipsec-vpn-services/&lt;service-id&gt;/ sessions/&lt;session-id&gt;/detailed-status instead. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [AggregateIPSecVpnSessionStatus]
    def get_tier0_ip_sec_vpn_session_status(tier_0_id, locale_service_id, service_id, session_id, opts = {})
      data, _status_code, _headers = get_tier0_ip_sec_vpn_session_status_with_http_info(tier_0_id, locale_service_id, service_id, session_id, opts)
      data
    end

    # Get IPSec VPN session detailed status under Tier-0
    # - no enforcement point path specified: detailed status is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source&#x3D;realtime: detailed status is fetched realtime from the enforcement point. - source&#x3D;cached: cached detailed status from enforcement point is returned.  &lt;br&gt; This API is deprecated. Please use GET /infra/tier-0s/&amp;lt;tier-0-id&amp;gt;/ipsec-vpn-services/&amp;lt;service-id&amp;gt;/ sessions/&amp;lt;session-id&amp;gt;/detailed-status instead. 
    # @param tier_0_id 
    # @param locale_service_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(AggregateIPSecVpnSessionStatus, Fixnum, Hash)>] AggregateIPSecVpnSessionStatus data, response status code and response headers
    def get_tier0_ip_sec_vpn_session_status_with_http_info(tier_0_id, locale_service_id, service_id, session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_tier0_ip_sec_vpn_session_status ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling StatusApi.get_tier0_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling StatusApi.get_tier0_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling StatusApi.get_tier0_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling StatusApi.get_tier0_ip_sec_vpn_session_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/ipsec-vpn-services/{service-id}/sessions/{session-id}/detailed-status'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'session-id' + '}', session_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AggregateIPSecVpnSessionStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_tier0_ip_sec_vpn_session_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get IPSec VPN session detailed status under Tier-0
    # - no enforcement point path specified: detailed status is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source=realtime: detailed status is fetched realtime from the enforcement point. - source=cached: cached detailed status from enforcement point is returned. 
    # @param tier_0_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [AggregateIPSecVpnSessionStatus]
    def get_tier0_vpn_ip_sec_vpn_session_status(tier_0_id, service_id, session_id, opts = {})
      data, _status_code, _headers = get_tier0_vpn_ip_sec_vpn_session_status_with_http_info(tier_0_id, service_id, session_id, opts)
      data
    end

    # Get IPSec VPN session detailed status under Tier-0
    # - no enforcement point path specified: detailed status is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source&#x3D;realtime: detailed status is fetched realtime from the enforcement point. - source&#x3D;cached: cached detailed status from enforcement point is returned. 
    # @param tier_0_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(AggregateIPSecVpnSessionStatus, Fixnum, Hash)>] AggregateIPSecVpnSessionStatus data, response status code and response headers
    def get_tier0_vpn_ip_sec_vpn_session_status_with_http_info(tier_0_id, service_id, session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_tier0_vpn_ip_sec_vpn_session_status ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling StatusApi.get_tier0_vpn_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling StatusApi.get_tier0_vpn_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling StatusApi.get_tier0_vpn_ip_sec_vpn_session_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/ipsec-vpn-services/{service-id}/sessions/{session-id}/detailed-status'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'session-id' + '}', session_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AggregateIPSecVpnSessionStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_tier0_vpn_ip_sec_vpn_session_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get L2VPN session detailed status under Tier-0
    # - no enforcement point path specified: detailed tatus is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source=realtime: detailed tatus is fetched realtime from the enforcement point. - source=cached: cached detailed status is returned. 
    # @param tier_0_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [AggregateL2VPNSessionStatus]
    def get_tier0_vpn_l2_vpn_session_status(tier_0_id, service_id, session_id, opts = {})
      data, _status_code, _headers = get_tier0_vpn_l2_vpn_session_status_with_http_info(tier_0_id, service_id, session_id, opts)
      data
    end

    # Get L2VPN session detailed status under Tier-0
    # - no enforcement point path specified: detailed tatus is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source&#x3D;realtime: detailed tatus is fetched realtime from the enforcement point. - source&#x3D;cached: cached detailed status is returned. 
    # @param tier_0_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(AggregateL2VPNSessionStatus, Fixnum, Hash)>] AggregateL2VPNSessionStatus data, response status code and response headers
    def get_tier0_vpn_l2_vpn_session_status_with_http_info(tier_0_id, service_id, session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_tier0_vpn_l2_vpn_session_status ...'
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling StatusApi.get_tier0_vpn_l2_vpn_session_status"
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling StatusApi.get_tier0_vpn_l2_vpn_session_status"
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling StatusApi.get_tier0_vpn_l2_vpn_session_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/tier-0s/{tier-0-id}/l2vpn-services/{service-id}/sessions/{session-id}/detailed-status'.sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'session-id' + '}', session_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AggregateL2VPNSessionStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_tier0_vpn_l2_vpn_session_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get IPSec VPN session detailed status under Tier-1
    # - no enforcement point path specified: detailed status is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source=realtime: detailed status is fetched realtime from the enforcement point. - source=cached: cached detailed status from enforcement point is returned.  <br> This API is deprecated. Please use GET /infra/tier-1s/&lt;tier-1-id&gt;/ipsec-vpn-services/&lt;service-id&gt;/sessions/&lt;session-id&gt;/detailed-status instead. 
    # @param tier_1_id 
    # @param locale_service_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [AggregateIPSecVpnSessionStatus]
    def get_tier1_ip_sec_vpn_session_status(tier_1_id, locale_service_id, service_id, session_id, opts = {})
      data, _status_code, _headers = get_tier1_ip_sec_vpn_session_status_with_http_info(tier_1_id, locale_service_id, service_id, session_id, opts)
      data
    end

    # Get IPSec VPN session detailed status under Tier-1
    # - no enforcement point path specified: detailed status is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source&#x3D;realtime: detailed status is fetched realtime from the enforcement point. - source&#x3D;cached: cached detailed status from enforcement point is returned.  &lt;br&gt; This API is deprecated. Please use GET /infra/tier-1s/&amp;lt;tier-1-id&amp;gt;/ipsec-vpn-services/&amp;lt;service-id&amp;gt;/sessions/&amp;lt;session-id&amp;gt;/detailed-status instead. 
    # @param tier_1_id 
    # @param locale_service_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(AggregateIPSecVpnSessionStatus, Fixnum, Hash)>] AggregateIPSecVpnSessionStatus data, response status code and response headers
    def get_tier1_ip_sec_vpn_session_status_with_http_info(tier_1_id, locale_service_id, service_id, session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_tier1_ip_sec_vpn_session_status ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling StatusApi.get_tier1_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling StatusApi.get_tier1_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling StatusApi.get_tier1_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling StatusApi.get_tier1_ip_sec_vpn_session_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/locale-services/{locale-service-id}/ipsec-vpn-services/{service-id}/sessions/{session-id}/detailed-status'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'session-id' + '}', session_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AggregateIPSecVpnSessionStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_tier1_ip_sec_vpn_session_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get L2VPN session detailed status under Tier-1
    # - no enforcement point path specified: detailed tatus is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source=realtime: detailed tatus is fetched realtime from the enforcement point. - source=cached: cached detailed status is returned. sessions/&lt;session-id&gt;/detailed-status instead.  <br> This API is deprecated. Please use GET /infra/tier-1s/&lt;tier-1-id&gt;/l2vpn-services/&lt;service-id&gt;/ 
    # @param tier_1_id 
    # @param locale_service_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [AggregateL2VPNSessionStatus]
    def get_tier1_l2_vpn_session_status(tier_1_id, locale_service_id, service_id, session_id, opts = {})
      data, _status_code, _headers = get_tier1_l2_vpn_session_status_with_http_info(tier_1_id, locale_service_id, service_id, session_id, opts)
      data
    end

    # Get L2VPN session detailed status under Tier-1
    # - no enforcement point path specified: detailed tatus is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source&#x3D;realtime: detailed tatus is fetched realtime from the enforcement point. - source&#x3D;cached: cached detailed status is returned. sessions/&amp;lt;session-id&amp;gt;/detailed-status instead.  &lt;br&gt; This API is deprecated. Please use GET /infra/tier-1s/&amp;lt;tier-1-id&amp;gt;/l2vpn-services/&amp;lt;service-id&amp;gt;/ 
    # @param tier_1_id 
    # @param locale_service_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(AggregateL2VPNSessionStatus, Fixnum, Hash)>] AggregateL2VPNSessionStatus data, response status code and response headers
    def get_tier1_l2_vpn_session_status_with_http_info(tier_1_id, locale_service_id, service_id, session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_tier1_l2_vpn_session_status ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling StatusApi.get_tier1_l2_vpn_session_status"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling StatusApi.get_tier1_l2_vpn_session_status"
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling StatusApi.get_tier1_l2_vpn_session_status"
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling StatusApi.get_tier1_l2_vpn_session_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/locale-services/{locale-service-id}/l2vpn-services/{service-id}/sessions/{session-id}/detailed-status'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'session-id' + '}', session_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AggregateL2VPNSessionStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_tier1_l2_vpn_session_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get IPSec VPN session detailed status under Tier-1
    # - no enforcement point path specified: detailed status is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source=realtime: detailed status is fetched realtime from the enforcement point. - source=cached: cached detailed status from enforcement point is returned. 
    # @param tier_1_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [AggregateIPSecVpnSessionStatus]
    def get_tier1_vpn_ip_sec_vpn_session_status(tier_1_id, service_id, session_id, opts = {})
      data, _status_code, _headers = get_tier1_vpn_ip_sec_vpn_session_status_with_http_info(tier_1_id, service_id, session_id, opts)
      data
    end

    # Get IPSec VPN session detailed status under Tier-1
    # - no enforcement point path specified: detailed status is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source&#x3D;realtime: detailed status is fetched realtime from the enforcement point. - source&#x3D;cached: cached detailed status from enforcement point is returned. 
    # @param tier_1_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(AggregateIPSecVpnSessionStatus, Fixnum, Hash)>] AggregateIPSecVpnSessionStatus data, response status code and response headers
    def get_tier1_vpn_ip_sec_vpn_session_status_with_http_info(tier_1_id, service_id, session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_tier1_vpn_ip_sec_vpn_session_status ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling StatusApi.get_tier1_vpn_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling StatusApi.get_tier1_vpn_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling StatusApi.get_tier1_vpn_ip_sec_vpn_session_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/ipsec-vpn-services/{service-id}/sessions/{session-id}/detailed-status'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'session-id' + '}', session_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AggregateIPSecVpnSessionStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_tier1_vpn_ip_sec_vpn_session_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get L2VPN session detailed status under Tier-1
    # - no enforcement point path specified: detailed tatus is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source=realtime: detailed tatus is fetched realtime from the enforcement point. - source=cached: cached detailed status is returned. 
    # @param tier_1_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [AggregateL2VPNSessionStatus]
    def get_tier1_vpn_l2_vpn_session_status(tier_1_id, service_id, session_id, opts = {})
      data, _status_code, _headers = get_tier1_vpn_l2_vpn_session_status_with_http_info(tier_1_id, service_id, session_id, opts)
      data
    end

    # Get L2VPN session detailed status under Tier-1
    # - no enforcement point path specified: detailed tatus is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source&#x3D;realtime: detailed tatus is fetched realtime from the enforcement point. - source&#x3D;cached: cached detailed status is returned. 
    # @param tier_1_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(AggregateL2VPNSessionStatus, Fixnum, Hash)>] AggregateL2VPNSessionStatus data, response status code and response headers
    def get_tier1_vpn_l2_vpn_session_status_with_http_info(tier_1_id, service_id, session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_tier1_vpn_l2_vpn_session_status ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling StatusApi.get_tier1_vpn_l2_vpn_session_status"
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling StatusApi.get_tier1_vpn_l2_vpn_session_status"
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling StatusApi.get_tier1_vpn_l2_vpn_session_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/l2vpn-services/{service-id}/sessions/{session-id}/detailed-status'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'session-id' + '}', session_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AggregateL2VPNSessionStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_tier1_vpn_l2_vpn_session_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get NSX Application Platform upgrade-coordinator pre/post checks progress status.
    # Get NSX Application Platform upgrade-coordinator pre/post checks progress status.
    # @param site_id 
    # @param [Hash] opts the optional parameters
    # @return [DeploymentChecksStatusResult]
    def get_uc_deployment_checks_status(site_id, opts = {})
      data, _status_code, _headers = get_uc_deployment_checks_status_with_http_info(site_id, opts)
      data
    end

    # Get NSX Application Platform upgrade-coordinator pre/post checks progress status.
    # Get NSX Application Platform upgrade-coordinator pre/post checks progress status.
    # @param site_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(DeploymentChecksStatusResult, Fixnum, Hash)>] DeploymentChecksStatusResult data, response status code and response headers
    def get_uc_deployment_checks_status_with_http_info(site_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_uc_deployment_checks_status ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling StatusApi.get_uc_deployment_checks_status"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/napp/deployment/upgrade-coordinator/checks/status'.sub('{' + 'site-id' + '}', site_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DeploymentChecksStatusResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_uc_deployment_checks_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get deployment or undeployment progress status
    # Get deployment or undeployment progress status.
    # @param site_id 
    # @param [Hash] opts the optional parameters
    # @return [DeploymentProgressStatus]
    def get_upgrade_coordinator_deployment_progress_status(site_id, opts = {})
      data, _status_code, _headers = get_upgrade_coordinator_deployment_progress_status_with_http_info(site_id, opts)
      data
    end

    # Get deployment or undeployment progress status
    # Get deployment or undeployment progress status.
    # @param site_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(DeploymentProgressStatus, Fixnum, Hash)>] DeploymentProgressStatus data, response status code and response headers
    def get_upgrade_coordinator_deployment_progress_status_with_http_info(site_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_upgrade_coordinator_deployment_progress_status ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling StatusApi.get_upgrade_coordinator_deployment_progress_status"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/napp/deployment/upgrade-coordinator/status'.sub('{' + 'site-id' + '}', site_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DeploymentProgressStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_upgrade_coordinator_deployment_progress_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get progress status of kubernetes tools bundle upload
    # Get the progress of uploading kubernetes tools bundle from the remote location. This API will also verify the kubernetes tools bundle, before marking upload as a success. 
    # @param site_id 
    # @param bundle_id 
    # @param [Hash] opts the optional parameters
    # @return [UploadBundleStatus]
    def get_upload_bundle_status(site_id, bundle_id, opts = {})
      data, _status_code, _headers = get_upload_bundle_status_with_http_info(site_id, bundle_id, opts)
      data
    end

    # Get progress status of kubernetes tools bundle upload
    # Get the progress of uploading kubernetes tools bundle from the remote location. This API will also verify the kubernetes tools bundle, before marking upload as a success. 
    # @param site_id 
    # @param bundle_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(UploadBundleStatus, Fixnum, Hash)>] UploadBundleStatus data, response status code and response headers
    def get_upload_bundle_status_with_http_info(site_id, bundle_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_upload_bundle_status ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling StatusApi.get_upload_bundle_status"
      end
      # verify the required parameter 'bundle_id' is set
      if @api_client.config.client_side_validation && bundle_id.nil?
        fail ArgumentError, "Missing the required parameter 'bundle_id' when calling StatusApi.get_upload_bundle_status"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/napp/deployment/tools/upload/status/{bundle-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'bundle-id' + '}', bundle_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'UploadBundleStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_upload_bundle_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get LBPool status information
    # Get LBPool detailed status information. - no enforcement point path specified: Information will be aggregated from each enforcement point. - {enforcement_point_path}: Information will be retrieved only from the given enforcement point.  NSX Load Balancer availability in terms of use-cases and editions is specified in NSX Feature and Edition Guide. Please review before consuming those APIs. 
    # @param org_id Org ID
    # @param project_id Project ID
    # @param vpc_id VPC ID
    # @param vpc_lb_id Load Balancer ID
    # @param vpc_lb_pool_id LBPool id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [AggregateLBPoolStatus]
    def get_vpc_lb_pool_status(org_id, project_id, vpc_id, vpc_lb_id, vpc_lb_pool_id, opts = {})
      data, _status_code, _headers = get_vpc_lb_pool_status_with_http_info(org_id, project_id, vpc_id, vpc_lb_id, vpc_lb_pool_id, opts)
      data
    end

    # Get LBPool status information
    # Get LBPool detailed status information. - no enforcement point path specified: Information will be aggregated from each enforcement point. - {enforcement_point_path}: Information will be retrieved only from the given enforcement point.  NSX Load Balancer availability in terms of use-cases and editions is specified in NSX Feature and Edition Guide. Please review before consuming those APIs. 
    # @param org_id Org ID
    # @param project_id Project ID
    # @param vpc_id VPC ID
    # @param vpc_lb_id Load Balancer ID
    # @param vpc_lb_pool_id LBPool id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(AggregateLBPoolStatus, Fixnum, Hash)>] AggregateLBPoolStatus data, response status code and response headers
    def get_vpc_lb_pool_status_with_http_info(org_id, project_id, vpc_id, vpc_lb_id, vpc_lb_pool_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_vpc_lb_pool_status ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling StatusApi.get_vpc_lb_pool_status"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling StatusApi.get_vpc_lb_pool_status"
      end
      # verify the required parameter 'vpc_id' is set
      if @api_client.config.client_side_validation && vpc_id.nil?
        fail ArgumentError, "Missing the required parameter 'vpc_id' when calling StatusApi.get_vpc_lb_pool_status"
      end
      # verify the required parameter 'vpc_lb_id' is set
      if @api_client.config.client_side_validation && vpc_lb_id.nil?
        fail ArgumentError, "Missing the required parameter 'vpc_lb_id' when calling StatusApi.get_vpc_lb_pool_status"
      end
      # verify the required parameter 'vpc_lb_pool_id' is set
      if @api_client.config.client_side_validation && vpc_lb_pool_id.nil?
        fail ArgumentError, "Missing the required parameter 'vpc_lb_pool_id' when calling StatusApi.get_vpc_lb_pool_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/vpcs/{vpc-id}/vpc-lbs/{vpc-lb-id}/vpc-lb-pools/{vpc-lb-pool-id}/detailed-status'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'vpc-id' + '}', vpc_id.to_s).sub('{' + 'vpc-lb-id' + '}', vpc_lb_id.to_s).sub('{' + 'vpc-lb-pool-id' + '}', vpc_lb_pool_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AggregateLBPoolStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_vpc_lb_pool_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get load balancer status information
    # Get load balancer detailed status information. - no enforcement point path specified: Information will be aggregated from each enforcement point. - {enforcement_point_path}: Information will be retrieved only from the given enforcement point.  NSX Load Balancer availability in terms of use-cases and editions is specified in NSX Feature and Edition Guide. Please review before consuming those APIs. 
    # @param org_id Org ID
    # @param project_id Project ID
    # @param vpc_id VPC ID
    # @param vpc_lb_id Load Balancer ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [AggregateLBServiceStatus]
    def get_vpc_lb_service_status(org_id, project_id, vpc_id, vpc_lb_id, opts = {})
      data, _status_code, _headers = get_vpc_lb_service_status_with_http_info(org_id, project_id, vpc_id, vpc_lb_id, opts)
      data
    end

    # Get load balancer status information
    # Get load balancer detailed status information. - no enforcement point path specified: Information will be aggregated from each enforcement point. - {enforcement_point_path}: Information will be retrieved only from the given enforcement point.  NSX Load Balancer availability in terms of use-cases and editions is specified in NSX Feature and Edition Guide. Please review before consuming those APIs. 
    # @param org_id Org ID
    # @param project_id Project ID
    # @param vpc_id VPC ID
    # @param vpc_lb_id Load Balancer ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(AggregateLBServiceStatus, Fixnum, Hash)>] AggregateLBServiceStatus data, response status code and response headers
    def get_vpc_lb_service_status_with_http_info(org_id, project_id, vpc_id, vpc_lb_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_vpc_lb_service_status ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling StatusApi.get_vpc_lb_service_status"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling StatusApi.get_vpc_lb_service_status"
      end
      # verify the required parameter 'vpc_id' is set
      if @api_client.config.client_side_validation && vpc_id.nil?
        fail ArgumentError, "Missing the required parameter 'vpc_id' when calling StatusApi.get_vpc_lb_service_status"
      end
      # verify the required parameter 'vpc_lb_id' is set
      if @api_client.config.client_side_validation && vpc_lb_id.nil?
        fail ArgumentError, "Missing the required parameter 'vpc_lb_id' when calling StatusApi.get_vpc_lb_service_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/vpcs/{vpc-id}/vpc-lbs/{vpc-lb-id}/detailed-status'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'vpc-id' + '}', vpc_id.to_s).sub('{' + 'vpc-lb-id' + '}', vpc_lb_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AggregateLBServiceStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_vpc_lb_service_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get LBVirtualServer status information
    # Get LBVirtualServer detailed status information. - no enforcement point path specified: Information will be aggregated from each enforcement point. - {enforcement_point_path}: Information will be retrieved only from the given enforcement point.  NSX Load Balancer availability in terms of use-cases and editions is specified in NSX Feature and Edition Guide. Please review before consuming those APIs. 
    # @param org_id Org ID
    # @param project_id Project ID
    # @param vpc_id VPC ID
    # @param vpc_lb_id Load Balancer ID
    # @param vpc_lb_virtual_server_id LBVirtualServer id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [AggregateLBVirtualServerStatus]
    def get_vpc_lb_virtual_server_status(org_id, project_id, vpc_id, vpc_lb_id, vpc_lb_virtual_server_id, opts = {})
      data, _status_code, _headers = get_vpc_lb_virtual_server_status_with_http_info(org_id, project_id, vpc_id, vpc_lb_id, vpc_lb_virtual_server_id, opts)
      data
    end

    # Get LBVirtualServer status information
    # Get LBVirtualServer detailed status information. - no enforcement point path specified: Information will be aggregated from each enforcement point. - {enforcement_point_path}: Information will be retrieved only from the given enforcement point.  NSX Load Balancer availability in terms of use-cases and editions is specified in NSX Feature and Edition Guide. Please review before consuming those APIs. 
    # @param org_id Org ID
    # @param project_id Project ID
    # @param vpc_id VPC ID
    # @param vpc_lb_id Load Balancer ID
    # @param vpc_lb_virtual_server_id LBVirtualServer id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(AggregateLBVirtualServerStatus, Fixnum, Hash)>] AggregateLBVirtualServerStatus data, response status code and response headers
    def get_vpc_lb_virtual_server_status_with_http_info(org_id, project_id, vpc_id, vpc_lb_id, vpc_lb_virtual_server_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.get_vpc_lb_virtual_server_status ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling StatusApi.get_vpc_lb_virtual_server_status"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling StatusApi.get_vpc_lb_virtual_server_status"
      end
      # verify the required parameter 'vpc_id' is set
      if @api_client.config.client_side_validation && vpc_id.nil?
        fail ArgumentError, "Missing the required parameter 'vpc_id' when calling StatusApi.get_vpc_lb_virtual_server_status"
      end
      # verify the required parameter 'vpc_lb_id' is set
      if @api_client.config.client_side_validation && vpc_lb_id.nil?
        fail ArgumentError, "Missing the required parameter 'vpc_lb_id' when calling StatusApi.get_vpc_lb_virtual_server_status"
      end
      # verify the required parameter 'vpc_lb_virtual_server_id' is set
      if @api_client.config.client_side_validation && vpc_lb_virtual_server_id.nil?
        fail ArgumentError, "Missing the required parameter 'vpc_lb_virtual_server_id' when calling StatusApi.get_vpc_lb_virtual_server_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/vpcs/{vpc-id}/vpc-lbs/{vpc-lb-id}/vpc-lb-virtual-servers/{vpc-lb-virtual-server-id}/detailed-status'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'vpc-id' + '}', vpc_id.to_s).sub('{' + 'vpc-lb-id' + '}', vpc_lb_id.to_s).sub('{' + 'vpc-lb-virtual-server-id' + '}', vpc_lb_virtual_server_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AggregateLBVirtualServerStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#get_vpc_lb_virtual_server_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment port status information
    # Get infra segment port status information. 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentPortStatus]
    def global_infra_get_infra_segment_port_status(segments_id, port_id, opts = {})
      data, _status_code, _headers = global_infra_get_infra_segment_port_status_with_http_info(segments_id, port_id, opts)
      data
    end

    # Get infra segment port status information
    # Get infra segment port status information. 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentPortStatus, Fixnum, Hash)>] SegmentPortStatus data, response status code and response headers
    def global_infra_get_infra_segment_port_status_with_http_info(segments_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.global_infra_get_infra_segment_port_status ...'
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling StatusApi.global_infra_get_infra_segment_port_status"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling StatusApi.global_infra_get_infra_segment_port_status"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling StatusApi.global_infra_get_infra_segment_port_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling StatusApi.global_infra_get_infra_segment_port_status, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/global-infra/segments/{segments-id}/ports/{port-id}/status'.sub('{' + 'segments-id' + '}', segments_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#global_infra_get_infra_segment_port_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get a Policy Edge Cluster allocation status  under an Enforcement Point
    # Returns the allocation details of cluster and its members. Lists the edge node members, active and standby services of each node, utilization details of configured sub-pools. These allocation details can be monitored by customers to trigger migration of certain service contexts to different edge nodes, to balance the utilization of edge node resources. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param edge_cluster_id 
    # @param [Hash] opts the optional parameters
    # @return [PolicyEdgeClusterAllocationStatus]
    def global_infra_get_policy_edge_cluster_allocation_status(site_id, enforcementpoint_id, edge_cluster_id, opts = {})
      data, _status_code, _headers = global_infra_get_policy_edge_cluster_allocation_status_with_http_info(site_id, enforcementpoint_id, edge_cluster_id, opts)
      data
    end

    # Get a Policy Edge Cluster allocation status  under an Enforcement Point
    # Returns the allocation details of cluster and its members. Lists the edge node members, active and standby services of each node, utilization details of configured sub-pools. These allocation details can be monitored by customers to trigger migration of certain service contexts to different edge nodes, to balance the utilization of edge node resources. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param edge_cluster_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PolicyEdgeClusterAllocationStatus, Fixnum, Hash)>] PolicyEdgeClusterAllocationStatus data, response status code and response headers
    def global_infra_get_policy_edge_cluster_allocation_status_with_http_info(site_id, enforcementpoint_id, edge_cluster_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.global_infra_get_policy_edge_cluster_allocation_status ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling StatusApi.global_infra_get_policy_edge_cluster_allocation_status"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling StatusApi.global_infra_get_policy_edge_cluster_allocation_status"
      end
      # verify the required parameter 'edge_cluster_id' is set
      if @api_client.config.client_side_validation && edge_cluster_id.nil?
        fail ArgumentError, "Missing the required parameter 'edge_cluster_id' when calling StatusApi.global_infra_get_policy_edge_cluster_allocation_status"
      end
      # resource path
      local_var_path = '/global-infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/edge-clusters/{edge-cluster-id}/allocation/status'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'edge-cluster-id' + '}', edge_cluster_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyEdgeClusterAllocationStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#global_infra_get_policy_edge_cluster_allocation_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get a Policy Edge Cluster real time status  under an Enforcement Point
    # Returns the aggregated status for the Edge cluster along with status of all edge nodes in the cluster. Query parameter \"source=realtime\" is the only supported source. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param edge_cluster_id 
    # @param source Data source type.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PolicyEdgeClusterStatus]
    def global_infra_get_policy_edge_cluster_status(site_id, enforcementpoint_id, edge_cluster_id, source, opts = {})
      data, _status_code, _headers = global_infra_get_policy_edge_cluster_status_with_http_info(site_id, enforcementpoint_id, edge_cluster_id, source, opts)
      data
    end

    # Get a Policy Edge Cluster real time status  under an Enforcement Point
    # Returns the aggregated status for the Edge cluster along with status of all edge nodes in the cluster. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param edge_cluster_id 
    # @param source Data source type.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PolicyEdgeClusterStatus, Fixnum, Hash)>] PolicyEdgeClusterStatus data, response status code and response headers
    def global_infra_get_policy_edge_cluster_status_with_http_info(site_id, enforcementpoint_id, edge_cluster_id, source, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.global_infra_get_policy_edge_cluster_status ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling StatusApi.global_infra_get_policy_edge_cluster_status"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling StatusApi.global_infra_get_policy_edge_cluster_status"
      end
      # verify the required parameter 'edge_cluster_id' is set
      if @api_client.config.client_side_validation && edge_cluster_id.nil?
        fail ArgumentError, "Missing the required parameter 'edge_cluster_id' when calling StatusApi.global_infra_get_policy_edge_cluster_status"
      end
      # verify the required parameter 'source' is set
      if @api_client.config.client_side_validation && source.nil?
        fail ArgumentError, "Missing the required parameter 'source' when calling StatusApi.global_infra_get_policy_edge_cluster_status"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['realtime', 'cached'].include?(source)
        fail ArgumentError, "invalid value for 'source', must be one of realtime, cached"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling StatusApi.global_infra_get_policy_edge_cluster_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling StatusApi.global_infra_get_policy_edge_cluster_status, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/edge-clusters/{edge-cluster-id}/status'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'edge-cluster-id' + '}', edge_cluster_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'source'] = source
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyEdgeClusterStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#global_infra_get_policy_edge_cluster_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get segment port status information
    # Get tier1 segment port status information. 
    # @param tier_1_id 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentPortStatus]
    def global_infra_get_segment_port_status(tier_1_id, segments_id, port_id, opts = {})
      data, _status_code, _headers = global_infra_get_segment_port_status_with_http_info(tier_1_id, segments_id, port_id, opts)
      data
    end

    # Get segment port status information
    # Get tier1 segment port status information. 
    # @param tier_1_id 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentPortStatus, Fixnum, Hash)>] SegmentPortStatus data, response status code and response headers
    def global_infra_get_segment_port_status_with_http_info(tier_1_id, segments_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.global_infra_get_segment_port_status ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling StatusApi.global_infra_get_segment_port_status"
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling StatusApi.global_infra_get_segment_port_status"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling StatusApi.global_infra_get_segment_port_status"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling StatusApi.global_infra_get_segment_port_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling StatusApi.global_infra_get_segment_port_status, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segments-id}/ports/{port-id}/status'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segments-id' + '}', segments_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#global_infra_get_segment_port_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get metadata proxy status
    # Get metadata proxy status
    # @param metadata_proxy_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :segment_path String Path of the segment which is associated with this metadata proxy
    # @option opts [String] :source Data source type.
    # @return [PolicyMetadataProxyStatistics]
    def global_infra_read_metadata_proxy_statistics(metadata_proxy_id, opts = {})
      data, _status_code, _headers = global_infra_read_metadata_proxy_statistics_with_http_info(metadata_proxy_id, opts)
      data
    end

    # Get metadata proxy status
    # Get metadata proxy status
    # @param metadata_proxy_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :segment_path String Path of the segment which is associated with this metadata proxy
    # @option opts [String] :source Data source type.
    # @return [Array<(PolicyMetadataProxyStatistics, Fixnum, Hash)>] PolicyMetadataProxyStatistics data, response status code and response headers
    def global_infra_read_metadata_proxy_statistics_with_http_info(metadata_proxy_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.global_infra_read_metadata_proxy_statistics ...'
      end
      # verify the required parameter 'metadata_proxy_id' is set
      if @api_client.config.client_side_validation && metadata_proxy_id.nil?
        fail ArgumentError, "Missing the required parameter 'metadata_proxy_id' when calling StatusApi.global_infra_read_metadata_proxy_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/metadata-proxies/{metadata-proxy-id}/statistics'.sub('{' + 'metadata-proxy-id' + '}', metadata_proxy_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'segment_path'] = opts[:'segment_path'] if !opts[:'segment_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyMetadataProxyStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#global_infra_read_metadata_proxy_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get metadata proxy status
    # Get metadata proxy status
    # @param metadata_proxy_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :segment_path String Path of the segment which is associated with this metadata proxy
    # @option opts [String] :source Data source type.
    # @return [PolicyMetadataProxyStatus]
    def global_infra_read_metadata_proxy_status(metadata_proxy_id, opts = {})
      data, _status_code, _headers = global_infra_read_metadata_proxy_status_with_http_info(metadata_proxy_id, opts)
      data
    end

    # Get metadata proxy status
    # Get metadata proxy status
    # @param metadata_proxy_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :segment_path String Path of the segment which is associated with this metadata proxy
    # @option opts [String] :source Data source type.
    # @return [Array<(PolicyMetadataProxyStatus, Fixnum, Hash)>] PolicyMetadataProxyStatus data, response status code and response headers
    def global_infra_read_metadata_proxy_status_with_http_info(metadata_proxy_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.global_infra_read_metadata_proxy_status ...'
      end
      # verify the required parameter 'metadata_proxy_id' is set
      if @api_client.config.client_side_validation && metadata_proxy_id.nil?
        fail ArgumentError, "Missing the required parameter 'metadata_proxy_id' when calling StatusApi.global_infra_read_metadata_proxy_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/metadata-proxies/{metadata-proxy-id}/status'.sub('{' + 'metadata-proxy-id' + '}', metadata_proxy_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'segment_path'] = opts[:'segment_path'] if !opts[:'segment_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyMetadataProxyStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#global_infra_read_metadata_proxy_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment port status information
    # Get infra segment port status information. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentPortStatus]
    def orgs_org_id_projects_project_id_infra_get_infra_segment_port_status(org_id, project_id, segments_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_segment_port_status_with_http_info(org_id, project_id, segments_id, port_id, opts)
      data
    end

    # Get infra segment port status information
    # Get infra segment port status information. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentPortStatus, Fixnum, Hash)>] SegmentPortStatus data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_segment_port_status_with_http_info(org_id, project_id, segments_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_status ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_status"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_status"
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_status"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_status"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling StatusApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling StatusApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_status, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segments-id}/ports/{port-id}/status'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segments-id' + '}', segments_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#orgs_org_id_projects_project_id_infra_get_infra_segment_port_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get segment port status information
    # Get tier1 segment port status information. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentPortStatus]
    def orgs_org_id_projects_project_id_infra_get_segment_port_status(org_id, project_id, tier_1_id, segments_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_segment_port_status_with_http_info(org_id, project_id, tier_1_id, segments_id, port_id, opts)
      data
    end

    # Get segment port status information
    # Get tier1 segment port status information. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentPortStatus, Fixnum, Hash)>] SegmentPortStatus data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_segment_port_status_with_http_info(org_id, project_id, tier_1_id, segments_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.orgs_org_id_projects_project_id_infra_get_segment_port_status ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_segment_port_status"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_segment_port_status"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_segment_port_status"
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_segment_port_status"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_segment_port_status"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling StatusApi.orgs_org_id_projects_project_id_infra_get_segment_port_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling StatusApi.orgs_org_id_projects_project_id_infra_get_segment_port_status, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segments-id}/ports/{port-id}/status'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segments-id' + '}', segments_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#orgs_org_id_projects_project_id_infra_get_segment_port_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get IPSec VPN session detailed status under Tier-0
    # - no enforcement point path specified: detailed status is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source=realtime: detailed status is fetched realtime from the enforcement point. - source=cached: cached detailed status from enforcement point is returned.  <br> This API is deprecated. Please use GET /infra/tier-0s/&lt;tier-0-id&gt;/ipsec-vpn-services/&lt;service-id&gt;/ sessions/&lt;session-id&gt;/detailed-status instead. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_0_id 
    # @param locale_service_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [AggregateIPSecVpnSessionStatus]
    def orgs_org_id_projects_project_id_infra_get_tier0_ip_sec_vpn_session_status(org_id, project_id, tier_0_id, locale_service_id, service_id, session_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tier0_ip_sec_vpn_session_status_with_http_info(org_id, project_id, tier_0_id, locale_service_id, service_id, session_id, opts)
      data
    end

    # Get IPSec VPN session detailed status under Tier-0
    # - no enforcement point path specified: detailed status is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source&#x3D;realtime: detailed status is fetched realtime from the enforcement point. - source&#x3D;cached: cached detailed status from enforcement point is returned.  &lt;br&gt; This API is deprecated. Please use GET /infra/tier-0s/&amp;lt;tier-0-id&amp;gt;/ipsec-vpn-services/&amp;lt;service-id&amp;gt;/ sessions/&amp;lt;session-id&amp;gt;/detailed-status instead. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_0_id 
    # @param locale_service_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(AggregateIPSecVpnSessionStatus, Fixnum, Hash)>] AggregateIPSecVpnSessionStatus data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tier0_ip_sec_vpn_session_status_with_http_info(org_id, project_id, tier_0_id, locale_service_id, service_id, session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.orgs_org_id_projects_project_id_infra_get_tier0_ip_sec_vpn_session_status ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier0_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier0_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'tier_0_id' is set
      if @api_client.config.client_side_validation && tier_0_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_0_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier0_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier0_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier0_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier0_ip_sec_vpn_session_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-0s/{tier-0-id}/locale-services/{locale-service-id}/ipsec-vpn-services/{service-id}/sessions/{session-id}/detailed-status'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-0-id' + '}', tier_0_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'session-id' + '}', session_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AggregateIPSecVpnSessionStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#orgs_org_id_projects_project_id_infra_get_tier0_ip_sec_vpn_session_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get IPSec VPN session detailed status under Tier-1
    # - no enforcement point path specified: detailed status is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source=realtime: detailed status is fetched realtime from the enforcement point. - source=cached: cached detailed status from enforcement point is returned.  <br> This API is deprecated. Please use GET /infra/tier-1s/&lt;tier-1-id&gt;/ipsec-vpn-services/&lt;service-id&gt;/sessions/&lt;session-id&gt;/detailed-status instead. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param locale_service_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [AggregateIPSecVpnSessionStatus]
    def orgs_org_id_projects_project_id_infra_get_tier1_ip_sec_vpn_session_status(org_id, project_id, tier_1_id, locale_service_id, service_id, session_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tier1_ip_sec_vpn_session_status_with_http_info(org_id, project_id, tier_1_id, locale_service_id, service_id, session_id, opts)
      data
    end

    # Get IPSec VPN session detailed status under Tier-1
    # - no enforcement point path specified: detailed status is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source&#x3D;realtime: detailed status is fetched realtime from the enforcement point. - source&#x3D;cached: cached detailed status from enforcement point is returned.  &lt;br&gt; This API is deprecated. Please use GET /infra/tier-1s/&amp;lt;tier-1-id&amp;gt;/ipsec-vpn-services/&amp;lt;service-id&amp;gt;/sessions/&amp;lt;session-id&amp;gt;/detailed-status instead. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param locale_service_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(AggregateIPSecVpnSessionStatus, Fixnum, Hash)>] AggregateIPSecVpnSessionStatus data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tier1_ip_sec_vpn_session_status_with_http_info(org_id, project_id, tier_1_id, locale_service_id, service_id, session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.orgs_org_id_projects_project_id_infra_get_tier1_ip_sec_vpn_session_status ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier1_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier1_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier1_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'locale_service_id' is set
      if @api_client.config.client_side_validation && locale_service_id.nil?
        fail ArgumentError, "Missing the required parameter 'locale_service_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier1_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier1_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier1_ip_sec_vpn_session_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/locale-services/{locale-service-id}/ipsec-vpn-services/{service-id}/sessions/{session-id}/detailed-status'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'locale-service-id' + '}', locale_service_id.to_s).sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'session-id' + '}', session_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AggregateIPSecVpnSessionStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#orgs_org_id_projects_project_id_infra_get_tier1_ip_sec_vpn_session_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get IPSec VPN session detailed status under Tier-1
    # - no enforcement point path specified: detailed status is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source=realtime: detailed status is fetched realtime from the enforcement point. - source=cached: cached detailed status from enforcement point is returned. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [AggregateIPSecVpnSessionStatus]
    def orgs_org_id_projects_project_id_infra_get_tier1_vpn_ip_sec_vpn_session_status(org_id, project_id, tier_1_id, service_id, session_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tier1_vpn_ip_sec_vpn_session_status_with_http_info(org_id, project_id, tier_1_id, service_id, session_id, opts)
      data
    end

    # Get IPSec VPN session detailed status under Tier-1
    # - no enforcement point path specified: detailed status is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source&#x3D;realtime: detailed status is fetched realtime from the enforcement point. - source&#x3D;cached: cached detailed status from enforcement point is returned. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(AggregateIPSecVpnSessionStatus, Fixnum, Hash)>] AggregateIPSecVpnSessionStatus data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tier1_vpn_ip_sec_vpn_session_status_with_http_info(org_id, project_id, tier_1_id, service_id, session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.orgs_org_id_projects_project_id_infra_get_tier1_vpn_ip_sec_vpn_session_status ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier1_vpn_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier1_vpn_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier1_vpn_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier1_vpn_ip_sec_vpn_session_status"
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier1_vpn_ip_sec_vpn_session_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/ipsec-vpn-services/{service-id}/sessions/{session-id}/detailed-status'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'session-id' + '}', session_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AggregateIPSecVpnSessionStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#orgs_org_id_projects_project_id_infra_get_tier1_vpn_ip_sec_vpn_session_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get L2VPN session detailed status under Tier-1
    # - no enforcement point path specified: detailed tatus is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source=realtime: detailed tatus is fetched realtime from the enforcement point. - source=cached: cached detailed status is returned. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [AggregateL2VPNSessionStatus]
    def orgs_org_id_projects_project_id_infra_get_tier1_vpn_l2_vpn_session_status(org_id, project_id, tier_1_id, service_id, session_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tier1_vpn_l2_vpn_session_status_with_http_info(org_id, project_id, tier_1_id, service_id, session_id, opts)
      data
    end

    # Get L2VPN session detailed status under Tier-1
    # - no enforcement point path specified: detailed tatus is evaluated on each enforcement point. - an enforcement point path is specified: detailed status is evaluated only on the given enforcement point. - source&#x3D;realtime: detailed tatus is fetched realtime from the enforcement point. - source&#x3D;cached: cached detailed status is returned. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param service_id 
    # @param session_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(AggregateL2VPNSessionStatus, Fixnum, Hash)>] AggregateL2VPNSessionStatus data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tier1_vpn_l2_vpn_session_status_with_http_info(org_id, project_id, tier_1_id, service_id, session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.orgs_org_id_projects_project_id_infra_get_tier1_vpn_l2_vpn_session_status ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier1_vpn_l2_vpn_session_status"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier1_vpn_l2_vpn_session_status"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier1_vpn_l2_vpn_session_status"
      end
      # verify the required parameter 'service_id' is set
      if @api_client.config.client_side_validation && service_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier1_vpn_l2_vpn_session_status"
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling StatusApi.orgs_org_id_projects_project_id_infra_get_tier1_vpn_l2_vpn_session_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/l2vpn-services/{service-id}/sessions/{session-id}/detailed-status'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'service-id' + '}', service_id.to_s).sub('{' + 'session-id' + '}', session_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AggregateL2VPNSessionStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#orgs_org_id_projects_project_id_infra_get_tier1_vpn_l2_vpn_session_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get platform deployment or undeployment progress status
    # Get platform deployment or undeployment progress status.
    # @param site_id 
    # @param [Hash] opts the optional parameters
    # @return [DeploymentProgressStatus]
    def platform_deployment_progress(site_id, opts = {})
      data, _status_code, _headers = platform_deployment_progress_with_http_info(site_id, opts)
      data
    end

    # Get platform deployment or undeployment progress status
    # Get platform deployment or undeployment progress status.
    # @param site_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(DeploymentProgressStatus, Fixnum, Hash)>] DeploymentProgressStatus data, response status code and response headers
    def platform_deployment_progress_with_http_info(site_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.platform_deployment_progress ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling StatusApi.platform_deployment_progress"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/napp/deployment/platform/status'.sub('{' + 'site-id' + '}', site_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DeploymentProgressStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#platform_deployment_progress\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get metadata proxy status
    # Get metadata proxy status
    # @param metadata_proxy_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :segment_path String Path of the segment which is associated with this metadata proxy
    # @option opts [String] :source Data source type.
    # @return [PolicyMetadataProxyStatistics]
    def read_metadata_proxy_statistics(metadata_proxy_id, opts = {})
      data, _status_code, _headers = read_metadata_proxy_statistics_with_http_info(metadata_proxy_id, opts)
      data
    end

    # Get metadata proxy status
    # Get metadata proxy status
    # @param metadata_proxy_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :segment_path String Path of the segment which is associated with this metadata proxy
    # @option opts [String] :source Data source type.
    # @return [Array<(PolicyMetadataProxyStatistics, Fixnum, Hash)>] PolicyMetadataProxyStatistics data, response status code and response headers
    def read_metadata_proxy_statistics_with_http_info(metadata_proxy_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.read_metadata_proxy_statistics ...'
      end
      # verify the required parameter 'metadata_proxy_id' is set
      if @api_client.config.client_side_validation && metadata_proxy_id.nil?
        fail ArgumentError, "Missing the required parameter 'metadata_proxy_id' when calling StatusApi.read_metadata_proxy_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/metadata-proxies/{metadata-proxy-id}/statistics'.sub('{' + 'metadata-proxy-id' + '}', metadata_proxy_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'segment_path'] = opts[:'segment_path'] if !opts[:'segment_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyMetadataProxyStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#read_metadata_proxy_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get metadata proxy status
    # Get metadata proxy status
    # @param metadata_proxy_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :segment_path String Path of the segment which is associated with this metadata proxy
    # @option opts [String] :source Data source type.
    # @return [PolicyMetadataProxyStatus]
    def read_metadata_proxy_status(metadata_proxy_id, opts = {})
      data, _status_code, _headers = read_metadata_proxy_status_with_http_info(metadata_proxy_id, opts)
      data
    end

    # Get metadata proxy status
    # Get metadata proxy status
    # @param metadata_proxy_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :segment_path String Path of the segment which is associated with this metadata proxy
    # @option opts [String] :source Data source type.
    # @return [Array<(PolicyMetadataProxyStatus, Fixnum, Hash)>] PolicyMetadataProxyStatus data, response status code and response headers
    def read_metadata_proxy_status_with_http_info(metadata_proxy_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.read_metadata_proxy_status ...'
      end
      # verify the required parameter 'metadata_proxy_id' is set
      if @api_client.config.client_side_validation && metadata_proxy_id.nil?
        fail ArgumentError, "Missing the required parameter 'metadata_proxy_id' when calling StatusApi.read_metadata_proxy_status"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/metadata-proxies/{metadata-proxy-id}/status'.sub('{' + 'metadata-proxy-id' + '}', metadata_proxy_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'segment_path'] = opts[:'segment_path'] if !opts[:'segment_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyMetadataProxyStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#read_metadata_proxy_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Run pre/post checks for NSX Application Platform
    # Run pre/post checks for NSX Application Platform 
    # @param site_id 
    # @param platform_deployment_checks_action 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def run_deployment_checks(site_id, platform_deployment_checks_action, opts = {})
      run_deployment_checks_with_http_info(site_id, platform_deployment_checks_action, opts)
      nil
    end

    # Run pre/post checks for NSX Application Platform
    # Run pre/post checks for NSX Application Platform 
    # @param site_id 
    # @param platform_deployment_checks_action 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def run_deployment_checks_with_http_info(site_id, platform_deployment_checks_action, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: StatusApi.run_deployment_checks ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling StatusApi.run_deployment_checks"
      end
      # verify the required parameter 'platform_deployment_checks_action' is set
      if @api_client.config.client_side_validation && platform_deployment_checks_action.nil?
        fail ArgumentError, "Missing the required parameter 'platform_deployment_checks_action' when calling StatusApi.run_deployment_checks"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/napp/deployment/platform/checks'.sub('{' + 'site-id' + '}', site_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(platform_deployment_checks_action)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: StatusApi#run_deployment_checks\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
