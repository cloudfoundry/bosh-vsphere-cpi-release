=begin
#NSX Policy API

#VMware NSX Policy REST API

OpenAPI spec version: 9.0.0.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.4.46

=end

require 'uri'

module Nsxt9PolicyClient
  class ConfigurationApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Set the cluster configuration for the Avi Load Balancer Controller node. The VIP can be set once. Attempting to change the VIP once set will return an error in case Avi Controllers are deployed.
    # Set the cluster configuration for Avi Load Balancer Controller cluster. 
    # @param alb_controller_node_vm_cluster_config 
    # @param [Hash] opts the optional parameters
    # @return [ALBControllerNodeVMClusterConfig]
    def add_alb_controller_node_cluster_config(alb_controller_node_vm_cluster_config, opts = {})
      data, _status_code, _headers = add_alb_controller_node_cluster_config_with_http_info(alb_controller_node_vm_cluster_config, opts)
      data
    end

    # Set the cluster configuration for the Avi Load Balancer Controller node. The VIP can be set once. Attempting to change the VIP once set will return an error in case Avi Controllers are deployed.
    # Set the cluster configuration for Avi Load Balancer Controller cluster. 
    # @param alb_controller_node_vm_cluster_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ALBControllerNodeVMClusterConfig, Fixnum, Hash)>] ALBControllerNodeVMClusterConfig data, response status code and response headers
    def add_alb_controller_node_cluster_config_with_http_info(alb_controller_node_vm_cluster_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.add_alb_controller_node_cluster_config ...'
      end
      # verify the required parameter 'alb_controller_node_vm_cluster_config' is set
      if @api_client.config.client_side_validation && alb_controller_node_vm_cluster_config.nil?
        fail ArgumentError, "Missing the required parameter 'alb_controller_node_vm_cluster_config' when calling ConfigurationApi.add_alb_controller_node_cluster_config"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/clusterconfig'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(alb_controller_node_vm_cluster_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerNodeVMClusterConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#add_alb_controller_node_cluster_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Deploy and register a Avi Load Balancer Controller node
    # Deploys a Avi Load Balancer Controller node as specified by the deployment config. 
    # @param add_alb_controller_node_vm_info 
    # @param [Hash] opts the optional parameters
    # @return [ALBControllerNodeVMDeploymentRequestList]
    def add_alb_controller_node_vm(add_alb_controller_node_vm_info, opts = {})
      data, _status_code, _headers = add_alb_controller_node_vm_with_http_info(add_alb_controller_node_vm_info, opts)
      data
    end

    # Deploy and register a Avi Load Balancer Controller node
    # Deploys a Avi Load Balancer Controller node as specified by the deployment config. 
    # @param add_alb_controller_node_vm_info 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ALBControllerNodeVMDeploymentRequestList, Fixnum, Hash)>] ALBControllerNodeVMDeploymentRequestList data, response status code and response headers
    def add_alb_controller_node_vm_with_http_info(add_alb_controller_node_vm_info, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.add_alb_controller_node_vm ...'
      end
      # verify the required parameter 'add_alb_controller_node_vm_info' is set
      if @api_client.config.client_side_validation && add_alb_controller_node_vm_info.nil?
        fail ArgumentError, "Missing the required parameter 'add_alb_controller_node_vm_info' when calling ConfigurationApi.add_alb_controller_node_vm"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/deployments'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(add_alb_controller_node_vm_info)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerNodeVMDeploymentRequestList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#add_alb_controller_node_vm\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Validate admin password for Avi Load Balancer Controller.
    # Use this API to validate admin password in Avi Load Balancer Controller. This API is for VCF deployments only. 
    # @param alb_controller_admin_credential 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def admin_check_password(alb_controller_admin_credential, opts = {})
      admin_check_password_with_http_info(alb_controller_admin_credential, opts)
      nil
    end

    # Validate admin password for Avi Load Balancer Controller.
    # Use this API to validate admin password in Avi Load Balancer Controller. This API is for VCF deployments only. 
    # @param alb_controller_admin_credential 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def admin_check_password_with_http_info(alb_controller_admin_credential, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.admin_check_password ...'
      end
      # verify the required parameter 'alb_controller_admin_credential' is set
      if @api_client.config.client_side_validation && alb_controller_admin_credential.nil?
        fail ArgumentError, "Missing the required parameter 'alb_controller_admin_credential' when calling ConfigurationApi.admin_check_password"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/check-password'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(alb_controller_admin_credential)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#admin_check_password\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Configure the cluster for security
    # This API configures a compute collection for security. In the request body, specify a Transport Node Collection with only the ID of the target compute collection meant for security. Specifically, a Transport Node Profile ID should not be specified. This API will define a system-generated security Transport Node Profile and apply it on the compute collection to create the Transport Node Collection.
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param host_transport_node_collection 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def configure_transport_node_collection_for_security(site_id, enforcementpoint_id, transport_node_collection_id, host_transport_node_collection, opts = {})
      configure_transport_node_collection_for_security_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, host_transport_node_collection, opts)
      nil
    end

    # Configure the cluster for security
    # This API configures a compute collection for security. In the request body, specify a Transport Node Collection with only the ID of the target compute collection meant for security. Specifically, a Transport Node Profile ID should not be specified. This API will define a system-generated security Transport Node Profile and apply it on the compute collection to create the Transport Node Collection.
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param host_transport_node_collection 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def configure_transport_node_collection_for_security_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, host_transport_node_collection, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.configure_transport_node_collection_for_security ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.configure_transport_node_collection_for_security"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.configure_transport_node_collection_for_security"
      end
      # verify the required parameter 'transport_node_collection_id' is set
      if @api_client.config.client_side_validation && transport_node_collection_id.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_collection_id' when calling ConfigurationApi.configure_transport_node_collection_for_security"
      end
      # verify the required parameter 'host_transport_node_collection' is set
      if @api_client.config.client_side_validation && host_transport_node_collection.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_collection' when calling ConfigurationApi.configure_transport_node_collection_for_security"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/transport-node-collections/{transport-node-collection-id}?action=install_for_microseg'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'transport-node-collection-id' + '}', transport_node_collection_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(host_transport_node_collection)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#configure_transport_node_collection_for_security\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create portal certificate CSR for Avi Load Balancer Controller.
    # Use this API to create portal certificate CSR for Avi Load Balancer Controller. 
    # @param alb_controller_certificate_csr 
    # @param [Hash] opts the optional parameters
    # @return [ALBControllerCertificate]
    def create_alb_portal_certificate_csr(alb_controller_certificate_csr, opts = {})
      data, _status_code, _headers = create_alb_portal_certificate_csr_with_http_info(alb_controller_certificate_csr, opts)
      data
    end

    # Create portal certificate CSR for Avi Load Balancer Controller.
    # Use this API to create portal certificate CSR for Avi Load Balancer Controller. 
    # @param alb_controller_certificate_csr 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ALBControllerCertificate, Fixnum, Hash)>] ALBControllerCertificate data, response status code and response headers
    def create_alb_portal_certificate_csr_with_http_info(alb_controller_certificate_csr, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.create_alb_portal_certificate_csr ...'
      end
      # verify the required parameter 'alb_controller_certificate_csr' is set
      if @api_client.config.client_side_validation && alb_controller_certificate_csr.nil?
        fail ArgumentError, "Missing the required parameter 'alb_controller_certificate_csr' when calling ConfigurationApi.create_alb_portal_certificate_csr"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/certificate/csr'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(alb_controller_certificate_csr)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#create_alb_portal_certificate_csr\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create service user object credential in Avi Load Balancer Controller cluster.
    # Use this API to create service user object credential in Avi Load Balancer Controller cluster. This API is for VCF deployments only. 
    # @param alb_controller_user_credential 
    # @param [Hash] opts the optional parameters
    # @return [ALBControllerUserCredentialResponse]
    def create_alb_user_credential_object(alb_controller_user_credential, opts = {})
      data, _status_code, _headers = create_alb_user_credential_object_with_http_info(alb_controller_user_credential, opts)
      data
    end

    # Create service user object credential in Avi Load Balancer Controller cluster.
    # Use this API to create service user object credential in Avi Load Balancer Controller cluster. This API is for VCF deployments only. 
    # @param alb_controller_user_credential 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ALBControllerUserCredentialResponse, Fixnum, Hash)>] ALBControllerUserCredentialResponse data, response status code and response headers
    def create_alb_user_credential_object_with_http_info(alb_controller_user_credential, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.create_alb_user_credential_object ...'
      end
      # verify the required parameter 'alb_controller_user_credential' is set
      if @api_client.config.client_side_validation && alb_controller_user_credential.nil?
        fail ArgumentError, "Missing the required parameter 'alb_controller_user_credential' when calling ConfigurationApi.create_alb_user_credential_object"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/user-credential'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(alb_controller_user_credential)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerUserCredentialResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#create_alb_user_credential_object\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update deployment information.
    # This is an API called by VCF to store or update deployment information. 
    # @param nsx_manager_deployment_info 
    # @param [Hash] opts the optional parameters
    # @return [NSXManagerDeploymentInfo]
    def create_deployment_info(nsx_manager_deployment_info, opts = {})
      data, _status_code, _headers = create_deployment_info_with_http_info(nsx_manager_deployment_info, opts)
      data
    end

    # Create or update deployment information.
    # This is an API called by VCF to store or update deployment information. 
    # @param nsx_manager_deployment_info 
    # @param [Hash] opts the optional parameters
    # @return [Array<(NSXManagerDeploymentInfo, Fixnum, Hash)>] NSXManagerDeploymentInfo data, response status code and response headers
    def create_deployment_info_with_http_info(nsx_manager_deployment_info, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.create_deployment_info ...'
      end
      # verify the required parameter 'nsx_manager_deployment_info' is set
      if @api_client.config.client_side_validation && nsx_manager_deployment_info.nil?
        fail ArgumentError, "Missing the required parameter 'nsx_manager_deployment_info' when calling ConfigurationApi.create_deployment_info"
      end
      # resource path
      local_var_path = '/watermark'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(nsx_manager_deployment_info)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'NSXManagerDeploymentInfo')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#create_deployment_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create a Event Log server for Firewall Identity store
    # More than one Event Log server can be created and only one event log server is used to synchronize directory objects. If more than one Event Log server is configured, NSX will try all the servers until it is able to successfully connect to one.  <br> <br> Use the following Policy API - <br> PATCH /infra/identity-firewall-stores/&lt;identity-firewall-store-id&gt;/event-log-servers/&lt;event-log-server-id&gt;
    # @param firewall_identity_store_id Firewall Identity store identifier
    # @param event_log_server_id Event Log server identifier
    # @param directory_event_log_server 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @return [nil]
    def create_or_patch_firewall_identity_store_event_log_server(firewall_identity_store_id, event_log_server_id, directory_event_log_server, opts = {})
      create_or_patch_firewall_identity_store_event_log_server_with_http_info(firewall_identity_store_id, event_log_server_id, directory_event_log_server, opts)
      nil
    end

    # Create a Event Log server for Firewall Identity store
    # More than one Event Log server can be created and only one event log server is used to synchronize directory objects. If more than one Event Log server is configured, NSX will try all the servers until it is able to successfully connect to one.  &lt;br&gt; &lt;br&gt; Use the following Policy API - &lt;br&gt; PATCH /infra/identity-firewall-stores/&amp;lt;identity-firewall-store-id&amp;gt;/event-log-servers/&amp;lt;event-log-server-id&amp;gt;
    # @param firewall_identity_store_id Firewall Identity store identifier
    # @param event_log_server_id Event Log server identifier
    # @param directory_event_log_server 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def create_or_patch_firewall_identity_store_event_log_server_with_http_info(firewall_identity_store_id, event_log_server_id, directory_event_log_server, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.create_or_patch_firewall_identity_store_event_log_server ...'
      end
      # verify the required parameter 'firewall_identity_store_id' is set
      if @api_client.config.client_side_validation && firewall_identity_store_id.nil?
        fail ArgumentError, "Missing the required parameter 'firewall_identity_store_id' when calling ConfigurationApi.create_or_patch_firewall_identity_store_event_log_server"
      end
      # verify the required parameter 'event_log_server_id' is set
      if @api_client.config.client_side_validation && event_log_server_id.nil?
        fail ArgumentError, "Missing the required parameter 'event_log_server_id' when calling ConfigurationApi.create_or_patch_firewall_identity_store_event_log_server"
      end
      # verify the required parameter 'directory_event_log_server' is set
      if @api_client.config.client_side_validation && directory_event_log_server.nil?
        fail ArgumentError, "Missing the required parameter 'directory_event_log_server' when calling ConfigurationApi.create_or_patch_firewall_identity_store_event_log_server"
      end
      # resource path
      local_var_path = '/infra/firewall-identity-stores/{firewall-identity-store-id}/event-log-servers/{event-log-server-id}'.sub('{' + 'firewall-identity-store-id' + '}', firewall_identity_store_id.to_s).sub('{' + 'event-log-server-id' + '}', event_log_server_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(directory_event_log_server)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#create_or_patch_firewall_identity_store_event_log_server\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or Update Cluster Control Plane to NSX-T
    # Joins a Cluster Control Plane to NSX-T 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param cluster_control_plane 
    # @param [Hash] opts the optional parameters
    # @return [ClusterControlPlane]
    def create_or_update_cluster_control_plane(site_id, enforcementpoint_id, cluster_control_plane_id, cluster_control_plane, opts = {})
      data, _status_code, _headers = create_or_update_cluster_control_plane_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, cluster_control_plane, opts)
      data
    end

    # Create or Update Cluster Control Plane to NSX-T
    # Joins a Cluster Control Plane to NSX-T 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param cluster_control_plane 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ClusterControlPlane, Fixnum, Hash)>] ClusterControlPlane data, response status code and response headers
    def create_or_update_cluster_control_plane_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, cluster_control_plane, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.create_or_update_cluster_control_plane ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.create_or_update_cluster_control_plane"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.create_or_update_cluster_control_plane"
      end
      # verify the required parameter 'cluster_control_plane_id' is set
      if @api_client.config.client_side_validation && cluster_control_plane_id.nil?
        fail ArgumentError, "Missing the required parameter 'cluster_control_plane_id' when calling ConfigurationApi.create_or_update_cluster_control_plane"
      end
      # verify the required parameter 'cluster_control_plane' is set
      if @api_client.config.client_side_validation && cluster_control_plane.nil?
        fail ArgumentError, "Missing the required parameter 'cluster_control_plane' when calling ConfigurationApi.create_or_update_cluster_control_plane"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/cluster-control-planes/{cluster-control-plane-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'cluster-control-plane-id' + '}', cluster_control_plane_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(cluster_control_plane)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ClusterControlPlane')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#create_or_update_cluster_control_plane\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update deployment information.
    # This is an API called by VCF to update stored deployment information. 
    # @param nsx_manager_deployment_info 
    # @param [Hash] opts the optional parameters
    # @return [NSXManagerDeploymentInfo]
    def create_or_update_deployment_info(nsx_manager_deployment_info, opts = {})
      data, _status_code, _headers = create_or_update_deployment_info_with_http_info(nsx_manager_deployment_info, opts)
      data
    end

    # Create or update deployment information.
    # This is an API called by VCF to update stored deployment information. 
    # @param nsx_manager_deployment_info 
    # @param [Hash] opts the optional parameters
    # @return [Array<(NSXManagerDeploymentInfo, Fixnum, Hash)>] NSXManagerDeploymentInfo data, response status code and response headers
    def create_or_update_deployment_info_with_http_info(nsx_manager_deployment_info, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.create_or_update_deployment_info ...'
      end
      # verify the required parameter 'nsx_manager_deployment_info' is set
      if @api_client.config.client_side_validation && nsx_manager_deployment_info.nil?
        fail ArgumentError, "Missing the required parameter 'nsx_manager_deployment_info' when calling ConfigurationApi.create_or_update_deployment_info"
      end
      # resource path
      local_var_path = '/watermark'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(nsx_manager_deployment_info)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'NSXManagerDeploymentInfo')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#create_or_update_deployment_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a Host Transport Node
    # Transport nodes are hypervisor hosts that will participate in an NSX-T overlay. For a hypervisor host, this means that it hosts VMs that will communicate over NSX-T logical switches.  This API creates transport node for a host node (hypervisor) in the transport network.  When you run this command for a host, NSX Manager attempts to install the NSX kernel modules, which are packaged as VIB, RPM, or DEB files. For the installation to succeed, you must provide the host login credentials and the host thumbprint.  To get the ESXi host thumbprint, SSH to the host and run the <b>openssl x509 -in /etc/vmware/ssl/rui.crt -fingerprint -sha256 -noout</b> command.  To generate host key thumbprint using SHA-256 algorithm please follow the steps below.  Log into the host, making sure that the connection is not vulnerable to a man in the middle attack. Check whether a public key already exists. Host public key is generally located at '/etc/ssh/ssh_host_rsa_key.pub'. If the key is not present then generate a new key by running the following command and follow the instructions.  <b>ssh-keygen -t rsa</b>  Now generate a SHA256 hash of the key using the following command. Please make sure to pass the appropriate file name if the public key is stored with a different file name other than the default 'id_rsa.pub'.  <b>awk '{print $2}' id_rsa.pub | base64 -d | sha256sum -b | sed 's/ .*$//' | xxd -r -p | base64</b>  Additional documentation on creating a transport node can be found in the NSX-T Installation Guide.  In order for the transport node to forward packets, the host_switch_spec property must be specified.  Host switches (called bridges in OVS on KVM hypervisors) are the individual switches within the host virtual switch. Virtual machines are connected to the host switches.  When creating a transport node, you need to specify if the host switches are already manually preconfigured on the node, or if NSX should create and manage the host switches. You specify this choice by the type of host switches you pass in the host_switch_spec property of the TransportNode request payload.  For a KVM host, you can preconfigure the host switch, or you can have NSX Manager perform the configuration. For an ESXi host NSX Manager always configures the host switch.  To preconfigure the host switches on a KVM host, pass an array of PreconfiguredHostSwitchSpec objects that describes those host switches. In the current NSX-T release, only one prefonfigured host switch can be specified.  See the PreconfiguredHostSwitchSpec schema definition for documentation on the properties that must be provided. Preconfigured host switches are only supported on KVM hosts, not on ESXi hosts.  To allow NSX to manage the host switch configuration on KVM hosts, ESXi hosts, pass an array of StandardHostSwitchSpec objects in the host_switch_spec property, and NSX will automatically create host switches with the properties you provide. In the current NSX-T release, up to 16 host switches can be automatically managed. See the StandardHostSwitchSpec schema definition for documentation on the properties that must be provided.  The request should provide node_deployement_info. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param host_transport_node 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :esx_mgmt_if_migration_dest The network ids to which the ESX vmk interfaces will be migrated
    # @option opts [String] :if_id The ESX vmk interfaces to migrate
    # @option opts [BOOLEAN] :override_nsx_ownership Override NSX Ownership (default to false)
    # @option opts [String] :ping_ip IP Addresses to ping right after ESX vmk interfaces were migrated.
    # @option opts [BOOLEAN] :skip_validation Whether to skip front-end validation for vmk/vnic/pnic migration (default to false)
    # @option opts [String] :vnic The ESX vmk interfaces and/or VM NIC to migrate
    # @option opts [String] :vnic_migration_dest The migration destinations of ESX vmk interfaces and/or VM NIC
    # @return [HostTransportNode]
    def create_or_update_host_transport_node(site_id, enforcementpoint_id, host_transport_node_id, host_transport_node, opts = {})
      data, _status_code, _headers = create_or_update_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, host_transport_node, opts)
      data
    end

    # Create or update a Host Transport Node
    # Transport nodes are hypervisor hosts that will participate in an NSX-T overlay. For a hypervisor host, this means that it hosts VMs that will communicate over NSX-T logical switches.  This API creates transport node for a host node (hypervisor) in the transport network.  When you run this command for a host, NSX Manager attempts to install the NSX kernel modules, which are packaged as VIB, RPM, or DEB files. For the installation to succeed, you must provide the host login credentials and the host thumbprint.  To get the ESXi host thumbprint, SSH to the host and run the &lt;b&gt;openssl x509 -in /etc/vmware/ssl/rui.crt -fingerprint -sha256 -noout&lt;/b&gt; command.  To generate host key thumbprint using SHA-256 algorithm please follow the steps below.  Log into the host, making sure that the connection is not vulnerable to a man in the middle attack. Check whether a public key already exists. Host public key is generally located at &#39;/etc/ssh/ssh_host_rsa_key.pub&#39;. If the key is not present then generate a new key by running the following command and follow the instructions.  &lt;b&gt;ssh-keygen -t rsa&lt;/b&gt;  Now generate a SHA256 hash of the key using the following command. Please make sure to pass the appropriate file name if the public key is stored with a different file name other than the default &#39;id_rsa.pub&#39;.  &lt;b&gt;awk &#39;{print $2}&#39; id_rsa.pub | base64 -d | sha256sum -b | sed &#39;s/ .*$//&#39; | xxd -r -p | base64&lt;/b&gt;  Additional documentation on creating a transport node can be found in the NSX-T Installation Guide.  In order for the transport node to forward packets, the host_switch_spec property must be specified.  Host switches (called bridges in OVS on KVM hypervisors) are the individual switches within the host virtual switch. Virtual machines are connected to the host switches.  When creating a transport node, you need to specify if the host switches are already manually preconfigured on the node, or if NSX should create and manage the host switches. You specify this choice by the type of host switches you pass in the host_switch_spec property of the TransportNode request payload.  For a KVM host, you can preconfigure the host switch, or you can have NSX Manager perform the configuration. For an ESXi host NSX Manager always configures the host switch.  To preconfigure the host switches on a KVM host, pass an array of PreconfiguredHostSwitchSpec objects that describes those host switches. In the current NSX-T release, only one prefonfigured host switch can be specified.  See the PreconfiguredHostSwitchSpec schema definition for documentation on the properties that must be provided. Preconfigured host switches are only supported on KVM hosts, not on ESXi hosts.  To allow NSX to manage the host switch configuration on KVM hosts, ESXi hosts, pass an array of StandardHostSwitchSpec objects in the host_switch_spec property, and NSX will automatically create host switches with the properties you provide. In the current NSX-T release, up to 16 host switches can be automatically managed. See the StandardHostSwitchSpec schema definition for documentation on the properties that must be provided.  The request should provide node_deployement_info. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param host_transport_node 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :esx_mgmt_if_migration_dest The network ids to which the ESX vmk interfaces will be migrated
    # @option opts [String] :if_id The ESX vmk interfaces to migrate
    # @option opts [BOOLEAN] :override_nsx_ownership Override NSX Ownership
    # @option opts [String] :ping_ip IP Addresses to ping right after ESX vmk interfaces were migrated.
    # @option opts [BOOLEAN] :skip_validation Whether to skip front-end validation for vmk/vnic/pnic migration
    # @option opts [String] :vnic The ESX vmk interfaces and/or VM NIC to migrate
    # @option opts [String] :vnic_migration_dest The migration destinations of ESX vmk interfaces and/or VM NIC
    # @return [Array<(HostTransportNode, Fixnum, Hash)>] HostTransportNode data, response status code and response headers
    def create_or_update_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, host_transport_node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.create_or_update_host_transport_node ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.create_or_update_host_transport_node"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.create_or_update_host_transport_node"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling ConfigurationApi.create_or_update_host_transport_node"
      end
      # verify the required parameter 'host_transport_node' is set
      if @api_client.config.client_side_validation && host_transport_node.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node' when calling ConfigurationApi.create_or_update_host_transport_node"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'esx_mgmt_if_migration_dest'] = opts[:'esx_mgmt_if_migration_dest'] if !opts[:'esx_mgmt_if_migration_dest'].nil?
      query_params[:'if_id'] = opts[:'if_id'] if !opts[:'if_id'].nil?
      query_params[:'override_nsx_ownership'] = opts[:'override_nsx_ownership'] if !opts[:'override_nsx_ownership'].nil?
      query_params[:'ping_ip'] = opts[:'ping_ip'] if !opts[:'ping_ip'].nil?
      query_params[:'skip_validation'] = opts[:'skip_validation'] if !opts[:'skip_validation'].nil?
      query_params[:'vnic'] = opts[:'vnic'] if !opts[:'vnic'].nil?
      query_params[:'vnic_migration_dest'] = opts[:'vnic_migration_dest'] if !opts[:'vnic_migration_dest'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(host_transport_node)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'HostTransportNode')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#create_or_update_host_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create transport node collection by attaching Transport Node Profile to cluster.
    # When transport node collection is created the hosts which are part of compute collection will be prepared automatically i.e. NSX Manager attempts to install the NSX components on hosts. Transport nodes for these hosts are created using the configuration specified in transport node profile. Pass apply_profile to false, if you do not want to apply transport node profile on the existing transport node with overridden host flag set and ignore overridden hosts flag is set to true on the transport node profile. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collections_id 
    # @param host_transport_node_collection 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :apply_profile Indicates if the Transport Node Profile (TNP) configuration should be applied during creation (default to true)
    # @option opts [BOOLEAN] :override_nsx_ownership Override NSX Ownership (default to false)
    # @return [HostTransportNodeCollection]
    def create_or_update_host_transport_node_collection(site_id, enforcementpoint_id, transport_node_collections_id, host_transport_node_collection, opts = {})
      data, _status_code, _headers = create_or_update_host_transport_node_collection_with_http_info(site_id, enforcementpoint_id, transport_node_collections_id, host_transport_node_collection, opts)
      data
    end

    # Create transport node collection by attaching Transport Node Profile to cluster.
    # When transport node collection is created the hosts which are part of compute collection will be prepared automatically i.e. NSX Manager attempts to install the NSX components on hosts. Transport nodes for these hosts are created using the configuration specified in transport node profile. Pass apply_profile to false, if you do not want to apply transport node profile on the existing transport node with overridden host flag set and ignore overridden hosts flag is set to true on the transport node profile. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collections_id 
    # @param host_transport_node_collection 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :apply_profile Indicates if the Transport Node Profile (TNP) configuration should be applied during creation
    # @option opts [BOOLEAN] :override_nsx_ownership Override NSX Ownership
    # @return [Array<(HostTransportNodeCollection, Fixnum, Hash)>] HostTransportNodeCollection data, response status code and response headers
    def create_or_update_host_transport_node_collection_with_http_info(site_id, enforcementpoint_id, transport_node_collections_id, host_transport_node_collection, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.create_or_update_host_transport_node_collection ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.create_or_update_host_transport_node_collection"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.create_or_update_host_transport_node_collection"
      end
      # verify the required parameter 'transport_node_collections_id' is set
      if @api_client.config.client_side_validation && transport_node_collections_id.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_collections_id' when calling ConfigurationApi.create_or_update_host_transport_node_collection"
      end
      # verify the required parameter 'host_transport_node_collection' is set
      if @api_client.config.client_side_validation && host_transport_node_collection.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_collection' when calling ConfigurationApi.create_or_update_host_transport_node_collection"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/transport-node-collections/{transport-node-collections-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'transport-node-collections-id' + '}', transport_node_collections_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'apply_profile'] = opts[:'apply_profile'] if !opts[:'apply_profile'].nil?
      query_params[:'override_nsx_ownership'] = opts[:'override_nsx_ownership'] if !opts[:'override_nsx_ownership'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(host_transport_node_collection)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'HostTransportNodeCollection')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#create_or_update_host_transport_node_collection\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a Hostswitch Profile
    # Create or update a hostswitch profile. The resource_type is required and needs to be one of the following, UplinkHostSwitchProfile, LldpHostSwitchProfile, NiocProfile & ExtraConfigHostSwitchProfile. Uplink profile - For uplink profiles, the teaming and policy parameters are required. By default, the mtu is 1600 and the transport_vlan is 0. The supported MTU range is 1280 through (uplink_mtu_threshold). uplink_mtu_threshold is 9000 by default. Range can be extended by modifying (uplink_mtu_threshold) in SwitchingGlobalConfig to the required upper threshold. Teaming defined in this profile allows NSX to load balance traffic across different physical NICs (PNICs) on the hypervisor hosts. Multiple teaming policies are supported, including LACP active, LACP passive, load balancing based on source ID, and failover order. Lldp profile - Activate or deactivate sending LLDP packets NiocProfile - Network I/O Control settings: defines limits, shares and reservations for various host traffic types. ExtraConfig - Vendor specific configuration on HostSwitch, logical switch or logical port 
    # @param host_switch_profile_id 
    # @param policy_base_host_switch_profile 
    # @param [Hash] opts the optional parameters
    # @return [PolicyBaseHostSwitchProfile]
    def create_or_update_policy_host_switch_profile(host_switch_profile_id, policy_base_host_switch_profile, opts = {})
      data, _status_code, _headers = create_or_update_policy_host_switch_profile_with_http_info(host_switch_profile_id, policy_base_host_switch_profile, opts)
      data
    end

    # Create or update a Hostswitch Profile
    # Create or update a hostswitch profile. The resource_type is required and needs to be one of the following, UplinkHostSwitchProfile, LldpHostSwitchProfile, NiocProfile &amp; ExtraConfigHostSwitchProfile. Uplink profile - For uplink profiles, the teaming and policy parameters are required. By default, the mtu is 1600 and the transport_vlan is 0. The supported MTU range is 1280 through (uplink_mtu_threshold). uplink_mtu_threshold is 9000 by default. Range can be extended by modifying (uplink_mtu_threshold) in SwitchingGlobalConfig to the required upper threshold. Teaming defined in this profile allows NSX to load balance traffic across different physical NICs (PNICs) on the hypervisor hosts. Multiple teaming policies are supported, including LACP active, LACP passive, load balancing based on source ID, and failover order. Lldp profile - Activate or deactivate sending LLDP packets NiocProfile - Network I/O Control settings: defines limits, shares and reservations for various host traffic types. ExtraConfig - Vendor specific configuration on HostSwitch, logical switch or logical port 
    # @param host_switch_profile_id 
    # @param policy_base_host_switch_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PolicyBaseHostSwitchProfile, Fixnum, Hash)>] PolicyBaseHostSwitchProfile data, response status code and response headers
    def create_or_update_policy_host_switch_profile_with_http_info(host_switch_profile_id, policy_base_host_switch_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.create_or_update_policy_host_switch_profile ...'
      end
      # verify the required parameter 'host_switch_profile_id' is set
      if @api_client.config.client_side_validation && host_switch_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_switch_profile_id' when calling ConfigurationApi.create_or_update_policy_host_switch_profile"
      end
      # verify the required parameter 'policy_base_host_switch_profile' is set
      if @api_client.config.client_side_validation && policy_base_host_switch_profile.nil?
        fail ArgumentError, "Missing the required parameter 'policy_base_host_switch_profile' when calling ConfigurationApi.create_or_update_policy_host_switch_profile"
      end
      # resource path
      local_var_path = '/infra/host-switch-profiles/{host-switch-profile-id}'.sub('{' + 'host-switch-profile-id' + '}', host_switch_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(policy_base_host_switch_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyBaseHostSwitchProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#create_or_update_policy_host_switch_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update a Host Transport Node Profile
    # Host transport node profile captures the configuration needed to create a host transport node. A host transport node profile can be attached to compute collections for automatic host transport node creation of member hosts.  When configurations of a host transport node profile(TNP) are updated, all the host transport nodes in all the compute collections to which this TNP is attached are updated to reflect the updated configuration. 
    # @param transport_node_profile_id 
    # @param policy_host_transport_node_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override_nsx_ownership Override NSX Ownership (default to false)
    # @return [PolicyHostTransportNodeProfile]
    def create_or_update_policy_host_transport_node_profile(transport_node_profile_id, policy_host_transport_node_profile, opts = {})
      data, _status_code, _headers = create_or_update_policy_host_transport_node_profile_with_http_info(transport_node_profile_id, policy_host_transport_node_profile, opts)
      data
    end

    # Update a Host Transport Node Profile
    # Host transport node profile captures the configuration needed to create a host transport node. A host transport node profile can be attached to compute collections for automatic host transport node creation of member hosts.  When configurations of a host transport node profile(TNP) are updated, all the host transport nodes in all the compute collections to which this TNP is attached are updated to reflect the updated configuration. 
    # @param transport_node_profile_id 
    # @param policy_host_transport_node_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override_nsx_ownership Override NSX Ownership
    # @return [Array<(PolicyHostTransportNodeProfile, Fixnum, Hash)>] PolicyHostTransportNodeProfile data, response status code and response headers
    def create_or_update_policy_host_transport_node_profile_with_http_info(transport_node_profile_id, policy_host_transport_node_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.create_or_update_policy_host_transport_node_profile ...'
      end
      # verify the required parameter 'transport_node_profile_id' is set
      if @api_client.config.client_side_validation && transport_node_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_profile_id' when calling ConfigurationApi.create_or_update_policy_host_transport_node_profile"
      end
      # verify the required parameter 'policy_host_transport_node_profile' is set
      if @api_client.config.client_side_validation && policy_host_transport_node_profile.nil?
        fail ArgumentError, "Missing the required parameter 'policy_host_transport_node_profile' when calling ConfigurationApi.create_or_update_policy_host_transport_node_profile"
      end
      # resource path
      local_var_path = '/infra/host-transport-node-profiles/{transport-node-profile-id}'.sub('{' + 'transport-node-profile-id' + '}', transport_node_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override_nsx_ownership'] = opts[:'override_nsx_ownership'] if !opts[:'override_nsx_ownership'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(policy_host_transport_node_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyHostTransportNodeProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#create_or_update_policy_host_transport_node_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or Update a sub-cluster
    # Create or update a sub-cluster under a compute collection. Maximum number of sub-clusters that can be created under a compute collection is 16. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param subcluster_id 
    # @param sub_cluster 
    # @param [Hash] opts the optional parameters
    # @return [SubCluster]
    def create_or_update_sub_cluster(site_id, enforcementpoint_id, subcluster_id, sub_cluster, opts = {})
      data, _status_code, _headers = create_or_update_sub_cluster_with_http_info(site_id, enforcementpoint_id, subcluster_id, sub_cluster, opts)
      data
    end

    # Create or Update a sub-cluster
    # Create or update a sub-cluster under a compute collection. Maximum number of sub-clusters that can be created under a compute collection is 16. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param subcluster_id 
    # @param sub_cluster 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SubCluster, Fixnum, Hash)>] SubCluster data, response status code and response headers
    def create_or_update_sub_cluster_with_http_info(site_id, enforcementpoint_id, subcluster_id, sub_cluster, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.create_or_update_sub_cluster ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.create_or_update_sub_cluster"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.create_or_update_sub_cluster"
      end
      # verify the required parameter 'subcluster_id' is set
      if @api_client.config.client_side_validation && subcluster_id.nil?
        fail ArgumentError, "Missing the required parameter 'subcluster_id' when calling ConfigurationApi.create_or_update_sub_cluster"
      end
      # verify the required parameter 'sub_cluster' is set
      if @api_client.config.client_side_validation && sub_cluster.nil?
        fail ArgumentError, "Missing the required parameter 'sub_cluster' when calling ConfigurationApi.create_or_update_sub_cluster"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/sub-clusters/{subcluster-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'subcluster-id' + '}', subcluster_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(sub_cluster)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SubCluster')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#create_or_update_sub_cluster\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete the cluster configuration for the Avi Load Balancer Controller cluster configuration. If Avi Load Balancer Controllers are present delete will fail.
    # Delete the cluster configuration for Avi Load Balancer Controller cluster. This API is for VCF deployments only. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @return [nil]
    def delete_alb_controller_node_cluster_config(opts = {})
      delete_alb_controller_node_cluster_config_with_http_info(opts)
      nil
    end

    # Delete the cluster configuration for the Avi Load Balancer Controller cluster configuration. If Avi Load Balancer Controllers are present delete will fail.
    # Delete the cluster configuration for Avi Load Balancer Controller cluster. This API is for VCF deployments only. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_alb_controller_node_cluster_config_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.delete_alb_controller_node_cluster_config ...'
      end
      # resource path
      local_var_path = '/alb/controller-nodes/clusterconfig'

      # query parameters
      query_params = {}
      query_params[:'clustering_id'] = opts[:'clustering_id'] if !opts[:'clustering_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#delete_alb_controller_node_cluster_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Avi EnforcementPoint and the Infra Admin credentials contained by this workflow.
    # Delete Avi EnforcementPoint along with Infra Admin credentials. 
    # @param managed_by On Boarding flow managed by LCM/VCF.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_alb_on_boarding_workflow(managed_by, opts = {})
      delete_alb_on_boarding_workflow_with_http_info(managed_by, opts)
      nil
    end

    # Delete Avi EnforcementPoint and the Infra Admin credentials contained by this workflow.
    # Delete Avi EnforcementPoint along with Infra Admin credentials. 
    # @param managed_by On Boarding flow managed by LCM/VCF.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_alb_on_boarding_workflow_with_http_info(managed_by, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.delete_alb_on_boarding_workflow ...'
      end
      # verify the required parameter 'managed_by' is set
      if @api_client.config.client_side_validation && managed_by.nil?
        fail ArgumentError, "Missing the required parameter 'managed_by' when calling ConfigurationApi.delete_alb_on_boarding_workflow"
      end
      # resource path
      local_var_path = '/infra/alb-onboarding-workflow/{managed-by}'.sub('{' + 'managed-by' + '}', managed_by.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#delete_alb_on_boarding_workflow\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete user credential from Avi Load Balancer Controller cluster.
    # Use this API to delete user credentials in Avi Load Balancer Controller cluster. This API is for VCF deployments only. 
    # @param username Credentials to be deleted.
    # @param user_credential_type Type of user credential
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @return [nil]
    def delete_alb_user_credential_object(username, user_credential_type, opts = {})
      delete_alb_user_credential_object_with_http_info(username, user_credential_type, opts)
      nil
    end

    # Delete user credential from Avi Load Balancer Controller cluster.
    # Use this API to delete user credentials in Avi Load Balancer Controller cluster. This API is for VCF deployments only. 
    # @param username Credentials to be deleted.
    # @param user_credential_type Type of user credential
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_alb_user_credential_object_with_http_info(username, user_credential_type, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.delete_alb_user_credential_object ...'
      end
      # verify the required parameter 'username' is set
      if @api_client.config.client_side_validation && username.nil?
        fail ArgumentError, "Missing the required parameter 'username' when calling ConfigurationApi.delete_alb_user_credential_object"
      end
      # verify the required parameter 'user_credential_type' is set
      if @api_client.config.client_side_validation && user_credential_type.nil?
        fail ArgumentError, "Missing the required parameter 'user_credential_type' when calling ConfigurationApi.delete_alb_user_credential_object"
      end
      # verify enum value
      if @api_client.config.client_side_validation && !['VCENTER_SERVICE_USER_CREDENTIAL', 'NSX_SERVICE_USER_CREDENTIAL'].include?(user_credential_type)
        fail ArgumentError, "invalid value for 'user_credential_type', must be one of VCENTER_SERVICE_USER_CREDENTIAL, NSX_SERVICE_USER_CREDENTIAL"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/user-credential/{username}'.sub('{' + 'username' + '}', username.to_s)

      # query parameters
      query_params = {}
      query_params[:'user_credential_type'] = user_credential_type
      query_params[:'clustering_id'] = opts[:'clustering_id'] if !opts[:'clustering_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#delete_alb_user_credential_object\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Attempt to delete an auto-deployed Avi Load Balancer Controller node
    # Attempts to unregister and undeploy a specified auto-deployed cluster node. If it is a member of a cluster, then the node will be automatically detached from the cluster before being unregistered and undeployed. Alternatively, if the original deployment attempt failed or the node is not found, cleans up the deployment information associated with the deployment attempt. Note: If a node has been successfully auto-deployed, then the associated deployment information will not be deleted unless and until the node is successfully deleted. 
    # @param node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :force_delete Delete by force
    # @option opts [String] :inaccessible Delete when controller is inaccessible
    # @return [nil]
    def delete_auto_deployed_alb_controller_node_vm(node_id, opts = {})
      delete_auto_deployed_alb_controller_node_vm_with_http_info(node_id, opts)
      nil
    end

    # Attempt to delete an auto-deployed Avi Load Balancer Controller node
    # Attempts to unregister and undeploy a specified auto-deployed cluster node. If it is a member of a cluster, then the node will be automatically detached from the cluster before being unregistered and undeployed. Alternatively, if the original deployment attempt failed or the node is not found, cleans up the deployment information associated with the deployment attempt. Note: If a node has been successfully auto-deployed, then the associated deployment information will not be deleted unless and until the node is successfully deleted. 
    # @param node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :force_delete Delete by force
    # @option opts [String] :inaccessible Delete when controller is inaccessible
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_auto_deployed_alb_controller_node_vm_with_http_info(node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.delete_auto_deployed_alb_controller_node_vm ...'
      end
      # verify the required parameter 'node_id' is set
      if @api_client.config.client_side_validation && node_id.nil?
        fail ArgumentError, "Missing the required parameter 'node_id' when calling ConfigurationApi.delete_auto_deployed_alb_controller_node_vm"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/deployments/{node-id}?action=delete'.sub('{' + 'node-id' + '}', node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'force_delete'] = opts[:'force_delete'] if !opts[:'force_delete'].nil?
      query_params[:'inaccessible'] = opts[:'inaccessible'] if !opts[:'inaccessible'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#delete_auto_deployed_alb_controller_node_vm\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a Cluster Control Plane Node
    # Delete a Cluster Control Plane Node
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :cascade Flag to indicate if force delete cluster references from the firewall security policies. (default to false)
    # @return [nil]
    def delete_cluster_control_plane(site_id, enforcementpoint_id, cluster_control_plane_id, opts = {})
      delete_cluster_control_plane_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, opts)
      nil
    end

    # Delete a Cluster Control Plane Node
    # Delete a Cluster Control Plane Node
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :cascade Flag to indicate if force delete cluster references from the firewall security policies.
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_cluster_control_plane_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.delete_cluster_control_plane ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.delete_cluster_control_plane"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.delete_cluster_control_plane"
      end
      # verify the required parameter 'cluster_control_plane_id' is set
      if @api_client.config.client_side_validation && cluster_control_plane_id.nil?
        fail ArgumentError, "Missing the required parameter 'cluster_control_plane_id' when calling ConfigurationApi.delete_cluster_control_plane"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/cluster-control-planes/{cluster-control-plane-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'cluster-control-plane-id' + '}', cluster_control_plane_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cascade'] = opts[:'cascade'] if !opts[:'cascade'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#delete_cluster_control_plane\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete deployment information.
    # This is an API called by VCF to delete deployment information. 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_deployment_info(opts = {})
      delete_deployment_info_with_http_info(opts)
      nil
    end

    # Delete deployment information.
    # This is an API called by VCF to delete deployment information. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_deployment_info_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.delete_deployment_info ...'
      end
      # resource path
      local_var_path = '/watermark'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#delete_deployment_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a Transport Node
    # Deletes the specified transport node. Query param force can be used to force delete the host nodes. Force delete is not supported if transport node is part of a cluster on which Transport node profile is applied.  It also removes the specified host node from system. If unprepare_host option is set to false, then host will be deleted without uninstalling the NSX components from the host. If transport node delete is called with query param force not being set or set to false and uninstall of NSX components in the host fails, TransportNodeState object will be retained. If transport node delete is called with query param force set to true and uninstall of NSX components in the host fails, TransportNodeState object will be deleted. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :force Force delete the resource even if it is being used somewhere  (default to false)
    # @option opts [BOOLEAN] :unprepare_host Uninstall NSX components from host while deleting (default to true)
    # @return [nil]
    def delete_host_transport_node(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      delete_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      nil
    end

    # Delete a Transport Node
    # Deletes the specified transport node. Query param force can be used to force delete the host nodes. Force delete is not supported if transport node is part of a cluster on which Transport node profile is applied.  It also removes the specified host node from system. If unprepare_host option is set to false, then host will be deleted without uninstalling the NSX components from the host. If transport node delete is called with query param force not being set or set to false and uninstall of NSX components in the host fails, TransportNodeState object will be retained. If transport node delete is called with query param force set to true and uninstall of NSX components in the host fails, TransportNodeState object will be deleted. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :force Force delete the resource even if it is being used somewhere 
    # @option opts [BOOLEAN] :unprepare_host Uninstall NSX components from host while deleting
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.delete_host_transport_node ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.delete_host_transport_node"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.delete_host_transport_node"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling ConfigurationApi.delete_host_transport_node"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'force'] = opts[:'force'] if !opts[:'force'].nil?
      query_params[:'unprepare_host'] = opts[:'unprepare_host'] if !opts[:'unprepare_host'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#delete_host_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Detach transport node profile from compute collection.
    # By deleting transport node collection, we are detaching the transport node profile(TNP) from the compute collection. It has no effect on existing transport nodes. However, new hosts added to the compute collection will no longer be automatically converted to NSX transport node. Detaching TNP from compute collection does not delete TNP. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_host_transport_node_collection(site_id, enforcementpoint_id, transport_node_collection_id, opts = {})
      delete_host_transport_node_collection_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, opts)
      nil
    end

    # Detach transport node profile from compute collection.
    # By deleting transport node collection, we are detaching the transport node profile(TNP) from the compute collection. It has no effect on existing transport nodes. However, new hosts added to the compute collection will no longer be automatically converted to NSX transport node. Detaching TNP from compute collection does not delete TNP. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_host_transport_node_collection_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.delete_host_transport_node_collection ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.delete_host_transport_node_collection"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.delete_host_transport_node_collection"
      end
      # verify the required parameter 'transport_node_collection_id' is set
      if @api_client.config.client_side_validation && transport_node_collection_id.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_collection_id' when calling ConfigurationApi.delete_host_transport_node_collection"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/transport-node-collections/{transport-node-collection-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'transport-node-collection-id' + '}', transport_node_collection_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#delete_host_transport_node_collection\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a Hostswitch Profile
    # Deletes a specified hostswitch profile.
    # @param host_switch_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_policy_host_switch_profile(host_switch_profile_id, opts = {})
      delete_policy_host_switch_profile_with_http_info(host_switch_profile_id, opts)
      nil
    end

    # Delete a Hostswitch Profile
    # Deletes a specified hostswitch profile.
    # @param host_switch_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_policy_host_switch_profile_with_http_info(host_switch_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.delete_policy_host_switch_profile ...'
      end
      # verify the required parameter 'host_switch_profile_id' is set
      if @api_client.config.client_side_validation && host_switch_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_switch_profile_id' when calling ConfigurationApi.delete_policy_host_switch_profile"
      end
      # resource path
      local_var_path = '/infra/host-switch-profiles/{host-switch-profile-id}'.sub('{' + 'host-switch-profile-id' + '}', host_switch_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#delete_policy_host_switch_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a Host Transport Node Profile
    # Deletes the specified host transport node profile. A host transport node profile can be deleted only when it is not attached to any compute collection. 
    # @param transport_node_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_policy_host_transport_node_profile(transport_node_profile_id, opts = {})
      delete_policy_host_transport_node_profile_with_http_info(transport_node_profile_id, opts)
      nil
    end

    # Delete a Host Transport Node Profile
    # Deletes the specified host transport node profile. A host transport node profile can be deleted only when it is not attached to any compute collection. 
    # @param transport_node_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_policy_host_transport_node_profile_with_http_info(transport_node_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.delete_policy_host_transport_node_profile ...'
      end
      # verify the required parameter 'transport_node_profile_id' is set
      if @api_client.config.client_side_validation && transport_node_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_profile_id' when calling ConfigurationApi.delete_policy_host_transport_node_profile"
      end
      # resource path
      local_var_path = '/infra/host-transport-node-profiles/{transport-node-profile-id}'.sub('{' + 'transport-node-profile-id' + '}', transport_node_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#delete_policy_host_transport_node_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a Sub-Cluster
    # Delete a Sub-Cluster. Deletion will not be allowed if sub-cluster contains discovered nodes. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param subcluster_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_sub_cluster(site_id, enforcementpoint_id, subcluster_id, opts = {})
      delete_sub_cluster_with_http_info(site_id, enforcementpoint_id, subcluster_id, opts)
      nil
    end

    # Delete a Sub-Cluster
    # Delete a Sub-Cluster. Deletion will not be allowed if sub-cluster contains discovered nodes. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param subcluster_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_sub_cluster_with_http_info(site_id, enforcementpoint_id, subcluster_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.delete_sub_cluster ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.delete_sub_cluster"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.delete_sub_cluster"
      end
      # verify the required parameter 'subcluster_id' is set
      if @api_client.config.client_side_validation && subcluster_id.nil?
        fail ArgumentError, "Missing the required parameter 'subcluster_id' when calling ConfigurationApi.delete_sub_cluster"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/sub-clusters/{subcluster-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'subcluster-id' + '}', subcluster_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#delete_sub_cluster\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Auth Token API call to Avi Controller.
    # Passthorugh API calls to Avi controller using the Auth of policy API request send to this API will be passthrough to Avi controller and Avi controller response will be embedded for this API. 
    # @param alb_auth_token 
    # @param [Hash] opts the optional parameters
    # @return [ALBAuthToken]
    def get_alb_auth_token(alb_auth_token, opts = {})
      data, _status_code, _headers = get_alb_auth_token_with_http_info(alb_auth_token, opts)
      data
    end

    # Auth Token API call to Avi Controller.
    # Passthorugh API calls to Avi controller using the Auth of policy API request send to this API will be passthrough to Avi controller and Avi controller response will be embedded for this API. 
    # @param alb_auth_token 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ALBAuthToken, Fixnum, Hash)>] ALBAuthToken data, response status code and response headers
    def get_alb_auth_token_with_http_info(alb_auth_token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.get_alb_auth_token ...'
      end
      # verify the required parameter 'alb_auth_token' is set
      if @api_client.config.client_side_validation && alb_auth_token.nil?
        fail ArgumentError, "Missing the required parameter 'alb_auth_token' when calling ConfigurationApi.get_alb_auth_token"
      end
      # resource path
      local_var_path = '/infra/alb-auth-token'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(alb_auth_token)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBAuthToken')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#get_alb_auth_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read API service properties
    # Read the configuration of the NSX API service. 
    # @param [Hash] opts the optional parameters
    # @return [ApiServiceConfig]
    def get_api_service_config(opts = {})
      data, _status_code, _headers = get_api_service_config_with_http_info(opts)
      data
    end

    # Read API service properties
    # Read the configuration of the NSX API service. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiServiceConfig, Fixnum, Hash)>] ApiServiceConfig data, response status code and response headers
    def get_api_service_config_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.get_api_service_config ...'
      end
      # resource path
      local_var_path = '/cluster/api-service'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ApiServiceConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#get_api_service_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read API service properties
    # Read the configuration of the NSX API service. 
    # @param [Hash] opts the optional parameters
    # @return [ApiServiceConfig]
    def get_api_service_config_0(opts = {})
      data, _status_code, _headers = get_api_service_config_0_with_http_info(opts)
      data
    end

    # Read API service properties
    # Read the configuration of the NSX API service. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiServiceConfig, Fixnum, Hash)>] ApiServiceConfig data, response status code and response headers
    def get_api_service_config_0_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.get_api_service_config_0 ...'
      end
      # resource path
      local_var_path = '/cluster/api-service'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ApiServiceConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#get_api_service_config_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Fetch the auto enable gateway firewall configuration value.
    # Read Configuration values for auto-enable-gateway-firewall. 
    # @param [Hash] opts the optional parameters
    # @return [AutoEnableGatewayFirewallConfig]
    def get_auto_enable_gateway_firewall_config(opts = {})
      data, _status_code, _headers = get_auto_enable_gateway_firewall_config_with_http_info(opts)
      data
    end

    # Fetch the auto enable gateway firewall configuration value.
    # Read Configuration values for auto-enable-gateway-firewall. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(AutoEnableGatewayFirewallConfig, Fixnum, Hash)>] AutoEnableGatewayFirewallConfig data, response status code and response headers
    def get_auto_enable_gateway_firewall_config_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.get_auto_enable_gateway_firewall_config ...'
      end
      # resource path
      local_var_path = '/system-config/auto-enable-gateway-firewall'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'AutoEnableGatewayFirewallConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#get_auto_enable_gateway_firewall_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get a Cluster Control Plane
    # Returns information about a specified Cluster Control Plane .
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param [Hash] opts the optional parameters
    # @return [ClusterControlPlane]
    def get_cluster_control_plane(site_id, enforcementpoint_id, cluster_control_plane_id, opts = {})
      data, _status_code, _headers = get_cluster_control_plane_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, opts)
      data
    end

    # Get a Cluster Control Plane
    # Returns information about a specified Cluster Control Plane .
    # @param site_id 
    # @param enforcementpoint_id 
    # @param cluster_control_plane_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ClusterControlPlane, Fixnum, Hash)>] ClusterControlPlane data, response status code and response headers
    def get_cluster_control_plane_with_http_info(site_id, enforcementpoint_id, cluster_control_plane_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.get_cluster_control_plane ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.get_cluster_control_plane"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.get_cluster_control_plane"
      end
      # verify the required parameter 'cluster_control_plane_id' is set
      if @api_client.config.client_side_validation && cluster_control_plane_id.nil?
        fail ArgumentError, "Missing the required parameter 'cluster_control_plane_id' when calling ConfigurationApi.get_cluster_control_plane"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/cluster-control-planes/{cluster-control-plane-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'cluster-control-plane-id' + '}', cluster_control_plane_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ClusterControlPlane')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#get_cluster_control_plane\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get deployment information.
    # This is an API called by VCF to get deployment information. 
    # @param [Hash] opts the optional parameters
    # @return [NSXManagerDeploymentInfo]
    def get_deployment_info(opts = {})
      data, _status_code, _headers = get_deployment_info_with_http_info(opts)
      data
    end

    # Get deployment information.
    # This is an API called by VCF to get deployment information. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(NSXManagerDeploymentInfo, Fixnum, Hash)>] NSXManagerDeploymentInfo data, response status code and response headers
    def get_deployment_info_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.get_deployment_info ...'
      end
      # resource path
      local_var_path = '/watermark'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'NSXManagerDeploymentInfo')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#get_deployment_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get the module details of a host transport node 
    # Get the module details of a host transport node 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [SoftwareModuleResult]
    def get_fabric_node_modules_of_host_transport_node(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      data, _status_code, _headers = get_fabric_node_modules_of_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      data
    end

    # Get the module details of a host transport node 
    # Get the module details of a host transport node 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SoftwareModuleResult, Fixnum, Hash)>] SoftwareModuleResult data, response status code and response headers
    def get_fabric_node_modules_of_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.get_fabric_node_modules_of_host_transport_node ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.get_fabric_node_modules_of_host_transport_node"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.get_fabric_node_modules_of_host_transport_node"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling ConfigurationApi.get_fabric_node_modules_of_host_transport_node"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}/modules'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SoftwareModuleResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#get_fabric_node_modules_of_host_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get a Host Transport Node
    # Returns information about a specified transport node.
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [HostTransportNode]
    def get_host_transport_node(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      data, _status_code, _headers = get_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      data
    end

    # Get a Host Transport Node
    # Returns information about a specified transport node.
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(HostTransportNode, Fixnum, Hash)>] HostTransportNode data, response status code and response headers
    def get_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.get_host_transport_node ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.get_host_transport_node"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.get_host_transport_node"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling ConfigurationApi.get_host_transport_node"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'HostTransportNode')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#get_host_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Transport Node collection by id
    # Returns transport node collection by id
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [HostTransportNodeCollection]
    def get_host_transport_node_collection(site_id, enforcementpoint_id, transport_node_collection_id, opts = {})
      data, _status_code, _headers = get_host_transport_node_collection_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, opts)
      data
    end

    # Get Transport Node collection by id
    # Returns transport node collection by id
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(HostTransportNodeCollection, Fixnum, Hash)>] HostTransportNodeCollection data, response status code and response headers
    def get_host_transport_node_collection_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.get_host_transport_node_collection ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.get_host_transport_node_collection"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.get_host_transport_node_collection"
      end
      # verify the required parameter 'transport_node_collection_id' is set
      if @api_client.config.client_side_validation && transport_node_collection_id.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_collection_id' when calling ConfigurationApi.get_host_transport_node_collection"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/transport-node-collections/{transport-node-collection-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'transport-node-collection-id' + '}', transport_node_collection_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'HostTransportNodeCollection')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#get_host_transport_node_collection\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Transport Node collection application state
    # Returns the state of transport node collection based on the states of transport nodes of the hosts which are part of compute collection. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [TransportNodeCollectionState]
    def get_host_transport_node_collection_state(site_id, enforcementpoint_id, transport_node_collection_id, opts = {})
      data, _status_code, _headers = get_host_transport_node_collection_state_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, opts)
      data
    end

    # Get Transport Node collection application state
    # Returns the state of transport node collection based on the states of transport nodes of the hosts which are part of compute collection. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransportNodeCollectionState, Fixnum, Hash)>] TransportNodeCollectionState data, response status code and response headers
    def get_host_transport_node_collection_state_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.get_host_transport_node_collection_state ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.get_host_transport_node_collection_state"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.get_host_transport_node_collection_state"
      end
      # verify the required parameter 'transport_node_collection_id' is set
      if @api_client.config.client_side_validation && transport_node_collection_id.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_collection_id' when calling ConfigurationApi.get_host_transport_node_collection_state"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/transport-node-collections/{transport-node-collection-id}/state'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'transport-node-collection-id' + '}', transport_node_collection_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNodeCollectionState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#get_host_transport_node_collection_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get a Host Transport Node's State
    # Returns information about the current state of the transport node configuration and information about the associated hostswitch. Change introduced in 4.1.2 for ESX Transport node - The vib details will not be retrieved in every state API call. It will be retrieved by periodical polling on the host. Therefore the nsx vib version mismatch or nsx vib absence will be reported by this API only after subsequent polling takes place. Currently, the poll frequency is 10 minutes. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [TransportNodeState]
    def get_host_transport_node_state(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      data, _status_code, _headers = get_host_transport_node_state_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      data
    end

    # Get a Host Transport Node&#39;s State
    # Returns information about the current state of the transport node configuration and information about the associated hostswitch. Change introduced in 4.1.2 for ESX Transport node - The vib details will not be retrieved in every state API call. It will be retrieved by periodical polling on the host. Therefore the nsx vib version mismatch or nsx vib absence will be reported by this API only after subsequent polling takes place. Currently, the poll frequency is 10 minutes. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransportNodeState, Fixnum, Hash)>] TransportNodeState data, response status code and response headers
    def get_host_transport_node_state_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.get_host_transport_node_state ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.get_host_transport_node_state"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.get_host_transport_node_state"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling ConfigurationApi.get_host_transport_node_state"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}/state'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNodeState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#get_host_transport_node_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get the counter values for realtime datapath statistics.
    # Get the counter values for realtime datapath statistics. Support multiple types in one query.  Query types should be declared inside query parameters. By default the query type is packet_stats. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :type type
    # @return [ObservabilityCounterDebugQueryResult]
    def get_observability_debug_statics(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      data, _status_code, _headers = get_observability_debug_statics_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      data
    end

    # Get the counter values for realtime datapath statistics.
    # Get the counter values for realtime datapath statistics. Support multiple types in one query.  Query types should be declared inside query parameters. By default the query type is packet_stats. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :type type
    # @return [Array<(ObservabilityCounterDebugQueryResult, Fixnum, Hash)>] ObservabilityCounterDebugQueryResult data, response status code and response headers
    def get_observability_debug_statics_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.get_observability_debug_statics ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.get_observability_debug_statics"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.get_observability_debug_statics"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling ConfigurationApi.get_observability_debug_statics"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}/statistics/debug'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ObservabilityCounterDebugQueryResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#get_observability_debug_statics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get the counter values for cached datapath statistics.
    # Get the counter values for cached datapath statistics. Support multiple types in one query.  Query types should be declared inside query parameters. By default the query type is packet_stats. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :type type
    # @return [ObservabilityCounterMonitorQueryResult]
    def get_observability_monitor_statics(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      data, _status_code, _headers = get_observability_monitor_statics_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      data
    end

    # Get the counter values for cached datapath statistics.
    # Get the counter values for cached datapath statistics. Support multiple types in one query.  Query types should be declared inside query parameters. By default the query type is packet_stats. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :type type
    # @return [Array<(ObservabilityCounterMonitorQueryResult, Fixnum, Hash)>] ObservabilityCounterMonitorQueryResult data, response status code and response headers
    def get_observability_monitor_statics_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.get_observability_monitor_statics ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.get_observability_monitor_statics"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.get_observability_monitor_statics"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling ConfigurationApi.get_observability_monitor_statics"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}/statistics/monitor'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ObservabilityCounterMonitorQueryResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#get_observability_monitor_statics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Fetch the policy partial patch configuration value.
    # Read Configuration values for nsx-partial-patch. By default partial patch is deactivated (i.e false). Please refer to the description of PartialPatchConfig for more information. 
    # @param [Hash] opts the optional parameters
    # @return [PartialPatchConfig]
    def get_partial_patch_configuration(opts = {})
      data, _status_code, _headers = get_partial_patch_configuration_with_http_info(opts)
      data
    end

    # Fetch the policy partial patch configuration value.
    # Read Configuration values for nsx-partial-patch. By default partial patch is deactivated (i.e false). Please refer to the description of PartialPatchConfig for more information. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PartialPatchConfig, Fixnum, Hash)>] PartialPatchConfig data, response status code and response headers
    def get_partial_patch_configuration_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.get_partial_patch_configuration ...'
      end
      # resource path
      local_var_path = '/system-config/nsx-partial-patch-config'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PartialPatchConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#get_partial_patch_configuration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get a Hostswitch Profile by ID
    # Returns information about a specified hostswitch profile.
    # @param host_switch_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [PolicyBaseHostSwitchProfile]
    def get_policy_host_switch_profile(host_switch_profile_id, opts = {})
      data, _status_code, _headers = get_policy_host_switch_profile_with_http_info(host_switch_profile_id, opts)
      data
    end

    # Get a Hostswitch Profile by ID
    # Returns information about a specified hostswitch profile.
    # @param host_switch_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PolicyBaseHostSwitchProfile, Fixnum, Hash)>] PolicyBaseHostSwitchProfile data, response status code and response headers
    def get_policy_host_switch_profile_with_http_info(host_switch_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.get_policy_host_switch_profile ...'
      end
      # verify the required parameter 'host_switch_profile_id' is set
      if @api_client.config.client_side_validation && host_switch_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_switch_profile_id' when calling ConfigurationApi.get_policy_host_switch_profile"
      end
      # resource path
      local_var_path = '/infra/host-switch-profiles/{host-switch-profile-id}'.sub('{' + 'host-switch-profile-id' + '}', host_switch_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyBaseHostSwitchProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#get_policy_host_switch_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get a Transport Node
    # Returns information about a specified host transport node profile.
    # @param host_transport_node_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [PolicyHostTransportNodeProfile]
    def get_policy_host_transport_node_profile(host_transport_node_profile_id, opts = {})
      data, _status_code, _headers = get_policy_host_transport_node_profile_with_http_info(host_transport_node_profile_id, opts)
      data
    end

    # Get a Transport Node
    # Returns information about a specified host transport node profile.
    # @param host_transport_node_profile_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PolicyHostTransportNodeProfile, Fixnum, Hash)>] PolicyHostTransportNodeProfile data, response status code and response headers
    def get_policy_host_transport_node_profile_with_http_info(host_transport_node_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.get_policy_host_transport_node_profile ...'
      end
      # verify the required parameter 'host_transport_node_profile_id' is set
      if @api_client.config.client_side_validation && host_transport_node_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_profile_id' when calling ConfigurationApi.get_policy_host_transport_node_profile"
      end
      # resource path
      local_var_path = '/infra/host-transport-node-profiles/{host-transport-node-profile-id}'.sub('{' + 'host-transport-node-profile-id' + '}', host_transport_node_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyHostTransportNodeProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#get_policy_host_transport_node_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # This is Post Avi Controller Deployment Workflow. It will create role if not exist Create Service User Set System Configuration Create Enforcement Point Save Infra-Admin Creds to DB.
    # Set the post deployment cluster configuration for Avi Load Balancer Controller cluster. 
    # @param alb_controller_configuration 
    # @param [Hash] opts the optional parameters
    # @return [EnforcementPoint]
    def initiate_alb_on_boarding_workflow(alb_controller_configuration, opts = {})
      data, _status_code, _headers = initiate_alb_on_boarding_workflow_with_http_info(alb_controller_configuration, opts)
      data
    end

    # This is Post Avi Controller Deployment Workflow. It will create role if not exist Create Service User Set System Configuration Create Enforcement Point Save Infra-Admin Creds to DB.
    # Set the post deployment cluster configuration for Avi Load Balancer Controller cluster. 
    # @param alb_controller_configuration 
    # @param [Hash] opts the optional parameters
    # @return [Array<(EnforcementPoint, Fixnum, Hash)>] EnforcementPoint data, response status code and response headers
    def initiate_alb_on_boarding_workflow_with_http_info(alb_controller_configuration, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.initiate_alb_on_boarding_workflow ...'
      end
      # verify the required parameter 'alb_controller_configuration' is set
      if @api_client.config.client_side_validation && alb_controller_configuration.nil?
        fail ArgumentError, "Missing the required parameter 'alb_controller_configuration' when calling ConfigurationApi.initiate_alb_on_boarding_workflow"
      end
      # resource path
      local_var_path = '/infra/alb-onboarding-workflow'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(alb_controller_configuration)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EnforcementPoint')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#initiate_alb_on_boarding_workflow\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Install and update portal certificate in Avi Load Balancer Controller.
    # Use this API to install and update portal certificate in Avi Load Balancer Controller. 
    # @param alb_controller_certificate 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :ca_only Add given CA certificate to NSX Truststore
    # @return [ALBControllerCertificate]
    def install_alb_portal_certificate(alb_controller_certificate, opts = {})
      data, _status_code, _headers = install_alb_portal_certificate_with_http_info(alb_controller_certificate, opts)
      data
    end

    # Install and update portal certificate in Avi Load Balancer Controller.
    # Use this API to install and update portal certificate in Avi Load Balancer Controller. 
    # @param alb_controller_certificate 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :ca_only Add given CA certificate to NSX Truststore
    # @return [Array<(ALBControllerCertificate, Fixnum, Hash)>] ALBControllerCertificate data, response status code and response headers
    def install_alb_portal_certificate_with_http_info(alb_controller_certificate, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.install_alb_portal_certificate ...'
      end
      # verify the required parameter 'alb_controller_certificate' is set
      if @api_client.config.client_side_validation && alb_controller_certificate.nil?
        fail ArgumentError, "Missing the required parameter 'alb_controller_certificate' when calling ConfigurationApi.install_alb_portal_certificate"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/certificate/install'

      # query parameters
      query_params = {}
      query_params[:'ca_only'] = opts[:'ca_only'] if !opts[:'ca_only'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(alb_controller_certificate)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerCertificate')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#install_alb_portal_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns information for Avi Load Balancer Controller cluster.
    # Returns information about Avi Load Balancer Controller cluster status 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @return [ALBControllerClusterInfo]
    def list_alb_controller_cluster_info(opts = {})
      data, _status_code, _headers = list_alb_controller_cluster_info_with_http_info(opts)
      data
    end

    # Returns information for Avi Load Balancer Controller cluster.
    # Returns information about Avi Load Balancer Controller cluster status 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @return [Array<(ALBControllerClusterInfo, Fixnum, Hash)>] ALBControllerClusterInfo data, response status code and response headers
    def list_alb_controller_cluster_info_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.list_alb_controller_cluster_info ...'
      end
      # resource path
      local_var_path = '/alb/controller-nodes/cluster'

      # query parameters
      query_params = {}
      query_params[:'clustering_id'] = opts[:'clustering_id'] if !opts[:'clustering_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerClusterInfo')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#list_alb_controller_cluster_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List available Avi Load Balancer Controller form factors
    # Returns information about all form factors available for Avi Load Balancer Controller nodes. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :alb_major_version Major release version of Avi Load Balancer Controller for which form factor details will be returned.
    # @return [ALBControllerNodeFormFactors]
    def list_alb_controller_form_factors(opts = {})
      data, _status_code, _headers = list_alb_controller_form_factors_with_http_info(opts)
      data
    end

    # List available Avi Load Balancer Controller form factors
    # Returns information about all form factors available for Avi Load Balancer Controller nodes. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :alb_major_version Major release version of Avi Load Balancer Controller for which form factor details will be returned.
    # @return [Array<(ALBControllerNodeFormFactors, Fixnum, Hash)>] ALBControllerNodeFormFactors data, response status code and response headers
    def list_alb_controller_form_factors_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.list_alb_controller_form_factors ...'
      end
      # resource path
      local_var_path = '/alb/controller-nodes/form-factors'

      # query parameters
      query_params = {}
      query_params[:'alb_major_version'] = opts[:'alb_major_version'] if !opts[:'alb_major_version'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerNodeFormFactors')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#list_alb_controller_form_factors\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns info for all Avi Load Balancer cluster node auto-deployment attempts
    # Returns request information for every attempted deployment of a Avi Load Balancer cluster node. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @option opts [String] :state The current state of the Avi Load Balancer Controller node deployment
    # @return [ALBControllerNodeVMDeploymentRequestList]
    def list_alb_controller_node_vm_deployment_requests(opts = {})
      data, _status_code, _headers = list_alb_controller_node_vm_deployment_requests_with_http_info(opts)
      data
    end

    # Returns info for all Avi Load Balancer cluster node auto-deployment attempts
    # Returns request information for every attempted deployment of a Avi Load Balancer cluster node. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @option opts [String] :state The current state of the Avi Load Balancer Controller node deployment
    # @return [Array<(ALBControllerNodeVMDeploymentRequestList, Fixnum, Hash)>] ALBControllerNodeVMDeploymentRequestList data, response status code and response headers
    def list_alb_controller_node_vm_deployment_requests_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.list_alb_controller_node_vm_deployment_requests ...'
      end
      if @api_client.config.client_side_validation && opts[:'state'] && !['DEPLOYED', 'PENDING'].include?(opts[:'state'])
        fail ArgumentError, 'invalid value for "state", must be one of DEPLOYED, PENDING'
      end
      # resource path
      local_var_path = '/alb/controller-nodes/deployments'

      # query parameters
      query_params = {}
      query_params[:'clustering_id'] = opts[:'clustering_id'] if !opts[:'clustering_id'].nil?
      query_params[:'state'] = opts[:'state'] if !opts[:'state'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerNodeVMDeploymentRequestList')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#list_alb_controller_node_vm_deployment_requests\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Cluster Control Plane
    # list all Cluster Control Planes 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [ClusterControlPlaneListResult]
    def list_cluster_control_plane(site_id, enforcementpoint_id, opts = {})
      data, _status_code, _headers = list_cluster_control_plane_with_http_info(site_id, enforcementpoint_id, opts)
      data
    end

    # List Cluster Control Plane
    # list all Cluster Control Planes 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(ClusterControlPlaneListResult, Fixnum, Hash)>] ClusterControlPlaneListResult data, response status code and response headers
    def list_cluster_control_plane_with_http_info(site_id, enforcementpoint_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.list_cluster_control_plane ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.list_cluster_control_plane"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.list_cluster_control_plane"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ConfigurationApi.list_cluster_control_plane, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ConfigurationApi.list_cluster_control_plane, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/cluster-control-planes'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ClusterControlPlaneListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#list_cluster_control_plane\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Transport Node collections
    # Returns all Transport Node collections
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cluster_moid Managed object ID of cluster in VC
    # @option opts [String] :compute_collection_id Compute collection id
    # @option opts [String] :vc_instance_uuid UUID for VC deployment
    # @return [HostTransportNodeCollectionListResult]
    def list_host_transport_node_collections(site_id, enforcementpoint_id, opts = {})
      data, _status_code, _headers = list_host_transport_node_collections_with_http_info(site_id, enforcementpoint_id, opts)
      data
    end

    # List Transport Node collections
    # Returns all Transport Node collections
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cluster_moid Managed object ID of cluster in VC
    # @option opts [String] :compute_collection_id Compute collection id
    # @option opts [String] :vc_instance_uuid UUID for VC deployment
    # @return [Array<(HostTransportNodeCollectionListResult, Fixnum, Hash)>] HostTransportNodeCollectionListResult data, response status code and response headers
    def list_host_transport_node_collections_with_http_info(site_id, enforcementpoint_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.list_host_transport_node_collections ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.list_host_transport_node_collections"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.list_host_transport_node_collections"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/transport-node-collections'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cluster_moid'] = opts[:'cluster_moid'] if !opts[:'cluster_moid'].nil?
      query_params[:'compute_collection_id'] = opts[:'compute_collection_id'] if !opts[:'compute_collection_id'].nil?
      query_params[:'vc_instance_uuid'] = opts[:'vc_instance_uuid'] if !opts[:'vc_instance_uuid'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'HostTransportNodeCollectionListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#list_host_transport_node_collections\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Host Transport Nodes
    # Returns information about all host transport nodes along with underlying host details. A transport node is a host that contains hostswitches. A hostswitch can have virtual machines connected to them.  Because each transport node has hostswitches, transport nodes can also have virtual tunnel endpoints, which means that they can be part of the overlay. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :discovered_node_id discovered node id
    # @option opts [BOOLEAN] :in_maintenance_mode maintenance mode flag
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_ip Transport node IP address
    # @option opts [String] :node_types a list of node types separated by comma or a single type
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :transport_zone_path Transport zone path
    # @return [HostTransportNodeListResult]
    def list_host_transport_nodes(site_id, enforcementpoint_id, opts = {})
      data, _status_code, _headers = list_host_transport_nodes_with_http_info(site_id, enforcementpoint_id, opts)
      data
    end

    # List Host Transport Nodes
    # Returns information about all host transport nodes along with underlying host details. A transport node is a host that contains hostswitches. A hostswitch can have virtual machines connected to them.  Because each transport node has hostswitches, transport nodes can also have virtual tunnel endpoints, which means that they can be part of the overlay. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :discovered_node_id discovered node id
    # @option opts [BOOLEAN] :in_maintenance_mode maintenance mode flag
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [String] :node_ip Transport node IP address
    # @option opts [String] :node_types a list of node types separated by comma or a single type
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :transport_zone_path Transport zone path
    # @return [Array<(HostTransportNodeListResult, Fixnum, Hash)>] HostTransportNodeListResult data, response status code and response headers
    def list_host_transport_nodes_with_http_info(site_id, enforcementpoint_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.list_host_transport_nodes ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.list_host_transport_nodes"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.list_host_transport_nodes"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ConfigurationApi.list_host_transport_nodes, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ConfigurationApi.list_host_transport_nodes, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'discovered_node_id'] = opts[:'discovered_node_id'] if !opts[:'discovered_node_id'].nil?
      query_params[:'in_maintenance_mode'] = opts[:'in_maintenance_mode'] if !opts[:'in_maintenance_mode'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'node_ip'] = opts[:'node_ip'] if !opts[:'node_ip'].nil?
      query_params[:'node_types'] = opts[:'node_types'] if !opts[:'node_types'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'transport_zone_path'] = opts[:'transport_zone_path'] if !opts[:'transport_zone_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'HostTransportNodeListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#list_host_transport_nodes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List transport nodes by realized state
    # Returns a list of transport node states that have realized state as provided as query parameter. If this API is called multiple times in parallel then it will fail with error indicating that another request is already in progress. In such case, try the API on another NSX manager instance (if exists) or try again after some time. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :mm_state maintenance mode state
    # @option opts [String] :status Realized state of transport nodes
    # @option opts [String] :vtep_ip Virtual tunnel endpoint ip address of transport node
    # @return [TransportNodeStateListResult]
    def list_host_transport_nodes_by_state(site_id, enforcementpoint_id, opts = {})
      data, _status_code, _headers = list_host_transport_nodes_by_state_with_http_info(site_id, enforcementpoint_id, opts)
      data
    end

    # List transport nodes by realized state
    # Returns a list of transport node states that have realized state as provided as query parameter. If this API is called multiple times in parallel then it will fail with error indicating that another request is already in progress. In such case, try the API on another NSX manager instance (if exists) or try again after some time. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :mm_state maintenance mode state
    # @option opts [String] :status Realized state of transport nodes
    # @option opts [String] :vtep_ip Virtual tunnel endpoint ip address of transport node
    # @return [Array<(TransportNodeStateListResult, Fixnum, Hash)>] TransportNodeStateListResult data, response status code and response headers
    def list_host_transport_nodes_by_state_with_http_info(site_id, enforcementpoint_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.list_host_transport_nodes_by_state ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.list_host_transport_nodes_by_state"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.list_host_transport_nodes_by_state"
      end
      if @api_client.config.client_side_validation && opts[:'mm_state'] && !['ENTERING', 'ENABLED', 'EXITING', 'DISABLED'].include?(opts[:'mm_state'])
        fail ArgumentError, 'invalid value for "mm_state", must be one of ENTERING, ENABLED, EXITING, DISABLED'
      end
      if @api_client.config.client_side_validation && opts[:'status'] && !['PENDING', 'IN_PROGRESS', 'SUCCESS', 'PARTIAL_SUCCESS', 'FAILED', 'ORPHANED'].include?(opts[:'status'])
        fail ArgumentError, 'invalid value for "status", must be one of PENDING, IN_PROGRESS, SUCCESS, PARTIAL_SUCCESS, FAILED, ORPHANED'
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/state'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'mm_state'] = opts[:'mm_state'] if !opts[:'mm_state'].nil?
      query_params[:'status'] = opts[:'status'] if !opts[:'status'].nil?
      query_params[:'vtep_ip'] = opts[:'vtep_ip'] if !opts[:'vtep_ip'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNodeStateListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#list_host_transport_nodes_by_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Hostswitch Profiles
    # Returns information about the configured hostswitch profiles. Hostswitch profiles define networking policies for hostswitches (sometimes referred to as bridges in OVS). Currently, following profiles are supported. UplinkHostSwitchProfile, LldpHostSwitchProfile, NiocProfile & ExtraConfigHostSwitchProfile. Uplink profile - teaming defined in this profile allows NSX to load balance traffic across different physical NICs (PNICs) on the hypervisor hosts. Multiple teaming policies are supported, including LACP active, LACP passive, load balancing based on source ID, and failover order. Lldp profile - Activate or deactivate sending LLDP packets NiocProfile - Network I/O Control settings: defines limits, shares and reservations for various host traffic types. ExtraConfig - Vendor specific configuration on HostSwitch, logical switch or logical port 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :deployment_type Supported edge deployment type.
    # @option opts [String] :hostswitch_profile_type Supported HostSwitch profiles.
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [BOOLEAN] :include_system_owned Whether the list result contains system resources (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :max_active_uplink_count Filter uplink profiles by number of active links in teaming policy.
    # @option opts [String] :node_type Fabric node type for which uplink profiles are to be listed
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :uplink_teaming_policy_name The host switch profile&#39;s uplink teaming policy name
    # @return [PolicyHostSwitchProfilesListResult]
    def list_policy_host_switch_profiles(opts = {})
      data, _status_code, _headers = list_policy_host_switch_profiles_with_http_info(opts)
      data
    end

    # List Hostswitch Profiles
    # Returns information about the configured hostswitch profiles. Hostswitch profiles define networking policies for hostswitches (sometimes referred to as bridges in OVS). Currently, following profiles are supported. UplinkHostSwitchProfile, LldpHostSwitchProfile, NiocProfile &amp; ExtraConfigHostSwitchProfile. Uplink profile - teaming defined in this profile allows NSX to load balance traffic across different physical NICs (PNICs) on the hypervisor hosts. Multiple teaming policies are supported, including LACP active, LACP passive, load balancing based on source ID, and failover order. Lldp profile - Activate or deactivate sending LLDP packets NiocProfile - Network I/O Control settings: defines limits, shares and reservations for various host traffic types. ExtraConfig - Vendor specific configuration on HostSwitch, logical switch or logical port 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :deployment_type Supported edge deployment type.
    # @option opts [String] :hostswitch_profile_type Supported HostSwitch profiles.
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [BOOLEAN] :include_system_owned Whether the list result contains system resources
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :max_active_uplink_count Filter uplink profiles by number of active links in teaming policy.
    # @option opts [String] :node_type Fabric node type for which uplink profiles are to be listed
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :uplink_teaming_policy_name The host switch profile&#39;s uplink teaming policy name
    # @return [Array<(PolicyHostSwitchProfilesListResult, Fixnum, Hash)>] PolicyHostSwitchProfilesListResult data, response status code and response headers
    def list_policy_host_switch_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.list_policy_host_switch_profiles ...'
      end
      if @api_client.config.client_side_validation && opts[:'deployment_type'] && !['VIRTUAL_MACHINE', 'PHYSICAL_MACHINE', 'UNKNOWN'].include?(opts[:'deployment_type'])
        fail ArgumentError, 'invalid value for "deployment_type", must be one of VIRTUAL_MACHINE, PHYSICAL_MACHINE, UNKNOWN'
      end
      if @api_client.config.client_side_validation && opts[:'hostswitch_profile_type'] && !['PolicyUplinkHostSwitchProfile', 'PolicyLldpHostSwitchProfile', 'PolicyNiocProfile', 'PolicyExtraConfigHostSwitchProfile', 'PolicyVtepHAHostSwitchProfile', 'PolicyHighPerformanceHostSwitchProfile'].include?(opts[:'hostswitch_profile_type'])
        fail ArgumentError, 'invalid value for "hostswitch_profile_type", must be one of PolicyUplinkHostSwitchProfile, PolicyLldpHostSwitchProfile, PolicyNiocProfile, PolicyExtraConfigHostSwitchProfile, PolicyVtepHAHostSwitchProfile, PolicyHighPerformanceHostSwitchProfile'
      end
      if @api_client.config.client_side_validation && opts[:'node_type'] && !['EdgeNode', 'PublicCloudGatewayNode'].include?(opts[:'node_type'])
        fail ArgumentError, 'invalid value for "node_type", must be one of EdgeNode, PublicCloudGatewayNode'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ConfigurationApi.list_policy_host_switch_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ConfigurationApi.list_policy_host_switch_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/host-switch-profiles'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'deployment_type'] = opts[:'deployment_type'] if !opts[:'deployment_type'].nil?
      query_params[:'hostswitch_profile_type'] = opts[:'hostswitch_profile_type'] if !opts[:'hostswitch_profile_type'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'include_system_owned'] = opts[:'include_system_owned'] if !opts[:'include_system_owned'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'max_active_uplink_count'] = opts[:'max_active_uplink_count'] if !opts[:'max_active_uplink_count'].nil?
      query_params[:'node_type'] = opts[:'node_type'] if !opts[:'node_type'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'uplink_teaming_policy_name'] = opts[:'uplink_teaming_policy_name'] if !opts[:'uplink_teaming_policy_name'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyHostSwitchProfilesListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#list_policy_host_switch_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Host Transport Nodes
    # Returns information about all host transport node profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PolicyHostTransportNodeProfileListResult]
    def list_policy_host_transport_node_profiles(opts = {})
      data, _status_code, _headers = list_policy_host_transport_node_profiles_with_http_info(opts)
      data
    end

    # List Host Transport Nodes
    # Returns information about all host transport node profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PolicyHostTransportNodeProfileListResult, Fixnum, Hash)>] PolicyHostTransportNodeProfileListResult data, response status code and response headers
    def list_policy_host_transport_node_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.list_policy_host_transport_node_profiles ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ConfigurationApi.list_policy_host_transport_node_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ConfigurationApi.list_policy_host_transport_node_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/host-transport-node-profiles'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyHostTransportNodeProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#list_policy_host_transport_node_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List sub-clusters
    # Paginated list of all sub-clusters. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SubClusterListResult]
    def list_sub_clusters(site_id, enforcementpoint_id, opts = {})
      data, _status_code, _headers = list_sub_clusters_with_http_info(site_id, enforcementpoint_id, opts)
      data
    end

    # List sub-clusters
    # Paginated list of all sub-clusters. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SubClusterListResult, Fixnum, Hash)>] SubClusterListResult data, response status code and response headers
    def list_sub_clusters_with_http_info(site_id, enforcementpoint_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.list_sub_clusters ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.list_sub_clusters"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.list_sub_clusters"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ConfigurationApi.list_sub_clusters, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ConfigurationApi.list_sub_clusters, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/sub-clusters'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SubClusterListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#list_sub_clusters\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get information about all tasks
    # Get information about all tasks
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :request_uri Request URI(s) to include in query result
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :status Status(es) to include in query result
    # @option opts [String] :user Names of users to include in query result
    # @return [TaskListResult]
    def list_tasks(opts = {})
      data, _status_code, _headers = list_tasks_with_http_info(opts)
      data
    end

    # Get information about all tasks
    # Get information about all tasks
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :request_uri Request URI(s) to include in query result
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :status Status(es) to include in query result
    # @option opts [String] :user Names of users to include in query result
    # @return [Array<(TaskListResult, Fixnum, Hash)>] TaskListResult data, response status code and response headers
    def list_tasks_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.list_tasks ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ConfigurationApi.list_tasks, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ConfigurationApi.list_tasks, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/tasks'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'request_uri'] = opts[:'request_uri'] if !opts[:'request_uri'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'status'] = opts[:'status'] if !opts[:'status'].nil?
      query_params[:'user'] = opts[:'user'] if !opts[:'user'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TaskListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#list_tasks\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all TransportNode VTEP actions' status
    # List all VTEP actions' status for a particular TransportNode. If some action status is missing in the response, that indicates the action has completed successfully. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [TransportNodeVtepActionsStatusListResult]
    def list_transport_node_vtep_actions_status(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      data, _status_code, _headers = list_transport_node_vtep_actions_status_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      data
    end

    # List all TransportNode VTEP actions&#39; status
    # List all VTEP actions&#39; status for a particular TransportNode. If some action status is missing in the response, that indicates the action has completed successfully. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransportNodeVtepActionsStatusListResult, Fixnum, Hash)>] TransportNodeVtepActionsStatusListResult data, response status code and response headers
    def list_transport_node_vtep_actions_status_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.list_transport_node_vtep_actions_status ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.list_transport_node_vtep_actions_status"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.list_transport_node_vtep_actions_status"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling ConfigurationApi.list_transport_node_vtep_actions_status"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}/vteps/actions/status'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNodeVtepActionsStatusListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#list_transport_node_vtep_actions_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Fetch Discovered VIF State on given TransportNode
    # For the given TransportNode, fetch all the VIF info from VC and return the corresponding state. Only host switch configured for security will be considered. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :host_switch_id VDS identifier
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :segment_id Segment identifier
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [DiscoveredVifStateListResult]
    def list_vds_vifs_on_transport_node(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      data, _status_code, _headers = list_vds_vifs_on_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      data
    end

    # Fetch Discovered VIF State on given TransportNode
    # For the given TransportNode, fetch all the VIF info from VC and return the corresponding state. Only host switch configured for security will be considered. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :host_switch_id VDS identifier
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :segment_id Segment identifier
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(DiscoveredVifStateListResult, Fixnum, Hash)>] DiscoveredVifStateListResult data, response status code and response headers
    def list_vds_vifs_on_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.list_vds_vifs_on_transport_node ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.list_vds_vifs_on_transport_node"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.list_vds_vifs_on_transport_node"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling ConfigurationApi.list_vds_vifs_on_transport_node"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ConfigurationApi.list_vds_vifs_on_transport_node, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling ConfigurationApi.list_vds_vifs_on_transport_node, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}/discovered-vifs'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'host_switch_id'] = opts[:'host_switch_id'] if !opts[:'host_switch_id'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'segment_id'] = opts[:'segment_id'] if !opts[:'segment_id'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'DiscoveredVifStateListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#list_vds_vifs_on_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Move host from one sub-cluster to another sub-cluster. When a node is moved from one sub-cluster to another sub-cluster, based on the TransportNodeCollection configuration appropriate sub-configuration will be applied to the node. If TransportNodeCollection does not have sub-configurations for the sub-cluster, then global configuration will be applied. 
    # Move host from one sub-cluster to another sub-cluster. When a node is moved from one sub-cluster to another sub-cluster, based on the TransportNodeCollection configuration appropriate sub-configuration will be applied to the node. If TransportNodeCollection does not have sub-configurations for the sub-cluster, then global configuration will be applied. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_movement_spec 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def move_hosts(site_id, enforcementpoint_id, host_movement_spec, opts = {})
      move_hosts_with_http_info(site_id, enforcementpoint_id, host_movement_spec, opts)
      nil
    end

    # Move host from one sub-cluster to another sub-cluster. When a node is moved from one sub-cluster to another sub-cluster, based on the TransportNodeCollection configuration appropriate sub-configuration will be applied to the node. If TransportNodeCollection does not have sub-configurations for the sub-cluster, then global configuration will be applied. 
    # Move host from one sub-cluster to another sub-cluster. When a node is moved from one sub-cluster to another sub-cluster, based on the TransportNodeCollection configuration appropriate sub-configuration will be applied to the node. If TransportNodeCollection does not have sub-configurations for the sub-cluster, then global configuration will be applied. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_movement_spec 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def move_hosts_with_http_info(site_id, enforcementpoint_id, host_movement_spec, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.move_hosts ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.move_hosts"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.move_hosts"
      end
      # verify the required parameter 'host_movement_spec' is set
      if @api_client.config.client_side_validation && host_movement_spec.nil?
        fail ArgumentError, "Missing the required parameter 'host_movement_spec' when calling ConfigurationApi.move_hosts"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/sub-clusters?action=move'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(host_movement_spec)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#move_hosts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch a Host Transport Node
    # Transport nodes are hypervisor hosts that will participate in an NSX-T overlay. For a hypervisor host, this means that it hosts VMs that will communicate over NSX-T logical switches.  This API creates transport node for a host node (hypervisor) in the transport network.  When you run this command for a host, NSX Manager attempts to install the NSX kernel modules, which are packaged as VIB, RPM, or DEB files. For the installation to succeed, you must provide the host login credentials and the host thumbprint.  To get the ESXi host thumbprint, SSH to the host and run the <b>openssl x509 -in /etc/vmware/ssl/rui.crt -fingerprint -sha256 -noout</b> command.  To generate host key thumbprint using SHA-256 algorithm please follow the steps below.  Log into the host, making sure that the connection is not vulnerable to a man in the middle attack. Check whether a public key already exists. Host public key is generally located at '/etc/ssh/ssh_host_rsa_key.pub'. If the key is not present then generate a new key by running the following command and follow the instructions.  <b>ssh-keygen -t rsa</b>  Now generate a SHA256 hash of the key using the following command. Please make sure to pass the appropriate file name if the public key is stored with a different file name other than the default 'id_rsa.pub'.  <b>awk '{print $2}' id_rsa.pub | base64 -d | sha256sum -b | sed 's/ .*$//' | xxd -r -p | base64</b>  Additional documentation on creating a transport node can be found in the NSX-T Installation Guide.  In order for the transport node to forward packets, the host_switch_spec property must be specified.  Host switches (called bridges in OVS on KVM hypervisors) are the individual switches within the host virtual switch. Virtual machines are connected to the host switches.  When creating a transport node, you need to specify if the host switches are already manually preconfigured on the node, or if NSX should create and manage the host switches. You specify this choice by the type of host switches you pass in the host_switch_spec property of the TransportNode request payload.  For a KVM host, you can preconfigure the host switch, or you can have NSX Manager perform the configuration. For an ESXi host NSX Manager always configures the host switch.  To preconfigure the host switches on a KVM host, pass an array of PreconfiguredHostSwitchSpec objects that describes those host switches. In the current NSX-T release, only one prefonfigured host switch can be specified.  See the PreconfiguredHostSwitchSpec schema definition for documentation on the properties that must be provided. Preconfigured host switches are only supported on KVM hosts, not on ESXi hosts.  To allow NSX to manage the host switch configuration on KVM hosts, ESXi hosts, pass an array of StandardHostSwitchSpec objects in the host_switch_spec property, and NSX will automatically create host switches with the properties you provide. In the current NSX-T release, up to 16 host switches can be automatically managed. See the StandardHostSwitchSpec schema definition for documentation on the properties that must be provided.  The request should provide node_deployement_info. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param host_transport_node 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :esx_mgmt_if_migration_dest The network ids to which the ESX vmk interfaces will be migrated
    # @option opts [String] :if_id The ESX vmk interfaces to migrate
    # @option opts [BOOLEAN] :override_nsx_ownership Override NSX Ownership (default to false)
    # @option opts [String] :ping_ip IP Addresses to ping right after ESX vmk interfaces were migrated.
    # @option opts [BOOLEAN] :skip_validation Whether to skip front-end validation for vmk/vnic/pnic migration (default to false)
    # @option opts [String] :vnic The ESX vmk interfaces and/or VM NIC to migrate
    # @option opts [String] :vnic_migration_dest The migration destinations of ESX vmk interfaces and/or VM NIC
    # @return [nil]
    def patch_host_transport_node(site_id, enforcementpoint_id, host_transport_node_id, host_transport_node, opts = {})
      patch_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, host_transport_node, opts)
      nil
    end

    # Patch a Host Transport Node
    # Transport nodes are hypervisor hosts that will participate in an NSX-T overlay. For a hypervisor host, this means that it hosts VMs that will communicate over NSX-T logical switches.  This API creates transport node for a host node (hypervisor) in the transport network.  When you run this command for a host, NSX Manager attempts to install the NSX kernel modules, which are packaged as VIB, RPM, or DEB files. For the installation to succeed, you must provide the host login credentials and the host thumbprint.  To get the ESXi host thumbprint, SSH to the host and run the &lt;b&gt;openssl x509 -in /etc/vmware/ssl/rui.crt -fingerprint -sha256 -noout&lt;/b&gt; command.  To generate host key thumbprint using SHA-256 algorithm please follow the steps below.  Log into the host, making sure that the connection is not vulnerable to a man in the middle attack. Check whether a public key already exists. Host public key is generally located at &#39;/etc/ssh/ssh_host_rsa_key.pub&#39;. If the key is not present then generate a new key by running the following command and follow the instructions.  &lt;b&gt;ssh-keygen -t rsa&lt;/b&gt;  Now generate a SHA256 hash of the key using the following command. Please make sure to pass the appropriate file name if the public key is stored with a different file name other than the default &#39;id_rsa.pub&#39;.  &lt;b&gt;awk &#39;{print $2}&#39; id_rsa.pub | base64 -d | sha256sum -b | sed &#39;s/ .*$//&#39; | xxd -r -p | base64&lt;/b&gt;  Additional documentation on creating a transport node can be found in the NSX-T Installation Guide.  In order for the transport node to forward packets, the host_switch_spec property must be specified.  Host switches (called bridges in OVS on KVM hypervisors) are the individual switches within the host virtual switch. Virtual machines are connected to the host switches.  When creating a transport node, you need to specify if the host switches are already manually preconfigured on the node, or if NSX should create and manage the host switches. You specify this choice by the type of host switches you pass in the host_switch_spec property of the TransportNode request payload.  For a KVM host, you can preconfigure the host switch, or you can have NSX Manager perform the configuration. For an ESXi host NSX Manager always configures the host switch.  To preconfigure the host switches on a KVM host, pass an array of PreconfiguredHostSwitchSpec objects that describes those host switches. In the current NSX-T release, only one prefonfigured host switch can be specified.  See the PreconfiguredHostSwitchSpec schema definition for documentation on the properties that must be provided. Preconfigured host switches are only supported on KVM hosts, not on ESXi hosts.  To allow NSX to manage the host switch configuration on KVM hosts, ESXi hosts, pass an array of StandardHostSwitchSpec objects in the host_switch_spec property, and NSX will automatically create host switches with the properties you provide. In the current NSX-T release, up to 16 host switches can be automatically managed. See the StandardHostSwitchSpec schema definition for documentation on the properties that must be provided.  The request should provide node_deployement_info. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param host_transport_node 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :esx_mgmt_if_migration_dest The network ids to which the ESX vmk interfaces will be migrated
    # @option opts [String] :if_id The ESX vmk interfaces to migrate
    # @option opts [BOOLEAN] :override_nsx_ownership Override NSX Ownership
    # @option opts [String] :ping_ip IP Addresses to ping right after ESX vmk interfaces were migrated.
    # @option opts [BOOLEAN] :skip_validation Whether to skip front-end validation for vmk/vnic/pnic migration
    # @option opts [String] :vnic The ESX vmk interfaces and/or VM NIC to migrate
    # @option opts [String] :vnic_migration_dest The migration destinations of ESX vmk interfaces and/or VM NIC
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, host_transport_node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.patch_host_transport_node ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.patch_host_transport_node"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.patch_host_transport_node"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling ConfigurationApi.patch_host_transport_node"
      end
      # verify the required parameter 'host_transport_node' is set
      if @api_client.config.client_side_validation && host_transport_node.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node' when calling ConfigurationApi.patch_host_transport_node"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'esx_mgmt_if_migration_dest'] = opts[:'esx_mgmt_if_migration_dest'] if !opts[:'esx_mgmt_if_migration_dest'].nil?
      query_params[:'if_id'] = opts[:'if_id'] if !opts[:'if_id'].nil?
      query_params[:'override_nsx_ownership'] = opts[:'override_nsx_ownership'] if !opts[:'override_nsx_ownership'].nil?
      query_params[:'ping_ip'] = opts[:'ping_ip'] if !opts[:'ping_ip'].nil?
      query_params[:'skip_validation'] = opts[:'skip_validation'] if !opts[:'skip_validation'].nil?
      query_params[:'vnic'] = opts[:'vnic'] if !opts[:'vnic'].nil?
      query_params[:'vnic_migration_dest'] = opts[:'vnic_migration_dest'] if !opts[:'vnic_migration_dest'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(host_transport_node)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#patch_host_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch Transport Node collection
    # Attach different transport node profile to compute collection by updating transport node collection. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param host_transport_node_collection 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_host_transport_node_collection(site_id, enforcementpoint_id, transport_node_collection_id, host_transport_node_collection, opts = {})
      patch_host_transport_node_collection_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, host_transport_node_collection, opts)
      nil
    end

    # Patch Transport Node collection
    # Attach different transport node profile to compute collection by updating transport node collection. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param host_transport_node_collection 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_host_transport_node_collection_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, host_transport_node_collection, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.patch_host_transport_node_collection ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.patch_host_transport_node_collection"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.patch_host_transport_node_collection"
      end
      # verify the required parameter 'transport_node_collection_id' is set
      if @api_client.config.client_side_validation && transport_node_collection_id.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_collection_id' when calling ConfigurationApi.patch_host_transport_node_collection"
      end
      # verify the required parameter 'host_transport_node_collection' is set
      if @api_client.config.client_side_validation && host_transport_node_collection.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_collection' when calling ConfigurationApi.patch_host_transport_node_collection"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/transport-node-collections/{transport-node-collection-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'transport-node-collection-id' + '}', transport_node_collection_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(host_transport_node_collection)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#patch_host_transport_node_collection\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create a Event Log server for Firewall Identity store
    # More than one Event Log server can be created and only one event log server is used to synchronize directory objects. If more than one Event Log server is configured, NSX will try all the servers until it is able to successfully connect to one. 
    # @param identity_firewall_store_id Firewall Identity store identifier
    # @param event_log_server_id Event Log server identifier
    # @param identity_firewall_store_event_log_server 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @return [nil]
    def patch_or_create_firewall_identity_store_event_log_server(identity_firewall_store_id, event_log_server_id, identity_firewall_store_event_log_server, opts = {})
      patch_or_create_firewall_identity_store_event_log_server_with_http_info(identity_firewall_store_id, event_log_server_id, identity_firewall_store_event_log_server, opts)
      nil
    end

    # Create a Event Log server for Firewall Identity store
    # More than one Event Log server can be created and only one event log server is used to synchronize directory objects. If more than one Event Log server is configured, NSX will try all the servers until it is able to successfully connect to one. 
    # @param identity_firewall_store_id Firewall Identity store identifier
    # @param event_log_server_id Event Log server identifier
    # @param identity_firewall_store_event_log_server 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_or_create_firewall_identity_store_event_log_server_with_http_info(identity_firewall_store_id, event_log_server_id, identity_firewall_store_event_log_server, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.patch_or_create_firewall_identity_store_event_log_server ...'
      end
      # verify the required parameter 'identity_firewall_store_id' is set
      if @api_client.config.client_side_validation && identity_firewall_store_id.nil?
        fail ArgumentError, "Missing the required parameter 'identity_firewall_store_id' when calling ConfigurationApi.patch_or_create_firewall_identity_store_event_log_server"
      end
      # verify the required parameter 'event_log_server_id' is set
      if @api_client.config.client_side_validation && event_log_server_id.nil?
        fail ArgumentError, "Missing the required parameter 'event_log_server_id' when calling ConfigurationApi.patch_or_create_firewall_identity_store_event_log_server"
      end
      # verify the required parameter 'identity_firewall_store_event_log_server' is set
      if @api_client.config.client_side_validation && identity_firewall_store_event_log_server.nil?
        fail ArgumentError, "Missing the required parameter 'identity_firewall_store_event_log_server' when calling ConfigurationApi.patch_or_create_firewall_identity_store_event_log_server"
      end
      # resource path
      local_var_path = '/infra/identity-firewall-stores/{identity-firewall-store-id}/event-log-servers/{event-log-server-id}'.sub('{' + 'identity-firewall-store-id' + '}', identity_firewall_store_id.to_s).sub('{' + 'event-log-server-id' + '}', event_log_server_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(identity_firewall_store_event_log_server)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#patch_or_create_firewall_identity_store_event_log_server\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a Hostswitch Profile
    # Patch a hostswitch profile. The resource_type is required and needs to be one of the following, UplinkHostSwitchProfile, LldpHostSwitchProfile, NiocProfile & ExtraConfigHostSwitchProfile. Uplink profile - For uplink profiles, the teaming and policy parameters are required. By default, the mtu is 1600 and the transport_vlan is 0. The supported MTU range is 1280 through (uplink_mtu_threshold). uplink_mtu_threshold is 9000 by default. Range can be extended by modifying (uplink_mtu_threshold) in SwitchingGlobalConfig to the required upper threshold. Teaming defined in this profile allows NSX to load balance traffic across different physical NICs (PNICs) on the hypervisor hosts. Multiple teaming policies are supported, including LACP active, LACP passive, load balancing based on source ID, and failover order. Lldp profile - Activate or deactivate sending LLDP packets NiocProfile - Network I/O Control settings: defines limits, shares and reservations for various host traffic types. ExtraConfig - Vendor specific configuration on HostSwitch, logical switch or logical port 
    # @param host_switch_profile_id 
    # @param policy_base_host_switch_profile 
    # @param [Hash] opts the optional parameters
    # @return [PolicyBaseHostSwitchProfile]
    def patch_policy_host_switch_profile(host_switch_profile_id, policy_base_host_switch_profile, opts = {})
      data, _status_code, _headers = patch_policy_host_switch_profile_with_http_info(host_switch_profile_id, policy_base_host_switch_profile, opts)
      data
    end

    # Create or update a Hostswitch Profile
    # Patch a hostswitch profile. The resource_type is required and needs to be one of the following, UplinkHostSwitchProfile, LldpHostSwitchProfile, NiocProfile &amp; ExtraConfigHostSwitchProfile. Uplink profile - For uplink profiles, the teaming and policy parameters are required. By default, the mtu is 1600 and the transport_vlan is 0. The supported MTU range is 1280 through (uplink_mtu_threshold). uplink_mtu_threshold is 9000 by default. Range can be extended by modifying (uplink_mtu_threshold) in SwitchingGlobalConfig to the required upper threshold. Teaming defined in this profile allows NSX to load balance traffic across different physical NICs (PNICs) on the hypervisor hosts. Multiple teaming policies are supported, including LACP active, LACP passive, load balancing based on source ID, and failover order. Lldp profile - Activate or deactivate sending LLDP packets NiocProfile - Network I/O Control settings: defines limits, shares and reservations for various host traffic types. ExtraConfig - Vendor specific configuration on HostSwitch, logical switch or logical port 
    # @param host_switch_profile_id 
    # @param policy_base_host_switch_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PolicyBaseHostSwitchProfile, Fixnum, Hash)>] PolicyBaseHostSwitchProfile data, response status code and response headers
    def patch_policy_host_switch_profile_with_http_info(host_switch_profile_id, policy_base_host_switch_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.patch_policy_host_switch_profile ...'
      end
      # verify the required parameter 'host_switch_profile_id' is set
      if @api_client.config.client_side_validation && host_switch_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_switch_profile_id' when calling ConfigurationApi.patch_policy_host_switch_profile"
      end
      # verify the required parameter 'policy_base_host_switch_profile' is set
      if @api_client.config.client_side_validation && policy_base_host_switch_profile.nil?
        fail ArgumentError, "Missing the required parameter 'policy_base_host_switch_profile' when calling ConfigurationApi.patch_policy_host_switch_profile"
      end
      # resource path
      local_var_path = '/infra/host-switch-profiles/{host-switch-profile-id}'.sub('{' + 'host-switch-profile-id' + '}', host_switch_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(policy_base_host_switch_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyBaseHostSwitchProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#patch_policy_host_switch_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch Sub-Cluster
    # Patch a sub-cluster under compute collection. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param subcluster_id 
    # @param sub_cluster 
    # @param [Hash] opts the optional parameters
    # @return [SubCluster]
    def patch_sub_cluster(site_id, enforcementpoint_id, subcluster_id, sub_cluster, opts = {})
      data, _status_code, _headers = patch_sub_cluster_with_http_info(site_id, enforcementpoint_id, subcluster_id, sub_cluster, opts)
      data
    end

    # Patch Sub-Cluster
    # Patch a sub-cluster under compute collection. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param subcluster_id 
    # @param sub_cluster 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SubCluster, Fixnum, Hash)>] SubCluster data, response status code and response headers
    def patch_sub_cluster_with_http_info(site_id, enforcementpoint_id, subcluster_id, sub_cluster, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.patch_sub_cluster ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.patch_sub_cluster"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.patch_sub_cluster"
      end
      # verify the required parameter 'subcluster_id' is set
      if @api_client.config.client_side_validation && subcluster_id.nil?
        fail ArgumentError, "Missing the required parameter 'subcluster_id' when calling ConfigurationApi.patch_sub_cluster"
      end
      # verify the required parameter 'sub_cluster' is set
      if @api_client.config.client_side_validation && sub_cluster.nil?
        fail ArgumentError, "Missing the required parameter 'sub_cluster' when calling ConfigurationApi.patch_sub_cluster"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/sub-clusters/{subcluster-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'subcluster-id' + '}', subcluster_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(sub_cluster)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SubCluster')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#patch_sub_cluster\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns info for of the cluster configuration for the Avi Load Balancer Controller cluster
    # Returns cluster configuration for the Avi Load Balancer Controller cluster. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @return [ALBControllerNodeVMClusterConfig]
    def read_alb_controller_node_cluster_config(opts = {})
      data, _status_code, _headers = read_alb_controller_node_cluster_config_with_http_info(opts)
      data
    end

    # Returns info for of the cluster configuration for the Avi Load Balancer Controller cluster
    # Returns cluster configuration for the Avi Load Balancer Controller cluster. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @return [Array<(ALBControllerNodeVMClusterConfig, Fixnum, Hash)>] ALBControllerNodeVMClusterConfig data, response status code and response headers
    def read_alb_controller_node_cluster_config_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.read_alb_controller_node_cluster_config ...'
      end
      # resource path
      local_var_path = '/alb/controller-nodes/clusterconfig'

      # query parameters
      query_params = {}
      query_params[:'clustering_id'] = opts[:'clustering_id'] if !opts[:'clustering_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerNodeVMClusterConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#read_alb_controller_node_cluster_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns info for a Avi Load Balancer Controller deployment attempt
    # Returns deployment request information for a specific attempted deployment of a cluster node. 
    # @param node_id 
    # @param [Hash] opts the optional parameters
    # @return [ALBControllerNodeVMDeploymentRequest]
    def read_alb_controller_node_vm_deployment_request(node_id, opts = {})
      data, _status_code, _headers = read_alb_controller_node_vm_deployment_request_with_http_info(node_id, opts)
      data
    end

    # Returns info for a Avi Load Balancer Controller deployment attempt
    # Returns deployment request information for a specific attempted deployment of a cluster node. 
    # @param node_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ALBControllerNodeVMDeploymentRequest, Fixnum, Hash)>] ALBControllerNodeVMDeploymentRequest data, response status code and response headers
    def read_alb_controller_node_vm_deployment_request_with_http_info(node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.read_alb_controller_node_vm_deployment_request ...'
      end
      # verify the required parameter 'node_id' is set
      if @api_client.config.client_side_validation && node_id.nil?
        fail ArgumentError, "Missing the required parameter 'node_id' when calling ConfigurationApi.read_alb_controller_node_vm_deployment_request"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/deployments/{node-id}'.sub('{' + 'node-id' + '}', node_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerNodeVMDeploymentRequest')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#read_alb_controller_node_vm_deployment_request\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns the status of the node creation/deletion
    # Returns the current deployment or undeployment status for a node along with any other relevant current information, such as error messages. 
    # @param node_id 
    # @param [Hash] opts the optional parameters
    # @return [ALBControllerNodeVMDeploymentStatusReport]
    def read_alb_controller_node_vm_deployment_status(node_id, opts = {})
      data, _status_code, _headers = read_alb_controller_node_vm_deployment_status_with_http_info(node_id, opts)
      data
    end

    # Returns the status of the node creation/deletion
    # Returns the current deployment or undeployment status for a node along with any other relevant current information, such as error messages. 
    # @param node_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ALBControllerNodeVMDeploymentStatusReport, Fixnum, Hash)>] ALBControllerNodeVMDeploymentStatusReport data, response status code and response headers
    def read_alb_controller_node_vm_deployment_status_with_http_info(node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.read_alb_controller_node_vm_deployment_status ...'
      end
      # verify the required parameter 'node_id' is set
      if @api_client.config.client_side_validation && node_id.nil?
        fail ArgumentError, "Missing the required parameter 'node_id' when calling ConfigurationApi.read_alb_controller_node_vm_deployment_status"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/deployments/{node-id}/status'.sub('{' + 'node-id' + '}', node_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerNodeVMDeploymentStatusReport')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#read_alb_controller_node_vm_deployment_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read NSX Management nodes global configuration.
    # Returns the NSX Management nodes global configuration. 
    # @param [Hash] opts the optional parameters
    # @return [ManagementConfig]
    def read_management_config(opts = {})
      data, _status_code, _headers = read_management_config_with_http_info(opts)
      data
    end

    # Read NSX Management nodes global configuration.
    # Returns the NSX Management nodes global configuration. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ManagementConfig, Fixnum, Hash)>] ManagementConfig data, response status code and response headers
    def read_management_config_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.read_management_config ...'
      end
      # resource path
      local_var_path = '/configs/management'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ManagementConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#read_management_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read a Sub-cluster configuration
    # Read a Sub-cluster configuration. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param subcluster_id 
    # @param [Hash] opts the optional parameters
    # @return [SubCluster]
    def read_sub_cluster(site_id, enforcementpoint_id, subcluster_id, opts = {})
      data, _status_code, _headers = read_sub_cluster_with_http_info(site_id, enforcementpoint_id, subcluster_id, opts)
      data
    end

    # Read a Sub-cluster configuration
    # Read a Sub-cluster configuration. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param subcluster_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SubCluster, Fixnum, Hash)>] SubCluster data, response status code and response headers
    def read_sub_cluster_with_http_info(site_id, enforcementpoint_id, subcluster_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.read_sub_cluster ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.read_sub_cluster"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.read_sub_cluster"
      end
      # verify the required parameter 'subcluster_id' is set
      if @api_client.config.client_side_validation && subcluster_id.nil?
        fail ArgumentError, "Missing the required parameter 'subcluster_id' when calling ConfigurationApi.read_sub_cluster"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/sub-clusters/{subcluster-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'subcluster-id' + '}', subcluster_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SubCluster')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#read_sub_cluster\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get information about the specified task
    # Get information about the specified task
    # @param task_id ID of task to read
    # @param [Hash] opts the optional parameters
    # @return [TaskProperties]
    def read_task_properties(task_id, opts = {})
      data, _status_code, _headers = read_task_properties_with_http_info(task_id, opts)
      data
    end

    # Get information about the specified task
    # Get information about the specified task
    # @param task_id ID of task to read
    # @param [Hash] opts the optional parameters
    # @return [Array<(TaskProperties, Fixnum, Hash)>] TaskProperties data, response status code and response headers
    def read_task_properties_with_http_info(task_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.read_task_properties ...'
      end
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        fail ArgumentError, "Missing the required parameter 'task_id' when calling ConfigurationApi.read_task_properties"
      end
      # resource path
      local_var_path = '/tasks/{task-id}'.sub('{' + 'task-id' + '}', task_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TaskProperties')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#read_task_properties\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get the response of a task
    # Get the response of a task
    # @param task_id ID of task to read
    # @param [Hash] opts the optional parameters
    # @return [Object]
    def read_task_result(task_id, opts = {})
      data, _status_code, _headers = read_task_result_with_http_info(task_id, opts)
      data
    end

    # Get the response of a task
    # Get the response of a task
    # @param task_id ID of task to read
    # @param [Hash] opts the optional parameters
    # @return [Array<(Object, Fixnum, Hash)>] Object data, response status code and response headers
    def read_task_result_with_http_info(task_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.read_task_result ...'
      end
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        fail ArgumentError, "Missing the required parameter 'task_id' when calling ConfigurationApi.read_task_result"
      end
      # resource path
      local_var_path = '/tasks/{task-id}/response'.sub('{' + 'task-id' + '}', task_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Object')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#read_task_result\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Register a Collection of API Calls at a Single End Point
    # Enables you to make multiple API requests using a single request. The batch API takes in an array of logical HTTP requests represented as JSON arrays. Each request has a method (GET, PUT, POST, or DELETE), a relative_url (the portion of the URL after https://&lt;nsx-mgr&gt;/api/), optional headers array (corresponding to HTTP headers) and an optional body (for POST and PUT requests). The batch API returns an array of logical HTTP responses represented as JSON arrays. Each response has a status code, an optional headers array and an optional body (which is a JSON-encoded string). The batch API is not supported for any of the policy multi-tenancy related APIs. The multi-tenancy APIs start with the path /orgs/<org-id>/projects/<project-id>/ This API is deprecated. Instead, use the hierarchical API in the NSX-T policy API.  <br> Support for batched operations will be removed from a future NSX release. For policy APIs, use the hierarchical API to submit a set of updates as a single operation. For other APIs, submit the operations as individual REST API calls.
    # @param batch_request 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :atomic Ignored (transactional atomicity flag) (default to false)
    # @return [BatchResponse]
    def register_batch_request(batch_request, opts = {})
      data, _status_code, _headers = register_batch_request_with_http_info(batch_request, opts)
      data
    end

    # Register a Collection of API Calls at a Single End Point
    # Enables you to make multiple API requests using a single request. The batch API takes in an array of logical HTTP requests represented as JSON arrays. Each request has a method (GET, PUT, POST, or DELETE), a relative_url (the portion of the URL after https://&amp;lt;nsx-mgr&amp;gt;/api/), optional headers array (corresponding to HTTP headers) and an optional body (for POST and PUT requests). The batch API returns an array of logical HTTP responses represented as JSON arrays. Each response has a status code, an optional headers array and an optional body (which is a JSON-encoded string). The batch API is not supported for any of the policy multi-tenancy related APIs. The multi-tenancy APIs start with the path /orgs/&lt;org-id&gt;/projects/&lt;project-id&gt;/ This API is deprecated. Instead, use the hierarchical API in the NSX-T policy API.  &lt;br&gt; Support for batched operations will be removed from a future NSX release. For policy APIs, use the hierarchical API to submit a set of updates as a single operation. For other APIs, submit the operations as individual REST API calls.
    # @param batch_request 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :atomic Ignored (transactional atomicity flag)
    # @return [Array<(BatchResponse, Fixnum, Hash)>] BatchResponse data, response status code and response headers
    def register_batch_request_with_http_info(batch_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.register_batch_request ...'
      end
      # verify the required parameter 'batch_request' is set
      if @api_client.config.client_side_validation && batch_request.nil?
        fail ArgumentError, "Missing the required parameter 'batch_request' when calling ConfigurationApi.register_batch_request"
      end
      # resource path
      local_var_path = '/batch'

      # query parameters
      query_params = {}
      query_params[:'atomic'] = opts[:'atomic'] if !opts[:'atomic'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(batch_request)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BatchResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#register_batch_request\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Uninstall NSX from the specified Transport Node Collection
    # This API uninstalls NSX applied to the Transport Node Collection with the ID corresponding to the one specified in the request.
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def remove_nsxon_transport_node_collection(site_id, enforcementpoint_id, transport_node_collection_id, opts = {})
      remove_nsxon_transport_node_collection_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, opts)
      nil
    end

    # Uninstall NSX from the specified Transport Node Collection
    # This API uninstalls NSX applied to the Transport Node Collection with the ID corresponding to the one specified in the request.
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def remove_nsxon_transport_node_collection_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.remove_nsxon_transport_node_collection ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.remove_nsxon_transport_node_collection"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.remove_nsxon_transport_node_collection"
      end
      # verify the required parameter 'transport_node_collection_id' is set
      if @api_client.config.client_side_validation && transport_node_collection_id.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_collection_id' when calling ConfigurationApi.remove_nsxon_transport_node_collection"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/transport-node-collections/{transport-node-collection-id}?action=remove_nsx'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'transport-node-collection-id' + '}', transport_node_collection_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#remove_nsxon_transport_node_collection\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Apply cluster level Transport Node Profile on overridden host
    # A host can be overridden to have different configuration than Transport Node Profile(TNP) on cluster. This action will restore such overridden host back to cluster level TNP.  This API can be used in other case. When TNP is applied to a cluster, if any validation fails (e.g. VMs running on host) then existing transport node (TN) is not updated. In that case after the issue is resolved manually (e.g. VMs powered off), you can call this API to update TN as per cluster level TNP. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def restore_parent_cluster_configuration_on_host_transport_node(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      restore_parent_cluster_configuration_on_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      nil
    end

    # Apply cluster level Transport Node Profile on overridden host
    # A host can be overridden to have different configuration than Transport Node Profile(TNP) on cluster. This action will restore such overridden host back to cluster level TNP.  This API can be used in other case. When TNP is applied to a cluster, if any validation fails (e.g. VMs running on host) then existing transport node (TN) is not updated. In that case after the issue is resolved manually (e.g. VMs powered off), you can call this API to update TN as per cluster level TNP. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def restore_parent_cluster_configuration_on_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.restore_parent_cluster_configuration_on_host_transport_node ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.restore_parent_cluster_configuration_on_host_transport_node"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.restore_parent_cluster_configuration_on_host_transport_node"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling ConfigurationApi.restore_parent_cluster_configuration_on_host_transport_node"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}?action=restore_cluster_config'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#restore_parent_cluster_configuration_on_host_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Resync a Host Transport Node
    # Resync the TransportNode configuration on a host. It is similar to updating the TransportNode with existing configuration, but force synce these configurations to the host (no backend optimizations). 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def resync_host_transport_node(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      resync_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      nil
    end

    # Resync a Host Transport Node
    # Resync the TransportNode configuration on a host. It is similar to updating the TransportNode with existing configuration, but force synce these configurations to the host (no backend optimizations). 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def resync_host_transport_node_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.resync_host_transport_node ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.resync_host_transport_node"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.resync_host_transport_node"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling ConfigurationApi.resync_host_transport_node"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}?action=resync_host_config'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#resync_host_transport_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Re-trigger clustering for Avi Load Balancer Controller Nodes.
    # Re-trigger clustering for Avi Load Balancer Controller Nodes. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @return [ALBControllerClusterTrigger]
    def retrigger_clustering(opts = {})
      data, _status_code, _headers = retrigger_clustering_with_http_info(opts)
      data
    end

    # Re-trigger clustering for Avi Load Balancer Controller Nodes.
    # Re-trigger clustering for Avi Load Balancer Controller Nodes. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :clustering_id Unique Id for Avi Load Balancer Controller Cluster used in VCF managed NSX
    # @return [Array<(ALBControllerClusterTrigger, Fixnum, Hash)>] ALBControllerClusterTrigger data, response status code and response headers
    def retrigger_clustering_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.retrigger_clustering ...'
      end
      # resource path
      local_var_path = '/alb/controller-nodes/cluster'

      # query parameters
      query_params = {}
      query_params[:'clustering_id'] = opts[:'clustering_id'] if !opts[:'clustering_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerClusterTrigger')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#retrigger_clustering\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Retry the process on applying transport node profile
    # This API is relevant for compute collection on which vLCM is enabled. This API should be invoked to retry the realization of transport node profile on the compute collection. This is useful when profile realization had failed because of error in vLCM. This API has no effect if vLCM is not enabled on the computer collection.
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def retry_host_transport_node_collection_realization(site_id, enforcementpoint_id, transport_node_collection_id, opts = {})
      retry_host_transport_node_collection_realization_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, opts)
      nil
    end

    # Retry the process on applying transport node profile
    # This API is relevant for compute collection on which vLCM is enabled. This API should be invoked to retry the realization of transport node profile on the compute collection. This is useful when profile realization had failed because of error in vLCM. This API has no effect if vLCM is not enabled on the computer collection.
    # @param site_id 
    # @param enforcementpoint_id 
    # @param transport_node_collection_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def retry_host_transport_node_collection_realization_with_http_info(site_id, enforcementpoint_id, transport_node_collection_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.retry_host_transport_node_collection_realization ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.retry_host_transport_node_collection_realization"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.retry_host_transport_node_collection_realization"
      end
      # verify the required parameter 'transport_node_collection_id' is set
      if @api_client.config.client_side_validation && transport_node_collection_id.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_collection_id' when calling ConfigurationApi.retry_host_transport_node_collection_realization"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/transport-node-collections/{transport-node-collection-id}?action=retry_profile_realization'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'transport-node-collection-id' + '}', transport_node_collection_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#retry_host_transport_node_collection_realization\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Submit a new TransportNode VTEP action
    # Submit a new VTEP action for a particular TransportNode. The status of submitted actions could be retrieved using the ListTransportNodeVtepActionsStatus API. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param transport_node_vtep_action 
    # @param [Hash] opts the optional parameters
    # @return [TransportNodeVtepActionReference]
    def submit_transport_node_vtep_action(site_id, enforcementpoint_id, host_transport_node_id, transport_node_vtep_action, opts = {})
      data, _status_code, _headers = submit_transport_node_vtep_action_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, transport_node_vtep_action, opts)
      data
    end

    # Submit a new TransportNode VTEP action
    # Submit a new VTEP action for a particular TransportNode. The status of submitted actions could be retrieved using the ListTransportNodeVtepActionsStatus API. 
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param transport_node_vtep_action 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TransportNodeVtepActionReference, Fixnum, Hash)>] TransportNodeVtepActionReference data, response status code and response headers
    def submit_transport_node_vtep_action_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, transport_node_vtep_action, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.submit_transport_node_vtep_action ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.submit_transport_node_vtep_action"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.submit_transport_node_vtep_action"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling ConfigurationApi.submit_transport_node_vtep_action"
      end
      # verify the required parameter 'transport_node_vtep_action' is set
      if @api_client.config.client_side_validation && transport_node_vtep_action.nil?
        fail ArgumentError, "Missing the required parameter 'transport_node_vtep_action' when calling ConfigurationApi.submit_transport_node_vtep_action"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}/vteps/actions'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(transport_node_vtep_action)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'TransportNodeVtepActionReference')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#submit_transport_node_vtep_action\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update a Avi Load Balancer Controller cluster node. Only updating password, ntp and dns servers are supported. If controller is in a cluster then all nodes in the cluster are updated with the provided values
    # Update Avi Load Balancer Controller node details 
    # @param node_id 
    # @param alb_controller_node_vm_deployment_request 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :running_config Update Avi Load Balancer Controller runtime config as well
    # @return [ALBControllerNodeVMDeploymentRequest]
    def update_alb_controller_node_vm_deployment_request(node_id, alb_controller_node_vm_deployment_request, opts = {})
      data, _status_code, _headers = update_alb_controller_node_vm_deployment_request_with_http_info(node_id, alb_controller_node_vm_deployment_request, opts)
      data
    end

    # Update a Avi Load Balancer Controller cluster node. Only updating password, ntp and dns servers are supported. If controller is in a cluster then all nodes in the cluster are updated with the provided values
    # Update Avi Load Balancer Controller node details 
    # @param node_id 
    # @param alb_controller_node_vm_deployment_request 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :running_config Update Avi Load Balancer Controller runtime config as well
    # @return [Array<(ALBControllerNodeVMDeploymentRequest, Fixnum, Hash)>] ALBControllerNodeVMDeploymentRequest data, response status code and response headers
    def update_alb_controller_node_vm_deployment_request_with_http_info(node_id, alb_controller_node_vm_deployment_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.update_alb_controller_node_vm_deployment_request ...'
      end
      # verify the required parameter 'node_id' is set
      if @api_client.config.client_side_validation && node_id.nil?
        fail ArgumentError, "Missing the required parameter 'node_id' when calling ConfigurationApi.update_alb_controller_node_vm_deployment_request"
      end
      # verify the required parameter 'alb_controller_node_vm_deployment_request' is set
      if @api_client.config.client_side_validation && alb_controller_node_vm_deployment_request.nil?
        fail ArgumentError, "Missing the required parameter 'alb_controller_node_vm_deployment_request' when calling ConfigurationApi.update_alb_controller_node_vm_deployment_request"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/deployments/{node-id}'.sub('{' + 'node-id' + '}', node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'running_config'] = opts[:'running_config'] if !opts[:'running_config'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(alb_controller_node_vm_deployment_request)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerNodeVMDeploymentRequest')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#update_alb_controller_node_vm_deployment_request\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update DNS, NTP and Backup server config in Avi Load Balancer Controller.
    # Use this API to update DNS, NTP and Backup server config in Avi Load Balancer Controller. This API is for VCF deployments only. 
    # @param alb_controller_system_configuration 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :running_config Update Avi Load Balancer Controller runtime config as well
    # @return [ALBControllerSystemConfigurationResponse]
    def update_alb_system_configuration(alb_controller_system_configuration, opts = {})
      data, _status_code, _headers = update_alb_system_configuration_with_http_info(alb_controller_system_configuration, opts)
      data
    end

    # Update DNS, NTP and Backup server config in Avi Load Balancer Controller.
    # Use this API to update DNS, NTP and Backup server config in Avi Load Balancer Controller. This API is for VCF deployments only. 
    # @param alb_controller_system_configuration 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :running_config Update Avi Load Balancer Controller runtime config as well
    # @return [Array<(ALBControllerSystemConfigurationResponse, Fixnum, Hash)>] ALBControllerSystemConfigurationResponse data, response status code and response headers
    def update_alb_system_configuration_with_http_info(alb_controller_system_configuration, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.update_alb_system_configuration ...'
      end
      # verify the required parameter 'alb_controller_system_configuration' is set
      if @api_client.config.client_side_validation && alb_controller_system_configuration.nil?
        fail ArgumentError, "Missing the required parameter 'alb_controller_system_configuration' when calling ConfigurationApi.update_alb_system_configuration"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/system-configuration'

      # query parameters
      query_params = {}
      query_params[:'running_config'] = opts[:'running_config'] if !opts[:'running_config'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(alb_controller_system_configuration)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerSystemConfigurationResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#update_alb_system_configuration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update admin user or service user object password in Avi Load Balancer Controller.
    # Use this API to update admin user password or service user object password in Avi Load Balancer Controller. This API is for VCF deployments only. 
    # @param alb_controller_user_credential 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :running_config Update Avi Load Balancer Controller runtime config as well
    # @return [ALBControllerUserCredentialResponse]
    def update_alb_user_credential_object(alb_controller_user_credential, opts = {})
      data, _status_code, _headers = update_alb_user_credential_object_with_http_info(alb_controller_user_credential, opts)
      data
    end

    # Update admin user or service user object password in Avi Load Balancer Controller.
    # Use this API to update admin user password or service user object password in Avi Load Balancer Controller. This API is for VCF deployments only. 
    # @param alb_controller_user_credential 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :running_config Update Avi Load Balancer Controller runtime config as well
    # @return [Array<(ALBControllerUserCredentialResponse, Fixnum, Hash)>] ALBControllerUserCredentialResponse data, response status code and response headers
    def update_alb_user_credential_object_with_http_info(alb_controller_user_credential, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.update_alb_user_credential_object ...'
      end
      # verify the required parameter 'alb_controller_user_credential' is set
      if @api_client.config.client_side_validation && alb_controller_user_credential.nil?
        fail ArgumentError, "Missing the required parameter 'alb_controller_user_credential' when calling ConfigurationApi.update_alb_user_credential_object"
      end
      # resource path
      local_var_path = '/alb/controller-nodes/user-credential'

      # query parameters
      query_params = {}
      query_params[:'running_config'] = opts[:'running_config'] if !opts[:'running_config'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(alb_controller_user_credential)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ALBControllerUserCredentialResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#update_alb_user_credential_object\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update API service properties
    # Update the configuration of the NSX API service. Changes are applied to all nodes in the cluster. The API service on each node will restart after it is updated using this API. There may be a delay of up to a minute or so between the time this API call completes and when the new configuration goes into effect.
    # @param api_service_config 
    # @param [Hash] opts the optional parameters
    # @return [ApiServiceConfig]
    def update_api_service_config(api_service_config, opts = {})
      data, _status_code, _headers = update_api_service_config_with_http_info(api_service_config, opts)
      data
    end

    # Update API service properties
    # Update the configuration of the NSX API service. Changes are applied to all nodes in the cluster. The API service on each node will restart after it is updated using this API. There may be a delay of up to a minute or so between the time this API call completes and when the new configuration goes into effect.
    # @param api_service_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiServiceConfig, Fixnum, Hash)>] ApiServiceConfig data, response status code and response headers
    def update_api_service_config_with_http_info(api_service_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.update_api_service_config ...'
      end
      # verify the required parameter 'api_service_config' is set
      if @api_client.config.client_side_validation && api_service_config.nil?
        fail ArgumentError, "Missing the required parameter 'api_service_config' when calling ConfigurationApi.update_api_service_config"
      end
      # resource path
      local_var_path = '/cluster/api-service'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(api_service_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ApiServiceConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#update_api_service_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update API service properties
    # Update the configuration of the NSX API service. Changes are applied to all nodes in the cluster. The API service on each node will restart after it is updated using this API. There may be a delay of up to a minute or so between the time this API call completes and when the new configuration goes into effect.
    # @param api_service_config 
    # @param [Hash] opts the optional parameters
    # @return [ApiServiceConfig]
    def update_api_service_config_0(api_service_config, opts = {})
      data, _status_code, _headers = update_api_service_config_0_with_http_info(api_service_config, opts)
      data
    end

    # Update API service properties
    # Update the configuration of the NSX API service. Changes are applied to all nodes in the cluster. The API service on each node will restart after it is updated using this API. There may be a delay of up to a minute or so between the time this API call completes and when the new configuration goes into effect.
    # @param api_service_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiServiceConfig, Fixnum, Hash)>] ApiServiceConfig data, response status code and response headers
    def update_api_service_config_0_with_http_info(api_service_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.update_api_service_config_0 ...'
      end
      # verify the required parameter 'api_service_config' is set
      if @api_client.config.client_side_validation && api_service_config.nil?
        fail ArgumentError, "Missing the required parameter 'api_service_config' when calling ConfigurationApi.update_api_service_config_0"
      end
      # resource path
      local_var_path = '/cluster/api-service'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(api_service_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ApiServiceConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#update_api_service_config_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Saves the configuration for auto enable gateway firewall config
    # Update auto enable gateway firewall configuration value 
    # @param auto_enable_gateway_firewall_config 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def update_auto_enable_gateway_firewall_config(auto_enable_gateway_firewall_config, opts = {})
      update_auto_enable_gateway_firewall_config_with_http_info(auto_enable_gateway_firewall_config, opts)
      nil
    end

    # Saves the configuration for auto enable gateway firewall config
    # Update auto enable gateway firewall configuration value 
    # @param auto_enable_gateway_firewall_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def update_auto_enable_gateway_firewall_config_with_http_info(auto_enable_gateway_firewall_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.update_auto_enable_gateway_firewall_config ...'
      end
      # verify the required parameter 'auto_enable_gateway_firewall_config' is set
      if @api_client.config.client_side_validation && auto_enable_gateway_firewall_config.nil?
        fail ArgumentError, "Missing the required parameter 'auto_enable_gateway_firewall_config' when calling ConfigurationApi.update_auto_enable_gateway_firewall_config"
      end
      # resource path
      local_var_path = '/system-config/auto-enable-gateway-firewall'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(auto_enable_gateway_firewall_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#update_auto_enable_gateway_firewall_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update NSX Management nodes global configuration
    # Modifies the NSX Management nodes global configuration.
    # @param management_config 
    # @param [Hash] opts the optional parameters
    # @return [ManagementConfig]
    def update_management_config(management_config, opts = {})
      data, _status_code, _headers = update_management_config_with_http_info(management_config, opts)
      data
    end

    # Update NSX Management nodes global configuration
    # Modifies the NSX Management nodes global configuration.
    # @param management_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ManagementConfig, Fixnum, Hash)>] ManagementConfig data, response status code and response headers
    def update_management_config_with_http_info(management_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.update_management_config ...'
      end
      # verify the required parameter 'management_config' is set
      if @api_client.config.client_side_validation && management_config.nil?
        fail ArgumentError, "Missing the required parameter 'management_config' when calling ConfigurationApi.update_management_config"
      end
      # resource path
      local_var_path = '/configs/management'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(management_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ManagementConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#update_management_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Saves the configuration for policy partial patch
    # Update partial patch configuration values. Only boolean value is allowed for enable_partial_patch. Please refer to the description of PartialPatchConfig for more information. 
    # @param partial_patch_config 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def update_partial_patch_config(partial_patch_config, opts = {})
      update_partial_patch_config_with_http_info(partial_patch_config, opts)
      nil
    end

    # Saves the configuration for policy partial patch
    # Update partial patch configuration values. Only boolean value is allowed for enable_partial_patch. Please refer to the description of PartialPatchConfig for more information. 
    # @param partial_patch_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def update_partial_patch_config_with_http_info(partial_patch_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.update_partial_patch_config ...'
      end
      # verify the required parameter 'partial_patch_config' is set
      if @api_client.config.client_side_validation && partial_patch_config.nil?
        fail ArgumentError, "Missing the required parameter 'partial_patch_config' when calling ConfigurationApi.update_partial_patch_config"
      end
      # resource path
      local_var_path = '/system-config/nsx-partial-patch-config'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(partial_patch_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#update_partial_patch_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update transport node maintenance mode
    # Put transport node into maintenance mode or exit from maintenance mode. When HostTransportNode is in maintenance mode no configuration changes are allowed
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :action 
    # @return [nil]
    def update_policy_host_transport_node_maintenance_mode(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      update_policy_host_transport_node_maintenance_mode_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts)
      nil
    end

    # Update transport node maintenance mode
    # Put transport node into maintenance mode or exit from maintenance mode. When HostTransportNode is in maintenance mode no configuration changes are allowed
    # @param site_id 
    # @param enforcementpoint_id 
    # @param host_transport_node_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :action 
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def update_policy_host_transport_node_maintenance_mode_with_http_info(site_id, enforcementpoint_id, host_transport_node_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConfigurationApi.update_policy_host_transport_node_maintenance_mode ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling ConfigurationApi.update_policy_host_transport_node_maintenance_mode"
      end
      # verify the required parameter 'enforcementpoint_id' is set
      if @api_client.config.client_side_validation && enforcementpoint_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcementpoint_id' when calling ConfigurationApi.update_policy_host_transport_node_maintenance_mode"
      end
      # verify the required parameter 'host_transport_node_id' is set
      if @api_client.config.client_side_validation && host_transport_node_id.nil?
        fail ArgumentError, "Missing the required parameter 'host_transport_node_id' when calling ConfigurationApi.update_policy_host_transport_node_maintenance_mode"
      end
      if @api_client.config.client_side_validation && opts[:'action'] && !['enter_maintenance_mode', 'forced_enter_maintenance_mode', 'exit_maintenance_mode'].include?(opts[:'action'])
        fail ArgumentError, 'invalid value for "action", must be one of enter_maintenance_mode, forced_enter_maintenance_mode, exit_maintenance_mode'
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/host-transport-nodes/{host-transport-node-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcementpoint-id' + '}', enforcementpoint_id.to_s).sub('{' + 'host-transport-node-id' + '}', host_transport_node_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'action'] = opts[:'action'] if !opts[:'action'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConfigurationApi#update_policy_host_transport_node_maintenance_mode\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
