=begin
#NSX Policy API

#VMware NSX Policy REST API

OpenAPI spec version: 9.0.0.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.4.46

=end

require 'uri'

module Nsxt9PolicyClient
  class SegmentsApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Create IP Discovery Profile
    # API will create IP Discovery profile. 
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param ip_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def create_ip_discovery_profile(ip_discovery_profile_id, ip_discovery_profile, opts = {})
      create_ip_discovery_profile_with_http_info(ip_discovery_profile_id, ip_discovery_profile, opts)
      nil
    end

    # Create IP Discovery Profile
    # API will create IP Discovery profile. 
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param ip_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def create_ip_discovery_profile_with_http_info(ip_discovery_profile_id, ip_discovery_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_ip_discovery_profile ...'
      end
      # verify the required parameter 'ip_discovery_profile_id' is set
      if @api_client.config.client_side_validation && ip_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'ip_discovery_profile_id' when calling SegmentsApi.create_ip_discovery_profile"
      end
      # verify the required parameter 'ip_discovery_profile' is set
      if @api_client.config.client_side_validation && ip_discovery_profile.nil?
        fail ArgumentError, "Missing the required parameter 'ip_discovery_profile' when calling SegmentsApi.create_ip_discovery_profile"
      end
      # resource path
      local_var_path = '/infra/ip-discovery-profiles/{ip-discovery-profile-id}'.sub('{' + 'ip-discovery-profile-id' + '}', ip_discovery_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(ip_discovery_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_ip_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Mac Discovery Profile
    # API will create Mac Discovery profile. 
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param mac_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def create_mac_discovery_profile(mac_discovery_profile_id, mac_discovery_profile, opts = {})
      create_mac_discovery_profile_with_http_info(mac_discovery_profile_id, mac_discovery_profile, opts)
      nil
    end

    # Create Mac Discovery Profile
    # API will create Mac Discovery profile. 
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param mac_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def create_mac_discovery_profile_with_http_info(mac_discovery_profile_id, mac_discovery_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_mac_discovery_profile ...'
      end
      # verify the required parameter 'mac_discovery_profile_id' is set
      if @api_client.config.client_side_validation && mac_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'mac_discovery_profile_id' when calling SegmentsApi.create_mac_discovery_profile"
      end
      # verify the required parameter 'mac_discovery_profile' is set
      if @api_client.config.client_side_validation && mac_discovery_profile.nil?
        fail ArgumentError, "Missing the required parameter 'mac_discovery_profile' when calling SegmentsApi.create_mac_discovery_profile"
      end
      # resource path
      local_var_path = '/infra/mac-discovery-profiles/{mac-discovery-profile-id}'.sub('{' + 'mac-discovery-profile-id' + '}', mac_discovery_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(mac_discovery_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_mac_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a infra segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, replace the segment with this object. Note: Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \"l2_extension\" object in the PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Segment]
    def create_or_replace_infra_segment(segment_id, segment, opts = {})
      data, _status_code, _headers = create_or_replace_infra_segment_with_http_info(segment_id, segment, opts)
      data
    end

    # Create or update a infra segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, replace the segment with this object. Note: Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \&quot;l2_extension\&quot; object in the PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Segment, Fixnum, Hash)>] Segment data, response status code and response headers
    def create_or_replace_infra_segment_with_http_info(segment_id, segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_or_replace_infra_segment ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.create_or_replace_infra_segment"
      end
      # verify the required parameter 'segment' is set
      if @api_client.config.client_side_validation && segment.nil?
        fail ArgumentError, "Missing the required parameter 'segment' when calling SegmentsApi.create_or_replace_infra_segment"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Segment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_or_replace_infra_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a infra segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, replace the segment with this object. Note: Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \"l2_extension\" object in the PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Segment]
    def create_or_replace_infra_segment_0(segment_id, segment, opts = {})
      data, _status_code, _headers = create_or_replace_infra_segment_0_with_http_info(segment_id, segment, opts)
      data
    end

    # Create or update a infra segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, replace the segment with this object. Note: Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \&quot;l2_extension\&quot; object in the PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Segment, Fixnum, Hash)>] Segment data, response status code and response headers
    def create_or_replace_infra_segment_0_with_http_info(segment_id, segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_or_replace_infra_segment_0 ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.create_or_replace_infra_segment_0"
      end
      # verify the required parameter 'segment' is set
      if @api_client.config.client_side_validation && segment.nil?
        fail ArgumentError, "Missing the required parameter 'segment' when calling SegmentsApi.create_or_replace_infra_segment_0"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Segment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_or_replace_infra_segment_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update an infra segment port
    # Create an infra segment port if it does not exist based on the IDs, or update existing port information by replacing the port object already exists. 
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [SegmentPort]
    def create_or_replace_infra_segment_port(segment_id, port_id, segment_port, opts = {})
      data, _status_code, _headers = create_or_replace_infra_segment_port_with_http_info(segment_id, port_id, segment_port, opts)
      data
    end

    # Create or update an infra segment port
    # Create an infra segment port if it does not exist based on the IDs, or update existing port information by replacing the port object already exists. 
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentPort, Fixnum, Hash)>] SegmentPort data, response status code and response headers
    def create_or_replace_infra_segment_port_with_http_info(segment_id, port_id, segment_port, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_or_replace_infra_segment_port ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.create_or_replace_infra_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.create_or_replace_infra_segment_port"
      end
      # verify the required parameter 'segment_port' is set
      if @api_client.config.client_side_validation && segment_port.nil?
        fail ArgumentError, "Missing the required parameter 'segment_port' when calling SegmentsApi.create_or_replace_infra_segment_port"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_port)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPort')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_or_replace_infra_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a infra segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, replace the segment with this object.  Force parameter is required when workload connectivity is indirectly impacted with the current replacement. Note:   Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the   \"l2_extension\" object in the PATCH API payload, the path returned in the GET response payload may include the new path   instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.   Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path   instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Segment]
    def create_or_replace_infra_segment_with_force(segment_id, segment, opts = {})
      data, _status_code, _headers = create_or_replace_infra_segment_with_force_with_http_info(segment_id, segment, opts)
      data
    end

    # Create or update a infra segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, replace the segment with this object.  Force parameter is required when workload connectivity is indirectly impacted with the current replacement. Note:   Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the   \&quot;l2_extension\&quot; object in the PATCH API payload, the path returned in the GET response payload may include the new path   instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.   Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path   instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Segment, Fixnum, Hash)>] Segment data, response status code and response headers
    def create_or_replace_infra_segment_with_force_with_http_info(segment_id, segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_or_replace_infra_segment_with_force ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.create_or_replace_infra_segment_with_force"
      end
      # verify the required parameter 'segment' is set
      if @api_client.config.client_side_validation && segment.nil?
        fail ArgumentError, "Missing the required parameter 'segment' when calling SegmentsApi.create_or_replace_infra_segment_with_force"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}?force=true'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Segment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_or_replace_infra_segment_with_force\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a infra segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, replace the segment with this object.  Force parameter is required when workload connectivity is indirectly impacted with the current replacement. Note:   Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the   \"l2_extension\" object in the PATCH API payload, the path returned in the GET response payload may include the new path   instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.   Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path   instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Segment]
    def create_or_replace_infra_segment_with_force_0(segment_id, segment, opts = {})
      data, _status_code, _headers = create_or_replace_infra_segment_with_force_0_with_http_info(segment_id, segment, opts)
      data
    end

    # Create or update a infra segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, replace the segment with this object.  Force parameter is required when workload connectivity is indirectly impacted with the current replacement. Note:   Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the   \&quot;l2_extension\&quot; object in the PATCH API payload, the path returned in the GET response payload may include the new path   instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.   Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path   instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Segment, Fixnum, Hash)>] Segment data, response status code and response headers
    def create_or_replace_infra_segment_with_force_0_with_http_info(segment_id, segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_or_replace_infra_segment_with_force_0 ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.create_or_replace_infra_segment_with_force_0"
      end
      # verify the required parameter 'segment' is set
      if @api_client.config.client_side_validation && segment.nil?
        fail ArgumentError, "Missing the required parameter 'segment' when calling SegmentsApi.create_or_replace_infra_segment_with_force_0"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}?force=true'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Segment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_or_replace_infra_segment_with_force_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or Replace QoS profile.
    # Create or Replace QoS profile. 
    # @param qos_profile_id QoS profile Id
    # @param qo_s_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [QoSProfile]
    def create_or_replace_qo_s_profile(qos_profile_id, qo_s_profile, opts = {})
      data, _status_code, _headers = create_or_replace_qo_s_profile_with_http_info(qos_profile_id, qo_s_profile, opts)
      data
    end

    # Create or Replace QoS profile.
    # Create or Replace QoS profile. 
    # @param qos_profile_id QoS profile Id
    # @param qo_s_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(QoSProfile, Fixnum, Hash)>] QoSProfile data, response status code and response headers
    def create_or_replace_qo_s_profile_with_http_info(qos_profile_id, qo_s_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_or_replace_qo_s_profile ...'
      end
      # verify the required parameter 'qos_profile_id' is set
      if @api_client.config.client_side_validation && qos_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'qos_profile_id' when calling SegmentsApi.create_or_replace_qo_s_profile"
      end
      # verify the required parameter 'qo_s_profile' is set
      if @api_client.config.client_side_validation && qo_s_profile.nil?
        fail ArgumentError, "Missing the required parameter 'qo_s_profile' when calling SegmentsApi.create_or_replace_qo_s_profile"
      end
      # resource path
      local_var_path = '/infra/qos-profiles/{qos-profile-id}'.sub('{' + 'qos-profile-id' + '}', qos_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(qo_s_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'QoSProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_or_replace_qo_s_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or Replace Real Time Eth profile.
    # Create or Replace Real Time Eth profile. 
    # @param real_time_eth_profile_id Real Time Eth profile Id
    # @param real_time_eth_profile 
    # @param [Hash] opts the optional parameters
    # @return [RealTimeEthProfile]
    def create_or_replace_real_time_eth_profile(real_time_eth_profile_id, real_time_eth_profile, opts = {})
      data, _status_code, _headers = create_or_replace_real_time_eth_profile_with_http_info(real_time_eth_profile_id, real_time_eth_profile, opts)
      data
    end

    # Create or Replace Real Time Eth profile.
    # Create or Replace Real Time Eth profile. 
    # @param real_time_eth_profile_id Real Time Eth profile Id
    # @param real_time_eth_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(RealTimeEthProfile, Fixnum, Hash)>] RealTimeEthProfile data, response status code and response headers
    def create_or_replace_real_time_eth_profile_with_http_info(real_time_eth_profile_id, real_time_eth_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_or_replace_real_time_eth_profile ...'
      end
      # verify the required parameter 'real_time_eth_profile_id' is set
      if @api_client.config.client_side_validation && real_time_eth_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'real_time_eth_profile_id' when calling SegmentsApi.create_or_replace_real_time_eth_profile"
      end
      # verify the required parameter 'real_time_eth_profile' is set
      if @api_client.config.client_side_validation && real_time_eth_profile.nil?
        fail ArgumentError, "Missing the required parameter 'real_time_eth_profile' when calling SegmentsApi.create_or_replace_real_time_eth_profile"
      end
      # resource path
      local_var_path = '/infra/real-time-eth-profiles/{real-time-eth-profile-id}'.sub('{' + 'real-time-eth-profile-id' + '}', real_time_eth_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(real_time_eth_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RealTimeEthProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_or_replace_real_time_eth_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, replace the segment with this object. Note:   Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the   \"l2_extension\" object in the PUT API payload, the path returned in the PUT/GET response payload may include the new path   instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.   Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path   instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param tier_1_id 
    # @param segment_id 
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Segment]
    def create_or_replace_segment(tier_1_id, segment_id, segment, opts = {})
      data, _status_code, _headers = create_or_replace_segment_with_http_info(tier_1_id, segment_id, segment, opts)
      data
    end

    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, replace the segment with this object. Note:   Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the   \&quot;l2_extension\&quot; object in the PUT API payload, the path returned in the PUT/GET response payload may include the new path   instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.   Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path   instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param tier_1_id 
    # @param segment_id 
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Segment, Fixnum, Hash)>] Segment data, response status code and response headers
    def create_or_replace_segment_with_http_info(tier_1_id, segment_id, segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_or_replace_segment ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.create_or_replace_segment"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.create_or_replace_segment"
      end
      # verify the required parameter 'segment' is set
      if @api_client.config.client_side_validation && segment.nil?
        fail ArgumentError, "Missing the required parameter 'segment' when calling SegmentsApi.create_or_replace_segment"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Segment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_or_replace_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a static ARP config
    # Create static ARP config with Tier-1 and segment IDs provided if it doesn't exist, update with provided config if it's already created. 
    # @param tier_1_id 
    # @param segment_id 
    # @param static_arp_config 
    # @param [Hash] opts the optional parameters
    # @return [StaticARPConfig]
    def create_or_replace_static_arp_config(tier_1_id, segment_id, static_arp_config, opts = {})
      data, _status_code, _headers = create_or_replace_static_arp_config_with_http_info(tier_1_id, segment_id, static_arp_config, opts)
      data
    end

    # Create or update a static ARP config
    # Create static ARP config with Tier-1 and segment IDs provided if it doesn&#39;t exist, update with provided config if it&#39;s already created. 
    # @param tier_1_id 
    # @param segment_id 
    # @param static_arp_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(StaticARPConfig, Fixnum, Hash)>] StaticARPConfig data, response status code and response headers
    def create_or_replace_static_arp_config_with_http_info(tier_1_id, segment_id, static_arp_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_or_replace_static_arp_config ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.create_or_replace_static_arp_config"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.create_or_replace_static_arp_config"
      end
      # verify the required parameter 'static_arp_config' is set
      if @api_client.config.client_side_validation && static_arp_config.nil?
        fail ArgumentError, "Missing the required parameter 'static_arp_config' when calling SegmentsApi.create_or_replace_static_arp_config"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/static-arp'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(static_arp_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticARPConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_or_replace_static_arp_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a Tier-1 segment port
    # Create a Tier-1 segment port if it does not exist based on the IDs, or update existing port information by replacing the port object already exists. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [SegmentPort]
    def create_or_replace_tier1_segment_port(tier_1_id, segment_id, port_id, segment_port, opts = {})
      data, _status_code, _headers = create_or_replace_tier1_segment_port_with_http_info(tier_1_id, segment_id, port_id, segment_port, opts)
      data
    end

    # Create or update a Tier-1 segment port
    # Create a Tier-1 segment port if it does not exist based on the IDs, or update existing port information by replacing the port object already exists. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentPort, Fixnum, Hash)>] SegmentPort data, response status code and response headers
    def create_or_replace_tier1_segment_port_with_http_info(tier_1_id, segment_id, port_id, segment_port, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_or_replace_tier1_segment_port ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.create_or_replace_tier1_segment_port"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.create_or_replace_tier1_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.create_or_replace_tier1_segment_port"
      end
      # verify the required parameter 'segment_port' is set
      if @api_client.config.client_side_validation && segment_port.nil?
        fail ArgumentError, "Missing the required parameter 'segment_port' when calling SegmentsApi.create_or_replace_tier1_segment_port"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_port)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPort')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_or_replace_tier1_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch a infra segment connection binding map
    # Patch the infra segment connection binding map. If binding map corresponding to the the given values is not present, the object will get created and if it is present it will be updated. This is a full replace. 
    # @param segment_id 
    # @param map_id 
    # @param segment_connection_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [SegmentConnectionBindingMap]
    def create_or_update_infra_segment_connection_binding_map(segment_id, map_id, segment_connection_binding_map, opts = {})
      data, _status_code, _headers = create_or_update_infra_segment_connection_binding_map_with_http_info(segment_id, map_id, segment_connection_binding_map, opts)
      data
    end

    # Patch a infra segment connection binding map
    # Patch the infra segment connection binding map. If binding map corresponding to the the given values is not present, the object will get created and if it is present it will be updated. This is a full replace. 
    # @param segment_id 
    # @param map_id 
    # @param segment_connection_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentConnectionBindingMap, Fixnum, Hash)>] SegmentConnectionBindingMap data, response status code and response headers
    def create_or_update_infra_segment_connection_binding_map_with_http_info(segment_id, map_id, segment_connection_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_or_update_infra_segment_connection_binding_map ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.create_or_update_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'map_id' is set
      if @api_client.config.client_side_validation && map_id.nil?
        fail ArgumentError, "Missing the required parameter 'map_id' when calling SegmentsApi.create_or_update_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_connection_binding_map' is set
      if @api_client.config.client_side_validation && segment_connection_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_connection_binding_map' when calling SegmentsApi.create_or_update_infra_segment_connection_binding_map"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/segment-connection-binding-maps/{map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'map-id' + '}', map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_connection_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConnectionBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_or_update_infra_segment_connection_binding_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or replace the infra segment port security profile binding map
    # API will create or replace the port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortSecurityProfileBindingMap]
    def create_or_update_infra_segment_port_security_profile_binding(segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      data, _status_code, _headers = create_or_update_infra_segment_port_security_profile_binding_with_http_info(segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts)
      data
    end

    # Create or replace the infra segment port security profile binding map
    # API will create or replace the port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortSecurityProfileBindingMap, Fixnum, Hash)>] PortSecurityProfileBindingMap data, response status code and response headers
    def create_or_update_infra_segment_port_security_profile_binding_with_http_info(segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_or_update_infra_segment_port_security_profile_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.create_or_update_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.create_or_update_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.create_or_update_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map' when calling SegmentsApi.create_or_update_infra_segment_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_security_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_or_update_infra_segment_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or replace infra segment security profile binding map
    # API will create or replace segment security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param segment_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [SegmentSecurityProfileBindingMap]
    def create_or_update_infra_segment_security_profile_binding(segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts = {})
      data, _status_code, _headers = create_or_update_infra_segment_security_profile_binding_with_http_info(segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts)
      data
    end

    # Create or replace infra segment security profile binding map
    # API will create or replace segment security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param segment_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentSecurityProfileBindingMap, Fixnum, Hash)>] SegmentSecurityProfileBindingMap data, response status code and response headers
    def create_or_update_infra_segment_security_profile_binding_with_http_info(segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_or_update_infra_segment_security_profile_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.create_or_update_infra_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map_id' when calling SegmentsApi.create_or_update_infra_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map' when calling SegmentsApi.create_or_update_infra_segment_security_profile_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/segment-security-profile-binding-maps/{segment-security-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-security-profile-binding-map-id' + '}', segment_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_security_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_or_update_infra_segment_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or replace the port security profile binding map
    # API will create or replace the port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortSecurityProfileBindingMap]
    def create_or_update_port_security_profile_binding(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      data, _status_code, _headers = create_or_update_port_security_profile_binding_with_http_info(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts)
      data
    end

    # Create or replace the port security profile binding map
    # API will create or replace the port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortSecurityProfileBindingMap, Fixnum, Hash)>] PortSecurityProfileBindingMap data, response status code and response headers
    def create_or_update_port_security_profile_binding_with_http_info(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_or_update_port_security_profile_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.create_or_update_port_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.create_or_update_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.create_or_update_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.create_or_update_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map' when calling SegmentsApi.create_or_update_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_security_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_or_update_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # PUT segment security profile id
    # Create or replace a segment security profile 
    # @param segment_security_profile_id Segment security profile id
    # @param segment_security_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [SegmentSecurityProfile]
    def create_or_update_segment_security_profile(segment_security_profile_id, segment_security_profile, opts = {})
      data, _status_code, _headers = create_or_update_segment_security_profile_with_http_info(segment_security_profile_id, segment_security_profile, opts)
      data
    end

    # PUT segment security profile id
    # Create or replace a segment security profile 
    # @param segment_security_profile_id Segment security profile id
    # @param segment_security_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(SegmentSecurityProfile, Fixnum, Hash)>] SegmentSecurityProfile data, response status code and response headers
    def create_or_update_segment_security_profile_with_http_info(segment_security_profile_id, segment_security_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_or_update_segment_security_profile ...'
      end
      # verify the required parameter 'segment_security_profile_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_id' when calling SegmentsApi.create_or_update_segment_security_profile"
      end
      # verify the required parameter 'segment_security_profile' is set
      if @api_client.config.client_side_validation && segment_security_profile.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile' when calling SegmentsApi.create_or_update_segment_security_profile"
      end
      # resource path
      local_var_path = '/infra/segment-security-profiles/{segment-security-profile-id}'.sub('{' + 'segment-security-profile-id' + '}', segment_security_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_security_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_or_update_segment_security_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or replace segment security profile binding map
    # API will create or replace segment security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param segment_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [SegmentSecurityProfileBindingMap]
    def create_or_update_segment_security_profile_binding(tier_1_id, segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts = {})
      data, _status_code, _headers = create_or_update_segment_security_profile_binding_with_http_info(tier_1_id, segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts)
      data
    end

    # Create or replace segment security profile binding map
    # API will create or replace segment security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param segment_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentSecurityProfileBindingMap, Fixnum, Hash)>] SegmentSecurityProfileBindingMap data, response status code and response headers
    def create_or_update_segment_security_profile_binding_with_http_info(tier_1_id, segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_or_update_segment_security_profile_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.create_or_update_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.create_or_update_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map_id' when calling SegmentsApi.create_or_update_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map' when calling SegmentsApi.create_or_update_segment_security_profile_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-security-profile-binding-maps/{segment-security-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-security-profile-binding-map-id' + '}', segment_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_security_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_or_update_segment_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or replace SpoofGuard profile
    # API will create or replace SpoofGuard profile. 
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param spoof_guard_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [SpoofGuardProfile]
    def create_or_update_spoof_guard_profile(spoofguard_profile_id, spoof_guard_profile, opts = {})
      data, _status_code, _headers = create_or_update_spoof_guard_profile_with_http_info(spoofguard_profile_id, spoof_guard_profile, opts)
      data
    end

    # Create or replace SpoofGuard profile
    # API will create or replace SpoofGuard profile. 
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param spoof_guard_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(SpoofGuardProfile, Fixnum, Hash)>] SpoofGuardProfile data, response status code and response headers
    def create_or_update_spoof_guard_profile_with_http_info(spoofguard_profile_id, spoof_guard_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_or_update_spoof_guard_profile ...'
      end
      # verify the required parameter 'spoofguard_profile_id' is set
      if @api_client.config.client_side_validation && spoofguard_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'spoofguard_profile_id' when calling SegmentsApi.create_or_update_spoof_guard_profile"
      end
      # verify the required parameter 'spoof_guard_profile' is set
      if @api_client.config.client_side_validation && spoof_guard_profile.nil?
        fail ArgumentError, "Missing the required parameter 'spoof_guard_profile' when calling SegmentsApi.create_or_update_spoof_guard_profile"
      end
      # resource path
      local_var_path = '/infra/spoofguard-profiles/{spoofguard-profile-id}'.sub('{' + 'spoofguard-profile-id' + '}', spoofguard_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(spoof_guard_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SpoofGuardProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_or_update_spoof_guard_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch a tier1 segment connection binding map
    # Patch the infra segment connection binding map. If binding map corresponding to the the given values is not present, the object will get created and if it is present it will be updated. This is a full replace. 
    # @param tier_1_id 
    # @param segment_id 
    # @param map_id 
    # @param segment_connection_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [SegmentConnectionBindingMap]
    def create_or_update_tier1_segment_connection_binding_map(tier_1_id, segment_id, map_id, segment_connection_binding_map, opts = {})
      data, _status_code, _headers = create_or_update_tier1_segment_connection_binding_map_with_http_info(tier_1_id, segment_id, map_id, segment_connection_binding_map, opts)
      data
    end

    # Patch a tier1 segment connection binding map
    # Patch the infra segment connection binding map. If binding map corresponding to the the given values is not present, the object will get created and if it is present it will be updated. This is a full replace. 
    # @param tier_1_id 
    # @param segment_id 
    # @param map_id 
    # @param segment_connection_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentConnectionBindingMap, Fixnum, Hash)>] SegmentConnectionBindingMap data, response status code and response headers
    def create_or_update_tier1_segment_connection_binding_map_with_http_info(tier_1_id, segment_id, map_id, segment_connection_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_or_update_tier1_segment_connection_binding_map ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.create_or_update_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.create_or_update_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'map_id' is set
      if @api_client.config.client_side_validation && map_id.nil?
        fail ArgumentError, "Missing the required parameter 'map_id' when calling SegmentsApi.create_or_update_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_connection_binding_map' is set
      if @api_client.config.client_side_validation && segment_connection_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_connection_binding_map' when calling SegmentsApi.create_or_update_tier1_segment_connection_binding_map"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-connection-binding-maps/{map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'map-id' + '}', map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_connection_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConnectionBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_or_update_tier1_segment_connection_binding_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create service segment
    # A service segment with the service-segment-id is created. Modification of service segment is not supported. 
    # @param service_segment_id Service Segment ID
    # @param service_segment 
    # @param [Hash] opts the optional parameters
    # @return [ServiceSegment]
    def create_service_segment(service_segment_id, service_segment, opts = {})
      data, _status_code, _headers = create_service_segment_with_http_info(service_segment_id, service_segment, opts)
      data
    end

    # Create service segment
    # A service segment with the service-segment-id is created. Modification of service segment is not supported. 
    # @param service_segment_id Service Segment ID
    # @param service_segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ServiceSegment, Fixnum, Hash)>] ServiceSegment data, response status code and response headers
    def create_service_segment_with_http_info(service_segment_id, service_segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_service_segment ...'
      end
      # verify the required parameter 'service_segment_id' is set
      if @api_client.config.client_side_validation && service_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_segment_id' when calling SegmentsApi.create_service_segment"
      end
      # verify the required parameter 'service_segment' is set
      if @api_client.config.client_side_validation && service_segment.nil?
        fail ArgumentError, "Missing the required parameter 'service_segment' when calling SegmentsApi.create_service_segment"
      end
      # resource path
      local_var_path = '/infra/segments/service-segments/{service-segment-id}'.sub('{' + 'service-segment-id' + '}', service_segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(service_segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceSegment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_service_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Group discovery profile binding map
    # API will delete Group discovery profile binding map
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param discovery_profile_binding_map_id Group discovery profile binding map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_group_discovery_profile_binding(domain_id, group_id, discovery_profile_binding_map_id, opts = {})
      delete_group_discovery_profile_binding_with_http_info(domain_id, group_id, discovery_profile_binding_map_id, opts)
      nil
    end

    # Delete Group discovery profile binding map
    # API will delete Group discovery profile binding map
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param discovery_profile_binding_map_id Group discovery profile binding map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_group_discovery_profile_binding_with_http_info(domain_id, group_id, discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_group_discovery_profile_binding ...'
      end
      # verify the required parameter 'domain_id' is set
      if @api_client.config.client_side_validation && domain_id.nil?
        fail ArgumentError, "Missing the required parameter 'domain_id' when calling SegmentsApi.delete_group_discovery_profile_binding"
      end
      # verify the required parameter 'group_id' is set
      if @api_client.config.client_side_validation && group_id.nil?
        fail ArgumentError, "Missing the required parameter 'group_id' when calling SegmentsApi.delete_group_discovery_profile_binding"
      end
      # verify the required parameter 'discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'discovery_profile_binding_map_id' when calling SegmentsApi.delete_group_discovery_profile_binding"
      end
      # resource path
      local_var_path = '/infra/domains/{domain-id}/groups/{group-id}/discovery-profile-binding-maps/{discovery-profile-binding-map-id}'.sub('{' + 'domain-id' + '}', domain_id.to_s).sub('{' + 'group-id' + '}', group_id.to_s).sub('{' + 'discovery-profile-binding-map-id' + '}', discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_group_discovery_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Infra Port Discovery Profile Binding Profile
    # API will delete Infra Port Discovery Profile Binding Profile
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_infra_port_discovery_binding(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, opts = {})
      delete_infra_port_discovery_binding_with_http_info(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, opts)
      nil
    end

    # Delete Infra Port Discovery Profile Binding Profile
    # API will delete Infra Port Discovery Profile Binding Profile
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_infra_port_discovery_binding_with_http_info(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_infra_port_discovery_binding ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.delete_infra_port_discovery_binding"
      end
      # verify the required parameter 'infra_port_id' is set
      if @api_client.config.client_side_validation && infra_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_port_id' when calling SegmentsApi.delete_infra_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.delete_infra_port_discovery_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/ports/{infra-port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'infra-port-id' + '}', infra_port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_infra_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Infra Port Monitoring Profile Binding Profile
    # API will delete Infra Port Monitoring Profile Binding Profile.
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_monitoring_profile_binding_map_id Port Monitoring Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_infra_port_monitoring_binding(infra_segment_id, infra_port_id, port_monitoring_profile_binding_map_id, opts = {})
      delete_infra_port_monitoring_binding_with_http_info(infra_segment_id, infra_port_id, port_monitoring_profile_binding_map_id, opts)
      nil
    end

    # Delete Infra Port Monitoring Profile Binding Profile
    # API will delete Infra Port Monitoring Profile Binding Profile.
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_monitoring_profile_binding_map_id Port Monitoring Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_infra_port_monitoring_binding_with_http_info(infra_segment_id, infra_port_id, port_monitoring_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_infra_port_monitoring_binding ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.delete_infra_port_monitoring_binding"
      end
      # verify the required parameter 'infra_port_id' is set
      if @api_client.config.client_side_validation && infra_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_port_id' when calling SegmentsApi.delete_infra_port_monitoring_binding"
      end
      # verify the required parameter 'port_monitoring_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_monitoring_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_monitoring_profile_binding_map_id' when calling SegmentsApi.delete_infra_port_monitoring_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/ports/{infra-port-id}/port-monitoring-profile-binding-maps/{port-monitoring-profile-binding-map-id}'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'infra-port-id' + '}', infra_port_id.to_s).sub('{' + 'port-monitoring-profile-binding-map-id' + '}', port_monitoring_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_infra_port_monitoring_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Port QoS Profile Binding Profile
    # API will delete Port QoS Profile Binding Profile.
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_infra_port_qo_s_binding(segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      delete_infra_port_qo_s_binding_with_http_info(segment_id, port_id, port_qos_profile_binding_map_id, opts)
      nil
    end

    # Delete Port QoS Profile Binding Profile
    # API will delete Port QoS Profile Binding Profile.
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_infra_port_qo_s_binding_with_http_info(segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_infra_port_qo_s_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.delete_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.delete_infra_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_infra_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Port Real Time Eth Profile Binding Profile
    # API will delete Port Real Time Eth Profile Binding Profile.
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_real_time_eth_profile_binding_map_id Port Real Time Eth Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_infra_port_real_time_eth_binding(segment_id, port_id, port_real_time_eth_profile_binding_map_id, opts = {})
      delete_infra_port_real_time_eth_binding_with_http_info(segment_id, port_id, port_real_time_eth_profile_binding_map_id, opts)
      nil
    end

    # Delete Port Real Time Eth Profile Binding Profile
    # API will delete Port Real Time Eth Profile Binding Profile.
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_real_time_eth_profile_binding_map_id Port Real Time Eth Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_infra_port_real_time_eth_binding_with_http_info(segment_id, port_id, port_real_time_eth_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_infra_port_real_time_eth_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.delete_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'port_real_time_eth_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_real_time_eth_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_real_time_eth_profile_binding_map_id' when calling SegmentsApi.delete_infra_port_real_time_eth_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}/port-real-time-eth-profile-binding-maps/{port-real-time-eth-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-real-time-eth-profile-binding-map-id' + '}', port_real_time_eth_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_infra_port_real_time_eth_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete infra segment
    # Delete infra segment
    # @param segment_id Segment ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_infra_segment(segment_id, opts = {})
      delete_infra_segment_with_http_info(segment_id, opts)
      nil
    end

    # Delete infra segment
    # Delete infra segment
    # @param segment_id Segment ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_infra_segment_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_infra_segment ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_infra_segment"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_infra_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete infra segment
    # Delete infra segment
    # @param segment_id Segment ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_infra_segment_0(segment_id, opts = {})
      delete_infra_segment_0_with_http_info(segment_id, opts)
      nil
    end

    # Delete infra segment
    # Delete infra segment
    # @param segment_id Segment ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_infra_segment_0_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_infra_segment_0 ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_infra_segment_0"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_infra_segment_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Deletes infra SegmentConnectionBindingMap.
    # Deletes infra SegmentConnectionBindingMap. 
    # @param segment_id 
    # @param map_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_infra_segment_connection_binding_map(segment_id, map_id, opts = {})
      delete_infra_segment_connection_binding_map_with_http_info(segment_id, map_id, opts)
      nil
    end

    # Deletes infra SegmentConnectionBindingMap.
    # Deletes infra SegmentConnectionBindingMap. 
    # @param segment_id 
    # @param map_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_infra_segment_connection_binding_map_with_http_info(segment_id, map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_infra_segment_connection_binding_map ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'map_id' is set
      if @api_client.config.client_side_validation && map_id.nil?
        fail ArgumentError, "Missing the required parameter 'map_id' when calling SegmentsApi.delete_infra_segment_connection_binding_map"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/segment-connection-binding-maps/{map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'map-id' + '}', map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_infra_segment_connection_binding_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Segment Discovery Profile Binding Profile
    # API will delete Segment Discovery Profile Binding Profile
    # @param infra_segment_id Infra Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_infra_segment_discovery_binding(infra_segment_id, segment_discovery_profile_binding_map_id, opts = {})
      delete_infra_segment_discovery_binding_with_http_info(infra_segment_id, segment_discovery_profile_binding_map_id, opts)
      nil
    end

    # Delete Segment Discovery Profile Binding Profile
    # API will delete Segment Discovery Profile Binding Profile
    # @param infra_segment_id Infra Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_infra_segment_discovery_binding_with_http_info(infra_segment_id, segment_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_infra_segment_discovery_binding ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.delete_infra_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map_id' when calling SegmentsApi.delete_infra_segment_discovery_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/segment-discovery-profile-binding-maps/{segment-discovery-profile-binding-map-id}'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'segment-discovery-profile-binding-map-id' + '}', segment_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_infra_segment_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Infra Segment Monitoring Profile Binding Profile
    # API will delete Infra Segment Monitoring Profile Binding Profile.
    # @param infra_segment_id Infra Segment ID
    # @param segment_monitoring_profile_binding_map_id Segment Monitoring Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_infra_segment_monitoring_binding(infra_segment_id, segment_monitoring_profile_binding_map_id, opts = {})
      delete_infra_segment_monitoring_binding_with_http_info(infra_segment_id, segment_monitoring_profile_binding_map_id, opts)
      nil
    end

    # Delete Infra Segment Monitoring Profile Binding Profile
    # API will delete Infra Segment Monitoring Profile Binding Profile.
    # @param infra_segment_id Infra Segment ID
    # @param segment_monitoring_profile_binding_map_id Segment Monitoring Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_infra_segment_monitoring_binding_with_http_info(infra_segment_id, segment_monitoring_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_infra_segment_monitoring_binding ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.delete_infra_segment_monitoring_binding"
      end
      # verify the required parameter 'segment_monitoring_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_monitoring_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_monitoring_profile_binding_map_id' when calling SegmentsApi.delete_infra_segment_monitoring_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/segment-monitoring-profile-binding-maps/{segment-monitoring-profile-binding-map-id}'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'segment-monitoring-profile-binding-map-id' + '}', segment_monitoring_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_infra_segment_monitoring_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete an infra segment port
    # Delete an infra segment port by giving ID. Please note that this operation will not delete the segment port from vCenter Server if the port was connected to a Virtual Machine. Please connect Virtual Machine to another network for the segment port to be deleted from vCenter Server. Do not provide any parameters to this call unless it is during VIF restore workflow by NSX container plugin(NCP). 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_infra_segment_port(segment_id, port_id, opts = {})
      delete_infra_segment_port_with_http_info(segment_id, port_id, opts)
      nil
    end

    # Delete an infra segment port
    # Delete an infra segment port by giving ID. Please note that this operation will not delete the segment port from vCenter Server if the port was connected to a Virtual Machine. Please connect Virtual Machine to another network for the segment port to be deleted from vCenter Server. Do not provide any parameters to this call unless it is during VIF restore workflow by NSX container plugin(NCP). 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_infra_segment_port_with_http_info(segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_infra_segment_port ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_infra_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.delete_infra_segment_port"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_infra_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete the infra segment port security profile binding map
    # API will delete the port security profile binding map. 
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_infra_segment_port_security_profile_binding(segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      delete_infra_segment_port_security_profile_binding_with_http_info(segment_id, port_id, port_security_profile_binding_map_id, opts)
      nil
    end

    # Delete the infra segment port security profile binding map
    # API will delete the port security profile binding map. 
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_infra_segment_port_security_profile_binding_with_http_info(segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_infra_segment_port_security_profile_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.delete_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.delete_infra_segment_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_infra_segment_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Segment QoS Profile Binding Profile
    # API will delete Segment QoS Profile Binding Profile.
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_infra_segment_qo_s_binding(segment_id, segment_qos_profile_binding_map_id, opts = {})
      delete_infra_segment_qo_s_binding_with_http_info(segment_id, segment_qos_profile_binding_map_id, opts)
      nil
    end

    # Delete Segment QoS Profile Binding Profile
    # API will delete Segment QoS Profile Binding Profile.
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_infra_segment_qo_s_binding_with_http_info(segment_id, segment_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_infra_segment_qo_s_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_infra_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qos_profile_binding_map_id' when calling SegmentsApi.delete_infra_segment_qo_s_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/segment-qos-profile-binding-maps/{segment-qos-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-qos-profile-binding-map-id' + '}', segment_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_infra_segment_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Segment Real Time Eth Profile Binding Profile
    # API will delete Segment Real Time Eth Profile Binding Profile.
    # @param segment_id Segment ID
    # @param segment_real_time_eth_profile_binding_map_id Segment Real Time Eth Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_infra_segment_real_time_eth_binding(segment_id, segment_real_time_eth_profile_binding_map_id, opts = {})
      delete_infra_segment_real_time_eth_binding_with_http_info(segment_id, segment_real_time_eth_profile_binding_map_id, opts)
      nil
    end

    # Delete Segment Real Time Eth Profile Binding Profile
    # API will delete Segment Real Time Eth Profile Binding Profile.
    # @param segment_id Segment ID
    # @param segment_real_time_eth_profile_binding_map_id Segment Real Time Eth Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_infra_segment_real_time_eth_binding_with_http_info(segment_id, segment_real_time_eth_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_infra_segment_real_time_eth_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_infra_segment_real_time_eth_binding"
      end
      # verify the required parameter 'segment_real_time_eth_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_real_time_eth_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_real_time_eth_profile_binding_map_id' when calling SegmentsApi.delete_infra_segment_real_time_eth_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/segment-real-time-eth-profile-binding-maps/{segment-real-time-eth-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-real-time-eth-profile-binding-map-id' + '}', segment_real_time_eth_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_infra_segment_real_time_eth_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete infra segment security profile binding map
    # API will delete segment security profile binding map. 
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_infra_segment_security_profile_binding(segment_id, segment_security_profile_binding_map_id, opts = {})
      delete_infra_segment_security_profile_binding_with_http_info(segment_id, segment_security_profile_binding_map_id, opts)
      nil
    end

    # Delete infra segment security profile binding map
    # API will delete segment security profile binding map. 
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_infra_segment_security_profile_binding_with_http_info(segment_id, segment_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_infra_segment_security_profile_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_infra_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map_id' when calling SegmentsApi.delete_infra_segment_security_profile_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/segment-security-profile-binding-maps/{segment-security-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-security-profile-binding-map-id' + '}', segment_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_infra_segment_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete IP Discovery Profile
    # API will delete IP Discovery profile. 
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def delete_ip_discovery_profile(ip_discovery_profile_id, opts = {})
      delete_ip_discovery_profile_with_http_info(ip_discovery_profile_id, opts)
      nil
    end

    # Delete IP Discovery Profile
    # API will delete IP Discovery profile. 
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_ip_discovery_profile_with_http_info(ip_discovery_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_ip_discovery_profile ...'
      end
      # verify the required parameter 'ip_discovery_profile_id' is set
      if @api_client.config.client_side_validation && ip_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'ip_discovery_profile_id' when calling SegmentsApi.delete_ip_discovery_profile"
      end
      # resource path
      local_var_path = '/infra/ip-discovery-profiles/{ip-discovery-profile-id}'.sub('{' + 'ip-discovery-profile-id' + '}', ip_discovery_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_ip_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete L2 Bridge Endpoint Profile
    # API will delete L2 bridge profile with ID profile-id
    # @param site_id site ID
    # @param enforcement_point_id enforcement point ID
    # @param profile_id profile ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_l2_bridge_profile(site_id, enforcement_point_id, profile_id, opts = {})
      delete_l2_bridge_profile_with_http_info(site_id, enforcement_point_id, profile_id, opts)
      nil
    end

    # Delete L2 Bridge Endpoint Profile
    # API will delete L2 bridge profile with ID profile-id
    # @param site_id site ID
    # @param enforcement_point_id enforcement point ID
    # @param profile_id profile ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_l2_bridge_profile_with_http_info(site_id, enforcement_point_id, profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_l2_bridge_profile ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SegmentsApi.delete_l2_bridge_profile"
      end
      # verify the required parameter 'enforcement_point_id' is set
      if @api_client.config.client_side_validation && enforcement_point_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcement_point_id' when calling SegmentsApi.delete_l2_bridge_profile"
      end
      # verify the required parameter 'profile_id' is set
      if @api_client.config.client_side_validation && profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'profile_id' when calling SegmentsApi.delete_l2_bridge_profile"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcement-point-id}/edge-bridge-profiles/{profile-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcement-point-id' + '}', enforcement_point_id.to_s).sub('{' + 'profile-id' + '}', profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_l2_bridge_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Mac Discovery Profile
    # API will delete Mac Discovery profile. 
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def delete_mac_discovery_profile(mac_discovery_profile_id, opts = {})
      delete_mac_discovery_profile_with_http_info(mac_discovery_profile_id, opts)
      nil
    end

    # Delete Mac Discovery Profile
    # API will delete Mac Discovery profile. 
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_mac_discovery_profile_with_http_info(mac_discovery_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_mac_discovery_profile ...'
      end
      # verify the required parameter 'mac_discovery_profile_id' is set
      if @api_client.config.client_side_validation && mac_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'mac_discovery_profile_id' when calling SegmentsApi.delete_mac_discovery_profile"
      end
      # resource path
      local_var_path = '/infra/mac-discovery-profiles/{mac-discovery-profile-id}'.sub('{' + 'mac-discovery-profile-id' + '}', mac_discovery_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_mac_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Port Discovery Profile Binding Profile
    # API will delete Port Discovery Profile Binding Profile
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_port_discovery_binding(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, opts = {})
      delete_port_discovery_binding_with_http_info(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, opts)
      nil
    end

    # Delete Port Discovery Profile Binding Profile
    # API will delete Port Discovery Profile Binding Profile
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_port_discovery_binding_with_http_info(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_port_discovery_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.delete_port_discovery_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_port_discovery_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.delete_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.delete_port_discovery_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Port Monitoring Profile Binding Profile
    # API will delete Port Monitoring Profile Binding Profile.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_monitoring_profile_binding_map_id Port Monitoring Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_port_monitoring_binding(tier_1_id, segment_id, port_id, port_monitoring_profile_binding_map_id, opts = {})
      delete_port_monitoring_binding_with_http_info(tier_1_id, segment_id, port_id, port_monitoring_profile_binding_map_id, opts)
      nil
    end

    # Delete Port Monitoring Profile Binding Profile
    # API will delete Port Monitoring Profile Binding Profile.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_monitoring_profile_binding_map_id Port Monitoring Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_port_monitoring_binding_with_http_info(tier_1_id, segment_id, port_id, port_monitoring_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_port_monitoring_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.delete_port_monitoring_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_port_monitoring_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.delete_port_monitoring_binding"
      end
      # verify the required parameter 'port_monitoring_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_monitoring_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_monitoring_profile_binding_map_id' when calling SegmentsApi.delete_port_monitoring_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-monitoring-profile-binding-maps/{port-monitoring-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-monitoring-profile-binding-map-id' + '}', port_monitoring_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_port_monitoring_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Port QoS Profile Binding Profile
    # API will delete Port QoS Profile Binding Profile.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_port_qo_s_binding(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      delete_port_qo_s_binding_with_http_info(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, opts)
      nil
    end

    # Delete Port QoS Profile Binding Profile
    # API will delete Port QoS Profile Binding Profile.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_port_qo_s_binding_with_http_info(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_port_qo_s_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.delete_port_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.delete_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.delete_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete the port security profile binding map
    # API will delete the port security profile binding map. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_port_security_profile_binding(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      delete_port_security_profile_binding_with_http_info(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, opts)
      nil
    end

    # Delete the port security profile binding map
    # API will delete the port security profile binding map. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_port_security_profile_binding_with_http_info(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_port_security_profile_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.delete_port_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.delete_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.delete_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete QoS profile
    # API will delete QoS profile. 
    # @param qos_profile_id QoS profile Id
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def delete_qo_s_profile(qos_profile_id, opts = {})
      delete_qo_s_profile_with_http_info(qos_profile_id, opts)
      nil
    end

    # Delete QoS profile
    # API will delete QoS profile. 
    # @param qos_profile_id QoS profile Id
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_qo_s_profile_with_http_info(qos_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_qo_s_profile ...'
      end
      # verify the required parameter 'qos_profile_id' is set
      if @api_client.config.client_side_validation && qos_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'qos_profile_id' when calling SegmentsApi.delete_qo_s_profile"
      end
      # resource path
      local_var_path = '/infra/qos-profiles/{qos-profile-id}'.sub('{' + 'qos-profile-id' + '}', qos_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_qo_s_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Real Time Eth profile
    # API will delete Real Time Eth profile. 
    # @param real_time_eth_profile_id Real Time Eth profile Id
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_real_time_eth_profile(real_time_eth_profile_id, opts = {})
      delete_real_time_eth_profile_with_http_info(real_time_eth_profile_id, opts)
      nil
    end

    # Delete Real Time Eth profile
    # API will delete Real Time Eth profile. 
    # @param real_time_eth_profile_id Real Time Eth profile Id
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_real_time_eth_profile_with_http_info(real_time_eth_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_real_time_eth_profile ...'
      end
      # verify the required parameter 'real_time_eth_profile_id' is set
      if @api_client.config.client_side_validation && real_time_eth_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'real_time_eth_profile_id' when calling SegmentsApi.delete_real_time_eth_profile"
      end
      # resource path
      local_var_path = '/infra/real-time-eth-profiles/{real-time-eth-profile-id}'.sub('{' + 'real-time-eth-profile-id' + '}', real_time_eth_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_real_time_eth_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete segment
    # Delete segment
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_segment(tier_1_id, segment_id, opts = {})
      delete_segment_with_http_info(tier_1_id, segment_id, opts)
      nil
    end

    # Delete segment
    # Delete segment
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_segment_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_segment ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.delete_segment"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_segment"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Segment Discovery Profile Binding Profile
    # API will delete Segment Discovery Profile Binding Profile
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_segment_discovery_binding(tier_1_id, segment_id, segment_discovery_profile_binding_map_id, opts = {})
      delete_segment_discovery_binding_with_http_info(tier_1_id, segment_id, segment_discovery_profile_binding_map_id, opts)
      nil
    end

    # Delete Segment Discovery Profile Binding Profile
    # API will delete Segment Discovery Profile Binding Profile
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_segment_discovery_binding_with_http_info(tier_1_id, segment_id, segment_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_segment_discovery_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.delete_segment_discovery_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map_id' when calling SegmentsApi.delete_segment_discovery_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-discovery-profile-binding-maps/{segment-discovery-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-discovery-profile-binding-map-id' + '}', segment_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_segment_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Segment Monitoring Profile Binding Profile
    # API will delete Segment Monitoring Profile Binding Profile.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_monitoring_profile_binding_map_id Segment Monitoring Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_segment_monitoring_binding(tier_1_id, segment_id, segment_monitoring_profile_binding_map_id, opts = {})
      delete_segment_monitoring_binding_with_http_info(tier_1_id, segment_id, segment_monitoring_profile_binding_map_id, opts)
      nil
    end

    # Delete Segment Monitoring Profile Binding Profile
    # API will delete Segment Monitoring Profile Binding Profile.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_monitoring_profile_binding_map_id Segment Monitoring Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_segment_monitoring_binding_with_http_info(tier_1_id, segment_id, segment_monitoring_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_segment_monitoring_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.delete_segment_monitoring_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_segment_monitoring_binding"
      end
      # verify the required parameter 'segment_monitoring_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_monitoring_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_monitoring_profile_binding_map_id' when calling SegmentsApi.delete_segment_monitoring_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-monitoring-profile-binding-maps/{segment-monitoring-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-monitoring-profile-binding-map-id' + '}', segment_monitoring_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_segment_monitoring_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Segment QoS Profile Binding Profile
    # API will delete Segment QoS Profile Binding Profile.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_segment_qo_s_binding(tier_1_id, segment_id, segment_qos_profile_binding_map_id, opts = {})
      delete_segment_qo_s_binding_with_http_info(tier_1_id, segment_id, segment_qos_profile_binding_map_id, opts)
      nil
    end

    # Delete Segment QoS Profile Binding Profile
    # API will delete Segment QoS Profile Binding Profile.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_segment_qo_s_binding_with_http_info(tier_1_id, segment_id, segment_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_segment_qo_s_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.delete_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qos_profile_binding_map_id' when calling SegmentsApi.delete_segment_qo_s_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-qos-profile-binding-maps/{segment-qos-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-qos-profile-binding-map-id' + '}', segment_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_segment_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # DELETE segment security profile
    # API will delete segment security profile with the given id. 
    # @param segment_security_profile_id Segment security profile id
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def delete_segment_security_profile(segment_security_profile_id, opts = {})
      delete_segment_security_profile_with_http_info(segment_security_profile_id, opts)
      nil
    end

    # DELETE segment security profile
    # API will delete segment security profile with the given id. 
    # @param segment_security_profile_id Segment security profile id
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_segment_security_profile_with_http_info(segment_security_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_segment_security_profile ...'
      end
      # verify the required parameter 'segment_security_profile_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_id' when calling SegmentsApi.delete_segment_security_profile"
      end
      # resource path
      local_var_path = '/infra/segment-security-profiles/{segment-security-profile-id}'.sub('{' + 'segment-security-profile-id' + '}', segment_security_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_segment_security_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete segment security profile binding map
    # API will delete segment security profile binding map. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_segment_security_profile_binding(tier_1_id, segment_id, segment_security_profile_binding_map_id, opts = {})
      delete_segment_security_profile_binding_with_http_info(tier_1_id, segment_id, segment_security_profile_binding_map_id, opts)
      nil
    end

    # Delete segment security profile binding map
    # API will delete segment security profile binding map. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_segment_security_profile_binding_with_http_info(tier_1_id, segment_id, segment_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_segment_security_profile_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.delete_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map_id' when calling SegmentsApi.delete_segment_security_profile_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-security-profile-binding-maps/{segment-security-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-security-profile-binding-map-id' + '}', segment_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_segment_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Service Segment
    # Delete Service Segment with given ID
    # @param service_segment_id Service Segment ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_service_segment(service_segment_id, opts = {})
      delete_service_segment_with_http_info(service_segment_id, opts)
      nil
    end

    # Delete Service Segment
    # Delete Service Segment with given ID
    # @param service_segment_id Service Segment ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_service_segment_with_http_info(service_segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_service_segment ...'
      end
      # verify the required parameter 'service_segment_id' is set
      if @api_client.config.client_side_validation && service_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_segment_id' when calling SegmentsApi.delete_service_segment"
      end
      # resource path
      local_var_path = '/infra/segments/service-segments/{service-segment-id}'.sub('{' + 'service-segment-id' + '}', service_segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_service_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete SpoofGuard profile
    # API will delete SpoofGuard profile with the given id. 
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def delete_spoof_guard_profile(spoofguard_profile_id, opts = {})
      delete_spoof_guard_profile_with_http_info(spoofguard_profile_id, opts)
      nil
    end

    # Delete SpoofGuard profile
    # API will delete SpoofGuard profile with the given id. 
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_spoof_guard_profile_with_http_info(spoofguard_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_spoof_guard_profile ...'
      end
      # verify the required parameter 'spoofguard_profile_id' is set
      if @api_client.config.client_side_validation && spoofguard_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'spoofguard_profile_id' when calling SegmentsApi.delete_spoof_guard_profile"
      end
      # resource path
      local_var_path = '/infra/spoofguard-profiles/{spoofguard-profile-id}'.sub('{' + 'spoofguard-profile-id' + '}', spoofguard_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_spoof_guard_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete static ARP config
    # Delete static ARP config
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_static_arp_config(tier_1_id, segment_id, opts = {})
      delete_static_arp_config_with_http_info(tier_1_id, segment_id, opts)
      nil
    end

    # Delete static ARP config
    # Delete static ARP config
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_static_arp_config_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_static_arp_config ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.delete_static_arp_config"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_static_arp_config"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/static-arp'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_static_arp_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Deletes infra SegmentConnectionBindingMap.
    # Deletes infra SegmentConnectionBindingMap. 
    # @param tier_1_id 
    # @param segment_id 
    # @param map_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_tier1_segment_connection_binding_map(tier_1_id, segment_id, map_id, opts = {})
      delete_tier1_segment_connection_binding_map_with_http_info(tier_1_id, segment_id, map_id, opts)
      nil
    end

    # Deletes infra SegmentConnectionBindingMap.
    # Deletes infra SegmentConnectionBindingMap. 
    # @param tier_1_id 
    # @param segment_id 
    # @param map_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_tier1_segment_connection_binding_map_with_http_info(tier_1_id, segment_id, map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_tier1_segment_connection_binding_map ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.delete_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'map_id' is set
      if @api_client.config.client_side_validation && map_id.nil?
        fail ArgumentError, "Missing the required parameter 'map_id' when calling SegmentsApi.delete_tier1_segment_connection_binding_map"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-connection-binding-maps/{map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'map-id' + '}', map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_tier1_segment_connection_binding_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a Tier-1 segment port. Please note that this operation will not delete the segment port from vCenter Server if the port was connected to a Virtual Machine. Please connect Virtual Machine to another network for the segment port to be deleted from vCenter Server. 
    # Delete a Tier-1 segment port by giving ID. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_tier1_segment_port(tier_1_id, segment_id, port_id, opts = {})
      delete_tier1_segment_port_with_http_info(tier_1_id, segment_id, port_id, opts)
      nil
    end

    # Delete a Tier-1 segment port. Please note that this operation will not delete the segment port from vCenter Server if the port was connected to a Virtual Machine. Please connect Virtual Machine to another network for the segment port to be deleted from vCenter Server. 
    # Delete a Tier-1 segment port by giving ID. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def delete_tier1_segment_port_with_http_info(tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_tier1_segment_port ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.delete_tier1_segment_port"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_tier1_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.delete_tier1_segment_port"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_tier1_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Force delete infra segment
    # Force delete bypasses validations during segment deletion. This may result in an inconsistent connectivity.
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :cascade Flag to specify whether to delete related segment ports (default to false)
    # @return [nil]
    def force_delete_infra_segment(segment_id, opts = {})
      force_delete_infra_segment_with_http_info(segment_id, opts)
      nil
    end

    # Force delete infra segment
    # Force delete bypasses validations during segment deletion. This may result in an inconsistent connectivity.
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :cascade Flag to specify whether to delete related segment ports
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def force_delete_infra_segment_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.force_delete_infra_segment ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.force_delete_infra_segment"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}?force=true'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cascade'] = opts[:'cascade'] if !opts[:'cascade'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#force_delete_infra_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Force delete infra segment
    # Force delete bypasses validations during segment deletion. This may result in an inconsistent connectivity.
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :cascade Flag to specify whether to delete related segment ports (default to false)
    # @return [nil]
    def force_delete_infra_segment_0(segment_id, opts = {})
      force_delete_infra_segment_0_with_http_info(segment_id, opts)
      nil
    end

    # Force delete infra segment
    # Force delete bypasses validations during segment deletion. This may result in an inconsistent connectivity.
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :cascade Flag to specify whether to delete related segment ports
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def force_delete_infra_segment_0_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.force_delete_infra_segment_0 ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.force_delete_infra_segment_0"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}?force=true'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cascade'] = opts[:'cascade'] if !opts[:'cascade'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#force_delete_infra_segment_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Force delete segment
    # Force delete bypasses validations during segment deletion. This may result in an inconsistent connectivity. 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def force_delete_segment(tier_1_id, segment_id, opts = {})
      force_delete_segment_with_http_info(tier_1_id, segment_id, opts)
      nil
    end

    # Force delete segment
    # Force delete bypasses validations during segment deletion. This may result in an inconsistent connectivity. 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def force_delete_segment_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.force_delete_segment ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.force_delete_segment"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.force_delete_segment"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}?force=true'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#force_delete_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get downlink port Address Resolution Protocol Proxies for infra segment
    # Returns ARP proxy table for downlink port on connected to the segment 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyArpProxyTableListResult]
    def get_downlink_port_arp_proxies_for_infra_segment(segment_id, opts = {})
      data, _status_code, _headers = get_downlink_port_arp_proxies_for_infra_segment_with_http_info(segment_id, opts)
      data
    end

    # Get downlink port Address Resolution Protocol Proxies for infra segment
    # Returns ARP proxy table for downlink port on connected to the segment 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyArpProxyTableListResult, Fixnum, Hash)>] PolicyArpProxyTableListResult data, response status code and response headers
    def get_downlink_port_arp_proxies_for_infra_segment_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_downlink_port_arp_proxies_for_infra_segment ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_downlink_port_arp_proxies_for_infra_segment"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_downlink_port_arp_proxies_for_infra_segment, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_downlink_port_arp_proxies_for_infra_segment, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/arp-proxy'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyArpProxyTableListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_downlink_port_arp_proxies_for_infra_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get downlink port Address Resolution Protocol Proxies for infra segment in CSV format
    # Returns ARP proxy table for downlink port on connected to the segment in CSV format 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyArpProxyTableCsvListResult]
    def get_downlink_port_arp_proxies_for_infra_segment_in_csv(segment_id, opts = {})
      data, _status_code, _headers = get_downlink_port_arp_proxies_for_infra_segment_in_csv_with_http_info(segment_id, opts)
      data
    end

    # Get downlink port Address Resolution Protocol Proxies for infra segment in CSV format
    # Returns ARP proxy table for downlink port on connected to the segment in CSV format 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyArpProxyTableCsvListResult, Fixnum, Hash)>] PolicyArpProxyTableCsvListResult data, response status code and response headers
    def get_downlink_port_arp_proxies_for_infra_segment_in_csv_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_downlink_port_arp_proxies_for_infra_segment_in_csv ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_downlink_port_arp_proxies_for_infra_segment_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/arp-proxy?format=csv'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyArpProxyTableCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_downlink_port_arp_proxies_for_infra_segment_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get downlink port Address Resolution Protocol Proxies for tier-1 segment
    # Returns ARP proxy table for downlink port on connected to the segment 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyArpProxyTableListResult]
    def get_downlink_port_arp_proxies_for_tier1_segment(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = get_downlink_port_arp_proxies_for_tier1_segment_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # Get downlink port Address Resolution Protocol Proxies for tier-1 segment
    # Returns ARP proxy table for downlink port on connected to the segment 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyArpProxyTableListResult, Fixnum, Hash)>] PolicyArpProxyTableListResult data, response status code and response headers
    def get_downlink_port_arp_proxies_for_tier1_segment_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_downlink_port_arp_proxies_for_tier1_segment ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_downlink_port_arp_proxies_for_tier1_segment"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_downlink_port_arp_proxies_for_tier1_segment"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_downlink_port_arp_proxies_for_tier1_segment, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_downlink_port_arp_proxies_for_tier1_segment, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/arp-proxy'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyArpProxyTableListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_downlink_port_arp_proxies_for_tier1_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get downlink port Address Resolution Protocol Proxies for tier-1 segment in CSV
    # Returns ARP proxy table for downlink port on connected to the segment in CSV 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyArpProxyTableCsvListResult]
    def get_downlink_port_arp_proxies_for_tier1_segment_in_csv(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = get_downlink_port_arp_proxies_for_tier1_segment_in_csv_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # Get downlink port Address Resolution Protocol Proxies for tier-1 segment in CSV
    # Returns ARP proxy table for downlink port on connected to the segment in CSV 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyArpProxyTableCsvListResult, Fixnum, Hash)>] PolicyArpProxyTableCsvListResult data, response status code and response headers
    def get_downlink_port_arp_proxies_for_tier1_segment_in_csv_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_downlink_port_arp_proxies_for_tier1_segment_in_csv ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_downlink_port_arp_proxies_for_tier1_segment_in_csv"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_downlink_port_arp_proxies_for_tier1_segment_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/arp-proxy?format=csv'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyArpProxyTableCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_downlink_port_arp_proxies_for_tier1_segment_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Group discovery profile binding map
    # API will get Group discovery profile binding map
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param discovery_profile_binding_map_id Group discovery profile binding map ID
    # @param [Hash] opts the optional parameters
    # @return [GroupDiscoveryProfileBindingMap]
    def get_group_discovery_profile_binding(domain_id, group_id, discovery_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_group_discovery_profile_binding_with_http_info(domain_id, group_id, discovery_profile_binding_map_id, opts)
      data
    end

    # Get Group discovery profile binding map
    # API will get Group discovery profile binding map
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param discovery_profile_binding_map_id Group discovery profile binding map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(GroupDiscoveryProfileBindingMap, Fixnum, Hash)>] GroupDiscoveryProfileBindingMap data, response status code and response headers
    def get_group_discovery_profile_binding_with_http_info(domain_id, group_id, discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_group_discovery_profile_binding ...'
      end
      # verify the required parameter 'domain_id' is set
      if @api_client.config.client_side_validation && domain_id.nil?
        fail ArgumentError, "Missing the required parameter 'domain_id' when calling SegmentsApi.get_group_discovery_profile_binding"
      end
      # verify the required parameter 'group_id' is set
      if @api_client.config.client_side_validation && group_id.nil?
        fail ArgumentError, "Missing the required parameter 'group_id' when calling SegmentsApi.get_group_discovery_profile_binding"
      end
      # verify the required parameter 'discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'discovery_profile_binding_map_id' when calling SegmentsApi.get_group_discovery_profile_binding"
      end
      # resource path
      local_var_path = '/infra/domains/{domain-id}/groups/{group-id}/discovery-profile-binding-maps/{discovery-profile-binding-map-id}'.sub('{' + 'domain-id' + '}', domain_id.to_s).sub('{' + 'group-id' + '}', group_id.to_s).sub('{' + 'discovery-profile-binding-map-id' + '}', discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'GroupDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_group_discovery_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get mirror stack status for Group Monitoring Profile Binding Map.
    # API will get mirror stack status by Group Monitoring Profile Binding Map 
    # @param domain_id 
    # @param group_id 
    # @param group_monitoring_profile_binding_map_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Binding map path enforcemnt point path to remote L3 mirror session
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [MirrorStackStatusListResult]
    def get_group_monitoring_binding_mirror_stack_status(domain_id, group_id, group_monitoring_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_group_monitoring_binding_mirror_stack_status_with_http_info(domain_id, group_id, group_monitoring_profile_binding_map_id, opts)
      data
    end

    # Get mirror stack status for Group Monitoring Profile Binding Map.
    # API will get mirror stack status by Group Monitoring Profile Binding Map 
    # @param domain_id 
    # @param group_id 
    # @param group_monitoring_profile_binding_map_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Binding map path enforcemnt point path to remote L3 mirror session
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(MirrorStackStatusListResult, Fixnum, Hash)>] MirrorStackStatusListResult data, response status code and response headers
    def get_group_monitoring_binding_mirror_stack_status_with_http_info(domain_id, group_id, group_monitoring_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_group_monitoring_binding_mirror_stack_status ...'
      end
      # verify the required parameter 'domain_id' is set
      if @api_client.config.client_side_validation && domain_id.nil?
        fail ArgumentError, "Missing the required parameter 'domain_id' when calling SegmentsApi.get_group_monitoring_binding_mirror_stack_status"
      end
      # verify the required parameter 'group_id' is set
      if @api_client.config.client_side_validation && group_id.nil?
        fail ArgumentError, "Missing the required parameter 'group_id' when calling SegmentsApi.get_group_monitoring_binding_mirror_stack_status"
      end
      # verify the required parameter 'group_monitoring_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && group_monitoring_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'group_monitoring_profile_binding_map_id' when calling SegmentsApi.get_group_monitoring_binding_mirror_stack_status"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_group_monitoring_binding_mirror_stack_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_group_monitoring_binding_mirror_stack_status, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/domains/{domain-id}/groups/{group-id}/group-monitoring-profile-binding-maps/{group-monitoring-profile-binding-map-id}/mirror-stack-status'.sub('{' + 'domain-id' + '}', domain_id.to_s).sub('{' + 'group-id' + '}', group_id.to_s).sub('{' + 'group-monitoring-profile-binding-map-id' + '}', group_monitoring_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MirrorStackStatusListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_group_monitoring_binding_mirror_stack_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Infra Port Discovery Profile Binding Map
    # API will get Infra Port Discovery Profile Binding Map 
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [PortDiscoveryProfileBindingMap]
    def get_infra_port_discovery_binding(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_infra_port_discovery_binding_with_http_info(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, opts)
      data
    end

    # Get Infra Port Discovery Profile Binding Map
    # API will get Infra Port Discovery Profile Binding Map 
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortDiscoveryProfileBindingMap, Fixnum, Hash)>] PortDiscoveryProfileBindingMap data, response status code and response headers
    def get_infra_port_discovery_binding_with_http_info(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_port_discovery_binding ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.get_infra_port_discovery_binding"
      end
      # verify the required parameter 'infra_port_id' is set
      if @api_client.config.client_side_validation && infra_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_port_id' when calling SegmentsApi.get_infra_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.get_infra_port_discovery_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/ports/{infra-port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'infra-port-id' + '}', infra_port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Infra Port Monitoring Profile Binding Map
    # API will get Infra Port Monitoring Profile Binding Map. 
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_monitoring_profile_binding_map_id Port Monitoring Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [PortMonitoringProfileBindingMap]
    def get_infra_port_monitoring_binding(infra_segment_id, infra_port_id, port_monitoring_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_infra_port_monitoring_binding_with_http_info(infra_segment_id, infra_port_id, port_monitoring_profile_binding_map_id, opts)
      data
    end

    # Get Infra Port Monitoring Profile Binding Map
    # API will get Infra Port Monitoring Profile Binding Map. 
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_monitoring_profile_binding_map_id Port Monitoring Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortMonitoringProfileBindingMap, Fixnum, Hash)>] PortMonitoringProfileBindingMap data, response status code and response headers
    def get_infra_port_monitoring_binding_with_http_info(infra_segment_id, infra_port_id, port_monitoring_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_port_monitoring_binding ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.get_infra_port_monitoring_binding"
      end
      # verify the required parameter 'infra_port_id' is set
      if @api_client.config.client_side_validation && infra_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_port_id' when calling SegmentsApi.get_infra_port_monitoring_binding"
      end
      # verify the required parameter 'port_monitoring_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_monitoring_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_monitoring_profile_binding_map_id' when calling SegmentsApi.get_infra_port_monitoring_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/ports/{infra-port-id}/port-monitoring-profile-binding-maps/{port-monitoring-profile-binding-map-id}'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'infra-port-id' + '}', infra_port_id.to_s).sub('{' + 'port-monitoring-profile-binding-map-id' + '}', port_monitoring_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortMonitoringProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_port_monitoring_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get mirror stack status for Infra Port Monitoring Profile Binding Map
    # API will get Infra Port Monitoring Profile Binding Map mirror stack status. 
    # @param infra_segment_id 
    # @param infra_port_id 
    # @param port_monitoring_profile_binding_map_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Binding map path enforcemnt point path to remote L3 mirror session
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [MirrorStackStatusListResult]
    def get_infra_port_monitoring_binding_mirror_stack_status(infra_segment_id, infra_port_id, port_monitoring_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_infra_port_monitoring_binding_mirror_stack_status_with_http_info(infra_segment_id, infra_port_id, port_monitoring_profile_binding_map_id, opts)
      data
    end

    # Get mirror stack status for Infra Port Monitoring Profile Binding Map
    # API will get Infra Port Monitoring Profile Binding Map mirror stack status. 
    # @param infra_segment_id 
    # @param infra_port_id 
    # @param port_monitoring_profile_binding_map_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Binding map path enforcemnt point path to remote L3 mirror session
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(MirrorStackStatusListResult, Fixnum, Hash)>] MirrorStackStatusListResult data, response status code and response headers
    def get_infra_port_monitoring_binding_mirror_stack_status_with_http_info(infra_segment_id, infra_port_id, port_monitoring_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_port_monitoring_binding_mirror_stack_status ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.get_infra_port_monitoring_binding_mirror_stack_status"
      end
      # verify the required parameter 'infra_port_id' is set
      if @api_client.config.client_side_validation && infra_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_port_id' when calling SegmentsApi.get_infra_port_monitoring_binding_mirror_stack_status"
      end
      # verify the required parameter 'port_monitoring_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_monitoring_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_monitoring_profile_binding_map_id' when calling SegmentsApi.get_infra_port_monitoring_binding_mirror_stack_status"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_infra_port_monitoring_binding_mirror_stack_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_infra_port_monitoring_binding_mirror_stack_status, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/ports/{infra-port-id}/port-monitoring-profile-binding-maps/{port-monitoring-profile-binding-map-id}/mirror-stack-status'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'infra-port-id' + '}', infra_port_id.to_s).sub('{' + 'port-monitoring-profile-binding-map-id' + '}', port_monitoring_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MirrorStackStatusListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_port_monitoring_binding_mirror_stack_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Port QoS Profile Binding Map
    # API will get Port QoS Profile Binding Map. 
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [PortQoSProfileBindingMap]
    def get_infra_port_qo_s_binding(segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_infra_port_qo_s_binding_with_http_info(segment_id, port_id, port_qos_profile_binding_map_id, opts)
      data
    end

    # Get Port QoS Profile Binding Map
    # API will get Port QoS Profile Binding Map. 
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortQoSProfileBindingMap, Fixnum, Hash)>] PortQoSProfileBindingMap data, response status code and response headers
    def get_infra_port_qo_s_binding_with_http_info(segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_port_qo_s_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.get_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.get_infra_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Port Real Time Eth Profile Binding Map
    # API will get Port Real Time Eth Profile Binding Map. 
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_real_time_eth_profile_binding_map_id Port Real Time Eth Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [PortRealTimeEthProfileBindingMap]
    def get_infra_port_real_time_eth_binding(segment_id, port_id, port_real_time_eth_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_infra_port_real_time_eth_binding_with_http_info(segment_id, port_id, port_real_time_eth_profile_binding_map_id, opts)
      data
    end

    # Get Port Real Time Eth Profile Binding Map
    # API will get Port Real Time Eth Profile Binding Map. 
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_real_time_eth_profile_binding_map_id Port Real Time Eth Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortRealTimeEthProfileBindingMap, Fixnum, Hash)>] PortRealTimeEthProfileBindingMap data, response status code and response headers
    def get_infra_port_real_time_eth_binding_with_http_info(segment_id, port_id, port_real_time_eth_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_port_real_time_eth_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.get_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'port_real_time_eth_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_real_time_eth_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_real_time_eth_profile_binding_map_id' when calling SegmentsApi.get_infra_port_real_time_eth_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}/port-real-time-eth-profile-binding-maps/{port-real-time-eth-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-real-time-eth-profile-binding-map-id' + '}', port_real_time_eth_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortRealTimeEthProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_port_real_time_eth_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Infra Segment Discovery Profile Binding Map
    # API will get Infra Segment Discovery Profile Binding Map 
    # @param infra_segment_id Infra Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [SegmentDiscoveryProfileBindingMap]
    def get_infra_segment_discovery_binding(infra_segment_id, segment_discovery_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_infra_segment_discovery_binding_with_http_info(infra_segment_id, segment_discovery_profile_binding_map_id, opts)
      data
    end

    # Get Infra Segment Discovery Profile Binding Map
    # API will get Infra Segment Discovery Profile Binding Map 
    # @param infra_segment_id Infra Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentDiscoveryProfileBindingMap, Fixnum, Hash)>] SegmentDiscoveryProfileBindingMap data, response status code and response headers
    def get_infra_segment_discovery_binding_with_http_info(infra_segment_id, segment_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_segment_discovery_binding ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.get_infra_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map_id' when calling SegmentsApi.get_infra_segment_discovery_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/segment-discovery-profile-binding-maps/{segment-discovery-profile-binding-map-id}'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'segment-discovery-profile-binding-map-id' + '}', segment_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_segment_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment MAC table
    # Returns MAC table for a segment 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [SegmentMacAddressListResult]
    def get_infra_segment_mac_table(segment_id, opts = {})
      data, _status_code, _headers = get_infra_segment_mac_table_with_http_info(segment_id, opts)
      data
    end

    # Get infra segment MAC table
    # Returns MAC table for a segment 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(SegmentMacAddressListResult, Fixnum, Hash)>] SegmentMacAddressListResult data, response status code and response headers
    def get_infra_segment_mac_table_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_segment_mac_table ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_infra_segment_mac_table"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_infra_segment_mac_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_infra_segment_mac_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/mac-table'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentMacAddressListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_segment_mac_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment MAC table in CSV
    # Returns MAC table for a segment 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [MacAddressCsvListResult]
    def get_infra_segment_mac_table_in_csv(segment_id, opts = {})
      data, _status_code, _headers = get_infra_segment_mac_table_in_csv_with_http_info(segment_id, opts)
      data
    end

    # Get infra segment MAC table in CSV
    # Returns MAC table for a segment 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(MacAddressCsvListResult, Fixnum, Hash)>] MacAddressCsvListResult data, response status code and response headers
    def get_infra_segment_mac_table_in_csv_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_segment_mac_table_in_csv ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_infra_segment_mac_table_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/mac-table?format=csv'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MacAddressCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_segment_mac_table_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Infra Segment Monitoring Profile Binding Map
    # API will get Infra Segment Monitoring Profile Binding Map. 
    # @param infra_segment_id Infra Segment ID
    # @param segment_monitoring_profile_binding_map_id Segment Monitoring Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [SegmentMonitoringProfileBindingMap]
    def get_infra_segment_monitoring_binding(infra_segment_id, segment_monitoring_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_infra_segment_monitoring_binding_with_http_info(infra_segment_id, segment_monitoring_profile_binding_map_id, opts)
      data
    end

    # Get Infra Segment Monitoring Profile Binding Map
    # API will get Infra Segment Monitoring Profile Binding Map. 
    # @param infra_segment_id Infra Segment ID
    # @param segment_monitoring_profile_binding_map_id Segment Monitoring Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentMonitoringProfileBindingMap, Fixnum, Hash)>] SegmentMonitoringProfileBindingMap data, response status code and response headers
    def get_infra_segment_monitoring_binding_with_http_info(infra_segment_id, segment_monitoring_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_segment_monitoring_binding ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.get_infra_segment_monitoring_binding"
      end
      # verify the required parameter 'segment_monitoring_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_monitoring_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_monitoring_profile_binding_map_id' when calling SegmentsApi.get_infra_segment_monitoring_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/segment-monitoring-profile-binding-maps/{segment-monitoring-profile-binding-map-id}'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'segment-monitoring-profile-binding-map-id' + '}', segment_monitoring_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentMonitoringProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_segment_monitoring_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Infra Segment Monitoring Profile Binding Map
    # API will get Infra Segment Monitoring Profile Binding Map mirror stack status. 
    # @param infra_segment_id 
    # @param segment_monitoring_profile_binding_map_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Binding map path enforcemnt point path to remote L3 mirror session
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [MirrorStackStatusListResult]
    def get_infra_segment_monitoring_binding_mirror_stack_status(infra_segment_id, segment_monitoring_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_infra_segment_monitoring_binding_mirror_stack_status_with_http_info(infra_segment_id, segment_monitoring_profile_binding_map_id, opts)
      data
    end

    # Get Infra Segment Monitoring Profile Binding Map
    # API will get Infra Segment Monitoring Profile Binding Map mirror stack status. 
    # @param infra_segment_id 
    # @param segment_monitoring_profile_binding_map_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Binding map path enforcemnt point path to remote L3 mirror session
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(MirrorStackStatusListResult, Fixnum, Hash)>] MirrorStackStatusListResult data, response status code and response headers
    def get_infra_segment_monitoring_binding_mirror_stack_status_with_http_info(infra_segment_id, segment_monitoring_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_segment_monitoring_binding_mirror_stack_status ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.get_infra_segment_monitoring_binding_mirror_stack_status"
      end
      # verify the required parameter 'segment_monitoring_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_monitoring_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_monitoring_profile_binding_map_id' when calling SegmentsApi.get_infra_segment_monitoring_binding_mirror_stack_status"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_infra_segment_monitoring_binding_mirror_stack_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_infra_segment_monitoring_binding_mirror_stack_status, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/segment-monitoring-profile-binding-maps/{segment-monitoring-profile-binding-map-id}/mirror-stack-status'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'segment-monitoring-profile-binding-map-id' + '}', segment_monitoring_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MirrorStackStatusListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_segment_monitoring_binding_mirror_stack_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment port by ID
    # Get detail information on an infra segment port by giving ID. 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [SegmentPort]
    def get_infra_segment_port(segment_id, port_id, opts = {})
      data, _status_code, _headers = get_infra_segment_port_with_http_info(segment_id, port_id, opts)
      data
    end

    # Get infra segment port by ID
    # Get detail information on an infra segment port by giving ID. 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentPort, Fixnum, Hash)>] SegmentPort data, response status code and response headers
    def get_infra_segment_port_with_http_info(segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_segment_port ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_infra_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.get_infra_segment_port"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPort')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get MAC table for infra segment port
    # Returns MAC table for a segment port 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [SegmentPortMacAddressListResult]
    def get_infra_segment_port_mac_table(segment_id, port_id, opts = {})
      data, _status_code, _headers = get_infra_segment_port_mac_table_with_http_info(segment_id, port_id, opts)
      data
    end

    # Get MAC table for infra segment port
    # Returns MAC table for a segment port 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(SegmentPortMacAddressListResult, Fixnum, Hash)>] SegmentPortMacAddressListResult data, response status code and response headers
    def get_infra_segment_port_mac_table_with_http_info(segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_segment_port_mac_table ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_infra_segment_port_mac_table"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.get_infra_segment_port_mac_table"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_infra_segment_port_mac_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_infra_segment_port_mac_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}/mac-table'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortMacAddressListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_segment_port_mac_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment port MAC table in CSV
    # Returns MAC table for a segment port 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [SegmentPortMacAddressCsvListResult]
    def get_infra_segment_port_mac_table_in_csv(segment_id, port_id, opts = {})
      data, _status_code, _headers = get_infra_segment_port_mac_table_in_csv_with_http_info(segment_id, port_id, opts)
      data
    end

    # Get infra segment port MAC table in CSV
    # Returns MAC table for a segment port 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(SegmentPortMacAddressCsvListResult, Fixnum, Hash)>] SegmentPortMacAddressCsvListResult data, response status code and response headers
    def get_infra_segment_port_mac_table_in_csv_with_http_info(segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_segment_port_mac_table_in_csv ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_infra_segment_port_mac_table_in_csv"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.get_infra_segment_port_mac_table_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}/mac-table?format=csv'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortMacAddressCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_segment_port_mac_table_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment port security profile binding map
    # API will return details of the port security profile binding map. If the security profile binding map does not exist, it will return 404. 
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [PortSecurityProfileBindingMap]
    def get_infra_segment_port_security_profile_binding(segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_infra_segment_port_security_profile_binding_with_http_info(segment_id, port_id, port_security_profile_binding_map_id, opts)
      data
    end

    # Get infra segment port security profile binding map
    # API will return details of the port security profile binding map. If the security profile binding map does not exist, it will return 404. 
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortSecurityProfileBindingMap, Fixnum, Hash)>] PortSecurityProfileBindingMap data, response status code and response headers
    def get_infra_segment_port_security_profile_binding_with_http_info(segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_segment_port_security_profile_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.get_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.get_infra_segment_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_segment_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment port state
    # Returns infra segment port state on enforcement point 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [SegmentPortState]
    def get_infra_segment_port_state(segment_id, port_id, opts = {})
      data, _status_code, _headers = get_infra_segment_port_state_with_http_info(segment_id, port_id, opts)
      data
    end

    # Get infra segment port state
    # Returns infra segment port state on enforcement point 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(SegmentPortState, Fixnum, Hash)>] SegmentPortState data, response status code and response headers
    def get_infra_segment_port_state_with_http_info(segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_segment_port_state ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_infra_segment_port_state"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.get_infra_segment_port_state"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}/state'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_segment_port_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment port statistics information
    # Get infra segment port statistics information. 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentPortStatistics]
    def get_infra_segment_port_statistics(segments_id, port_id, opts = {})
      data, _status_code, _headers = get_infra_segment_port_statistics_with_http_info(segments_id, port_id, opts)
      data
    end

    # Get infra segment port statistics information
    # Get infra segment port statistics information. 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentPortStatistics, Fixnum, Hash)>] SegmentPortStatistics data, response status code and response headers
    def get_infra_segment_port_statistics_with_http_info(segments_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_segment_port_statistics ...'
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.get_infra_segment_port_statistics"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.get_infra_segment_port_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_infra_segment_port_statistics, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_infra_segment_port_statistics, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/infra/segments/{segments-id}/ports/{port-id}/statistics'.sub('{' + 'segments-id' + '}', segments_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_segment_port_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment port status information
    # Get infra segment port status information. 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentPortStatus]
    def get_infra_segment_port_status(segments_id, port_id, opts = {})
      data, _status_code, _headers = get_infra_segment_port_status_with_http_info(segments_id, port_id, opts)
      data
    end

    # Get infra segment port status information
    # Get infra segment port status information. 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentPortStatus, Fixnum, Hash)>] SegmentPortStatus data, response status code and response headers
    def get_infra_segment_port_status_with_http_info(segments_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_segment_port_status ...'
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.get_infra_segment_port_status"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.get_infra_segment_port_status"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_infra_segment_port_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_infra_segment_port_status, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/infra/segments/{segments-id}/ports/{port-id}/status'.sub('{' + 'segments-id' + '}', segments_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_segment_port_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Segment QoS Profile Binding Map
    # API will get Segment QoS Profile Binding Map. 
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [SegmentQoSProfileBindingMap]
    def get_infra_segment_qo_s_binding(segment_id, segment_qos_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_infra_segment_qo_s_binding_with_http_info(segment_id, segment_qos_profile_binding_map_id, opts)
      data
    end

    # Get Segment QoS Profile Binding Map
    # API will get Segment QoS Profile Binding Map. 
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentQoSProfileBindingMap, Fixnum, Hash)>] SegmentQoSProfileBindingMap data, response status code and response headers
    def get_infra_segment_qo_s_binding_with_http_info(segment_id, segment_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_segment_qo_s_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_infra_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qos_profile_binding_map_id' when calling SegmentsApi.get_infra_segment_qo_s_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/segment-qos-profile-binding-maps/{segment-qos-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-qos-profile-binding-map-id' + '}', segment_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_segment_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Segment Real Time Eth Profile Binding Map
    # API will get Segment Real Time Eth Profile Binding Map. 
    # @param segment_id Segment ID
    # @param segment_real_time_eth_profile_binding_map_id Segment Real Time Eth Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [SegmentRealTimeEthProfileBindingMap]
    def get_infra_segment_real_time_eth_binding(segment_id, segment_real_time_eth_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_infra_segment_real_time_eth_binding_with_http_info(segment_id, segment_real_time_eth_profile_binding_map_id, opts)
      data
    end

    # Get Segment Real Time Eth Profile Binding Map
    # API will get Segment Real Time Eth Profile Binding Map. 
    # @param segment_id Segment ID
    # @param segment_real_time_eth_profile_binding_map_id Segment Real Time Eth Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentRealTimeEthProfileBindingMap, Fixnum, Hash)>] SegmentRealTimeEthProfileBindingMap data, response status code and response headers
    def get_infra_segment_real_time_eth_binding_with_http_info(segment_id, segment_real_time_eth_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_segment_real_time_eth_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_infra_segment_real_time_eth_binding"
      end
      # verify the required parameter 'segment_real_time_eth_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_real_time_eth_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_real_time_eth_profile_binding_map_id' when calling SegmentsApi.get_infra_segment_real_time_eth_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/segment-real-time-eth-profile-binding-maps/{segment-real-time-eth-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-real-time-eth-profile-binding-map-id' + '}', segment_real_time_eth_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentRealTimeEthProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_segment_real_time_eth_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment security profile binding map
    # API will return details of the segment security profile binding map. If the binding map does not exist, it will return 404. 
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [SegmentSecurityProfileBindingMap]
    def get_infra_segment_security_profile_binding(segment_id, segment_security_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_infra_segment_security_profile_binding_with_http_info(segment_id, segment_security_profile_binding_map_id, opts)
      data
    end

    # Get infra segment security profile binding map
    # API will return details of the segment security profile binding map. If the binding map does not exist, it will return 404. 
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentSecurityProfileBindingMap, Fixnum, Hash)>] SegmentSecurityProfileBindingMap data, response status code and response headers
    def get_infra_segment_security_profile_binding_with_http_info(segment_id, segment_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_segment_security_profile_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_infra_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map_id' when calling SegmentsApi.get_infra_segment_security_profile_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/segment-security-profile-binding-maps/{segment-security-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-security-profile-binding-map-id' + '}', segment_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_segment_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment state information
    # Get infra segment state information. 
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentConfigurationState]
    def get_infra_segment_state(segments_id, opts = {})
      data, _status_code, _headers = get_infra_segment_state_with_http_info(segments_id, opts)
      data
    end

    # Get infra segment state information
    # Get infra segment state information. 
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentConfigurationState, Fixnum, Hash)>] SegmentConfigurationState data, response status code and response headers
    def get_infra_segment_state_with_http_info(segments_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_segment_state ...'
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.get_infra_segment_state"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_infra_segment_state, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_infra_segment_state, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/infra/segments/{segments-id}/state'.sub('{' + 'segments-id' + '}', segments_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConfigurationState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_segment_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment statistics information
    # Get infra segment statistics information. 
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentStatistics]
    def get_infra_segment_statistics(segments_id, opts = {})
      data, _status_code, _headers = get_infra_segment_statistics_with_http_info(segments_id, opts)
      data
    end

    # Get infra segment statistics information
    # Get infra segment statistics information. 
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentStatistics, Fixnum, Hash)>] SegmentStatistics data, response status code and response headers
    def get_infra_segment_statistics_with_http_info(segments_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_segment_statistics ...'
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.get_infra_segment_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_infra_segment_statistics, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_infra_segment_statistics, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/infra/segments/{segments-id}/statistics'.sub('{' + 'segments-id' + '}', segments_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_segment_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment TEP table
    # Returns TEP table for a segment 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyTepListResult]
    def get_infra_segment_tep_table(segment_id, opts = {})
      data, _status_code, _headers = get_infra_segment_tep_table_with_http_info(segment_id, opts)
      data
    end

    # Get infra segment TEP table
    # Returns TEP table for a segment 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyTepListResult, Fixnum, Hash)>] PolicyTepListResult data, response status code and response headers
    def get_infra_segment_tep_table_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_segment_tep_table ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_infra_segment_tep_table"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_infra_segment_tep_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_infra_segment_tep_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/tep-table'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyTepListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_segment_tep_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get tier-1 segment TEP table in CSV
    # Returns TEP table for a segment in CSV 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyTepCsvListResult]
    def get_infra_segment_tep_table_in_csv(segment_id, opts = {})
      data, _status_code, _headers = get_infra_segment_tep_table_in_csv_with_http_info(segment_id, opts)
      data
    end

    # Get tier-1 segment TEP table in CSV
    # Returns TEP table for a segment in CSV 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyTepCsvListResult, Fixnum, Hash)>] PolicyTepCsvListResult data, response status code and response headers
    def get_infra_segment_tep_table_in_csv_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_segment_tep_table_in_csv ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_infra_segment_tep_table_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/tep-table?format=csv'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyTepCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_segment_tep_table_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segments by configuration state
    # Returns all infra segments with configuration state on the enforcement point specified in the request 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :configuration_state Configuration state of the segment on enforcement point
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [SegmentConfigurationStateListResult]
    def get_infra_segments_by_state(opts = {})
      data, _status_code, _headers = get_infra_segments_by_state_with_http_info(opts)
      data
    end

    # Get infra segments by configuration state
    # Returns all infra segments with configuration state on the enforcement point specified in the request 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :configuration_state Configuration state of the segment on enforcement point
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(SegmentConfigurationStateListResult, Fixnum, Hash)>] SegmentConfigurationStateListResult data, response status code and response headers
    def get_infra_segments_by_state_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_infra_segments_by_state ...'
      end
      if @api_client.config.client_side_validation && opts[:'configuration_state'] && !['pending', 'in_progress', 'success', 'failed', 'partial_success', 'orphaned', 'unknown'].include?(opts[:'configuration_state'])
        fail ArgumentError, 'invalid value for "configuration_state", must be one of pending, in_progress, success, failed, partial_success, orphaned, unknown'
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/segments/state'

      # query parameters
      query_params = {}
      query_params[:'configuration_state'] = opts[:'configuration_state'] if !opts[:'configuration_state'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConfigurationStateListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_infra_segments_by_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get IP Discovery Profile
    # API will get IP Discovery profile. 
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @return [IPDiscoveryProfile]
    def get_ip_discovery_profile(ip_discovery_profile_id, opts = {})
      data, _status_code, _headers = get_ip_discovery_profile_with_http_info(ip_discovery_profile_id, opts)
      data
    end

    # Get IP Discovery Profile
    # API will get IP Discovery profile. 
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(IPDiscoveryProfile, Fixnum, Hash)>] IPDiscoveryProfile data, response status code and response headers
    def get_ip_discovery_profile_with_http_info(ip_discovery_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_ip_discovery_profile ...'
      end
      # verify the required parameter 'ip_discovery_profile_id' is set
      if @api_client.config.client_side_validation && ip_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'ip_discovery_profile_id' when calling SegmentsApi.get_ip_discovery_profile"
      end
      # resource path
      local_var_path = '/infra/ip-discovery-profiles/{ip-discovery-profile-id}'.sub('{' + 'ip-discovery-profile-id' + '}', ip_discovery_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'IPDiscoveryProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_ip_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List IP Discovery Profiles
    # API will list all IP Discovery Profiles active in current discovery profile id. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [IPDiscoveryProfileListResult]
    def get_ip_discovery_profiles(opts = {})
      data, _status_code, _headers = get_ip_discovery_profiles_with_http_info(opts)
      data
    end

    # List IP Discovery Profiles
    # API will list all IP Discovery Profiles active in current discovery profile id. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(IPDiscoveryProfileListResult, Fixnum, Hash)>] IPDiscoveryProfileListResult data, response status code and response headers
    def get_ip_discovery_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_ip_discovery_profiles ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_ip_discovery_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_ip_discovery_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/ip-discovery-profiles'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'IPDiscoveryProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_ip_discovery_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Mac Discovery Profile
    # API will get Mac Discovery profile. 
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @return [MacDiscoveryProfile]
    def get_mac_discovery_profile(mac_discovery_profile_id, opts = {})
      data, _status_code, _headers = get_mac_discovery_profile_with_http_info(mac_discovery_profile_id, opts)
      data
    end

    # Get Mac Discovery Profile
    # API will get Mac Discovery profile. 
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(MacDiscoveryProfile, Fixnum, Hash)>] MacDiscoveryProfile data, response status code and response headers
    def get_mac_discovery_profile_with_http_info(mac_discovery_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_mac_discovery_profile ...'
      end
      # verify the required parameter 'mac_discovery_profile_id' is set
      if @api_client.config.client_side_validation && mac_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'mac_discovery_profile_id' when calling SegmentsApi.get_mac_discovery_profile"
      end
      # resource path
      local_var_path = '/infra/mac-discovery-profiles/{mac-discovery-profile-id}'.sub('{' + 'mac-discovery-profile-id' + '}', mac_discovery_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MacDiscoveryProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_mac_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Mac Discovery Profiles
    # API will list all Mac Discovery Profiles active in current discovery profile id. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [MacDiscoveryProfileListResult]
    def get_mac_discovery_profiles(opts = {})
      data, _status_code, _headers = get_mac_discovery_profiles_with_http_info(opts)
      data
    end

    # List Mac Discovery Profiles
    # API will list all Mac Discovery Profiles active in current discovery profile id. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(MacDiscoveryProfileListResult, Fixnum, Hash)>] MacDiscoveryProfileListResult data, response status code and response headers
    def get_mac_discovery_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_mac_discovery_profiles ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_mac_discovery_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_mac_discovery_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/mac-discovery-profiles'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MacDiscoveryProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_mac_discovery_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Port Discovery Profile Binding Map
    # API will get Port Discovery Profile Binding Map 
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [PortDiscoveryProfileBindingMap]
    def get_port_discovery_binding(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_port_discovery_binding_with_http_info(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, opts)
      data
    end

    # Get Port Discovery Profile Binding Map
    # API will get Port Discovery Profile Binding Map 
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortDiscoveryProfileBindingMap, Fixnum, Hash)>] PortDiscoveryProfileBindingMap data, response status code and response headers
    def get_port_discovery_binding_with_http_info(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_port_discovery_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_port_discovery_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_port_discovery_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.get_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.get_port_discovery_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Port Monitoring Profile Binding Map
    # API will get Port Monitoring Profile Binding Map. 
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_monitoring_profile_binding_map_id Port Monitoring Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [PortMonitoringProfileBindingMap]
    def get_port_monitoring_binding(tier_1_id, segment_id, port_id, port_monitoring_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_port_monitoring_binding_with_http_info(tier_1_id, segment_id, port_id, port_monitoring_profile_binding_map_id, opts)
      data
    end

    # Get Port Monitoring Profile Binding Map
    # API will get Port Monitoring Profile Binding Map. 
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_monitoring_profile_binding_map_id Port Monitoring Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortMonitoringProfileBindingMap, Fixnum, Hash)>] PortMonitoringProfileBindingMap data, response status code and response headers
    def get_port_monitoring_binding_with_http_info(tier_1_id, segment_id, port_id, port_monitoring_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_port_monitoring_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_port_monitoring_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_port_monitoring_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.get_port_monitoring_binding"
      end
      # verify the required parameter 'port_monitoring_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_monitoring_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_monitoring_profile_binding_map_id' when calling SegmentsApi.get_port_monitoring_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-monitoring-profile-binding-maps/{port-monitoring-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-monitoring-profile-binding-map-id' + '}', port_monitoring_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortMonitoringProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_port_monitoring_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get mirror stack status for Port Monitoring Profile Binding Map
    # API will get mirror stack status by Port Monitoring Profile Binding Map. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param port_monitoring_profile_binding_map_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Binding map path enforcemnt point path to remote L3 mirror session
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [MirrorStackStatusListResult]
    def get_port_monitoring_binding_mirror_stack_status(tier_1_id, segment_id, port_id, port_monitoring_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_port_monitoring_binding_mirror_stack_status_with_http_info(tier_1_id, segment_id, port_id, port_monitoring_profile_binding_map_id, opts)
      data
    end

    # Get mirror stack status for Port Monitoring Profile Binding Map
    # API will get mirror stack status by Port Monitoring Profile Binding Map. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param port_monitoring_profile_binding_map_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Binding map path enforcemnt point path to remote L3 mirror session
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(MirrorStackStatusListResult, Fixnum, Hash)>] MirrorStackStatusListResult data, response status code and response headers
    def get_port_monitoring_binding_mirror_stack_status_with_http_info(tier_1_id, segment_id, port_id, port_monitoring_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_port_monitoring_binding_mirror_stack_status ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_port_monitoring_binding_mirror_stack_status"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_port_monitoring_binding_mirror_stack_status"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.get_port_monitoring_binding_mirror_stack_status"
      end
      # verify the required parameter 'port_monitoring_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_monitoring_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_monitoring_profile_binding_map_id' when calling SegmentsApi.get_port_monitoring_binding_mirror_stack_status"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_port_monitoring_binding_mirror_stack_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_port_monitoring_binding_mirror_stack_status, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-monitoring-profile-binding-maps/{port-monitoring-profile-binding-map-id}/mirror-stack-status'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-monitoring-profile-binding-map-id' + '}', port_monitoring_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MirrorStackStatusListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_port_monitoring_binding_mirror_stack_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Port QoS Profile Binding Map
    # API will get Port QoS Profile Binding Map. 
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [PortQoSProfileBindingMap]
    def get_port_qo_s_binding(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_port_qo_s_binding_with_http_info(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, opts)
      data
    end

    # Get Port QoS Profile Binding Map
    # API will get Port QoS Profile Binding Map. 
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortQoSProfileBindingMap, Fixnum, Hash)>] PortQoSProfileBindingMap data, response status code and response headers
    def get_port_qo_s_binding_with_http_info(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_port_qo_s_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_port_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.get_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.get_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get port security profile binding map
    # API will return details of the port security profile binding map. If the security profile binding map does not exist, it will return 404. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [PortSecurityProfileBindingMap]
    def get_port_security_profile_binding(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_port_security_profile_binding_with_http_info(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, opts)
      data
    end

    # Get port security profile binding map
    # API will return details of the port security profile binding map. If the security profile binding map does not exist, it will return 404. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortSecurityProfileBindingMap, Fixnum, Hash)>] PortSecurityProfileBindingMap data, response status code and response headers
    def get_port_security_profile_binding_with_http_info(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_port_security_profile_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_port_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.get_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.get_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Segment Discovery Profile Binding Map
    # API will get Segment Discovery Profile Binding Map 
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [SegmentDiscoveryProfileBindingMap]
    def get_segment_discovery_binding(tier_1_id, segment_id, segment_discovery_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_segment_discovery_binding_with_http_info(tier_1_id, segment_id, segment_discovery_profile_binding_map_id, opts)
      data
    end

    # Get Segment Discovery Profile Binding Map
    # API will get Segment Discovery Profile Binding Map 
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentDiscoveryProfileBindingMap, Fixnum, Hash)>] SegmentDiscoveryProfileBindingMap data, response status code and response headers
    def get_segment_discovery_binding_with_http_info(tier_1_id, segment_id, segment_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_segment_discovery_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_segment_discovery_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map_id' when calling SegmentsApi.get_segment_discovery_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-discovery-profile-binding-maps/{segment-discovery-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-discovery-profile-binding-map-id' + '}', segment_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_segment_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Segment Monitoring Profile Binding Map
    # API will get Segment Monitoring Profile Binding Map. 
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_monitoring_profile_binding_map_id Segment Monitoring Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [SegmentMonitoringProfileBindingMap]
    def get_segment_monitoring_binding(tier_1_id, segment_id, segment_monitoring_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_segment_monitoring_binding_with_http_info(tier_1_id, segment_id, segment_monitoring_profile_binding_map_id, opts)
      data
    end

    # Get Segment Monitoring Profile Binding Map
    # API will get Segment Monitoring Profile Binding Map. 
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_monitoring_profile_binding_map_id Segment Monitoring Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentMonitoringProfileBindingMap, Fixnum, Hash)>] SegmentMonitoringProfileBindingMap data, response status code and response headers
    def get_segment_monitoring_binding_with_http_info(tier_1_id, segment_id, segment_monitoring_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_segment_monitoring_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_segment_monitoring_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_segment_monitoring_binding"
      end
      # verify the required parameter 'segment_monitoring_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_monitoring_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_monitoring_profile_binding_map_id' when calling SegmentsApi.get_segment_monitoring_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-monitoring-profile-binding-maps/{segment-monitoring-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-monitoring-profile-binding-map-id' + '}', segment_monitoring_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentMonitoringProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_segment_monitoring_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get mirror stack status for Segment Monitoring Profile Binding Map
    # API will get mirror stack status by Segment Monitoring Profile Binding Map. 
    # @param tier_1_id 
    # @param segment_id 
    # @param segment_monitoring_profile_binding_map_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Binding map path enforcemnt point path to remote L3 mirror session
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [MirrorStackStatusListResult]
    def get_segment_monitoring_binding_mirror_stack_status(tier_1_id, segment_id, segment_monitoring_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_segment_monitoring_binding_mirror_stack_status_with_http_info(tier_1_id, segment_id, segment_monitoring_profile_binding_map_id, opts)
      data
    end

    # Get mirror stack status for Segment Monitoring Profile Binding Map
    # API will get mirror stack status by Segment Monitoring Profile Binding Map. 
    # @param tier_1_id 
    # @param segment_id 
    # @param segment_monitoring_profile_binding_map_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path Binding map path enforcemnt point path to remote L3 mirror session
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(MirrorStackStatusListResult, Fixnum, Hash)>] MirrorStackStatusListResult data, response status code and response headers
    def get_segment_monitoring_binding_mirror_stack_status_with_http_info(tier_1_id, segment_id, segment_monitoring_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_segment_monitoring_binding_mirror_stack_status ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_segment_monitoring_binding_mirror_stack_status"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_segment_monitoring_binding_mirror_stack_status"
      end
      # verify the required parameter 'segment_monitoring_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_monitoring_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_monitoring_profile_binding_map_id' when calling SegmentsApi.get_segment_monitoring_binding_mirror_stack_status"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_segment_monitoring_binding_mirror_stack_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_segment_monitoring_binding_mirror_stack_status, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-monitoring-profile-binding-maps/{segment-monitoring-profile-binding-map-id}/mirror-stack-status'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-monitoring-profile-binding-map-id' + '}', segment_monitoring_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MirrorStackStatusListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_segment_monitoring_binding_mirror_stack_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get tier-1 segment port statistics information
    # Get tier-1 segment port statistics information. 
    # @param tier_1_id 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentPortStatistics]
    def get_segment_port_statistics(tier_1_id, segments_id, port_id, opts = {})
      data, _status_code, _headers = get_segment_port_statistics_with_http_info(tier_1_id, segments_id, port_id, opts)
      data
    end

    # Get tier-1 segment port statistics information
    # Get tier-1 segment port statistics information. 
    # @param tier_1_id 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentPortStatistics, Fixnum, Hash)>] SegmentPortStatistics data, response status code and response headers
    def get_segment_port_statistics_with_http_info(tier_1_id, segments_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_segment_port_statistics ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_segment_port_statistics"
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.get_segment_port_statistics"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.get_segment_port_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_segment_port_statistics, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_segment_port_statistics, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segments-id}/ports/{port-id}/statistics'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segments-id' + '}', segments_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_segment_port_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get segment port status information
    # Get tier1 segment port status information. 
    # @param tier_1_id 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentPortStatus]
    def get_segment_port_status(tier_1_id, segments_id, port_id, opts = {})
      data, _status_code, _headers = get_segment_port_status_with_http_info(tier_1_id, segments_id, port_id, opts)
      data
    end

    # Get segment port status information
    # Get tier1 segment port status information. 
    # @param tier_1_id 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentPortStatus, Fixnum, Hash)>] SegmentPortStatus data, response status code and response headers
    def get_segment_port_status_with_http_info(tier_1_id, segments_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_segment_port_status ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_segment_port_status"
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.get_segment_port_status"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.get_segment_port_status"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_segment_port_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_segment_port_status, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segments-id}/ports/{port-id}/status'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segments-id' + '}', segments_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_segment_port_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Segment QoS Profile Binding Map
    # API will get Segment QoS Profile Binding Map. 
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [SegmentQoSProfileBindingMap]
    def get_segment_qo_s_binding(tier_1_id, segment_id, segment_qos_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_segment_qo_s_binding_with_http_info(tier_1_id, segment_id, segment_qos_profile_binding_map_id, opts)
      data
    end

    # Get Segment QoS Profile Binding Map
    # API will get Segment QoS Profile Binding Map. 
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentQoSProfileBindingMap, Fixnum, Hash)>] SegmentQoSProfileBindingMap data, response status code and response headers
    def get_segment_qo_s_binding_with_http_info(tier_1_id, segment_id, segment_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_segment_qo_s_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qos_profile_binding_map_id' when calling SegmentsApi.get_segment_qo_s_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-qos-profile-binding-maps/{segment-qos-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-qos-profile-binding-map-id' + '}', segment_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_segment_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # GET Segment security profile id
    # API will return details of the segment security profile with given id. If the profile does not exist, it will return 404. 
    # @param segment_security_profile_id Segment security profile id
    # @param [Hash] opts the optional parameters
    # @return [SegmentSecurityProfile]
    def get_segment_security_profile(segment_security_profile_id, opts = {})
      data, _status_code, _headers = get_segment_security_profile_with_http_info(segment_security_profile_id, opts)
      data
    end

    # GET Segment security profile id
    # API will return details of the segment security profile with given id. If the profile does not exist, it will return 404. 
    # @param segment_security_profile_id Segment security profile id
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentSecurityProfile, Fixnum, Hash)>] SegmentSecurityProfile data, response status code and response headers
    def get_segment_security_profile_with_http_info(segment_security_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_segment_security_profile ...'
      end
      # verify the required parameter 'segment_security_profile_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_id' when calling SegmentsApi.get_segment_security_profile"
      end
      # resource path
      local_var_path = '/infra/segment-security-profiles/{segment-security-profile-id}'.sub('{' + 'segment-security-profile-id' + '}', segment_security_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_segment_security_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get segment security profile binding map
    # API will return details of the segment security profile binding map. If the binding map does not exist, it will return 404. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [SegmentSecurityProfileBindingMap]
    def get_segment_security_profile_binding(tier_1_id, segment_id, segment_security_profile_binding_map_id, opts = {})
      data, _status_code, _headers = get_segment_security_profile_binding_with_http_info(tier_1_id, segment_id, segment_security_profile_binding_map_id, opts)
      data
    end

    # Get segment security profile binding map
    # API will return details of the segment security profile binding map. If the binding map does not exist, it will return 404. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentSecurityProfileBindingMap, Fixnum, Hash)>] SegmentSecurityProfileBindingMap data, response status code and response headers
    def get_segment_security_profile_binding_with_http_info(tier_1_id, segment_id, segment_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_segment_security_profile_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map_id' when calling SegmentsApi.get_segment_security_profile_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-security-profile-binding-maps/{segment-security-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-security-profile-binding-map-id' + '}', segment_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_segment_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get segment state information
    # Get tier1 segment state information. 
    # @param tier_1_id 
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentConfigurationState]
    def get_segment_state(tier_1_id, segments_id, opts = {})
      data, _status_code, _headers = get_segment_state_with_http_info(tier_1_id, segments_id, opts)
      data
    end

    # Get segment state information
    # Get tier1 segment state information. 
    # @param tier_1_id 
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentConfigurationState, Fixnum, Hash)>] SegmentConfigurationState data, response status code and response headers
    def get_segment_state_with_http_info(tier_1_id, segments_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_segment_state ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_segment_state"
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.get_segment_state"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_segment_state, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_segment_state, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segments-id}/state'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segments-id' + '}', segments_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConfigurationState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_segment_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get segment statistics information
    # Get tier1 segment statistics information. 
    # @param tier_1_id 
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentStatistics]
    def get_segment_statistics(tier_1_id, segments_id, opts = {})
      data, _status_code, _headers = get_segment_statistics_with_http_info(tier_1_id, segments_id, opts)
      data
    end

    # Get segment statistics information
    # Get tier1 segment statistics information. 
    # @param tier_1_id 
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentStatistics, Fixnum, Hash)>] SegmentStatistics data, response status code and response headers
    def get_segment_statistics_with_http_info(tier_1_id, segments_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_segment_statistics ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_segment_statistics"
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.get_segment_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_segment_statistics, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_segment_statistics, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segments-id}/statistics'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segments-id' + '}', segments_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_segment_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get SpoofGuard profile
    # API will return details of the SpoofGuard profile with given id. If the profile does not exist, it will return 404. 
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param [Hash] opts the optional parameters
    # @return [SpoofGuardProfile]
    def get_spoof_guard_profile(spoofguard_profile_id, opts = {})
      data, _status_code, _headers = get_spoof_guard_profile_with_http_info(spoofguard_profile_id, opts)
      data
    end

    # Get SpoofGuard profile
    # API will return details of the SpoofGuard profile with given id. If the profile does not exist, it will return 404. 
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param [Hash] opts the optional parameters
    # @return [Array<(SpoofGuardProfile, Fixnum, Hash)>] SpoofGuardProfile data, response status code and response headers
    def get_spoof_guard_profile_with_http_info(spoofguard_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_spoof_guard_profile ...'
      end
      # verify the required parameter 'spoofguard_profile_id' is set
      if @api_client.config.client_side_validation && spoofguard_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'spoofguard_profile_id' when calling SegmentsApi.get_spoof_guard_profile"
      end
      # resource path
      local_var_path = '/infra/spoofguard-profiles/{spoofguard-profile-id}'.sub('{' + 'spoofguard-profile-id' + '}', spoofguard_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SpoofGuardProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_spoof_guard_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tier-1 segment MAC table
    # Returns MAC table for a segment 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [SegmentMacAddressListResult]
    def get_tier1_segment_mac_table(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = get_tier1_segment_mac_table_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # Get Tier-1 segment MAC table
    # Returns MAC table for a segment 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(SegmentMacAddressListResult, Fixnum, Hash)>] SegmentMacAddressListResult data, response status code and response headers
    def get_tier1_segment_mac_table_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_tier1_segment_mac_table ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_tier1_segment_mac_table"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_tier1_segment_mac_table"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_tier1_segment_mac_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_tier1_segment_mac_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/mac-table'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentMacAddressListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_tier1_segment_mac_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tier-1 segment MAC table in CSV
    # Returns MAC table for a segment 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [MacAddressCsvListResult]
    def get_tier1_segment_mac_table_in_csv(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = get_tier1_segment_mac_table_in_csv_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # Get Tier-1 segment MAC table in CSV
    # Returns MAC table for a segment 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(MacAddressCsvListResult, Fixnum, Hash)>] MacAddressCsvListResult data, response status code and response headers
    def get_tier1_segment_mac_table_in_csv_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_tier1_segment_mac_table_in_csv ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_tier1_segment_mac_table_in_csv"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_tier1_segment_mac_table_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/mac-table?format=csv'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MacAddressCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_tier1_segment_mac_table_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tier-1 segment port by ID
    # Get detail information on a Tier-1 segment port by giving ID. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [SegmentPort]
    def get_tier1_segment_port(tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = get_tier1_segment_port_with_http_info(tier_1_id, segment_id, port_id, opts)
      data
    end

    # Get Tier-1 segment port by ID
    # Get detail information on a Tier-1 segment port by giving ID. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentPort, Fixnum, Hash)>] SegmentPort data, response status code and response headers
    def get_tier1_segment_port_with_http_info(tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_tier1_segment_port ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_tier1_segment_port"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_tier1_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.get_tier1_segment_port"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPort')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_tier1_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get MAC table for tier-1 segment port
    # Returns MAC table for a segment port 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [SegmentPortMacAddressListResult]
    def get_tier1_segment_port_mac_table(tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = get_tier1_segment_port_mac_table_with_http_info(tier_1_id, segment_id, port_id, opts)
      data
    end

    # Get MAC table for tier-1 segment port
    # Returns MAC table for a segment port 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(SegmentPortMacAddressListResult, Fixnum, Hash)>] SegmentPortMacAddressListResult data, response status code and response headers
    def get_tier1_segment_port_mac_table_with_http_info(tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_tier1_segment_port_mac_table ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_tier1_segment_port_mac_table"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_tier1_segment_port_mac_table"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.get_tier1_segment_port_mac_table"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_tier1_segment_port_mac_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_tier1_segment_port_mac_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/mac-table'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortMacAddressListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_tier1_segment_port_mac_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get tier-1 segment port MAC table in CSV
    # Returns MAC table for a segment port 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [SegmentPortMacAddressCsvListResult]
    def get_tier1_segment_port_mac_table_in_csv(tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = get_tier1_segment_port_mac_table_in_csv_with_http_info(tier_1_id, segment_id, port_id, opts)
      data
    end

    # Get tier-1 segment port MAC table in CSV
    # Returns MAC table for a segment port 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(SegmentPortMacAddressCsvListResult, Fixnum, Hash)>] SegmentPortMacAddressCsvListResult data, response status code and response headers
    def get_tier1_segment_port_mac_table_in_csv_with_http_info(tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_tier1_segment_port_mac_table_in_csv ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_tier1_segment_port_mac_table_in_csv"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_tier1_segment_port_mac_table_in_csv"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.get_tier1_segment_port_mac_table_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/mac-table?format=csv'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortMacAddressCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_tier1_segment_port_mac_table_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get tier-1  segment port state
    # Returns tier-1 segment port state on enforcement point 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [SegmentPortState]
    def get_tier1_segment_port_state(tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = get_tier1_segment_port_state_with_http_info(tier_1_id, segment_id, port_id, opts)
      data
    end

    # Get tier-1  segment port state
    # Returns tier-1 segment port state on enforcement point 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(SegmentPortState, Fixnum, Hash)>] SegmentPortState data, response status code and response headers
    def get_tier1_segment_port_state_with_http_info(tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_tier1_segment_port_state ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_tier1_segment_port_state"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_tier1_segment_port_state"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.get_tier1_segment_port_state"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/state'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_tier1_segment_port_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get tier-1 segment TEP table
    # Returns TEP table for a segment 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyTepListResult]
    def get_tier1_segment_tep_table(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = get_tier1_segment_tep_table_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # Get tier-1 segment TEP table
    # Returns TEP table for a segment 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyTepListResult, Fixnum, Hash)>] PolicyTepListResult data, response status code and response headers
    def get_tier1_segment_tep_table_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_tier1_segment_tep_table ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_tier1_segment_tep_table"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_tier1_segment_tep_table"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_tier1_segment_tep_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.get_tier1_segment_tep_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/tep-table'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyTepListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_tier1_segment_tep_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get tier-1 segment TEP table in CSV
    # Returns TEP table for a segment in CSV 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyTepCsvListResult]
    def get_tier1_segment_tep_table_in_csv(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = get_tier1_segment_tep_table_in_csv_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # Get tier-1 segment TEP table in CSV
    # Returns TEP table for a segment in CSV 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyTepCsvListResult, Fixnum, Hash)>] PolicyTepCsvListResult data, response status code and response headers
    def get_tier1_segment_tep_table_in_csv_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_tier1_segment_tep_table_in_csv ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_tier1_segment_tep_table_in_csv"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_tier1_segment_tep_table_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/tep-table?format=csv'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyTepCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_tier1_segment_tep_table_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get tier-1 segments by configuration state
    # Returns all tier-1 segments with configuration state on the enforcement point specified in the request 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :configuration_state Configuration state of the segment on enforcement point
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [SegmentConfigurationStateListResult]
    def get_tier1_segments_by_state(tier_1_id, opts = {})
      data, _status_code, _headers = get_tier1_segments_by_state_with_http_info(tier_1_id, opts)
      data
    end

    # Get tier-1 segments by configuration state
    # Returns all tier-1 segments with configuration state on the enforcement point specified in the request 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :configuration_state Configuration state of the segment on enforcement point
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(SegmentConfigurationStateListResult, Fixnum, Hash)>] SegmentConfigurationStateListResult data, response status code and response headers
    def get_tier1_segments_by_state_with_http_info(tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_tier1_segments_by_state ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.get_tier1_segments_by_state"
      end
      if @api_client.config.client_side_validation && opts[:'configuration_state'] && !['pending', 'in_progress', 'success', 'failed', 'partial_success', 'orphaned', 'unknown'].include?(opts[:'configuration_state'])
        fail ArgumentError, 'invalid value for "configuration_state", must be one of pending, in_progress, success, failed, partial_success, orphaned, unknown'
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/state'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'configuration_state'] = opts[:'configuration_state'] if !opts[:'configuration_state'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConfigurationStateListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_tier1_segments_by_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create IP Discovery Profile
    # API will create IP Discovery profile. 
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param ip_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def global_infra_create_ip_discovery_profile(ip_discovery_profile_id, ip_discovery_profile, opts = {})
      global_infra_create_ip_discovery_profile_with_http_info(ip_discovery_profile_id, ip_discovery_profile, opts)
      nil
    end

    # Create IP Discovery Profile
    # API will create IP Discovery profile. 
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param ip_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_create_ip_discovery_profile_with_http_info(ip_discovery_profile_id, ip_discovery_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_create_ip_discovery_profile ...'
      end
      # verify the required parameter 'ip_discovery_profile_id' is set
      if @api_client.config.client_side_validation && ip_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'ip_discovery_profile_id' when calling SegmentsApi.global_infra_create_ip_discovery_profile"
      end
      # verify the required parameter 'ip_discovery_profile' is set
      if @api_client.config.client_side_validation && ip_discovery_profile.nil?
        fail ArgumentError, "Missing the required parameter 'ip_discovery_profile' when calling SegmentsApi.global_infra_create_ip_discovery_profile"
      end
      # resource path
      local_var_path = '/global-infra/ip-discovery-profiles/{ip-discovery-profile-id}'.sub('{' + 'ip-discovery-profile-id' + '}', ip_discovery_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(ip_discovery_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_create_ip_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Mac Discovery Profile
    # API will create Mac Discovery profile. 
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param mac_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def global_infra_create_mac_discovery_profile(mac_discovery_profile_id, mac_discovery_profile, opts = {})
      global_infra_create_mac_discovery_profile_with_http_info(mac_discovery_profile_id, mac_discovery_profile, opts)
      nil
    end

    # Create Mac Discovery Profile
    # API will create Mac Discovery profile. 
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param mac_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_create_mac_discovery_profile_with_http_info(mac_discovery_profile_id, mac_discovery_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_create_mac_discovery_profile ...'
      end
      # verify the required parameter 'mac_discovery_profile_id' is set
      if @api_client.config.client_side_validation && mac_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'mac_discovery_profile_id' when calling SegmentsApi.global_infra_create_mac_discovery_profile"
      end
      # verify the required parameter 'mac_discovery_profile' is set
      if @api_client.config.client_side_validation && mac_discovery_profile.nil?
        fail ArgumentError, "Missing the required parameter 'mac_discovery_profile' when calling SegmentsApi.global_infra_create_mac_discovery_profile"
      end
      # resource path
      local_var_path = '/global-infra/mac-discovery-profiles/{mac-discovery-profile-id}'.sub('{' + 'mac-discovery-profile-id' + '}', mac_discovery_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(mac_discovery_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_create_mac_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update an infra segment port
    # Create an infra segment port if it does not exist based on the IDs, or update existing port information by replacing the port object already exists. 
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [SegmentPort]
    def global_infra_create_or_replace_infra_segment_port(segment_id, port_id, segment_port, opts = {})
      data, _status_code, _headers = global_infra_create_or_replace_infra_segment_port_with_http_info(segment_id, port_id, segment_port, opts)
      data
    end

    # Create or update an infra segment port
    # Create an infra segment port if it does not exist based on the IDs, or update existing port information by replacing the port object already exists. 
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentPort, Fixnum, Hash)>] SegmentPort data, response status code and response headers
    def global_infra_create_or_replace_infra_segment_port_with_http_info(segment_id, port_id, segment_port, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_create_or_replace_infra_segment_port ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_create_or_replace_infra_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_create_or_replace_infra_segment_port"
      end
      # verify the required parameter 'segment_port' is set
      if @api_client.config.client_side_validation && segment_port.nil?
        fail ArgumentError, "Missing the required parameter 'segment_port' when calling SegmentsApi.global_infra_create_or_replace_infra_segment_port"
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/ports/{port-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_port)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPort')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_create_or_replace_infra_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or Replace QoS profile.
    # Create or Replace QoS profile. 
    # @param qos_profile_id QoS profile Id
    # @param qo_s_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [QoSProfile]
    def global_infra_create_or_replace_qo_s_profile(qos_profile_id, qo_s_profile, opts = {})
      data, _status_code, _headers = global_infra_create_or_replace_qo_s_profile_with_http_info(qos_profile_id, qo_s_profile, opts)
      data
    end

    # Create or Replace QoS profile.
    # Create or Replace QoS profile. 
    # @param qos_profile_id QoS profile Id
    # @param qo_s_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(QoSProfile, Fixnum, Hash)>] QoSProfile data, response status code and response headers
    def global_infra_create_or_replace_qo_s_profile_with_http_info(qos_profile_id, qo_s_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_create_or_replace_qo_s_profile ...'
      end
      # verify the required parameter 'qos_profile_id' is set
      if @api_client.config.client_side_validation && qos_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'qos_profile_id' when calling SegmentsApi.global_infra_create_or_replace_qo_s_profile"
      end
      # verify the required parameter 'qo_s_profile' is set
      if @api_client.config.client_side_validation && qo_s_profile.nil?
        fail ArgumentError, "Missing the required parameter 'qo_s_profile' when calling SegmentsApi.global_infra_create_or_replace_qo_s_profile"
      end
      # resource path
      local_var_path = '/global-infra/qos-profiles/{qos-profile-id}'.sub('{' + 'qos-profile-id' + '}', qos_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(qo_s_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'QoSProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_create_or_replace_qo_s_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a Tier-1 segment port
    # Create a Tier-1 segment port if it does not exist based on the IDs, or update existing port information by replacing the port object already exists. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [SegmentPort]
    def global_infra_create_or_replace_tier1_segment_port(tier_1_id, segment_id, port_id, segment_port, opts = {})
      data, _status_code, _headers = global_infra_create_or_replace_tier1_segment_port_with_http_info(tier_1_id, segment_id, port_id, segment_port, opts)
      data
    end

    # Create or update a Tier-1 segment port
    # Create a Tier-1 segment port if it does not exist based on the IDs, or update existing port information by replacing the port object already exists. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentPort, Fixnum, Hash)>] SegmentPort data, response status code and response headers
    def global_infra_create_or_replace_tier1_segment_port_with_http_info(tier_1_id, segment_id, port_id, segment_port, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_create_or_replace_tier1_segment_port ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_create_or_replace_tier1_segment_port"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_create_or_replace_tier1_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_create_or_replace_tier1_segment_port"
      end
      # verify the required parameter 'segment_port' is set
      if @api_client.config.client_side_validation && segment_port.nil?
        fail ArgumentError, "Missing the required parameter 'segment_port' when calling SegmentsApi.global_infra_create_or_replace_tier1_segment_port"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_port)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPort')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_create_or_replace_tier1_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or replace the infra segment port security profile binding map
    # API will create or replace the port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortSecurityProfileBindingMap]
    def global_infra_create_or_update_infra_segment_port_security_profile_binding(segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      data, _status_code, _headers = global_infra_create_or_update_infra_segment_port_security_profile_binding_with_http_info(segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts)
      data
    end

    # Create or replace the infra segment port security profile binding map
    # API will create or replace the port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortSecurityProfileBindingMap, Fixnum, Hash)>] PortSecurityProfileBindingMap data, response status code and response headers
    def global_infra_create_or_update_infra_segment_port_security_profile_binding_with_http_info(segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_create_or_update_infra_segment_port_security_profile_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_create_or_update_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_create_or_update_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.global_infra_create_or_update_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map' when calling SegmentsApi.global_infra_create_or_update_infra_segment_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_security_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_create_or_update_infra_segment_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or replace the port security profile binding map
    # API will create or replace the port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortSecurityProfileBindingMap]
    def global_infra_create_or_update_port_security_profile_binding(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      data, _status_code, _headers = global_infra_create_or_update_port_security_profile_binding_with_http_info(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts)
      data
    end

    # Create or replace the port security profile binding map
    # API will create or replace the port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortSecurityProfileBindingMap, Fixnum, Hash)>] PortSecurityProfileBindingMap data, response status code and response headers
    def global_infra_create_or_update_port_security_profile_binding_with_http_info(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_create_or_update_port_security_profile_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_create_or_update_port_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_create_or_update_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_create_or_update_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.global_infra_create_or_update_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map' when calling SegmentsApi.global_infra_create_or_update_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_security_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_create_or_update_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # PUT segment security profile id
    # Create or replace a segment security profile 
    # @param segment_security_profile_id Segment security profile id
    # @param segment_security_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [SegmentSecurityProfile]
    def global_infra_create_or_update_segment_security_profile(segment_security_profile_id, segment_security_profile, opts = {})
      data, _status_code, _headers = global_infra_create_or_update_segment_security_profile_with_http_info(segment_security_profile_id, segment_security_profile, opts)
      data
    end

    # PUT segment security profile id
    # Create or replace a segment security profile 
    # @param segment_security_profile_id Segment security profile id
    # @param segment_security_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(SegmentSecurityProfile, Fixnum, Hash)>] SegmentSecurityProfile data, response status code and response headers
    def global_infra_create_or_update_segment_security_profile_with_http_info(segment_security_profile_id, segment_security_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_create_or_update_segment_security_profile ...'
      end
      # verify the required parameter 'segment_security_profile_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_id' when calling SegmentsApi.global_infra_create_or_update_segment_security_profile"
      end
      # verify the required parameter 'segment_security_profile' is set
      if @api_client.config.client_side_validation && segment_security_profile.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile' when calling SegmentsApi.global_infra_create_or_update_segment_security_profile"
      end
      # resource path
      local_var_path = '/global-infra/segment-security-profiles/{segment-security-profile-id}'.sub('{' + 'segment-security-profile-id' + '}', segment_security_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_security_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_create_or_update_segment_security_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or replace SpoofGuard profile
    # API will create or replace SpoofGuard profile. 
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param spoof_guard_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [SpoofGuardProfile]
    def global_infra_create_or_update_spoof_guard_profile(spoofguard_profile_id, spoof_guard_profile, opts = {})
      data, _status_code, _headers = global_infra_create_or_update_spoof_guard_profile_with_http_info(spoofguard_profile_id, spoof_guard_profile, opts)
      data
    end

    # Create or replace SpoofGuard profile
    # API will create or replace SpoofGuard profile. 
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param spoof_guard_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(SpoofGuardProfile, Fixnum, Hash)>] SpoofGuardProfile data, response status code and response headers
    def global_infra_create_or_update_spoof_guard_profile_with_http_info(spoofguard_profile_id, spoof_guard_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_create_or_update_spoof_guard_profile ...'
      end
      # verify the required parameter 'spoofguard_profile_id' is set
      if @api_client.config.client_side_validation && spoofguard_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'spoofguard_profile_id' when calling SegmentsApi.global_infra_create_or_update_spoof_guard_profile"
      end
      # verify the required parameter 'spoof_guard_profile' is set
      if @api_client.config.client_side_validation && spoof_guard_profile.nil?
        fail ArgumentError, "Missing the required parameter 'spoof_guard_profile' when calling SegmentsApi.global_infra_create_or_update_spoof_guard_profile"
      end
      # resource path
      local_var_path = '/global-infra/spoofguard-profiles/{spoofguard-profile-id}'.sub('{' + 'spoofguard-profile-id' + '}', spoofguard_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(spoof_guard_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SpoofGuardProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_create_or_update_spoof_guard_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Infra Port Discovery Profile Binding Profile
    # API will delete Infra Port Discovery Profile Binding Profile
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def global_infra_delete_infra_port_discovery_binding(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, opts = {})
      global_infra_delete_infra_port_discovery_binding_with_http_info(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, opts)
      nil
    end

    # Delete Infra Port Discovery Profile Binding Profile
    # API will delete Infra Port Discovery Profile Binding Profile
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_delete_infra_port_discovery_binding_with_http_info(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_delete_infra_port_discovery_binding ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.global_infra_delete_infra_port_discovery_binding"
      end
      # verify the required parameter 'infra_port_id' is set
      if @api_client.config.client_side_validation && infra_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_port_id' when calling SegmentsApi.global_infra_delete_infra_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.global_infra_delete_infra_port_discovery_binding"
      end
      # resource path
      local_var_path = '/global-infra/segments/{infra-segment-id}/ports/{infra-port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'infra-port-id' + '}', infra_port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_delete_infra_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Port QoS Profile Binding Profile
    # API will delete Port QoS Profile Binding Profile.
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def global_infra_delete_infra_port_qo_s_binding(segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      global_infra_delete_infra_port_qo_s_binding_with_http_info(segment_id, port_id, port_qos_profile_binding_map_id, opts)
      nil
    end

    # Delete Port QoS Profile Binding Profile
    # API will delete Port QoS Profile Binding Profile.
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_delete_infra_port_qo_s_binding_with_http_info(segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_delete_infra_port_qo_s_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_delete_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_delete_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.global_infra_delete_infra_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_delete_infra_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete an infra segment port
    # Delete an infra segment port by giving ID. Please note that this operation will not delete the segment port from vCenter Server if the port was connected to a Virtual Machine. Please connect Virtual Machine to another network for the segment port to be deleted from vCenter Server. Do not provide any parameters to this call unless it is during VIF restore workflow by NSX container plugin(NCP). 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def global_infra_delete_infra_segment_port(segment_id, port_id, opts = {})
      global_infra_delete_infra_segment_port_with_http_info(segment_id, port_id, opts)
      nil
    end

    # Delete an infra segment port
    # Delete an infra segment port by giving ID. Please note that this operation will not delete the segment port from vCenter Server if the port was connected to a Virtual Machine. Please connect Virtual Machine to another network for the segment port to be deleted from vCenter Server. Do not provide any parameters to this call unless it is during VIF restore workflow by NSX container plugin(NCP). 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_delete_infra_segment_port_with_http_info(segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_delete_infra_segment_port ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_delete_infra_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_delete_infra_segment_port"
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/ports/{port-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_delete_infra_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete the infra segment port security profile binding map
    # API will delete the port security profile binding map. 
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def global_infra_delete_infra_segment_port_security_profile_binding(segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      global_infra_delete_infra_segment_port_security_profile_binding_with_http_info(segment_id, port_id, port_security_profile_binding_map_id, opts)
      nil
    end

    # Delete the infra segment port security profile binding map
    # API will delete the port security profile binding map. 
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_delete_infra_segment_port_security_profile_binding_with_http_info(segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_delete_infra_segment_port_security_profile_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_delete_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_delete_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.global_infra_delete_infra_segment_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_delete_infra_segment_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete IP Discovery Profile
    # API will delete IP Discovery profile. 
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def global_infra_delete_ip_discovery_profile(ip_discovery_profile_id, opts = {})
      global_infra_delete_ip_discovery_profile_with_http_info(ip_discovery_profile_id, opts)
      nil
    end

    # Delete IP Discovery Profile
    # API will delete IP Discovery profile. 
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_delete_ip_discovery_profile_with_http_info(ip_discovery_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_delete_ip_discovery_profile ...'
      end
      # verify the required parameter 'ip_discovery_profile_id' is set
      if @api_client.config.client_side_validation && ip_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'ip_discovery_profile_id' when calling SegmentsApi.global_infra_delete_ip_discovery_profile"
      end
      # resource path
      local_var_path = '/global-infra/ip-discovery-profiles/{ip-discovery-profile-id}'.sub('{' + 'ip-discovery-profile-id' + '}', ip_discovery_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_delete_ip_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete L2 Bridge Endpoint Profile
    # API will delete L2 bridge profile with ID profile-id
    # @param site_id site ID
    # @param enforcement_point_id enforcement point ID
    # @param profile_id profile ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def global_infra_delete_l2_bridge_profile(site_id, enforcement_point_id, profile_id, opts = {})
      global_infra_delete_l2_bridge_profile_with_http_info(site_id, enforcement_point_id, profile_id, opts)
      nil
    end

    # Delete L2 Bridge Endpoint Profile
    # API will delete L2 bridge profile with ID profile-id
    # @param site_id site ID
    # @param enforcement_point_id enforcement point ID
    # @param profile_id profile ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_delete_l2_bridge_profile_with_http_info(site_id, enforcement_point_id, profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_delete_l2_bridge_profile ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SegmentsApi.global_infra_delete_l2_bridge_profile"
      end
      # verify the required parameter 'enforcement_point_id' is set
      if @api_client.config.client_side_validation && enforcement_point_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcement_point_id' when calling SegmentsApi.global_infra_delete_l2_bridge_profile"
      end
      # verify the required parameter 'profile_id' is set
      if @api_client.config.client_side_validation && profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'profile_id' when calling SegmentsApi.global_infra_delete_l2_bridge_profile"
      end
      # resource path
      local_var_path = '/global-infra/sites/{site-id}/enforcement-points/{enforcement-point-id}/edge-bridge-profiles/{profile-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcement-point-id' + '}', enforcement_point_id.to_s).sub('{' + 'profile-id' + '}', profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_delete_l2_bridge_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Mac Discovery Profile
    # API will delete Mac Discovery profile. 
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def global_infra_delete_mac_discovery_profile(mac_discovery_profile_id, opts = {})
      global_infra_delete_mac_discovery_profile_with_http_info(mac_discovery_profile_id, opts)
      nil
    end

    # Delete Mac Discovery Profile
    # API will delete Mac Discovery profile. 
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_delete_mac_discovery_profile_with_http_info(mac_discovery_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_delete_mac_discovery_profile ...'
      end
      # verify the required parameter 'mac_discovery_profile_id' is set
      if @api_client.config.client_side_validation && mac_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'mac_discovery_profile_id' when calling SegmentsApi.global_infra_delete_mac_discovery_profile"
      end
      # resource path
      local_var_path = '/global-infra/mac-discovery-profiles/{mac-discovery-profile-id}'.sub('{' + 'mac-discovery-profile-id' + '}', mac_discovery_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_delete_mac_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Port Discovery Profile Binding Profile
    # API will delete Port Discovery Profile Binding Profile
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def global_infra_delete_port_discovery_binding(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, opts = {})
      global_infra_delete_port_discovery_binding_with_http_info(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, opts)
      nil
    end

    # Delete Port Discovery Profile Binding Profile
    # API will delete Port Discovery Profile Binding Profile
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_delete_port_discovery_binding_with_http_info(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_delete_port_discovery_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_delete_port_discovery_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_delete_port_discovery_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_delete_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.global_infra_delete_port_discovery_binding"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_delete_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Port QoS Profile Binding Profile
    # API will delete Port QoS Profile Binding Profile.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def global_infra_delete_port_qo_s_binding(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      global_infra_delete_port_qo_s_binding_with_http_info(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, opts)
      nil
    end

    # Delete Port QoS Profile Binding Profile
    # API will delete Port QoS Profile Binding Profile.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_delete_port_qo_s_binding_with_http_info(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_delete_port_qo_s_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_delete_port_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_delete_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_delete_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.global_infra_delete_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_delete_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete the port security profile binding map
    # API will delete the port security profile binding map. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def global_infra_delete_port_security_profile_binding(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      global_infra_delete_port_security_profile_binding_with_http_info(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, opts)
      nil
    end

    # Delete the port security profile binding map
    # API will delete the port security profile binding map. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_delete_port_security_profile_binding_with_http_info(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_delete_port_security_profile_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_delete_port_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_delete_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_delete_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.global_infra_delete_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_delete_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete QoS profile
    # API will delete QoS profile. 
    # @param qos_profile_id QoS profile Id
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def global_infra_delete_qo_s_profile(qos_profile_id, opts = {})
      global_infra_delete_qo_s_profile_with_http_info(qos_profile_id, opts)
      nil
    end

    # Delete QoS profile
    # API will delete QoS profile. 
    # @param qos_profile_id QoS profile Id
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_delete_qo_s_profile_with_http_info(qos_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_delete_qo_s_profile ...'
      end
      # verify the required parameter 'qos_profile_id' is set
      if @api_client.config.client_side_validation && qos_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'qos_profile_id' when calling SegmentsApi.global_infra_delete_qo_s_profile"
      end
      # resource path
      local_var_path = '/global-infra/qos-profiles/{qos-profile-id}'.sub('{' + 'qos-profile-id' + '}', qos_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_delete_qo_s_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # DELETE segment security profile
    # API will delete segment security profile with the given id. 
    # @param segment_security_profile_id Segment security profile id
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def global_infra_delete_segment_security_profile(segment_security_profile_id, opts = {})
      global_infra_delete_segment_security_profile_with_http_info(segment_security_profile_id, opts)
      nil
    end

    # DELETE segment security profile
    # API will delete segment security profile with the given id. 
    # @param segment_security_profile_id Segment security profile id
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_delete_segment_security_profile_with_http_info(segment_security_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_delete_segment_security_profile ...'
      end
      # verify the required parameter 'segment_security_profile_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_id' when calling SegmentsApi.global_infra_delete_segment_security_profile"
      end
      # resource path
      local_var_path = '/global-infra/segment-security-profiles/{segment-security-profile-id}'.sub('{' + 'segment-security-profile-id' + '}', segment_security_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_delete_segment_security_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete SpoofGuard profile
    # API will delete SpoofGuard profile with the given id. 
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def global_infra_delete_spoof_guard_profile(spoofguard_profile_id, opts = {})
      global_infra_delete_spoof_guard_profile_with_http_info(spoofguard_profile_id, opts)
      nil
    end

    # Delete SpoofGuard profile
    # API will delete SpoofGuard profile with the given id. 
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_delete_spoof_guard_profile_with_http_info(spoofguard_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_delete_spoof_guard_profile ...'
      end
      # verify the required parameter 'spoofguard_profile_id' is set
      if @api_client.config.client_side_validation && spoofguard_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'spoofguard_profile_id' when calling SegmentsApi.global_infra_delete_spoof_guard_profile"
      end
      # resource path
      local_var_path = '/global-infra/spoofguard-profiles/{spoofguard-profile-id}'.sub('{' + 'spoofguard-profile-id' + '}', spoofguard_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_delete_spoof_guard_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a Tier-1 segment port. Please note that this operation will not delete the segment port from vCenter Server if the port was connected to a Virtual Machine. Please connect Virtual Machine to another network for the segment port to be deleted from vCenter Server. 
    # Delete a Tier-1 segment port by giving ID. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def global_infra_delete_tier1_segment_port(tier_1_id, segment_id, port_id, opts = {})
      global_infra_delete_tier1_segment_port_with_http_info(tier_1_id, segment_id, port_id, opts)
      nil
    end

    # Delete a Tier-1 segment port. Please note that this operation will not delete the segment port from vCenter Server if the port was connected to a Virtual Machine. Please connect Virtual Machine to another network for the segment port to be deleted from vCenter Server. 
    # Delete a Tier-1 segment port by giving ID. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_delete_tier1_segment_port_with_http_info(tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_delete_tier1_segment_port ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_delete_tier1_segment_port"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_delete_tier1_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_delete_tier1_segment_port"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_delete_tier1_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get downlink port Address Resolution Protocol Proxies for infra segment
    # Returns ARP proxy table for downlink port on connected to the segment 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyArpProxyTableListResult]
    def global_infra_get_downlink_port_arp_proxies_for_infra_segment(segment_id, opts = {})
      data, _status_code, _headers = global_infra_get_downlink_port_arp_proxies_for_infra_segment_with_http_info(segment_id, opts)
      data
    end

    # Get downlink port Address Resolution Protocol Proxies for infra segment
    # Returns ARP proxy table for downlink port on connected to the segment 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyArpProxyTableListResult, Fixnum, Hash)>] PolicyArpProxyTableListResult data, response status code and response headers
    def global_infra_get_downlink_port_arp_proxies_for_infra_segment_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_downlink_port_arp_proxies_for_infra_segment ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_downlink_port_arp_proxies_for_infra_segment"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_downlink_port_arp_proxies_for_infra_segment, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_downlink_port_arp_proxies_for_infra_segment, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/arp-proxy'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyArpProxyTableListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_downlink_port_arp_proxies_for_infra_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get downlink port Address Resolution Protocol Proxies for infra segment in CSV format
    # Returns ARP proxy table for downlink port on connected to the segment in CSV format 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyArpProxyTableCsvListResult]
    def global_infra_get_downlink_port_arp_proxies_for_infra_segment_in_csv(segment_id, opts = {})
      data, _status_code, _headers = global_infra_get_downlink_port_arp_proxies_for_infra_segment_in_csv_with_http_info(segment_id, opts)
      data
    end

    # Get downlink port Address Resolution Protocol Proxies for infra segment in CSV format
    # Returns ARP proxy table for downlink port on connected to the segment in CSV format 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyArpProxyTableCsvListResult, Fixnum, Hash)>] PolicyArpProxyTableCsvListResult data, response status code and response headers
    def global_infra_get_downlink_port_arp_proxies_for_infra_segment_in_csv_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_downlink_port_arp_proxies_for_infra_segment_in_csv ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_downlink_port_arp_proxies_for_infra_segment_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/arp-proxy?format=csv'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyArpProxyTableCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_downlink_port_arp_proxies_for_infra_segment_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get downlink port Address Resolution Protocol Proxies for tier-1 segment
    # Returns ARP proxy table for downlink port on connected to the segment 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyArpProxyTableListResult]
    def global_infra_get_downlink_port_arp_proxies_for_tier1_segment(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = global_infra_get_downlink_port_arp_proxies_for_tier1_segment_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # Get downlink port Address Resolution Protocol Proxies for tier-1 segment
    # Returns ARP proxy table for downlink port on connected to the segment 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyArpProxyTableListResult, Fixnum, Hash)>] PolicyArpProxyTableListResult data, response status code and response headers
    def global_infra_get_downlink_port_arp_proxies_for_tier1_segment_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_downlink_port_arp_proxies_for_tier1_segment ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_get_downlink_port_arp_proxies_for_tier1_segment"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_downlink_port_arp_proxies_for_tier1_segment"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_downlink_port_arp_proxies_for_tier1_segment, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_downlink_port_arp_proxies_for_tier1_segment, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/arp-proxy'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyArpProxyTableListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_downlink_port_arp_proxies_for_tier1_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get downlink port Address Resolution Protocol Proxies for tier-1 segment in CSV
    # Returns ARP proxy table for downlink port on connected to the segment in CSV 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyArpProxyTableCsvListResult]
    def global_infra_get_downlink_port_arp_proxies_for_tier1_segment_in_csv(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = global_infra_get_downlink_port_arp_proxies_for_tier1_segment_in_csv_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # Get downlink port Address Resolution Protocol Proxies for tier-1 segment in CSV
    # Returns ARP proxy table for downlink port on connected to the segment in CSV 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyArpProxyTableCsvListResult, Fixnum, Hash)>] PolicyArpProxyTableCsvListResult data, response status code and response headers
    def global_infra_get_downlink_port_arp_proxies_for_tier1_segment_in_csv_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_downlink_port_arp_proxies_for_tier1_segment_in_csv ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_get_downlink_port_arp_proxies_for_tier1_segment_in_csv"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_downlink_port_arp_proxies_for_tier1_segment_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/arp-proxy?format=csv'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyArpProxyTableCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_downlink_port_arp_proxies_for_tier1_segment_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Group discovery profile binding map
    # API will get Group discovery profile binding map
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param discovery_profile_binding_map_id Group discovery profile binding map ID
    # @param [Hash] opts the optional parameters
    # @return [GroupDiscoveryProfileBindingMap]
    def global_infra_get_group_discovery_profile_binding(domain_id, group_id, discovery_profile_binding_map_id, opts = {})
      data, _status_code, _headers = global_infra_get_group_discovery_profile_binding_with_http_info(domain_id, group_id, discovery_profile_binding_map_id, opts)
      data
    end

    # Get Group discovery profile binding map
    # API will get Group discovery profile binding map
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param discovery_profile_binding_map_id Group discovery profile binding map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(GroupDiscoveryProfileBindingMap, Fixnum, Hash)>] GroupDiscoveryProfileBindingMap data, response status code and response headers
    def global_infra_get_group_discovery_profile_binding_with_http_info(domain_id, group_id, discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_group_discovery_profile_binding ...'
      end
      # verify the required parameter 'domain_id' is set
      if @api_client.config.client_side_validation && domain_id.nil?
        fail ArgumentError, "Missing the required parameter 'domain_id' when calling SegmentsApi.global_infra_get_group_discovery_profile_binding"
      end
      # verify the required parameter 'group_id' is set
      if @api_client.config.client_side_validation && group_id.nil?
        fail ArgumentError, "Missing the required parameter 'group_id' when calling SegmentsApi.global_infra_get_group_discovery_profile_binding"
      end
      # verify the required parameter 'discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'discovery_profile_binding_map_id' when calling SegmentsApi.global_infra_get_group_discovery_profile_binding"
      end
      # resource path
      local_var_path = '/global-infra/domains/{domain-id}/groups/{group-id}/discovery-profile-binding-maps/{discovery-profile-binding-map-id}'.sub('{' + 'domain-id' + '}', domain_id.to_s).sub('{' + 'group-id' + '}', group_id.to_s).sub('{' + 'discovery-profile-binding-map-id' + '}', discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'GroupDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_group_discovery_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Infra Port Discovery Profile Binding Map
    # API will get Infra Port Discovery Profile Binding Map 
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [PortDiscoveryProfileBindingMap]
    def global_infra_get_infra_port_discovery_binding(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, opts = {})
      data, _status_code, _headers = global_infra_get_infra_port_discovery_binding_with_http_info(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, opts)
      data
    end

    # Get Infra Port Discovery Profile Binding Map
    # API will get Infra Port Discovery Profile Binding Map 
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortDiscoveryProfileBindingMap, Fixnum, Hash)>] PortDiscoveryProfileBindingMap data, response status code and response headers
    def global_infra_get_infra_port_discovery_binding_with_http_info(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_infra_port_discovery_binding ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.global_infra_get_infra_port_discovery_binding"
      end
      # verify the required parameter 'infra_port_id' is set
      if @api_client.config.client_side_validation && infra_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_port_id' when calling SegmentsApi.global_infra_get_infra_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.global_infra_get_infra_port_discovery_binding"
      end
      # resource path
      local_var_path = '/global-infra/segments/{infra-segment-id}/ports/{infra-port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'infra-port-id' + '}', infra_port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_infra_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Port QoS Profile Binding Map
    # API will get Port QoS Profile Binding Map. 
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [PortQoSProfileBindingMap]
    def global_infra_get_infra_port_qo_s_binding(segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      data, _status_code, _headers = global_infra_get_infra_port_qo_s_binding_with_http_info(segment_id, port_id, port_qos_profile_binding_map_id, opts)
      data
    end

    # Get Port QoS Profile Binding Map
    # API will get Port QoS Profile Binding Map. 
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortQoSProfileBindingMap, Fixnum, Hash)>] PortQoSProfileBindingMap data, response status code and response headers
    def global_infra_get_infra_port_qo_s_binding_with_http_info(segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_infra_port_qo_s_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_get_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.global_infra_get_infra_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_infra_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Infra Segment Discovery Profile Binding Map
    # API will get Infra Segment Discovery Profile Binding Map 
    # @param infra_segment_id Infra Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [SegmentDiscoveryProfileBindingMap]
    def global_infra_get_infra_segment_discovery_binding(infra_segment_id, segment_discovery_profile_binding_map_id, opts = {})
      data, _status_code, _headers = global_infra_get_infra_segment_discovery_binding_with_http_info(infra_segment_id, segment_discovery_profile_binding_map_id, opts)
      data
    end

    # Get Infra Segment Discovery Profile Binding Map
    # API will get Infra Segment Discovery Profile Binding Map 
    # @param infra_segment_id Infra Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentDiscoveryProfileBindingMap, Fixnum, Hash)>] SegmentDiscoveryProfileBindingMap data, response status code and response headers
    def global_infra_get_infra_segment_discovery_binding_with_http_info(infra_segment_id, segment_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_infra_segment_discovery_binding ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.global_infra_get_infra_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map_id' when calling SegmentsApi.global_infra_get_infra_segment_discovery_binding"
      end
      # resource path
      local_var_path = '/global-infra/segments/{infra-segment-id}/segment-discovery-profile-binding-maps/{segment-discovery-profile-binding-map-id}'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'segment-discovery-profile-binding-map-id' + '}', segment_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_infra_segment_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment MAC table
    # Returns MAC table for a segment 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [SegmentMacAddressListResult]
    def global_infra_get_infra_segment_mac_table(segment_id, opts = {})
      data, _status_code, _headers = global_infra_get_infra_segment_mac_table_with_http_info(segment_id, opts)
      data
    end

    # Get infra segment MAC table
    # Returns MAC table for a segment 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(SegmentMacAddressListResult, Fixnum, Hash)>] SegmentMacAddressListResult data, response status code and response headers
    def global_infra_get_infra_segment_mac_table_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_infra_segment_mac_table ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_infra_segment_mac_table"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_infra_segment_mac_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_infra_segment_mac_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/mac-table'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentMacAddressListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_infra_segment_mac_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment MAC table in CSV
    # Returns MAC table for a segment 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [MacAddressCsvListResult]
    def global_infra_get_infra_segment_mac_table_in_csv(segment_id, opts = {})
      data, _status_code, _headers = global_infra_get_infra_segment_mac_table_in_csv_with_http_info(segment_id, opts)
      data
    end

    # Get infra segment MAC table in CSV
    # Returns MAC table for a segment 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(MacAddressCsvListResult, Fixnum, Hash)>] MacAddressCsvListResult data, response status code and response headers
    def global_infra_get_infra_segment_mac_table_in_csv_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_infra_segment_mac_table_in_csv ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_infra_segment_mac_table_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/mac-table?format=csv'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MacAddressCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_infra_segment_mac_table_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment port by ID
    # Get detail information on an infra segment port by giving ID. 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [SegmentPort]
    def global_infra_get_infra_segment_port(segment_id, port_id, opts = {})
      data, _status_code, _headers = global_infra_get_infra_segment_port_with_http_info(segment_id, port_id, opts)
      data
    end

    # Get infra segment port by ID
    # Get detail information on an infra segment port by giving ID. 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentPort, Fixnum, Hash)>] SegmentPort data, response status code and response headers
    def global_infra_get_infra_segment_port_with_http_info(segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_infra_segment_port ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_infra_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_get_infra_segment_port"
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/ports/{port-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPort')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_infra_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get MAC table for infra segment port
    # Returns MAC table for a segment port 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [SegmentPortMacAddressListResult]
    def global_infra_get_infra_segment_port_mac_table(segment_id, port_id, opts = {})
      data, _status_code, _headers = global_infra_get_infra_segment_port_mac_table_with_http_info(segment_id, port_id, opts)
      data
    end

    # Get MAC table for infra segment port
    # Returns MAC table for a segment port 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(SegmentPortMacAddressListResult, Fixnum, Hash)>] SegmentPortMacAddressListResult data, response status code and response headers
    def global_infra_get_infra_segment_port_mac_table_with_http_info(segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_infra_segment_port_mac_table ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_infra_segment_port_mac_table"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_get_infra_segment_port_mac_table"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_infra_segment_port_mac_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_infra_segment_port_mac_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/ports/{port-id}/mac-table'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortMacAddressListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_infra_segment_port_mac_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment port MAC table in CSV
    # Returns MAC table for a segment port 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [SegmentPortMacAddressCsvListResult]
    def global_infra_get_infra_segment_port_mac_table_in_csv(segment_id, port_id, opts = {})
      data, _status_code, _headers = global_infra_get_infra_segment_port_mac_table_in_csv_with_http_info(segment_id, port_id, opts)
      data
    end

    # Get infra segment port MAC table in CSV
    # Returns MAC table for a segment port 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(SegmentPortMacAddressCsvListResult, Fixnum, Hash)>] SegmentPortMacAddressCsvListResult data, response status code and response headers
    def global_infra_get_infra_segment_port_mac_table_in_csv_with_http_info(segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_infra_segment_port_mac_table_in_csv ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_infra_segment_port_mac_table_in_csv"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_get_infra_segment_port_mac_table_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/ports/{port-id}/mac-table?format=csv'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortMacAddressCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_infra_segment_port_mac_table_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment port security profile binding map
    # API will return details of the port security profile binding map. If the security profile binding map does not exist, it will return 404. 
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [PortSecurityProfileBindingMap]
    def global_infra_get_infra_segment_port_security_profile_binding(segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      data, _status_code, _headers = global_infra_get_infra_segment_port_security_profile_binding_with_http_info(segment_id, port_id, port_security_profile_binding_map_id, opts)
      data
    end

    # Get infra segment port security profile binding map
    # API will return details of the port security profile binding map. If the security profile binding map does not exist, it will return 404. 
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortSecurityProfileBindingMap, Fixnum, Hash)>] PortSecurityProfileBindingMap data, response status code and response headers
    def global_infra_get_infra_segment_port_security_profile_binding_with_http_info(segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_infra_segment_port_security_profile_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_get_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.global_infra_get_infra_segment_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_infra_segment_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment port state
    # Returns infra segment port state on enforcement point 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [SegmentPortState]
    def global_infra_get_infra_segment_port_state(segment_id, port_id, opts = {})
      data, _status_code, _headers = global_infra_get_infra_segment_port_state_with_http_info(segment_id, port_id, opts)
      data
    end

    # Get infra segment port state
    # Returns infra segment port state on enforcement point 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(SegmentPortState, Fixnum, Hash)>] SegmentPortState data, response status code and response headers
    def global_infra_get_infra_segment_port_state_with_http_info(segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_infra_segment_port_state ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_infra_segment_port_state"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_get_infra_segment_port_state"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/ports/{port-id}/state'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_infra_segment_port_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment port statistics information
    # Get infra segment port statistics information. 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentPortStatistics]
    def global_infra_get_infra_segment_port_statistics(segments_id, port_id, opts = {})
      data, _status_code, _headers = global_infra_get_infra_segment_port_statistics_with_http_info(segments_id, port_id, opts)
      data
    end

    # Get infra segment port statistics information
    # Get infra segment port statistics information. 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentPortStatistics, Fixnum, Hash)>] SegmentPortStatistics data, response status code and response headers
    def global_infra_get_infra_segment_port_statistics_with_http_info(segments_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_infra_segment_port_statistics ...'
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.global_infra_get_infra_segment_port_statistics"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_get_infra_segment_port_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_infra_segment_port_statistics, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_infra_segment_port_statistics, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/global-infra/segments/{segments-id}/ports/{port-id}/statistics'.sub('{' + 'segments-id' + '}', segments_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_infra_segment_port_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment port status information
    # Get infra segment port status information. 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentPortStatus]
    def global_infra_get_infra_segment_port_status(segments_id, port_id, opts = {})
      data, _status_code, _headers = global_infra_get_infra_segment_port_status_with_http_info(segments_id, port_id, opts)
      data
    end

    # Get infra segment port status information
    # Get infra segment port status information. 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentPortStatus, Fixnum, Hash)>] SegmentPortStatus data, response status code and response headers
    def global_infra_get_infra_segment_port_status_with_http_info(segments_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_infra_segment_port_status ...'
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.global_infra_get_infra_segment_port_status"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_get_infra_segment_port_status"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_infra_segment_port_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_infra_segment_port_status, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/global-infra/segments/{segments-id}/ports/{port-id}/status'.sub('{' + 'segments-id' + '}', segments_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_infra_segment_port_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Segment QoS Profile Binding Map
    # API will get Segment QoS Profile Binding Map. 
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [SegmentQoSProfileBindingMap]
    def global_infra_get_infra_segment_qo_s_binding(segment_id, segment_qos_profile_binding_map_id, opts = {})
      data, _status_code, _headers = global_infra_get_infra_segment_qo_s_binding_with_http_info(segment_id, segment_qos_profile_binding_map_id, opts)
      data
    end

    # Get Segment QoS Profile Binding Map
    # API will get Segment QoS Profile Binding Map. 
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentQoSProfileBindingMap, Fixnum, Hash)>] SegmentQoSProfileBindingMap data, response status code and response headers
    def global_infra_get_infra_segment_qo_s_binding_with_http_info(segment_id, segment_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_infra_segment_qo_s_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_infra_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qos_profile_binding_map_id' when calling SegmentsApi.global_infra_get_infra_segment_qo_s_binding"
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/segment-qos-profile-binding-maps/{segment-qos-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-qos-profile-binding-map-id' + '}', segment_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_infra_segment_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment security profile binding map
    # API will return details of the segment security profile binding map. If the binding map does not exist, it will return 404. 
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [SegmentSecurityProfileBindingMap]
    def global_infra_get_infra_segment_security_profile_binding(segment_id, segment_security_profile_binding_map_id, opts = {})
      data, _status_code, _headers = global_infra_get_infra_segment_security_profile_binding_with_http_info(segment_id, segment_security_profile_binding_map_id, opts)
      data
    end

    # Get infra segment security profile binding map
    # API will return details of the segment security profile binding map. If the binding map does not exist, it will return 404. 
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentSecurityProfileBindingMap, Fixnum, Hash)>] SegmentSecurityProfileBindingMap data, response status code and response headers
    def global_infra_get_infra_segment_security_profile_binding_with_http_info(segment_id, segment_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_infra_segment_security_profile_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_infra_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map_id' when calling SegmentsApi.global_infra_get_infra_segment_security_profile_binding"
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/segment-security-profile-binding-maps/{segment-security-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-security-profile-binding-map-id' + '}', segment_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_infra_segment_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment state information
    # Get infra segment state information. 
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentConfigurationState]
    def global_infra_get_infra_segment_state(segments_id, opts = {})
      data, _status_code, _headers = global_infra_get_infra_segment_state_with_http_info(segments_id, opts)
      data
    end

    # Get infra segment state information
    # Get infra segment state information. 
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentConfigurationState, Fixnum, Hash)>] SegmentConfigurationState data, response status code and response headers
    def global_infra_get_infra_segment_state_with_http_info(segments_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_infra_segment_state ...'
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.global_infra_get_infra_segment_state"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_infra_segment_state, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_infra_segment_state, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/global-infra/segments/{segments-id}/state'.sub('{' + 'segments-id' + '}', segments_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConfigurationState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_infra_segment_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment statistics information
    # Get infra segment statistics information. 
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentStatistics]
    def global_infra_get_infra_segment_statistics(segments_id, opts = {})
      data, _status_code, _headers = global_infra_get_infra_segment_statistics_with_http_info(segments_id, opts)
      data
    end

    # Get infra segment statistics information
    # Get infra segment statistics information. 
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentStatistics, Fixnum, Hash)>] SegmentStatistics data, response status code and response headers
    def global_infra_get_infra_segment_statistics_with_http_info(segments_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_infra_segment_statistics ...'
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.global_infra_get_infra_segment_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_infra_segment_statistics, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_infra_segment_statistics, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/global-infra/segments/{segments-id}/statistics'.sub('{' + 'segments-id' + '}', segments_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_infra_segment_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment TEP table
    # Returns TEP table for a segment 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyTepListResult]
    def global_infra_get_infra_segment_tep_table(segment_id, opts = {})
      data, _status_code, _headers = global_infra_get_infra_segment_tep_table_with_http_info(segment_id, opts)
      data
    end

    # Get infra segment TEP table
    # Returns TEP table for a segment 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyTepListResult, Fixnum, Hash)>] PolicyTepListResult data, response status code and response headers
    def global_infra_get_infra_segment_tep_table_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_infra_segment_tep_table ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_infra_segment_tep_table"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_infra_segment_tep_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_infra_segment_tep_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/tep-table'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyTepListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_infra_segment_tep_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get tier-1 segment TEP table in CSV
    # Returns TEP table for a segment in CSV 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyTepCsvListResult]
    def global_infra_get_infra_segment_tep_table_in_csv(segment_id, opts = {})
      data, _status_code, _headers = global_infra_get_infra_segment_tep_table_in_csv_with_http_info(segment_id, opts)
      data
    end

    # Get tier-1 segment TEP table in CSV
    # Returns TEP table for a segment in CSV 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyTepCsvListResult, Fixnum, Hash)>] PolicyTepCsvListResult data, response status code and response headers
    def global_infra_get_infra_segment_tep_table_in_csv_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_infra_segment_tep_table_in_csv ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_infra_segment_tep_table_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/tep-table?format=csv'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyTepCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_infra_segment_tep_table_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segments by configuration state
    # Returns all infra segments with configuration state on the enforcement point specified in the request 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :configuration_state Configuration state of the segment on enforcement point
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [SegmentConfigurationStateListResult]
    def global_infra_get_infra_segments_by_state(opts = {})
      data, _status_code, _headers = global_infra_get_infra_segments_by_state_with_http_info(opts)
      data
    end

    # Get infra segments by configuration state
    # Returns all infra segments with configuration state on the enforcement point specified in the request 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :configuration_state Configuration state of the segment on enforcement point
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(SegmentConfigurationStateListResult, Fixnum, Hash)>] SegmentConfigurationStateListResult data, response status code and response headers
    def global_infra_get_infra_segments_by_state_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_infra_segments_by_state ...'
      end
      if @api_client.config.client_side_validation && opts[:'configuration_state'] && !['pending', 'in_progress', 'success', 'failed', 'partial_success', 'orphaned', 'unknown'].include?(opts[:'configuration_state'])
        fail ArgumentError, 'invalid value for "configuration_state", must be one of pending, in_progress, success, failed, partial_success, orphaned, unknown'
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/segments/state'

      # query parameters
      query_params = {}
      query_params[:'configuration_state'] = opts[:'configuration_state'] if !opts[:'configuration_state'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConfigurationStateListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_infra_segments_by_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get IP Discovery Profile
    # API will get IP Discovery profile. 
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @return [IPDiscoveryProfile]
    def global_infra_get_ip_discovery_profile(ip_discovery_profile_id, opts = {})
      data, _status_code, _headers = global_infra_get_ip_discovery_profile_with_http_info(ip_discovery_profile_id, opts)
      data
    end

    # Get IP Discovery Profile
    # API will get IP Discovery profile. 
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(IPDiscoveryProfile, Fixnum, Hash)>] IPDiscoveryProfile data, response status code and response headers
    def global_infra_get_ip_discovery_profile_with_http_info(ip_discovery_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_ip_discovery_profile ...'
      end
      # verify the required parameter 'ip_discovery_profile_id' is set
      if @api_client.config.client_side_validation && ip_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'ip_discovery_profile_id' when calling SegmentsApi.global_infra_get_ip_discovery_profile"
      end
      # resource path
      local_var_path = '/global-infra/ip-discovery-profiles/{ip-discovery-profile-id}'.sub('{' + 'ip-discovery-profile-id' + '}', ip_discovery_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'IPDiscoveryProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_ip_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List IP Discovery Profiles
    # API will list all IP Discovery Profiles active in current discovery profile id. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [IPDiscoveryProfileListResult]
    def global_infra_get_ip_discovery_profiles(opts = {})
      data, _status_code, _headers = global_infra_get_ip_discovery_profiles_with_http_info(opts)
      data
    end

    # List IP Discovery Profiles
    # API will list all IP Discovery Profiles active in current discovery profile id. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(IPDiscoveryProfileListResult, Fixnum, Hash)>] IPDiscoveryProfileListResult data, response status code and response headers
    def global_infra_get_ip_discovery_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_ip_discovery_profiles ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_ip_discovery_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_ip_discovery_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/ip-discovery-profiles'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'IPDiscoveryProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_ip_discovery_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Mac Discovery Profile
    # API will get Mac Discovery profile. 
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @return [MacDiscoveryProfile]
    def global_infra_get_mac_discovery_profile(mac_discovery_profile_id, opts = {})
      data, _status_code, _headers = global_infra_get_mac_discovery_profile_with_http_info(mac_discovery_profile_id, opts)
      data
    end

    # Get Mac Discovery Profile
    # API will get Mac Discovery profile. 
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(MacDiscoveryProfile, Fixnum, Hash)>] MacDiscoveryProfile data, response status code and response headers
    def global_infra_get_mac_discovery_profile_with_http_info(mac_discovery_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_mac_discovery_profile ...'
      end
      # verify the required parameter 'mac_discovery_profile_id' is set
      if @api_client.config.client_side_validation && mac_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'mac_discovery_profile_id' when calling SegmentsApi.global_infra_get_mac_discovery_profile"
      end
      # resource path
      local_var_path = '/global-infra/mac-discovery-profiles/{mac-discovery-profile-id}'.sub('{' + 'mac-discovery-profile-id' + '}', mac_discovery_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MacDiscoveryProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_mac_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Mac Discovery Profiles
    # API will list all Mac Discovery Profiles active in current discovery profile id. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [MacDiscoveryProfileListResult]
    def global_infra_get_mac_discovery_profiles(opts = {})
      data, _status_code, _headers = global_infra_get_mac_discovery_profiles_with_http_info(opts)
      data
    end

    # List Mac Discovery Profiles
    # API will list all Mac Discovery Profiles active in current discovery profile id. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(MacDiscoveryProfileListResult, Fixnum, Hash)>] MacDiscoveryProfileListResult data, response status code and response headers
    def global_infra_get_mac_discovery_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_mac_discovery_profiles ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_mac_discovery_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_mac_discovery_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/mac-discovery-profiles'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MacDiscoveryProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_mac_discovery_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Port Discovery Profile Binding Map
    # API will get Port Discovery Profile Binding Map 
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [PortDiscoveryProfileBindingMap]
    def global_infra_get_port_discovery_binding(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, opts = {})
      data, _status_code, _headers = global_infra_get_port_discovery_binding_with_http_info(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, opts)
      data
    end

    # Get Port Discovery Profile Binding Map
    # API will get Port Discovery Profile Binding Map 
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortDiscoveryProfileBindingMap, Fixnum, Hash)>] PortDiscoveryProfileBindingMap data, response status code and response headers
    def global_infra_get_port_discovery_binding_with_http_info(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_port_discovery_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_get_port_discovery_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_port_discovery_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_get_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.global_infra_get_port_discovery_binding"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Port QoS Profile Binding Map
    # API will get Port QoS Profile Binding Map. 
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [PortQoSProfileBindingMap]
    def global_infra_get_port_qo_s_binding(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      data, _status_code, _headers = global_infra_get_port_qo_s_binding_with_http_info(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, opts)
      data
    end

    # Get Port QoS Profile Binding Map
    # API will get Port QoS Profile Binding Map. 
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortQoSProfileBindingMap, Fixnum, Hash)>] PortQoSProfileBindingMap data, response status code and response headers
    def global_infra_get_port_qo_s_binding_with_http_info(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_port_qo_s_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_get_port_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_get_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.global_infra_get_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get port security profile binding map
    # API will return details of the port security profile binding map. If the security profile binding map does not exist, it will return 404. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [PortSecurityProfileBindingMap]
    def global_infra_get_port_security_profile_binding(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      data, _status_code, _headers = global_infra_get_port_security_profile_binding_with_http_info(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, opts)
      data
    end

    # Get port security profile binding map
    # API will return details of the port security profile binding map. If the security profile binding map does not exist, it will return 404. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortSecurityProfileBindingMap, Fixnum, Hash)>] PortSecurityProfileBindingMap data, response status code and response headers
    def global_infra_get_port_security_profile_binding_with_http_info(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_port_security_profile_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_get_port_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_get_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.global_infra_get_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Segment Discovery Profile Binding Map
    # API will get Segment Discovery Profile Binding Map 
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [SegmentDiscoveryProfileBindingMap]
    def global_infra_get_segment_discovery_binding(tier_1_id, segment_id, segment_discovery_profile_binding_map_id, opts = {})
      data, _status_code, _headers = global_infra_get_segment_discovery_binding_with_http_info(tier_1_id, segment_id, segment_discovery_profile_binding_map_id, opts)
      data
    end

    # Get Segment Discovery Profile Binding Map
    # API will get Segment Discovery Profile Binding Map 
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentDiscoveryProfileBindingMap, Fixnum, Hash)>] SegmentDiscoveryProfileBindingMap data, response status code and response headers
    def global_infra_get_segment_discovery_binding_with_http_info(tier_1_id, segment_id, segment_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_segment_discovery_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_get_segment_discovery_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map_id' when calling SegmentsApi.global_infra_get_segment_discovery_binding"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-discovery-profile-binding-maps/{segment-discovery-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-discovery-profile-binding-map-id' + '}', segment_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_segment_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get tier-1 segment port statistics information
    # Get tier-1 segment port statistics information. 
    # @param tier_1_id 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentPortStatistics]
    def global_infra_get_segment_port_statistics(tier_1_id, segments_id, port_id, opts = {})
      data, _status_code, _headers = global_infra_get_segment_port_statistics_with_http_info(tier_1_id, segments_id, port_id, opts)
      data
    end

    # Get tier-1 segment port statistics information
    # Get tier-1 segment port statistics information. 
    # @param tier_1_id 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentPortStatistics, Fixnum, Hash)>] SegmentPortStatistics data, response status code and response headers
    def global_infra_get_segment_port_statistics_with_http_info(tier_1_id, segments_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_segment_port_statistics ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_get_segment_port_statistics"
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.global_infra_get_segment_port_statistics"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_get_segment_port_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_segment_port_statistics, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_segment_port_statistics, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segments-id}/ports/{port-id}/statistics'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segments-id' + '}', segments_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_segment_port_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get segment port status information
    # Get tier1 segment port status information. 
    # @param tier_1_id 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentPortStatus]
    def global_infra_get_segment_port_status(tier_1_id, segments_id, port_id, opts = {})
      data, _status_code, _headers = global_infra_get_segment_port_status_with_http_info(tier_1_id, segments_id, port_id, opts)
      data
    end

    # Get segment port status information
    # Get tier1 segment port status information. 
    # @param tier_1_id 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentPortStatus, Fixnum, Hash)>] SegmentPortStatus data, response status code and response headers
    def global_infra_get_segment_port_status_with_http_info(tier_1_id, segments_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_segment_port_status ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_get_segment_port_status"
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.global_infra_get_segment_port_status"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_get_segment_port_status"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_segment_port_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_segment_port_status, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segments-id}/ports/{port-id}/status'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segments-id' + '}', segments_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_segment_port_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Segment QoS Profile Binding Map
    # API will get Segment QoS Profile Binding Map. 
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [SegmentQoSProfileBindingMap]
    def global_infra_get_segment_qo_s_binding(tier_1_id, segment_id, segment_qos_profile_binding_map_id, opts = {})
      data, _status_code, _headers = global_infra_get_segment_qo_s_binding_with_http_info(tier_1_id, segment_id, segment_qos_profile_binding_map_id, opts)
      data
    end

    # Get Segment QoS Profile Binding Map
    # API will get Segment QoS Profile Binding Map. 
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentQoSProfileBindingMap, Fixnum, Hash)>] SegmentQoSProfileBindingMap data, response status code and response headers
    def global_infra_get_segment_qo_s_binding_with_http_info(tier_1_id, segment_id, segment_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_segment_qo_s_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_get_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qos_profile_binding_map_id' when calling SegmentsApi.global_infra_get_segment_qo_s_binding"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-qos-profile-binding-maps/{segment-qos-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-qos-profile-binding-map-id' + '}', segment_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_segment_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # GET Segment security profile id
    # API will return details of the segment security profile with given id. If the profile does not exist, it will return 404. 
    # @param segment_security_profile_id Segment security profile id
    # @param [Hash] opts the optional parameters
    # @return [SegmentSecurityProfile]
    def global_infra_get_segment_security_profile(segment_security_profile_id, opts = {})
      data, _status_code, _headers = global_infra_get_segment_security_profile_with_http_info(segment_security_profile_id, opts)
      data
    end

    # GET Segment security profile id
    # API will return details of the segment security profile with given id. If the profile does not exist, it will return 404. 
    # @param segment_security_profile_id Segment security profile id
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentSecurityProfile, Fixnum, Hash)>] SegmentSecurityProfile data, response status code and response headers
    def global_infra_get_segment_security_profile_with_http_info(segment_security_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_segment_security_profile ...'
      end
      # verify the required parameter 'segment_security_profile_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_id' when calling SegmentsApi.global_infra_get_segment_security_profile"
      end
      # resource path
      local_var_path = '/global-infra/segment-security-profiles/{segment-security-profile-id}'.sub('{' + 'segment-security-profile-id' + '}', segment_security_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_segment_security_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get segment security profile binding map
    # API will return details of the segment security profile binding map. If the binding map does not exist, it will return 404. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [SegmentSecurityProfileBindingMap]
    def global_infra_get_segment_security_profile_binding(tier_1_id, segment_id, segment_security_profile_binding_map_id, opts = {})
      data, _status_code, _headers = global_infra_get_segment_security_profile_binding_with_http_info(tier_1_id, segment_id, segment_security_profile_binding_map_id, opts)
      data
    end

    # Get segment security profile binding map
    # API will return details of the segment security profile binding map. If the binding map does not exist, it will return 404. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentSecurityProfileBindingMap, Fixnum, Hash)>] SegmentSecurityProfileBindingMap data, response status code and response headers
    def global_infra_get_segment_security_profile_binding_with_http_info(tier_1_id, segment_id, segment_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_segment_security_profile_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_get_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map_id' when calling SegmentsApi.global_infra_get_segment_security_profile_binding"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-security-profile-binding-maps/{segment-security-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-security-profile-binding-map-id' + '}', segment_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_segment_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get segment state information
    # Get tier1 segment state information. 
    # @param tier_1_id 
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentConfigurationState]
    def global_infra_get_segment_state(tier_1_id, segments_id, opts = {})
      data, _status_code, _headers = global_infra_get_segment_state_with_http_info(tier_1_id, segments_id, opts)
      data
    end

    # Get segment state information
    # Get tier1 segment state information. 
    # @param tier_1_id 
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentConfigurationState, Fixnum, Hash)>] SegmentConfigurationState data, response status code and response headers
    def global_infra_get_segment_state_with_http_info(tier_1_id, segments_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_segment_state ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_get_segment_state"
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.global_infra_get_segment_state"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_segment_state, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_segment_state, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segments-id}/state'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segments-id' + '}', segments_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConfigurationState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_segment_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get segment statistics information
    # Get tier1 segment statistics information. 
    # @param tier_1_id 
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentStatistics]
    def global_infra_get_segment_statistics(tier_1_id, segments_id, opts = {})
      data, _status_code, _headers = global_infra_get_segment_statistics_with_http_info(tier_1_id, segments_id, opts)
      data
    end

    # Get segment statistics information
    # Get tier1 segment statistics information. 
    # @param tier_1_id 
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentStatistics, Fixnum, Hash)>] SegmentStatistics data, response status code and response headers
    def global_infra_get_segment_statistics_with_http_info(tier_1_id, segments_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_segment_statistics ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_get_segment_statistics"
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.global_infra_get_segment_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_segment_statistics, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_segment_statistics, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segments-id}/statistics'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segments-id' + '}', segments_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_segment_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get SpoofGuard profile
    # API will return details of the SpoofGuard profile with given id. If the profile does not exist, it will return 404. 
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param [Hash] opts the optional parameters
    # @return [SpoofGuardProfile]
    def global_infra_get_spoof_guard_profile(spoofguard_profile_id, opts = {})
      data, _status_code, _headers = global_infra_get_spoof_guard_profile_with_http_info(spoofguard_profile_id, opts)
      data
    end

    # Get SpoofGuard profile
    # API will return details of the SpoofGuard profile with given id. If the profile does not exist, it will return 404. 
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param [Hash] opts the optional parameters
    # @return [Array<(SpoofGuardProfile, Fixnum, Hash)>] SpoofGuardProfile data, response status code and response headers
    def global_infra_get_spoof_guard_profile_with_http_info(spoofguard_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_spoof_guard_profile ...'
      end
      # verify the required parameter 'spoofguard_profile_id' is set
      if @api_client.config.client_side_validation && spoofguard_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'spoofguard_profile_id' when calling SegmentsApi.global_infra_get_spoof_guard_profile"
      end
      # resource path
      local_var_path = '/global-infra/spoofguard-profiles/{spoofguard-profile-id}'.sub('{' + 'spoofguard-profile-id' + '}', spoofguard_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SpoofGuardProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_spoof_guard_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tier-1 segment MAC table
    # Returns MAC table for a segment 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [SegmentMacAddressListResult]
    def global_infra_get_tier1_segment_mac_table(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier1_segment_mac_table_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # Get Tier-1 segment MAC table
    # Returns MAC table for a segment 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(SegmentMacAddressListResult, Fixnum, Hash)>] SegmentMacAddressListResult data, response status code and response headers
    def global_infra_get_tier1_segment_mac_table_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_tier1_segment_mac_table ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_get_tier1_segment_mac_table"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_tier1_segment_mac_table"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_tier1_segment_mac_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_tier1_segment_mac_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/mac-table'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentMacAddressListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_tier1_segment_mac_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tier-1 segment MAC table in CSV
    # Returns MAC table for a segment 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [MacAddressCsvListResult]
    def global_infra_get_tier1_segment_mac_table_in_csv(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier1_segment_mac_table_in_csv_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # Get Tier-1 segment MAC table in CSV
    # Returns MAC table for a segment 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(MacAddressCsvListResult, Fixnum, Hash)>] MacAddressCsvListResult data, response status code and response headers
    def global_infra_get_tier1_segment_mac_table_in_csv_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_tier1_segment_mac_table_in_csv ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_get_tier1_segment_mac_table_in_csv"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_tier1_segment_mac_table_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/mac-table?format=csv'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MacAddressCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_tier1_segment_mac_table_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tier-1 segment port by ID
    # Get detail information on a Tier-1 segment port by giving ID. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [SegmentPort]
    def global_infra_get_tier1_segment_port(tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier1_segment_port_with_http_info(tier_1_id, segment_id, port_id, opts)
      data
    end

    # Get Tier-1 segment port by ID
    # Get detail information on a Tier-1 segment port by giving ID. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentPort, Fixnum, Hash)>] SegmentPort data, response status code and response headers
    def global_infra_get_tier1_segment_port_with_http_info(tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_tier1_segment_port ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_get_tier1_segment_port"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_tier1_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_get_tier1_segment_port"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPort')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_tier1_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get MAC table for tier-1 segment port
    # Returns MAC table for a segment port 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [SegmentPortMacAddressListResult]
    def global_infra_get_tier1_segment_port_mac_table(tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier1_segment_port_mac_table_with_http_info(tier_1_id, segment_id, port_id, opts)
      data
    end

    # Get MAC table for tier-1 segment port
    # Returns MAC table for a segment port 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(SegmentPortMacAddressListResult, Fixnum, Hash)>] SegmentPortMacAddressListResult data, response status code and response headers
    def global_infra_get_tier1_segment_port_mac_table_with_http_info(tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_tier1_segment_port_mac_table ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_get_tier1_segment_port_mac_table"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_tier1_segment_port_mac_table"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_get_tier1_segment_port_mac_table"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_tier1_segment_port_mac_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_tier1_segment_port_mac_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/mac-table'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortMacAddressListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_tier1_segment_port_mac_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get tier-1 segment port MAC table in CSV
    # Returns MAC table for a segment port 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [SegmentPortMacAddressCsvListResult]
    def global_infra_get_tier1_segment_port_mac_table_in_csv(tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier1_segment_port_mac_table_in_csv_with_http_info(tier_1_id, segment_id, port_id, opts)
      data
    end

    # Get tier-1 segment port MAC table in CSV
    # Returns MAC table for a segment port 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(SegmentPortMacAddressCsvListResult, Fixnum, Hash)>] SegmentPortMacAddressCsvListResult data, response status code and response headers
    def global_infra_get_tier1_segment_port_mac_table_in_csv_with_http_info(tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_tier1_segment_port_mac_table_in_csv ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_get_tier1_segment_port_mac_table_in_csv"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_tier1_segment_port_mac_table_in_csv"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_get_tier1_segment_port_mac_table_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/mac-table?format=csv'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortMacAddressCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_tier1_segment_port_mac_table_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get tier-1  segment port state
    # Returns tier-1 segment port state on enforcement point 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [SegmentPortState]
    def global_infra_get_tier1_segment_port_state(tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier1_segment_port_state_with_http_info(tier_1_id, segment_id, port_id, opts)
      data
    end

    # Get tier-1  segment port state
    # Returns tier-1 segment port state on enforcement point 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(SegmentPortState, Fixnum, Hash)>] SegmentPortState data, response status code and response headers
    def global_infra_get_tier1_segment_port_state_with_http_info(tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_tier1_segment_port_state ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_get_tier1_segment_port_state"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_tier1_segment_port_state"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_get_tier1_segment_port_state"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/state'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_tier1_segment_port_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get tier-1 segment TEP table
    # Returns TEP table for a segment 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyTepListResult]
    def global_infra_get_tier1_segment_tep_table(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier1_segment_tep_table_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # Get tier-1 segment TEP table
    # Returns TEP table for a segment 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyTepListResult, Fixnum, Hash)>] PolicyTepListResult data, response status code and response headers
    def global_infra_get_tier1_segment_tep_table_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_tier1_segment_tep_table ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_get_tier1_segment_tep_table"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_tier1_segment_tep_table"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_tier1_segment_tep_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_get_tier1_segment_tep_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/tep-table'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyTepListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_tier1_segment_tep_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get tier-1 segment TEP table in CSV
    # Returns TEP table for a segment in CSV 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyTepCsvListResult]
    def global_infra_get_tier1_segment_tep_table_in_csv(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier1_segment_tep_table_in_csv_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # Get tier-1 segment TEP table in CSV
    # Returns TEP table for a segment in CSV 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyTepCsvListResult, Fixnum, Hash)>] PolicyTepCsvListResult data, response status code and response headers
    def global_infra_get_tier1_segment_tep_table_in_csv_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_tier1_segment_tep_table_in_csv ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_get_tier1_segment_tep_table_in_csv"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_get_tier1_segment_tep_table_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/tep-table?format=csv'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyTepCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_tier1_segment_tep_table_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get tier-1 segments by configuration state
    # Returns all tier-1 segments with configuration state on the enforcement point specified in the request 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :configuration_state Configuration state of the segment on enforcement point
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [SegmentConfigurationStateListResult]
    def global_infra_get_tier1_segments_by_state(tier_1_id, opts = {})
      data, _status_code, _headers = global_infra_get_tier1_segments_by_state_with_http_info(tier_1_id, opts)
      data
    end

    # Get tier-1 segments by configuration state
    # Returns all tier-1 segments with configuration state on the enforcement point specified in the request 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :configuration_state Configuration state of the segment on enforcement point
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(SegmentConfigurationStateListResult, Fixnum, Hash)>] SegmentConfigurationStateListResult data, response status code and response headers
    def global_infra_get_tier1_segments_by_state_with_http_info(tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_get_tier1_segments_by_state ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_get_tier1_segments_by_state"
      end
      if @api_client.config.client_side_validation && opts[:'configuration_state'] && !['pending', 'in_progress', 'success', 'failed', 'partial_success', 'orphaned', 'unknown'].include?(opts[:'configuration_state'])
        fail ArgumentError, 'invalid value for "configuration_state", must be one of pending, in_progress, success, failed, partial_success, orphaned, unknown'
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/state'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'configuration_state'] = opts[:'configuration_state'] if !opts[:'configuration_state'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConfigurationStateListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_get_tier1_segments_by_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all segments under infra
    # Paginated list of all segments under infra. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :segment_type Segment type
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentListResult]
    def global_infra_list_all_infra_segments(opts = {})
      data, _status_code, _headers = global_infra_list_all_infra_segments_with_http_info(opts)
      data
    end

    # List all segments under infra
    # Paginated list of all segments under infra. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :segment_type Segment type
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentListResult, Fixnum, Hash)>] SegmentListResult data, response status code and response headers
    def global_infra_list_all_infra_segments_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_all_infra_segments ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_all_infra_segments, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_all_infra_segments, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'segment_type'] && !['DVPortgroup', 'ALL'].include?(opts[:'segment_type'])
        fail ArgumentError, 'invalid value for "segment_type", must be one of DVPortgroup, ALL'
      end
      # resource path
      local_var_path = '/global-infra/segments'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'segment_type'] = opts[:'segment_type'] if !opts[:'segment_type'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_all_infra_segments\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all segments under infra
    # Paginated list of all segments under infra. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :segment_type Segment type
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentListResult]
    def global_infra_list_all_infra_segments_0(opts = {})
      data, _status_code, _headers = global_infra_list_all_infra_segments_0_with_http_info(opts)
      data
    end

    # List all segments under infra
    # Paginated list of all segments under infra. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :segment_type Segment type
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentListResult, Fixnum, Hash)>] SegmentListResult data, response status code and response headers
    def global_infra_list_all_infra_segments_0_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_all_infra_segments_0 ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_all_infra_segments_0, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_all_infra_segments_0, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'segment_type'] && !['DVPortgroup', 'ALL'].include?(opts[:'segment_type'])
        fail ArgumentError, 'invalid value for "segment_type", must be one of DVPortgroup, ALL'
      end
      # resource path
      local_var_path = '/global-infra/segments'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'segment_type'] = opts[:'segment_type'] if !opts[:'segment_type'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_all_infra_segments_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Group discovery profile binding map
    # API will get Group discovery profile binding map
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [GroupDiscoveryProfileBindingMapListResult]
    def global_infra_list_group_discovery_profile_bindings(domain_id, group_id, opts = {})
      data, _status_code, _headers = global_infra_list_group_discovery_profile_bindings_with_http_info(domain_id, group_id, opts)
      data
    end

    # Get Group discovery profile binding map
    # API will get Group discovery profile binding map
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(GroupDiscoveryProfileBindingMapListResult, Fixnum, Hash)>] GroupDiscoveryProfileBindingMapListResult data, response status code and response headers
    def global_infra_list_group_discovery_profile_bindings_with_http_info(domain_id, group_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_group_discovery_profile_bindings ...'
      end
      # verify the required parameter 'domain_id' is set
      if @api_client.config.client_side_validation && domain_id.nil?
        fail ArgumentError, "Missing the required parameter 'domain_id' when calling SegmentsApi.global_infra_list_group_discovery_profile_bindings"
      end
      # verify the required parameter 'group_id' is set
      if @api_client.config.client_side_validation && group_id.nil?
        fail ArgumentError, "Missing the required parameter 'group_id' when calling SegmentsApi.global_infra_list_group_discovery_profile_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_group_discovery_profile_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_group_discovery_profile_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/domains/{domain-id}/groups/{group-id}/discovery-profile-binding-maps'.sub('{' + 'domain-id' + '}', domain_id.to_s).sub('{' + 'group-id' + '}', group_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'GroupDiscoveryProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_group_discovery_profile_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Infra Port Discovery Profile Binding Maps
    # API will list all Infra Port Discovery Profile Binding Maps in current port id. 
    # @param infra_segment_id 
    # @param infra_port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortDiscoveryProfileBindingMapListResult]
    def global_infra_list_infra_port_discovery_bindings(infra_segment_id, infra_port_id, opts = {})
      data, _status_code, _headers = global_infra_list_infra_port_discovery_bindings_with_http_info(infra_segment_id, infra_port_id, opts)
      data
    end

    # List Infra Port Discovery Profile Binding Maps
    # API will list all Infra Port Discovery Profile Binding Maps in current port id. 
    # @param infra_segment_id 
    # @param infra_port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortDiscoveryProfileBindingMapListResult, Fixnum, Hash)>] PortDiscoveryProfileBindingMapListResult data, response status code and response headers
    def global_infra_list_infra_port_discovery_bindings_with_http_info(infra_segment_id, infra_port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_infra_port_discovery_bindings ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.global_infra_list_infra_port_discovery_bindings"
      end
      # verify the required parameter 'infra_port_id' is set
      if @api_client.config.client_side_validation && infra_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_port_id' when calling SegmentsApi.global_infra_list_infra_port_discovery_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_infra_port_discovery_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_infra_port_discovery_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/segments/{infra-segment-id}/ports/{infra-port-id}/port-discovery-profile-binding-maps'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'infra-port-id' + '}', infra_port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortDiscoveryProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_infra_port_discovery_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Port QoS Profile Binding Maps
    # API will list all Port QoS Profile Binding Maps in current port id. 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortQoSProfileBindingMapListResult]
    def global_infra_list_infra_port_qo_s_bindings(segment_id, port_id, opts = {})
      data, _status_code, _headers = global_infra_list_infra_port_qo_s_bindings_with_http_info(segment_id, port_id, opts)
      data
    end

    # List Port QoS Profile Binding Maps
    # API will list all Port QoS Profile Binding Maps in current port id. 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortQoSProfileBindingMapListResult, Fixnum, Hash)>] PortQoSProfileBindingMapListResult data, response status code and response headers
    def global_infra_list_infra_port_qo_s_bindings_with_http_info(segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_infra_port_qo_s_bindings ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_list_infra_port_qo_s_bindings"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_list_infra_port_qo_s_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_infra_port_qo_s_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_infra_port_qo_s_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortQoSProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_infra_port_qo_s_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Infra Segment Discovery Profile Binding Maps
    # API will list all Infra Segment Discovery Profile Binding Maps in current segment id. 
    # @param infra_segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentDiscoveryProfileBindingMapListResult]
    def global_infra_list_infra_segment_discovery_bindings(infra_segment_id, opts = {})
      data, _status_code, _headers = global_infra_list_infra_segment_discovery_bindings_with_http_info(infra_segment_id, opts)
      data
    end

    # List Infra Segment Discovery Profile Binding Maps
    # API will list all Infra Segment Discovery Profile Binding Maps in current segment id. 
    # @param infra_segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentDiscoveryProfileBindingMapListResult, Fixnum, Hash)>] SegmentDiscoveryProfileBindingMapListResult data, response status code and response headers
    def global_infra_list_infra_segment_discovery_bindings_with_http_info(infra_segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_infra_segment_discovery_bindings ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.global_infra_list_infra_segment_discovery_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_infra_segment_discovery_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_infra_segment_discovery_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/segments/{infra-segment-id}/segment-discovery-profile-binding-maps'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentDiscoveryProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_infra_segment_discovery_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all effective profiles for infra segment
    # List all effective profiles for this segment on given enforcement point.
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [EffectiveProfilesResponse]
    def global_infra_list_infra_segment_effective_profiles(segment_id, opts = {})
      data, _status_code, _headers = global_infra_list_infra_segment_effective_profiles_with_http_info(segment_id, opts)
      data
    end

    # List all effective profiles for infra segment
    # List all effective profiles for this segment on given enforcement point.
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [Array<(EffectiveProfilesResponse, Fixnum, Hash)>] EffectiveProfilesResponse data, response status code and response headers
    def global_infra_list_infra_segment_effective_profiles_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_infra_segment_effective_profiles ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_list_infra_segment_effective_profiles"
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/effective-profiles'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EffectiveProfilesResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_infra_segment_effective_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all effective profiles for infra segment
    # List all effective profiles for this segment on given enforcement point.
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [EffectiveProfilesResponse]
    def global_infra_list_infra_segment_effective_profiles_0(segment_id, opts = {})
      data, _status_code, _headers = global_infra_list_infra_segment_effective_profiles_0_with_http_info(segment_id, opts)
      data
    end

    # List all effective profiles for infra segment
    # List all effective profiles for this segment on given enforcement point.
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [Array<(EffectiveProfilesResponse, Fixnum, Hash)>] EffectiveProfilesResponse data, response status code and response headers
    def global_infra_list_infra_segment_effective_profiles_0_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_infra_segment_effective_profiles_0 ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_list_infra_segment_effective_profiles_0"
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/effective-profiles'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EffectiveProfilesResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_infra_segment_effective_profiles_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List infra segment port security profile binding maps
    # API will list all port security profile binding maps. 
    # @param segment_id segment id
    # @param port_id port id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortSecurityProfileBindingMapListResult]
    def global_infra_list_infra_segment_port_security_profile_bindings(segment_id, port_id, opts = {})
      data, _status_code, _headers = global_infra_list_infra_segment_port_security_profile_bindings_with_http_info(segment_id, port_id, opts)
      data
    end

    # List infra segment port security profile binding maps
    # API will list all port security profile binding maps. 
    # @param segment_id segment id
    # @param port_id port id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortSecurityProfileBindingMapListResult, Fixnum, Hash)>] PortSecurityProfileBindingMapListResult data, response status code and response headers
    def global_infra_list_infra_segment_port_security_profile_bindings_with_http_info(segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_infra_segment_port_security_profile_bindings ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_list_infra_segment_port_security_profile_bindings"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_list_infra_segment_port_security_profile_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_infra_segment_port_security_profile_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_infra_segment_port_security_profile_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortSecurityProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_infra_segment_port_security_profile_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List infra segment ports
    # List all the ports for an infra. 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentPortListResult]
    def global_infra_list_infra_segment_ports(segment_id, opts = {})
      data, _status_code, _headers = global_infra_list_infra_segment_ports_with_http_info(segment_id, opts)
      data
    end

    # List infra segment ports
    # List all the ports for an infra. 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentPortListResult, Fixnum, Hash)>] SegmentPortListResult data, response status code and response headers
    def global_infra_list_infra_segment_ports_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_infra_segment_ports ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_list_infra_segment_ports"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_infra_segment_ports, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_infra_segment_ports, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/ports'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_infra_segment_ports\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all effective profiles for infra segment port
    # List all effective profiles for this segment port on given enforcement point.
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [EffectiveProfilesResponse]
    def global_infra_list_infra_segment_ports_effective_profiles(segment_id, port_id, opts = {})
      data, _status_code, _headers = global_infra_list_infra_segment_ports_effective_profiles_with_http_info(segment_id, port_id, opts)
      data
    end

    # List all effective profiles for infra segment port
    # List all effective profiles for this segment port on given enforcement point.
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [Array<(EffectiveProfilesResponse, Fixnum, Hash)>] EffectiveProfilesResponse data, response status code and response headers
    def global_infra_list_infra_segment_ports_effective_profiles_with_http_info(segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_infra_segment_ports_effective_profiles ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_list_infra_segment_ports_effective_profiles"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_list_infra_segment_ports_effective_profiles"
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/ports/{port-id}/effective-profiles'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EffectiveProfilesResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_infra_segment_ports_effective_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Segment QoS Profile Binding Maps
    # API will list all Segment QoS Profile Binding Maps in current segment id. 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentQoSProfileBindingMapListResult]
    def global_infra_list_infra_segment_qo_s_bindings(segment_id, opts = {})
      data, _status_code, _headers = global_infra_list_infra_segment_qo_s_bindings_with_http_info(segment_id, opts)
      data
    end

    # List Segment QoS Profile Binding Maps
    # API will list all Segment QoS Profile Binding Maps in current segment id. 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentQoSProfileBindingMapListResult, Fixnum, Hash)>] SegmentQoSProfileBindingMapListResult data, response status code and response headers
    def global_infra_list_infra_segment_qo_s_bindings_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_infra_segment_qo_s_bindings ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_list_infra_segment_qo_s_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_infra_segment_qo_s_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_infra_segment_qo_s_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/segment-qos-profile-binding-maps'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentQoSProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_infra_segment_qo_s_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List infra segment security profile binding maps
    # API will list all segment security profile binding maps. 
    # @param segment_id segment id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentSecurityProfileBindingMapListResult]
    def global_infra_list_infra_segment_security_profile_bindings(segment_id, opts = {})
      data, _status_code, _headers = global_infra_list_infra_segment_security_profile_bindings_with_http_info(segment_id, opts)
      data
    end

    # List infra segment security profile binding maps
    # API will list all segment security profile binding maps. 
    # @param segment_id segment id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentSecurityProfileBindingMapListResult, Fixnum, Hash)>] SegmentSecurityProfileBindingMapListResult data, response status code and response headers
    def global_infra_list_infra_segment_security_profile_bindings_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_infra_segment_security_profile_bindings ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_list_infra_segment_security_profile_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_infra_segment_security_profile_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_infra_segment_security_profile_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/segment-security-profile-binding-maps'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_infra_segment_security_profile_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List L2 Bridge Endpoint Profiles
    # List all L2 bridge profiles
    # @param site_id site ID
    # @param enforcement_point_id enforcement point ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [L2BridgeEndpointProfileListResult]
    def global_infra_list_l2_bridge_profiles(site_id, enforcement_point_id, opts = {})
      data, _status_code, _headers = global_infra_list_l2_bridge_profiles_with_http_info(site_id, enforcement_point_id, opts)
      data
    end

    # List L2 Bridge Endpoint Profiles
    # List all L2 bridge profiles
    # @param site_id site ID
    # @param enforcement_point_id enforcement point ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(L2BridgeEndpointProfileListResult, Fixnum, Hash)>] L2BridgeEndpointProfileListResult data, response status code and response headers
    def global_infra_list_l2_bridge_profiles_with_http_info(site_id, enforcement_point_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_l2_bridge_profiles ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SegmentsApi.global_infra_list_l2_bridge_profiles"
      end
      # verify the required parameter 'enforcement_point_id' is set
      if @api_client.config.client_side_validation && enforcement_point_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcement_point_id' when calling SegmentsApi.global_infra_list_l2_bridge_profiles"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_l2_bridge_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_l2_bridge_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/sites/{site-id}/enforcement-points/{enforcement-point-id}/edge-bridge-profiles'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcement-point-id' + '}', enforcement_point_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'L2BridgeEndpointProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_l2_bridge_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Port Discovery Profile Binding Maps
    # API will list all Port Discovery Profile Binding Maps in current port id. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortDiscoveryProfileBindingMapListResult]
    def global_infra_list_port_discovery_bindings(tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = global_infra_list_port_discovery_bindings_with_http_info(tier_1_id, segment_id, port_id, opts)
      data
    end

    # List Port Discovery Profile Binding Maps
    # API will list all Port Discovery Profile Binding Maps in current port id. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortDiscoveryProfileBindingMapListResult, Fixnum, Hash)>] PortDiscoveryProfileBindingMapListResult data, response status code and response headers
    def global_infra_list_port_discovery_bindings_with_http_info(tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_port_discovery_bindings ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_list_port_discovery_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_list_port_discovery_bindings"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_list_port_discovery_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_port_discovery_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_port_discovery_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-discovery-profile-binding-maps'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortDiscoveryProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_port_discovery_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Port QoS Profile Binding Maps
    # API will list all Port QoS Profile Binding Maps in current port id. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortQoSProfileBindingMapListResult]
    def global_infra_list_port_qo_s_bindings(tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = global_infra_list_port_qo_s_bindings_with_http_info(tier_1_id, segment_id, port_id, opts)
      data
    end

    # List Port QoS Profile Binding Maps
    # API will list all Port QoS Profile Binding Maps in current port id. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortQoSProfileBindingMapListResult, Fixnum, Hash)>] PortQoSProfileBindingMapListResult data, response status code and response headers
    def global_infra_list_port_qo_s_bindings_with_http_info(tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_port_qo_s_bindings ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_list_port_qo_s_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_list_port_qo_s_bindings"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_list_port_qo_s_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_port_qo_s_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_port_qo_s_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortQoSProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_port_qo_s_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List port security profile binding maps
    # API will list all port security profile binding maps. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortSecurityProfileBindingMapListResult]
    def global_infra_list_port_security_profile_bindings(tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = global_infra_list_port_security_profile_bindings_with_http_info(tier_1_id, segment_id, port_id, opts)
      data
    end

    # List port security profile binding maps
    # API will list all port security profile binding maps. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortSecurityProfileBindingMapListResult, Fixnum, Hash)>] PortSecurityProfileBindingMapListResult data, response status code and response headers
    def global_infra_list_port_security_profile_bindings_with_http_info(tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_port_security_profile_bindings ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_list_port_security_profile_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_list_port_security_profile_bindings"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_list_port_security_profile_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_port_security_profile_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_port_security_profile_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortSecurityProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_port_security_profile_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List QoS Profiles
    # API will list all QoS profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [QoSProfileListResult]
    def global_infra_list_qo_s_profiles(opts = {})
      data, _status_code, _headers = global_infra_list_qo_s_profiles_with_http_info(opts)
      data
    end

    # List QoS Profiles
    # API will list all QoS profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(QoSProfileListResult, Fixnum, Hash)>] QoSProfileListResult data, response status code and response headers
    def global_infra_list_qo_s_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_qo_s_profiles ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_qo_s_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_qo_s_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/qos-profiles'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'QoSProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_qo_s_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Segment Discovery Profile Binding Maps
    # API will list all Segment Discovery Profile Binding Maps in current segment id. 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentDiscoveryProfileBindingMapListResult]
    def global_infra_list_segment_discovery_bindings(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = global_infra_list_segment_discovery_bindings_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # List Segment Discovery Profile Binding Maps
    # API will list all Segment Discovery Profile Binding Maps in current segment id. 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentDiscoveryProfileBindingMapListResult, Fixnum, Hash)>] SegmentDiscoveryProfileBindingMapListResult data, response status code and response headers
    def global_infra_list_segment_discovery_bindings_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_segment_discovery_bindings ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_list_segment_discovery_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_list_segment_discovery_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_segment_discovery_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_segment_discovery_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-discovery-profile-binding-maps'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentDiscoveryProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_segment_discovery_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all effective profiles for segment
    # List all effective profiles for this segment on given enforcement point.
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [EffectiveProfilesResponse]
    def global_infra_list_segment_effective_profiles(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = global_infra_list_segment_effective_profiles_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # List all effective profiles for segment
    # List all effective profiles for this segment on given enforcement point.
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [Array<(EffectiveProfilesResponse, Fixnum, Hash)>] EffectiveProfilesResponse data, response status code and response headers
    def global_infra_list_segment_effective_profiles_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_segment_effective_profiles ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_list_segment_effective_profiles"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_list_segment_effective_profiles"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/effective-profiles'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EffectiveProfilesResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_segment_effective_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Segment QoS Profile Binding Maps
    # API will list all Segment QoS Profile Binding Maps in current segment id. 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentQoSProfileBindingMapListResult]
    def global_infra_list_segment_qo_s_bindings(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = global_infra_list_segment_qo_s_bindings_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # List Segment QoS Profile Binding Maps
    # API will list all Segment QoS Profile Binding Maps in current segment id. 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentQoSProfileBindingMapListResult, Fixnum, Hash)>] SegmentQoSProfileBindingMapListResult data, response status code and response headers
    def global_infra_list_segment_qo_s_bindings_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_segment_qo_s_bindings ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_list_segment_qo_s_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_list_segment_qo_s_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_segment_qo_s_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_segment_qo_s_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-qos-profile-binding-maps'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentQoSProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_segment_qo_s_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List segment security profile binding maps
    # API will list all segment security profile binding maps. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentSecurityProfileBindingMapListResult]
    def global_infra_list_segment_security_profile_bindings(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = global_infra_list_segment_security_profile_bindings_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # List segment security profile binding maps
    # API will list all segment security profile binding maps. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentSecurityProfileBindingMapListResult, Fixnum, Hash)>] SegmentSecurityProfileBindingMapListResult data, response status code and response headers
    def global_infra_list_segment_security_profile_bindings_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_segment_security_profile_bindings ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_list_segment_security_profile_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_list_segment_security_profile_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_segment_security_profile_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_segment_security_profile_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-security-profile-binding-maps'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_segment_security_profile_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List segment security profiles
    # API will list all segment security profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentSecurityProfileListResult]
    def global_infra_list_segment_security_profiles(opts = {})
      data, _status_code, _headers = global_infra_list_segment_security_profiles_with_http_info(opts)
      data
    end

    # List segment security profiles
    # API will list all segment security profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentSecurityProfileListResult, Fixnum, Hash)>] SegmentSecurityProfileListResult data, response status code and response headers
    def global_infra_list_segment_security_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_segment_security_profiles ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_segment_security_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_segment_security_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/segment-security-profiles'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_segment_security_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Paginated list of all fixed segments (identified as /policy/api/v1/infra/tier-1s/<tier-1-id>/segments/<segment-id>) under Tier-1 instance.
    # Paginated list of all fixed segments (identified as /policy/api/v1/infra/tier-1s/<tier-1-id>/segments/<segment-id>) under Tier-1 instance. This API call does not return flexible segments (identified as /policy/api/v1/infra/segments/<segment-id>) connected to the Tier-1. To return all segments connected as a downlink to a Tier-1 one possibility is to use the search API with: https://{{nsx-mgr}}/policy/api/v1/search?query=resource_type:Segment%20AND%20connectivity_path:/infra/tier-1s/<tier-1> Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \"l2_extension\" object in the PUT/PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :segment_type Segment type
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentListResult]
    def global_infra_list_segments(tier_1_id, opts = {})
      data, _status_code, _headers = global_infra_list_segments_with_http_info(tier_1_id, opts)
      data
    end

    # Paginated list of all fixed segments (identified as /policy/api/v1/infra/tier-1s/&lt;tier-1-id&gt;/segments/&lt;segment-id&gt;) under Tier-1 instance.
    # Paginated list of all fixed segments (identified as /policy/api/v1/infra/tier-1s/&lt;tier-1-id&gt;/segments/&lt;segment-id&gt;) under Tier-1 instance. This API call does not return flexible segments (identified as /policy/api/v1/infra/segments/&lt;segment-id&gt;) connected to the Tier-1. To return all segments connected as a downlink to a Tier-1 one possibility is to use the search API with: https://{{nsx-mgr}}/policy/api/v1/search?query&#x3D;resource_type:Segment%20AND%20connectivity_path:/infra/tier-1s/&lt;tier-1&gt; Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \&quot;l2_extension\&quot; object in the PUT/PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :segment_type Segment type
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentListResult, Fixnum, Hash)>] SegmentListResult data, response status code and response headers
    def global_infra_list_segments_with_http_info(tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_segments ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_list_segments"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_segments, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_segments, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'segment_type'] && !['DVPortgroup', 'ALL'].include?(opts[:'segment_type'])
        fail ArgumentError, 'invalid value for "segment_type", must be one of DVPortgroup, ALL'
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'segment_type'] = opts[:'segment_type'] if !opts[:'segment_type'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_segments\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List SpoofGuard profiles
    # API will list all SpoofGuard profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SpoofGuardProfileListResult]
    def global_infra_list_spoof_guard_profiles(opts = {})
      data, _status_code, _headers = global_infra_list_spoof_guard_profiles_with_http_info(opts)
      data
    end

    # List SpoofGuard profiles
    # API will list all SpoofGuard profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SpoofGuardProfileListResult, Fixnum, Hash)>] SpoofGuardProfileListResult data, response status code and response headers
    def global_infra_list_spoof_guard_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_spoof_guard_profiles ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_spoof_guard_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_spoof_guard_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/spoofguard-profiles'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SpoofGuardProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_spoof_guard_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Tier-1 segment ports
    # List all the ports for a Tier-1 segment. 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentPortListResult]
    def global_infra_list_tier1_segment_ports(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = global_infra_list_tier1_segment_ports_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # List Tier-1 segment ports
    # List all the ports for a Tier-1 segment. 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentPortListResult, Fixnum, Hash)>] SegmentPortListResult data, response status code and response headers
    def global_infra_list_tier1_segment_ports_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_tier1_segment_ports ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_list_tier1_segment_ports"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_list_tier1_segment_ports"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_tier1_segment_ports, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.global_infra_list_tier1_segment_ports, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_tier1_segment_ports\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all effective profiles for tier-1 segment port
    # List all effective profiles for this segment port on given enforcement point.
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [EffectiveProfilesResponse]
    def global_infra_list_tier1_segment_ports_effective_profiles(tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = global_infra_list_tier1_segment_ports_effective_profiles_with_http_info(tier_1_id, segment_id, port_id, opts)
      data
    end

    # List all effective profiles for tier-1 segment port
    # List all effective profiles for this segment port on given enforcement point.
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [Array<(EffectiveProfilesResponse, Fixnum, Hash)>] EffectiveProfilesResponse data, response status code and response headers
    def global_infra_list_tier1_segment_ports_effective_profiles_with_http_info(tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_list_tier1_segment_ports_effective_profiles ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_list_tier1_segment_ports_effective_profiles"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_list_tier1_segment_ports_effective_profiles"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_list_tier1_segment_ports_effective_profiles"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/effective-profiles'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EffectiveProfilesResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_list_tier1_segment_ports_effective_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Infra Port Discovery Profile Binding Map
    # API will create Infra Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def global_infra_patch_infra_port_discovery_binding(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      global_infra_patch_infra_port_discovery_binding_with_http_info(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts)
      nil
    end

    # Create Infra Port Discovery Profile Binding Map
    # API will create Infra Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_patch_infra_port_discovery_binding_with_http_info(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_patch_infra_port_discovery_binding ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.global_infra_patch_infra_port_discovery_binding"
      end
      # verify the required parameter 'infra_port_id' is set
      if @api_client.config.client_side_validation && infra_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_port_id' when calling SegmentsApi.global_infra_patch_infra_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.global_infra_patch_infra_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map' when calling SegmentsApi.global_infra_patch_infra_port_discovery_binding"
      end
      # resource path
      local_var_path = '/global-infra/segments/{infra-segment-id}/ports/{infra-port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'infra-port-id' + '}', infra_port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_patch_infra_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Port QoS Profile Binding Map
    # API will create Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def global_infra_patch_infra_port_qo_s_binding(segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      global_infra_patch_infra_port_qo_s_binding_with_http_info(segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts)
      nil
    end

    # Create Port QoS Profile Binding Map
    # API will create Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_patch_infra_port_qo_s_binding_with_http_info(segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_patch_infra_port_qo_s_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_patch_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_patch_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.global_infra_patch_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_qo_s_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_qo_s_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_qo_s_profile_binding_map' when calling SegmentsApi.global_infra_patch_infra_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_qo_s_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_patch_infra_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch an infra segment port
    # Create an infra segment port if it does not exist based on the IDs, or update existing port information by replacing the port object fields which presents in the request body. 
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def global_infra_patch_infra_segment_port(segment_id, port_id, segment_port, opts = {})
      global_infra_patch_infra_segment_port_with_http_info(segment_id, port_id, segment_port, opts)
      nil
    end

    # Patch an infra segment port
    # Create an infra segment port if it does not exist based on the IDs, or update existing port information by replacing the port object fields which presents in the request body. 
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_patch_infra_segment_port_with_http_info(segment_id, port_id, segment_port, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_patch_infra_segment_port ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_patch_infra_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_patch_infra_segment_port"
      end
      # verify the required parameter 'segment_port' is set
      if @api_client.config.client_side_validation && segment_port.nil?
        fail ArgumentError, "Missing the required parameter 'segment_port' when calling SegmentsApi.global_infra_patch_infra_segment_port"
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/ports/{port-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_port)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_patch_infra_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch infra segment port security profile binding map
    # Create a new port security profile binding map if the given security profile binding map does not exist. Otherwise, patch the existing port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def global_infra_patch_infra_segment_port_security_profile_binding(segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      global_infra_patch_infra_segment_port_security_profile_binding_with_http_info(segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts)
      nil
    end

    # Patch infra segment port security profile binding map
    # Create a new port security profile binding map if the given security profile binding map does not exist. Otherwise, patch the existing port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_patch_infra_segment_port_security_profile_binding_with_http_info(segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_patch_infra_segment_port_security_profile_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_patch_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_patch_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.global_infra_patch_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map' when calling SegmentsApi.global_infra_patch_infra_segment_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_security_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_patch_infra_segment_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update L2 Bridge Endpoint Profile
    # API will create or update L2 bridge profile with ID profile-id. L2 Bridge profile is only allowed under an enforcement-point with path /infra/sites/default/enforcement-points/default. 
    # @param site_id site ID
    # @param enforcement_point_id enforcement point ID
    # @param profile_id profile ID
    # @param l2_bridge_endpoint_profile 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def global_infra_patch_l2_bridge_profile(site_id, enforcement_point_id, profile_id, l2_bridge_endpoint_profile, opts = {})
      global_infra_patch_l2_bridge_profile_with_http_info(site_id, enforcement_point_id, profile_id, l2_bridge_endpoint_profile, opts)
      nil
    end

    # Create or update L2 Bridge Endpoint Profile
    # API will create or update L2 bridge profile with ID profile-id. L2 Bridge profile is only allowed under an enforcement-point with path /infra/sites/default/enforcement-points/default. 
    # @param site_id site ID
    # @param enforcement_point_id enforcement point ID
    # @param profile_id profile ID
    # @param l2_bridge_endpoint_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_patch_l2_bridge_profile_with_http_info(site_id, enforcement_point_id, profile_id, l2_bridge_endpoint_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_patch_l2_bridge_profile ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SegmentsApi.global_infra_patch_l2_bridge_profile"
      end
      # verify the required parameter 'enforcement_point_id' is set
      if @api_client.config.client_side_validation && enforcement_point_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcement_point_id' when calling SegmentsApi.global_infra_patch_l2_bridge_profile"
      end
      # verify the required parameter 'profile_id' is set
      if @api_client.config.client_side_validation && profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'profile_id' when calling SegmentsApi.global_infra_patch_l2_bridge_profile"
      end
      # verify the required parameter 'l2_bridge_endpoint_profile' is set
      if @api_client.config.client_side_validation && l2_bridge_endpoint_profile.nil?
        fail ArgumentError, "Missing the required parameter 'l2_bridge_endpoint_profile' when calling SegmentsApi.global_infra_patch_l2_bridge_profile"
      end
      # resource path
      local_var_path = '/global-infra/sites/{site-id}/enforcement-points/{enforcement-point-id}/edge-bridge-profiles/{profile-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcement-point-id' + '}', enforcement_point_id.to_s).sub('{' + 'profile-id' + '}', profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(l2_bridge_endpoint_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_patch_l2_bridge_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Port Discovery Profile Binding Map
    # API will create Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def global_infra_patch_port_discovery_binding(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      global_infra_patch_port_discovery_binding_with_http_info(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts)
      nil
    end

    # Create Port Discovery Profile Binding Map
    # API will create Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_patch_port_discovery_binding_with_http_info(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_patch_port_discovery_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_patch_port_discovery_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_patch_port_discovery_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_patch_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.global_infra_patch_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map' when calling SegmentsApi.global_infra_patch_port_discovery_binding"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_patch_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Port QoS Profile Binding Map
    # API will create Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def global_infra_patch_port_qo_s_binding(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      global_infra_patch_port_qo_s_binding_with_http_info(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts)
      nil
    end

    # Create Port QoS Profile Binding Map
    # API will create Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_patch_port_qo_s_binding_with_http_info(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_patch_port_qo_s_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_patch_port_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_patch_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_patch_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.global_infra_patch_port_qo_s_binding"
      end
      # verify the required parameter 'port_qo_s_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_qo_s_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_qo_s_profile_binding_map' when calling SegmentsApi.global_infra_patch_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_qo_s_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_patch_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch port security profile binding map
    # Create a new port security profile binding map if the given security profile binding map does not exist. Otherwise, patch the existing port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def global_infra_patch_port_security_profile_binding(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      global_infra_patch_port_security_profile_binding_with_http_info(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts)
      nil
    end

    # Patch port security profile binding map
    # Create a new port security profile binding map if the given security profile binding map does not exist. Otherwise, patch the existing port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_patch_port_security_profile_binding_with_http_info(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_patch_port_security_profile_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_patch_port_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_patch_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_patch_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.global_infra_patch_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map' when calling SegmentsApi.global_infra_patch_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_security_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_patch_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch QoS profile.
    # Create a new QoS profile if the QoS profile with given id does not already exist. If the QoS profile with the given id already exists, patch with the existing QoS profile. 
    # @param qos_profile_id QoS profile Id
    # @param qo_s_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def global_infra_patch_qo_s_profile(qos_profile_id, qo_s_profile, opts = {})
      global_infra_patch_qo_s_profile_with_http_info(qos_profile_id, qo_s_profile, opts)
      nil
    end

    # Patch QoS profile.
    # Create a new QoS profile if the QoS profile with given id does not already exist. If the QoS profile with the given id already exists, patch with the existing QoS profile. 
    # @param qos_profile_id QoS profile Id
    # @param qo_s_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_patch_qo_s_profile_with_http_info(qos_profile_id, qo_s_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_patch_qo_s_profile ...'
      end
      # verify the required parameter 'qos_profile_id' is set
      if @api_client.config.client_side_validation && qos_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'qos_profile_id' when calling SegmentsApi.global_infra_patch_qo_s_profile"
      end
      # verify the required parameter 'qo_s_profile' is set
      if @api_client.config.client_side_validation && qo_s_profile.nil?
        fail ArgumentError, "Missing the required parameter 'qo_s_profile' when calling SegmentsApi.global_infra_patch_qo_s_profile"
      end
      # resource path
      local_var_path = '/global-infra/qos-profiles/{qos-profile-id}'.sub('{' + 'qos-profile-id' + '}', qos_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(qo_s_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_patch_qo_s_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # PATCH segment security profile id
    # Create a new segment security profile if the segment security profile with given id does not exist. Otherwise, PATCH the existing segment security profile 
    # @param segment_security_profile_id Segment security profile id
    # @param segment_security_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def global_infra_patch_segment_security_profile(segment_security_profile_id, segment_security_profile, opts = {})
      global_infra_patch_segment_security_profile_with_http_info(segment_security_profile_id, segment_security_profile, opts)
      nil
    end

    # PATCH segment security profile id
    # Create a new segment security profile if the segment security profile with given id does not exist. Otherwise, PATCH the existing segment security profile 
    # @param segment_security_profile_id Segment security profile id
    # @param segment_security_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_patch_segment_security_profile_with_http_info(segment_security_profile_id, segment_security_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_patch_segment_security_profile ...'
      end
      # verify the required parameter 'segment_security_profile_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_id' when calling SegmentsApi.global_infra_patch_segment_security_profile"
      end
      # verify the required parameter 'segment_security_profile' is set
      if @api_client.config.client_side_validation && segment_security_profile.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile' when calling SegmentsApi.global_infra_patch_segment_security_profile"
      end
      # resource path
      local_var_path = '/global-infra/segment-security-profiles/{segment-security-profile-id}'.sub('{' + 'segment-security-profile-id' + '}', segment_security_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_security_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_patch_segment_security_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch SpoofGuard profile
    # Create a new SpoofGuard profile if the SpoofGuard profile with the given id does not exist. Otherwise, patch with the existing SpoofGuard profile. 
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param spoof_guard_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def global_infra_patch_spoof_guard_profile(spoofguard_profile_id, spoof_guard_profile, opts = {})
      global_infra_patch_spoof_guard_profile_with_http_info(spoofguard_profile_id, spoof_guard_profile, opts)
      nil
    end

    # Patch SpoofGuard profile
    # Create a new SpoofGuard profile if the SpoofGuard profile with the given id does not exist. Otherwise, patch with the existing SpoofGuard profile. 
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param spoof_guard_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_patch_spoof_guard_profile_with_http_info(spoofguard_profile_id, spoof_guard_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_patch_spoof_guard_profile ...'
      end
      # verify the required parameter 'spoofguard_profile_id' is set
      if @api_client.config.client_side_validation && spoofguard_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'spoofguard_profile_id' when calling SegmentsApi.global_infra_patch_spoof_guard_profile"
      end
      # verify the required parameter 'spoof_guard_profile' is set
      if @api_client.config.client_side_validation && spoof_guard_profile.nil?
        fail ArgumentError, "Missing the required parameter 'spoof_guard_profile' when calling SegmentsApi.global_infra_patch_spoof_guard_profile"
      end
      # resource path
      local_var_path = '/global-infra/spoofguard-profiles/{spoofguard-profile-id}'.sub('{' + 'spoofguard-profile-id' + '}', spoofguard_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(spoof_guard_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_patch_spoof_guard_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch a Tier-1 segment port
    # Create a Tier-1 segment port if it does not exist based on the IDs, or update existing port information by replacing the port object fields which presents in the request body. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def global_infra_patch_tier1_segment_port(tier_1_id, segment_id, port_id, segment_port, opts = {})
      global_infra_patch_tier1_segment_port_with_http_info(tier_1_id, segment_id, port_id, segment_port, opts)
      nil
    end

    # Patch a Tier-1 segment port
    # Create a Tier-1 segment port if it does not exist based on the IDs, or update existing port information by replacing the port object fields which presents in the request body. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def global_infra_patch_tier1_segment_port_with_http_info(tier_1_id, segment_id, port_id, segment_port, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_patch_tier1_segment_port ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_patch_tier1_segment_port"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_patch_tier1_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_patch_tier1_segment_port"
      end
      # verify the required parameter 'segment_port' is set
      if @api_client.config.client_side_validation && segment_port.nil?
        fail ArgumentError, "Missing the required parameter 'segment_port' when calling SegmentsApi.global_infra_patch_tier1_segment_port"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_port)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_patch_tier1_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read infra segment
    # Read infra segment Note: Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \"l2_extension\" object in the PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the  error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param segment_id Segment ID
    # @param [Hash] opts the optional parameters
    # @return [Segment]
    def global_infra_read_infra_segment(segment_id, opts = {})
      data, _status_code, _headers = global_infra_read_infra_segment_with_http_info(segment_id, opts)
      data
    end

    # Read infra segment
    # Read infra segment Note: Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \&quot;l2_extension\&quot; object in the PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the  error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param segment_id Segment ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(Segment, Fixnum, Hash)>] Segment data, response status code and response headers
    def global_infra_read_infra_segment_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_read_infra_segment ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_read_infra_segment"
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Segment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_read_infra_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read infra segment
    # Read infra segment Note: Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \"l2_extension\" object in the PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the  error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param segment_id Segment ID
    # @param [Hash] opts the optional parameters
    # @return [Segment]
    def global_infra_read_infra_segment_0(segment_id, opts = {})
      data, _status_code, _headers = global_infra_read_infra_segment_0_with_http_info(segment_id, opts)
      data
    end

    # Read infra segment
    # Read infra segment Note: Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \&quot;l2_extension\&quot; object in the PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the  error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param segment_id Segment ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(Segment, Fixnum, Hash)>] Segment data, response status code and response headers
    def global_infra_read_infra_segment_0_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_read_infra_segment_0 ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_read_infra_segment_0"
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Segment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_read_infra_segment_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get L2 Bridge Endpoint Profile
    # Read L2 bridge profile with ID profile-id
    # @param site_id site ID
    # @param enforcement_point_id enforcement point ID
    # @param profile_id profile ID
    # @param [Hash] opts the optional parameters
    # @return [L2BridgeEndpointProfile]
    def global_infra_read_l2_bridge_profile(site_id, enforcement_point_id, profile_id, opts = {})
      data, _status_code, _headers = global_infra_read_l2_bridge_profile_with_http_info(site_id, enforcement_point_id, profile_id, opts)
      data
    end

    # Get L2 Bridge Endpoint Profile
    # Read L2 bridge profile with ID profile-id
    # @param site_id site ID
    # @param enforcement_point_id enforcement point ID
    # @param profile_id profile ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(L2BridgeEndpointProfile, Fixnum, Hash)>] L2BridgeEndpointProfile data, response status code and response headers
    def global_infra_read_l2_bridge_profile_with_http_info(site_id, enforcement_point_id, profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_read_l2_bridge_profile ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SegmentsApi.global_infra_read_l2_bridge_profile"
      end
      # verify the required parameter 'enforcement_point_id' is set
      if @api_client.config.client_side_validation && enforcement_point_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcement_point_id' when calling SegmentsApi.global_infra_read_l2_bridge_profile"
      end
      # verify the required parameter 'profile_id' is set
      if @api_client.config.client_side_validation && profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'profile_id' when calling SegmentsApi.global_infra_read_l2_bridge_profile"
      end
      # resource path
      local_var_path = '/global-infra/sites/{site-id}/enforcement-points/{enforcement-point-id}/edge-bridge-profiles/{profile-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcement-point-id' + '}', enforcement_point_id.to_s).sub('{' + 'profile-id' + '}', profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'L2BridgeEndpointProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_read_l2_bridge_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Details of QoS profile 
    # API will return details of QoS profile. 
    # @param qos_profile_id QoS profile Id
    # @param [Hash] opts the optional parameters
    # @return [QoSProfile]
    def global_infra_read_qo_s_profile(qos_profile_id, opts = {})
      data, _status_code, _headers = global_infra_read_qo_s_profile_with_http_info(qos_profile_id, opts)
      data
    end

    # Details of QoS profile 
    # API will return details of QoS profile. 
    # @param qos_profile_id QoS profile Id
    # @param [Hash] opts the optional parameters
    # @return [Array<(QoSProfile, Fixnum, Hash)>] QoSProfile data, response status code and response headers
    def global_infra_read_qo_s_profile_with_http_info(qos_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_read_qo_s_profile ...'
      end
      # verify the required parameter 'qos_profile_id' is set
      if @api_client.config.client_side_validation && qos_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'qos_profile_id' when calling SegmentsApi.global_infra_read_qo_s_profile"
      end
      # resource path
      local_var_path = '/global-infra/qos-profiles/{qos-profile-id}'.sub('{' + 'qos-profile-id' + '}', qos_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'QoSProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_read_qo_s_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read segment
    # Read segment Note:   Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the   \"l2_extension\" object in the PUT/PATCH API payload, the path returned in the GET response payload may include the new path   instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.   Also note that l2vpn path included in the error messages returned from validation may include the new VPN path   instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [Segment]
    def global_infra_read_segment(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = global_infra_read_segment_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # Read segment
    # Read segment Note:   Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the   \&quot;l2_extension\&quot; object in the PUT/PATCH API payload, the path returned in the GET response payload may include the new path   instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.   Also note that l2vpn path included in the error messages returned from validation may include the new VPN path   instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Segment, Fixnum, Hash)>] Segment data, response status code and response headers
    def global_infra_read_segment_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_read_segment ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_read_segment"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_read_segment"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Segment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_read_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read static ARP config
    # Read static ARP config
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [StaticARPConfig]
    def global_infra_read_static_arp_config(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = global_infra_read_static_arp_config_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # Read static ARP config
    # Read static ARP config
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(StaticARPConfig, Fixnum, Hash)>] StaticARPConfig data, response status code and response headers
    def global_infra_read_static_arp_config_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_read_static_arp_config ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_read_static_arp_config"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_read_static_arp_config"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/static-arp'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticARPConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_read_static_arp_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tier-1 segment bridge end point statistics using segment ID and profile path.
    # Get detailed information on Tier-1 segment bridge end point statistics using segment ID and profile path. 
    # @param tier_1_id 
    # @param segment_id 
    # @param bridge_profile_path Bridge profile path
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @return [BridgeEndpointStatistics]
    def global_infra_tier1_segment_bridge_endpoint_statistics(tier_1_id, segment_id, bridge_profile_path, opts = {})
      data, _status_code, _headers = global_infra_tier1_segment_bridge_endpoint_statistics_with_http_info(tier_1_id, segment_id, bridge_profile_path, opts)
      data
    end

    # Get Tier-1 segment bridge end point statistics using segment ID and profile path.
    # Get detailed information on Tier-1 segment bridge end point statistics using segment ID and profile path. 
    # @param tier_1_id 
    # @param segment_id 
    # @param bridge_profile_path Bridge profile path
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @return [Array<(BridgeEndpointStatistics, Fixnum, Hash)>] BridgeEndpointStatistics data, response status code and response headers
    def global_infra_tier1_segment_bridge_endpoint_statistics_with_http_info(tier_1_id, segment_id, bridge_profile_path, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_tier1_segment_bridge_endpoint_statistics ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_tier1_segment_bridge_endpoint_statistics"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_tier1_segment_bridge_endpoint_statistics"
      end
      # verify the required parameter 'bridge_profile_path' is set
      if @api_client.config.client_side_validation && bridge_profile_path.nil?
        fail ArgumentError, "Missing the required parameter 'bridge_profile_path' when calling SegmentsApi.global_infra_tier1_segment_bridge_endpoint_statistics"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/bep-statistics'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bridge_profile_path'] = bridge_profile_path
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BridgeEndpointStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_tier1_segment_bridge_endpoint_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tier-1 segment bridge end point status using segment ID and profile path.
    # Get detailed information on Tier-1 segment bridge end point status using segment ID and profile path. 
    # @param tier_1_id 
    # @param segment_id 
    # @param bridge_profile_path Bridge profile path
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @return [BridgeEndpointStatus]
    def global_infra_tier1_segment_bridge_endpoint_status(tier_1_id, segment_id, bridge_profile_path, opts = {})
      data, _status_code, _headers = global_infra_tier1_segment_bridge_endpoint_status_with_http_info(tier_1_id, segment_id, bridge_profile_path, opts)
      data
    end

    # Get Tier-1 segment bridge end point status using segment ID and profile path.
    # Get detailed information on Tier-1 segment bridge end point status using segment ID and profile path. 
    # @param tier_1_id 
    # @param segment_id 
    # @param bridge_profile_path Bridge profile path
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @return [Array<(BridgeEndpointStatus, Fixnum, Hash)>] BridgeEndpointStatus data, response status code and response headers
    def global_infra_tier1_segment_bridge_endpoint_status_with_http_info(tier_1_id, segment_id, bridge_profile_path, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_tier1_segment_bridge_endpoint_status ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_tier1_segment_bridge_endpoint_status"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_tier1_segment_bridge_endpoint_status"
      end
      # verify the required parameter 'bridge_profile_path' is set
      if @api_client.config.client_side_validation && bridge_profile_path.nil?
        fail ArgumentError, "Missing the required parameter 'bridge_profile_path' when calling SegmentsApi.global_infra_tier1_segment_bridge_endpoint_status"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/bep-status'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bridge_profile_path'] = bridge_profile_path
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BridgeEndpointStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_tier1_segment_bridge_endpoint_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Infra Port Discovery Profile Binding Map
    # API will update Infra Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortDiscoveryProfileBindingMap]
    def global_infra_update_infra_port_discovery_binding(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      data, _status_code, _headers = global_infra_update_infra_port_discovery_binding_with_http_info(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts)
      data
    end

    # Update Infra Port Discovery Profile Binding Map
    # API will update Infra Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortDiscoveryProfileBindingMap, Fixnum, Hash)>] PortDiscoveryProfileBindingMap data, response status code and response headers
    def global_infra_update_infra_port_discovery_binding_with_http_info(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_update_infra_port_discovery_binding ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.global_infra_update_infra_port_discovery_binding"
      end
      # verify the required parameter 'infra_port_id' is set
      if @api_client.config.client_side_validation && infra_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_port_id' when calling SegmentsApi.global_infra_update_infra_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.global_infra_update_infra_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map' when calling SegmentsApi.global_infra_update_infra_port_discovery_binding"
      end
      # resource path
      local_var_path = '/global-infra/segments/{infra-segment-id}/ports/{infra-port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'infra-port-id' + '}', infra_port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_update_infra_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Port QoS Profile Binding Map
    # API will update Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortQoSProfileBindingMap]
    def global_infra_update_infra_port_qo_s_binding(segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      data, _status_code, _headers = global_infra_update_infra_port_qo_s_binding_with_http_info(segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts)
      data
    end

    # Update Port QoS Profile Binding Map
    # API will update Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortQoSProfileBindingMap, Fixnum, Hash)>] PortQoSProfileBindingMap data, response status code and response headers
    def global_infra_update_infra_port_qo_s_binding_with_http_info(segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_update_infra_port_qo_s_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_update_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_update_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.global_infra_update_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_qo_s_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_qo_s_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_qo_s_profile_binding_map' when calling SegmentsApi.global_infra_update_infra_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/global-infra/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_qo_s_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_update_infra_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update IP Discovery Profile
    # API will update IP Discovery profile. 
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param ip_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [IPDiscoveryProfile]
    def global_infra_update_ip_discovery_profile(ip_discovery_profile_id, ip_discovery_profile, opts = {})
      data, _status_code, _headers = global_infra_update_ip_discovery_profile_with_http_info(ip_discovery_profile_id, ip_discovery_profile, opts)
      data
    end

    # Update IP Discovery Profile
    # API will update IP Discovery profile. 
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param ip_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(IPDiscoveryProfile, Fixnum, Hash)>] IPDiscoveryProfile data, response status code and response headers
    def global_infra_update_ip_discovery_profile_with_http_info(ip_discovery_profile_id, ip_discovery_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_update_ip_discovery_profile ...'
      end
      # verify the required parameter 'ip_discovery_profile_id' is set
      if @api_client.config.client_side_validation && ip_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'ip_discovery_profile_id' when calling SegmentsApi.global_infra_update_ip_discovery_profile"
      end
      # verify the required parameter 'ip_discovery_profile' is set
      if @api_client.config.client_side_validation && ip_discovery_profile.nil?
        fail ArgumentError, "Missing the required parameter 'ip_discovery_profile' when calling SegmentsApi.global_infra_update_ip_discovery_profile"
      end
      # resource path
      local_var_path = '/global-infra/ip-discovery-profiles/{ip-discovery-profile-id}'.sub('{' + 'ip-discovery-profile-id' + '}', ip_discovery_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(ip_discovery_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'IPDiscoveryProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_update_ip_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update L2 Bridge Endpoint Profile
    # API will create or update L2 bridge profile with ID profile-id. L2 Bridge profile is only allowed under an enforcement-point with path /infra/sites/default/enforcement-points/default. 
    # @param site_id site ID
    # @param enforcement_point_id enforcement point ID
    # @param profile_id profile ID
    # @param l2_bridge_endpoint_profile 
    # @param [Hash] opts the optional parameters
    # @return [L2BridgeEndpointProfile]
    def global_infra_update_l2_bridge_profile(site_id, enforcement_point_id, profile_id, l2_bridge_endpoint_profile, opts = {})
      data, _status_code, _headers = global_infra_update_l2_bridge_profile_with_http_info(site_id, enforcement_point_id, profile_id, l2_bridge_endpoint_profile, opts)
      data
    end

    # Create or update L2 Bridge Endpoint Profile
    # API will create or update L2 bridge profile with ID profile-id. L2 Bridge profile is only allowed under an enforcement-point with path /infra/sites/default/enforcement-points/default. 
    # @param site_id site ID
    # @param enforcement_point_id enforcement point ID
    # @param profile_id profile ID
    # @param l2_bridge_endpoint_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(L2BridgeEndpointProfile, Fixnum, Hash)>] L2BridgeEndpointProfile data, response status code and response headers
    def global_infra_update_l2_bridge_profile_with_http_info(site_id, enforcement_point_id, profile_id, l2_bridge_endpoint_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_update_l2_bridge_profile ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SegmentsApi.global_infra_update_l2_bridge_profile"
      end
      # verify the required parameter 'enforcement_point_id' is set
      if @api_client.config.client_side_validation && enforcement_point_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcement_point_id' when calling SegmentsApi.global_infra_update_l2_bridge_profile"
      end
      # verify the required parameter 'profile_id' is set
      if @api_client.config.client_side_validation && profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'profile_id' when calling SegmentsApi.global_infra_update_l2_bridge_profile"
      end
      # verify the required parameter 'l2_bridge_endpoint_profile' is set
      if @api_client.config.client_side_validation && l2_bridge_endpoint_profile.nil?
        fail ArgumentError, "Missing the required parameter 'l2_bridge_endpoint_profile' when calling SegmentsApi.global_infra_update_l2_bridge_profile"
      end
      # resource path
      local_var_path = '/global-infra/sites/{site-id}/enforcement-points/{enforcement-point-id}/edge-bridge-profiles/{profile-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcement-point-id' + '}', enforcement_point_id.to_s).sub('{' + 'profile-id' + '}', profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(l2_bridge_endpoint_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'L2BridgeEndpointProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_update_l2_bridge_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Mac Discovery Profile
    # API will update Mac Discovery profile. 
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param mac_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [MacDiscoveryProfile]
    def global_infra_update_mac_discovery_profile(mac_discovery_profile_id, mac_discovery_profile, opts = {})
      data, _status_code, _headers = global_infra_update_mac_discovery_profile_with_http_info(mac_discovery_profile_id, mac_discovery_profile, opts)
      data
    end

    # Update Mac Discovery Profile
    # API will update Mac Discovery profile. 
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param mac_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(MacDiscoveryProfile, Fixnum, Hash)>] MacDiscoveryProfile data, response status code and response headers
    def global_infra_update_mac_discovery_profile_with_http_info(mac_discovery_profile_id, mac_discovery_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_update_mac_discovery_profile ...'
      end
      # verify the required parameter 'mac_discovery_profile_id' is set
      if @api_client.config.client_side_validation && mac_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'mac_discovery_profile_id' when calling SegmentsApi.global_infra_update_mac_discovery_profile"
      end
      # verify the required parameter 'mac_discovery_profile' is set
      if @api_client.config.client_side_validation && mac_discovery_profile.nil?
        fail ArgumentError, "Missing the required parameter 'mac_discovery_profile' when calling SegmentsApi.global_infra_update_mac_discovery_profile"
      end
      # resource path
      local_var_path = '/global-infra/mac-discovery-profiles/{mac-discovery-profile-id}'.sub('{' + 'mac-discovery-profile-id' + '}', mac_discovery_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(mac_discovery_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MacDiscoveryProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_update_mac_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Port Discovery Profile Binding Map
    # API will update Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortDiscoveryProfileBindingMap]
    def global_infra_update_port_discovery_binding(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      data, _status_code, _headers = global_infra_update_port_discovery_binding_with_http_info(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts)
      data
    end

    # Update Port Discovery Profile Binding Map
    # API will update Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortDiscoveryProfileBindingMap, Fixnum, Hash)>] PortDiscoveryProfileBindingMap data, response status code and response headers
    def global_infra_update_port_discovery_binding_with_http_info(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_update_port_discovery_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_update_port_discovery_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_update_port_discovery_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_update_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.global_infra_update_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map' when calling SegmentsApi.global_infra_update_port_discovery_binding"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_update_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Port QoS Profile Binding Map
    # API will update Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortQoSProfileBindingMap]
    def global_infra_update_port_qo_s_binding(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      data, _status_code, _headers = global_infra_update_port_qo_s_binding_with_http_info(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts)
      data
    end

    # Update Port QoS Profile Binding Map
    # API will update Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortQoSProfileBindingMap, Fixnum, Hash)>] PortQoSProfileBindingMap data, response status code and response headers
    def global_infra_update_port_qo_s_binding_with_http_info(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.global_infra_update_port_qo_s_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.global_infra_update_port_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.global_infra_update_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.global_infra_update_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.global_infra_update_port_qo_s_binding"
      end
      # verify the required parameter 'port_qo_s_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_qo_s_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_qo_s_profile_binding_map' when calling SegmentsApi.global_infra_update_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/global-infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_qo_s_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#global_infra_update_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment bridge end point statistics using segment ID and profile path.
    # Get detailed information on infra segment bridge end point statistics using segment ID and profile path. 
    # @param segment_id 
    # @param bridge_profile_path Bridge profile path
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @return [BridgeEndpointStatistics]
    def infra_segment_bridge_endpoint_statistics(segment_id, bridge_profile_path, opts = {})
      data, _status_code, _headers = infra_segment_bridge_endpoint_statistics_with_http_info(segment_id, bridge_profile_path, opts)
      data
    end

    # Get infra segment bridge end point statistics using segment ID and profile path.
    # Get detailed information on infra segment bridge end point statistics using segment ID and profile path. 
    # @param segment_id 
    # @param bridge_profile_path Bridge profile path
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @return [Array<(BridgeEndpointStatistics, Fixnum, Hash)>] BridgeEndpointStatistics data, response status code and response headers
    def infra_segment_bridge_endpoint_statistics_with_http_info(segment_id, bridge_profile_path, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.infra_segment_bridge_endpoint_statistics ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.infra_segment_bridge_endpoint_statistics"
      end
      # verify the required parameter 'bridge_profile_path' is set
      if @api_client.config.client_side_validation && bridge_profile_path.nil?
        fail ArgumentError, "Missing the required parameter 'bridge_profile_path' when calling SegmentsApi.infra_segment_bridge_endpoint_statistics"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/bep-statistics'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bridge_profile_path'] = bridge_profile_path
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BridgeEndpointStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#infra_segment_bridge_endpoint_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tier-1 segment bridge end point status using segment ID and profile path.
    # Get detailed information on Tier-1 segment bridge end point status using segment ID and profile path. 
    # @param segment_id 
    # @param bridge_profile_path Bridge profile path
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @return [BridgeEndpointStatus]
    def infra_segment_bridge_endpoint_status(segment_id, bridge_profile_path, opts = {})
      data, _status_code, _headers = infra_segment_bridge_endpoint_status_with_http_info(segment_id, bridge_profile_path, opts)
      data
    end

    # Get Tier-1 segment bridge end point status using segment ID and profile path.
    # Get detailed information on Tier-1 segment bridge end point status using segment ID and profile path. 
    # @param segment_id 
    # @param bridge_profile_path Bridge profile path
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @return [Array<(BridgeEndpointStatus, Fixnum, Hash)>] BridgeEndpointStatus data, response status code and response headers
    def infra_segment_bridge_endpoint_status_with_http_info(segment_id, bridge_profile_path, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.infra_segment_bridge_endpoint_status ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.infra_segment_bridge_endpoint_status"
      end
      # verify the required parameter 'bridge_profile_path' is set
      if @api_client.config.client_side_validation && bridge_profile_path.nil?
        fail ArgumentError, "Missing the required parameter 'bridge_profile_path' when calling SegmentsApi.infra_segment_bridge_endpoint_status"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/bep-status'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bridge_profile_path'] = bridge_profile_path
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BridgeEndpointStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#infra_segment_bridge_endpoint_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all segments under infra
    # Paginated list of all segments under infra. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :segment_type Segment type
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentListResult]
    def list_all_infra_segments(opts = {})
      data, _status_code, _headers = list_all_infra_segments_with_http_info(opts)
      data
    end

    # List all segments under infra
    # Paginated list of all segments under infra. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :segment_type Segment type
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentListResult, Fixnum, Hash)>] SegmentListResult data, response status code and response headers
    def list_all_infra_segments_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_all_infra_segments ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_all_infra_segments, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_all_infra_segments, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'segment_type'] && !['DVPortgroup', 'ALL'].include?(opts[:'segment_type'])
        fail ArgumentError, 'invalid value for "segment_type", must be one of DVPortgroup, ALL'
      end
      # resource path
      local_var_path = '/infra/segments'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'segment_type'] = opts[:'segment_type'] if !opts[:'segment_type'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_all_infra_segments\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all segments under infra
    # Paginated list of all segments under infra. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :segment_type Segment type
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentListResult]
    def list_all_infra_segments_0(opts = {})
      data, _status_code, _headers = list_all_infra_segments_0_with_http_info(opts)
      data
    end

    # List all segments under infra
    # Paginated list of all segments under infra. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :segment_type Segment type
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentListResult, Fixnum, Hash)>] SegmentListResult data, response status code and response headers
    def list_all_infra_segments_0_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_all_infra_segments_0 ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_all_infra_segments_0, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_all_infra_segments_0, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'segment_type'] && !['DVPortgroup', 'ALL'].include?(opts[:'segment_type'])
        fail ArgumentError, 'invalid value for "segment_type", must be one of DVPortgroup, ALL'
      end
      # resource path
      local_var_path = '/infra/segments'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'segment_type'] = opts[:'segment_type'] if !opts[:'segment_type'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_all_infra_segments_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Group discovery profile binding map
    # API will get Group discovery profile binding map
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [GroupDiscoveryProfileBindingMapListResult]
    def list_group_discovery_profile_bindings(domain_id, group_id, opts = {})
      data, _status_code, _headers = list_group_discovery_profile_bindings_with_http_info(domain_id, group_id, opts)
      data
    end

    # Get Group discovery profile binding map
    # API will get Group discovery profile binding map
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(GroupDiscoveryProfileBindingMapListResult, Fixnum, Hash)>] GroupDiscoveryProfileBindingMapListResult data, response status code and response headers
    def list_group_discovery_profile_bindings_with_http_info(domain_id, group_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_group_discovery_profile_bindings ...'
      end
      # verify the required parameter 'domain_id' is set
      if @api_client.config.client_side_validation && domain_id.nil?
        fail ArgumentError, "Missing the required parameter 'domain_id' when calling SegmentsApi.list_group_discovery_profile_bindings"
      end
      # verify the required parameter 'group_id' is set
      if @api_client.config.client_side_validation && group_id.nil?
        fail ArgumentError, "Missing the required parameter 'group_id' when calling SegmentsApi.list_group_discovery_profile_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_group_discovery_profile_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_group_discovery_profile_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/domains/{domain-id}/groups/{group-id}/discovery-profile-binding-maps'.sub('{' + 'domain-id' + '}', domain_id.to_s).sub('{' + 'group-id' + '}', group_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'GroupDiscoveryProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_group_discovery_profile_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Infra Port Discovery Profile Binding Maps
    # API will list all Infra Port Discovery Profile Binding Maps in current port id. 
    # @param infra_segment_id 
    # @param infra_port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortDiscoveryProfileBindingMapListResult]
    def list_infra_port_discovery_bindings(infra_segment_id, infra_port_id, opts = {})
      data, _status_code, _headers = list_infra_port_discovery_bindings_with_http_info(infra_segment_id, infra_port_id, opts)
      data
    end

    # List Infra Port Discovery Profile Binding Maps
    # API will list all Infra Port Discovery Profile Binding Maps in current port id. 
    # @param infra_segment_id 
    # @param infra_port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortDiscoveryProfileBindingMapListResult, Fixnum, Hash)>] PortDiscoveryProfileBindingMapListResult data, response status code and response headers
    def list_infra_port_discovery_bindings_with_http_info(infra_segment_id, infra_port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_infra_port_discovery_bindings ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.list_infra_port_discovery_bindings"
      end
      # verify the required parameter 'infra_port_id' is set
      if @api_client.config.client_side_validation && infra_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_port_id' when calling SegmentsApi.list_infra_port_discovery_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_port_discovery_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_port_discovery_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/ports/{infra-port-id}/port-discovery-profile-binding-maps'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'infra-port-id' + '}', infra_port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortDiscoveryProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_infra_port_discovery_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Infra Port Monitoring Profile Binding Maps
    # API will list all Infra Port Monitoring Profile Binding Maps in current port id. 
    # @param infra_segment_id 
    # @param infra_port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortMonitoringProfileBindingMapListResult]
    def list_infra_port_monitoring_bindings(infra_segment_id, infra_port_id, opts = {})
      data, _status_code, _headers = list_infra_port_monitoring_bindings_with_http_info(infra_segment_id, infra_port_id, opts)
      data
    end

    # List Infra Port Monitoring Profile Binding Maps
    # API will list all Infra Port Monitoring Profile Binding Maps in current port id. 
    # @param infra_segment_id 
    # @param infra_port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortMonitoringProfileBindingMapListResult, Fixnum, Hash)>] PortMonitoringProfileBindingMapListResult data, response status code and response headers
    def list_infra_port_monitoring_bindings_with_http_info(infra_segment_id, infra_port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_infra_port_monitoring_bindings ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.list_infra_port_monitoring_bindings"
      end
      # verify the required parameter 'infra_port_id' is set
      if @api_client.config.client_side_validation && infra_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_port_id' when calling SegmentsApi.list_infra_port_monitoring_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_port_monitoring_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_port_monitoring_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/ports/{infra-port-id}/port-monitoring-profile-binding-maps'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'infra-port-id' + '}', infra_port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortMonitoringProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_infra_port_monitoring_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Port QoS Profile Binding Maps
    # API will list all Port QoS Profile Binding Maps in current port id. 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortQoSProfileBindingMapListResult]
    def list_infra_port_qo_s_bindings(segment_id, port_id, opts = {})
      data, _status_code, _headers = list_infra_port_qo_s_bindings_with_http_info(segment_id, port_id, opts)
      data
    end

    # List Port QoS Profile Binding Maps
    # API will list all Port QoS Profile Binding Maps in current port id. 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortQoSProfileBindingMapListResult, Fixnum, Hash)>] PortQoSProfileBindingMapListResult data, response status code and response headers
    def list_infra_port_qo_s_bindings_with_http_info(segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_infra_port_qo_s_bindings ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_infra_port_qo_s_bindings"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.list_infra_port_qo_s_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_port_qo_s_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_port_qo_s_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortQoSProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_infra_port_qo_s_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Port Real Time Eth Profile Binding Maps
    # API will list all Port Real Time Eth Profile Binding Maps in current port id. 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortRealTimeEthProfileBindingMapListResult]
    def list_infra_port_real_time_eth_bindings(segment_id, port_id, opts = {})
      data, _status_code, _headers = list_infra_port_real_time_eth_bindings_with_http_info(segment_id, port_id, opts)
      data
    end

    # List Port Real Time Eth Profile Binding Maps
    # API will list all Port Real Time Eth Profile Binding Maps in current port id. 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortRealTimeEthProfileBindingMapListResult, Fixnum, Hash)>] PortRealTimeEthProfileBindingMapListResult data, response status code and response headers
    def list_infra_port_real_time_eth_bindings_with_http_info(segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_infra_port_real_time_eth_bindings ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_infra_port_real_time_eth_bindings"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.list_infra_port_real_time_eth_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_port_real_time_eth_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_port_real_time_eth_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}/port-real-time-eth-profile-binding-maps'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortRealTimeEthProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_infra_port_real_time_eth_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List SegmentConnectionBindingMap specific Segment
    # List SegmentConnectionBindingMap specific Segment 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentConnectionBindingMapListResult]
    def list_infra_segment_connection_binding_map(segment_id, opts = {})
      data, _status_code, _headers = list_infra_segment_connection_binding_map_with_http_info(segment_id, opts)
      data
    end

    # List SegmentConnectionBindingMap specific Segment
    # List SegmentConnectionBindingMap specific Segment 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentConnectionBindingMapListResult, Fixnum, Hash)>] SegmentConnectionBindingMapListResult data, response status code and response headers
    def list_infra_segment_connection_binding_map_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_infra_segment_connection_binding_map ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_infra_segment_connection_binding_map"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_segment_connection_binding_map, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_segment_connection_binding_map, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/segments/{segment-id}/segment-connection-binding-maps'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConnectionBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_infra_segment_connection_binding_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Infra Segment Discovery Profile Binding Maps
    # API will list all Infra Segment Discovery Profile Binding Maps in current segment id. 
    # @param infra_segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentDiscoveryProfileBindingMapListResult]
    def list_infra_segment_discovery_bindings(infra_segment_id, opts = {})
      data, _status_code, _headers = list_infra_segment_discovery_bindings_with_http_info(infra_segment_id, opts)
      data
    end

    # List Infra Segment Discovery Profile Binding Maps
    # API will list all Infra Segment Discovery Profile Binding Maps in current segment id. 
    # @param infra_segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentDiscoveryProfileBindingMapListResult, Fixnum, Hash)>] SegmentDiscoveryProfileBindingMapListResult data, response status code and response headers
    def list_infra_segment_discovery_bindings_with_http_info(infra_segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_infra_segment_discovery_bindings ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.list_infra_segment_discovery_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_segment_discovery_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_segment_discovery_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/segment-discovery-profile-binding-maps'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentDiscoveryProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_infra_segment_discovery_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all effective profiles for infra segment
    # List all effective profiles for this segment on given enforcement point.
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [EffectiveProfilesResponse]
    def list_infra_segment_effective_profiles(segment_id, opts = {})
      data, _status_code, _headers = list_infra_segment_effective_profiles_with_http_info(segment_id, opts)
      data
    end

    # List all effective profiles for infra segment
    # List all effective profiles for this segment on given enforcement point.
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [Array<(EffectiveProfilesResponse, Fixnum, Hash)>] EffectiveProfilesResponse data, response status code and response headers
    def list_infra_segment_effective_profiles_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_infra_segment_effective_profiles ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_infra_segment_effective_profiles"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/effective-profiles'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EffectiveProfilesResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_infra_segment_effective_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all effective profiles for infra segment
    # List all effective profiles for this segment on given enforcement point.
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [EffectiveProfilesResponse]
    def list_infra_segment_effective_profiles_0(segment_id, opts = {})
      data, _status_code, _headers = list_infra_segment_effective_profiles_0_with_http_info(segment_id, opts)
      data
    end

    # List all effective profiles for infra segment
    # List all effective profiles for this segment on given enforcement point.
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [Array<(EffectiveProfilesResponse, Fixnum, Hash)>] EffectiveProfilesResponse data, response status code and response headers
    def list_infra_segment_effective_profiles_0_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_infra_segment_effective_profiles_0 ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_infra_segment_effective_profiles_0"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/effective-profiles'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EffectiveProfilesResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_infra_segment_effective_profiles_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Infra Segment Monitoring Profile Binding Maps
    # API will list all Infra Segment Monitoring Profile Binding Maps in current segment id. 
    # @param infra_segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentMonitoringProfileBindingMapListResult]
    def list_infra_segment_monitoring_bindings(infra_segment_id, opts = {})
      data, _status_code, _headers = list_infra_segment_monitoring_bindings_with_http_info(infra_segment_id, opts)
      data
    end

    # List Infra Segment Monitoring Profile Binding Maps
    # API will list all Infra Segment Monitoring Profile Binding Maps in current segment id. 
    # @param infra_segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentMonitoringProfileBindingMapListResult, Fixnum, Hash)>] SegmentMonitoringProfileBindingMapListResult data, response status code and response headers
    def list_infra_segment_monitoring_bindings_with_http_info(infra_segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_infra_segment_monitoring_bindings ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.list_infra_segment_monitoring_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_segment_monitoring_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_segment_monitoring_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/segment-monitoring-profile-binding-maps'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentMonitoringProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_infra_segment_monitoring_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List infra segment port security profile binding maps
    # API will list all port security profile binding maps. 
    # @param segment_id segment id
    # @param port_id port id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortSecurityProfileBindingMapListResult]
    def list_infra_segment_port_security_profile_bindings(segment_id, port_id, opts = {})
      data, _status_code, _headers = list_infra_segment_port_security_profile_bindings_with_http_info(segment_id, port_id, opts)
      data
    end

    # List infra segment port security profile binding maps
    # API will list all port security profile binding maps. 
    # @param segment_id segment id
    # @param port_id port id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortSecurityProfileBindingMapListResult, Fixnum, Hash)>] PortSecurityProfileBindingMapListResult data, response status code and response headers
    def list_infra_segment_port_security_profile_bindings_with_http_info(segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_infra_segment_port_security_profile_bindings ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_infra_segment_port_security_profile_bindings"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.list_infra_segment_port_security_profile_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_segment_port_security_profile_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_segment_port_security_profile_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortSecurityProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_infra_segment_port_security_profile_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List infra segment ports
    # List all the ports for an infra. 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentPortListResult]
    def list_infra_segment_ports(segment_id, opts = {})
      data, _status_code, _headers = list_infra_segment_ports_with_http_info(segment_id, opts)
      data
    end

    # List infra segment ports
    # List all the ports for an infra. 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentPortListResult, Fixnum, Hash)>] SegmentPortListResult data, response status code and response headers
    def list_infra_segment_ports_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_infra_segment_ports ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_infra_segment_ports"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_segment_ports, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_segment_ports, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_infra_segment_ports\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all effective profiles for infra segment port
    # List all effective profiles for this segment port on given enforcement point.
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [EffectiveProfilesResponse]
    def list_infra_segment_ports_effective_profiles(segment_id, port_id, opts = {})
      data, _status_code, _headers = list_infra_segment_ports_effective_profiles_with_http_info(segment_id, port_id, opts)
      data
    end

    # List all effective profiles for infra segment port
    # List all effective profiles for this segment port on given enforcement point.
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [Array<(EffectiveProfilesResponse, Fixnum, Hash)>] EffectiveProfilesResponse data, response status code and response headers
    def list_infra_segment_ports_effective_profiles_with_http_info(segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_infra_segment_ports_effective_profiles ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_infra_segment_ports_effective_profiles"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.list_infra_segment_ports_effective_profiles"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}/effective-profiles'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EffectiveProfilesResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_infra_segment_ports_effective_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Segment QoS Profile Binding Maps
    # API will list all Segment QoS Profile Binding Maps in current segment id. 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentQoSProfileBindingMapListResult]
    def list_infra_segment_qo_s_bindings(segment_id, opts = {})
      data, _status_code, _headers = list_infra_segment_qo_s_bindings_with_http_info(segment_id, opts)
      data
    end

    # List Segment QoS Profile Binding Maps
    # API will list all Segment QoS Profile Binding Maps in current segment id. 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentQoSProfileBindingMapListResult, Fixnum, Hash)>] SegmentQoSProfileBindingMapListResult data, response status code and response headers
    def list_infra_segment_qo_s_bindings_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_infra_segment_qo_s_bindings ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_infra_segment_qo_s_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_segment_qo_s_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_segment_qo_s_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/segments/{segment-id}/segment-qos-profile-binding-maps'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentQoSProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_infra_segment_qo_s_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Segment Real Time Eth Profile Binding Maps
    # API will list all Segment Real Time Eth Profile Binding Maps in current segment id. 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentRealTimeEthProfileBindingMapListResult]
    def list_infra_segment_real_time_eth_bindings(segment_id, opts = {})
      data, _status_code, _headers = list_infra_segment_real_time_eth_bindings_with_http_info(segment_id, opts)
      data
    end

    # List Segment Real Time Eth Profile Binding Maps
    # API will list all Segment Real Time Eth Profile Binding Maps in current segment id. 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentRealTimeEthProfileBindingMapListResult, Fixnum, Hash)>] SegmentRealTimeEthProfileBindingMapListResult data, response status code and response headers
    def list_infra_segment_real_time_eth_bindings_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_infra_segment_real_time_eth_bindings ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_infra_segment_real_time_eth_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_segment_real_time_eth_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_segment_real_time_eth_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/segments/{segment-id}/segment-real-time-eth-profile-binding-maps'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentRealTimeEthProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_infra_segment_real_time_eth_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List infra segment security profile binding maps
    # API will list all segment security profile binding maps. 
    # @param segment_id segment id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentSecurityProfileBindingMapListResult]
    def list_infra_segment_security_profile_bindings(segment_id, opts = {})
      data, _status_code, _headers = list_infra_segment_security_profile_bindings_with_http_info(segment_id, opts)
      data
    end

    # List infra segment security profile binding maps
    # API will list all segment security profile binding maps. 
    # @param segment_id segment id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentSecurityProfileBindingMapListResult, Fixnum, Hash)>] SegmentSecurityProfileBindingMapListResult data, response status code and response headers
    def list_infra_segment_security_profile_bindings_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_infra_segment_security_profile_bindings ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_infra_segment_security_profile_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_segment_security_profile_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_infra_segment_security_profile_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/segments/{segment-id}/segment-security-profile-binding-maps'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_infra_segment_security_profile_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List L2 Bridge Endpoint Profiles
    # List all L2 bridge profiles
    # @param site_id site ID
    # @param enforcement_point_id enforcement point ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [L2BridgeEndpointProfileListResult]
    def list_l2_bridge_profiles(site_id, enforcement_point_id, opts = {})
      data, _status_code, _headers = list_l2_bridge_profiles_with_http_info(site_id, enforcement_point_id, opts)
      data
    end

    # List L2 Bridge Endpoint Profiles
    # List all L2 bridge profiles
    # @param site_id site ID
    # @param enforcement_point_id enforcement point ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(L2BridgeEndpointProfileListResult, Fixnum, Hash)>] L2BridgeEndpointProfileListResult data, response status code and response headers
    def list_l2_bridge_profiles_with_http_info(site_id, enforcement_point_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_l2_bridge_profiles ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SegmentsApi.list_l2_bridge_profiles"
      end
      # verify the required parameter 'enforcement_point_id' is set
      if @api_client.config.client_side_validation && enforcement_point_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcement_point_id' when calling SegmentsApi.list_l2_bridge_profiles"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_l2_bridge_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_l2_bridge_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcement-point-id}/edge-bridge-profiles'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcement-point-id' + '}', enforcement_point_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'L2BridgeEndpointProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_l2_bridge_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Port Discovery Profile Binding Maps
    # API will list all Port Discovery Profile Binding Maps in current port id. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortDiscoveryProfileBindingMapListResult]
    def list_port_discovery_bindings(tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = list_port_discovery_bindings_with_http_info(tier_1_id, segment_id, port_id, opts)
      data
    end

    # List Port Discovery Profile Binding Maps
    # API will list all Port Discovery Profile Binding Maps in current port id. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortDiscoveryProfileBindingMapListResult, Fixnum, Hash)>] PortDiscoveryProfileBindingMapListResult data, response status code and response headers
    def list_port_discovery_bindings_with_http_info(tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_port_discovery_bindings ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.list_port_discovery_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_port_discovery_bindings"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.list_port_discovery_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_port_discovery_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_port_discovery_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-discovery-profile-binding-maps'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortDiscoveryProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_port_discovery_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Port Monitoring Profile Binding Maps
    # API will list all Port Monitoring Profile Binding Maps in current port id. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortMonitoringProfileBindingMapListResult]
    def list_port_monitoring_bindings(tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = list_port_monitoring_bindings_with_http_info(tier_1_id, segment_id, port_id, opts)
      data
    end

    # List Port Monitoring Profile Binding Maps
    # API will list all Port Monitoring Profile Binding Maps in current port id. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortMonitoringProfileBindingMapListResult, Fixnum, Hash)>] PortMonitoringProfileBindingMapListResult data, response status code and response headers
    def list_port_monitoring_bindings_with_http_info(tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_port_monitoring_bindings ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.list_port_monitoring_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_port_monitoring_bindings"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.list_port_monitoring_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_port_monitoring_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_port_monitoring_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-monitoring-profile-binding-maps'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortMonitoringProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_port_monitoring_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Port QoS Profile Binding Maps
    # API will list all Port QoS Profile Binding Maps in current port id. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortQoSProfileBindingMapListResult]
    def list_port_qo_s_bindings(tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = list_port_qo_s_bindings_with_http_info(tier_1_id, segment_id, port_id, opts)
      data
    end

    # List Port QoS Profile Binding Maps
    # API will list all Port QoS Profile Binding Maps in current port id. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortQoSProfileBindingMapListResult, Fixnum, Hash)>] PortQoSProfileBindingMapListResult data, response status code and response headers
    def list_port_qo_s_bindings_with_http_info(tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_port_qo_s_bindings ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.list_port_qo_s_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_port_qo_s_bindings"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.list_port_qo_s_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_port_qo_s_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_port_qo_s_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortQoSProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_port_qo_s_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List port security profile binding maps
    # API will list all port security profile binding maps. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortSecurityProfileBindingMapListResult]
    def list_port_security_profile_bindings(tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = list_port_security_profile_bindings_with_http_info(tier_1_id, segment_id, port_id, opts)
      data
    end

    # List port security profile binding maps
    # API will list all port security profile binding maps. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortSecurityProfileBindingMapListResult, Fixnum, Hash)>] PortSecurityProfileBindingMapListResult data, response status code and response headers
    def list_port_security_profile_bindings_with_http_info(tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_port_security_profile_bindings ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.list_port_security_profile_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_port_security_profile_bindings"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.list_port_security_profile_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_port_security_profile_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_port_security_profile_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortSecurityProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_port_security_profile_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List QoS Profiles
    # API will list all QoS profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [QoSProfileListResult]
    def list_qo_s_profiles(opts = {})
      data, _status_code, _headers = list_qo_s_profiles_with_http_info(opts)
      data
    end

    # List QoS Profiles
    # API will list all QoS profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(QoSProfileListResult, Fixnum, Hash)>] QoSProfileListResult data, response status code and response headers
    def list_qo_s_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_qo_s_profiles ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_qo_s_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_qo_s_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/qos-profiles'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'QoSProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_qo_s_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Real Time Eth Profiles
    # API will list all Real Time Eth profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [RealTimeEthProfileListResult]
    def list_real_time_eth_profiles(opts = {})
      data, _status_code, _headers = list_real_time_eth_profiles_with_http_info(opts)
      data
    end

    # List Real Time Eth Profiles
    # API will list all Real Time Eth profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(RealTimeEthProfileListResult, Fixnum, Hash)>] RealTimeEthProfileListResult data, response status code and response headers
    def list_real_time_eth_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_real_time_eth_profiles ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_real_time_eth_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_real_time_eth_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/real-time-eth-profiles'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RealTimeEthProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_real_time_eth_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Segment Discovery Profile Binding Maps
    # API will list all Segment Discovery Profile Binding Maps in current segment id. 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentDiscoveryProfileBindingMapListResult]
    def list_segment_discovery_bindings(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = list_segment_discovery_bindings_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # List Segment Discovery Profile Binding Maps
    # API will list all Segment Discovery Profile Binding Maps in current segment id. 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentDiscoveryProfileBindingMapListResult, Fixnum, Hash)>] SegmentDiscoveryProfileBindingMapListResult data, response status code and response headers
    def list_segment_discovery_bindings_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_segment_discovery_bindings ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.list_segment_discovery_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_segment_discovery_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_segment_discovery_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_segment_discovery_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-discovery-profile-binding-maps'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentDiscoveryProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_segment_discovery_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all effective profiles for segment
    # List all effective profiles for this segment on given enforcement point.
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [EffectiveProfilesResponse]
    def list_segment_effective_profiles(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = list_segment_effective_profiles_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # List all effective profiles for segment
    # List all effective profiles for this segment on given enforcement point.
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [Array<(EffectiveProfilesResponse, Fixnum, Hash)>] EffectiveProfilesResponse data, response status code and response headers
    def list_segment_effective_profiles_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_segment_effective_profiles ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.list_segment_effective_profiles"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_segment_effective_profiles"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/effective-profiles'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EffectiveProfilesResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_segment_effective_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Segment Monitoring Profile Binding Maps
    # API will list all Segment Monitoring Profile Binding Maps in current segment id. 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentMonitoringProfileBindingMapListResult]
    def list_segment_monitoring_bindings(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = list_segment_monitoring_bindings_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # List Segment Monitoring Profile Binding Maps
    # API will list all Segment Monitoring Profile Binding Maps in current segment id. 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentMonitoringProfileBindingMapListResult, Fixnum, Hash)>] SegmentMonitoringProfileBindingMapListResult data, response status code and response headers
    def list_segment_monitoring_bindings_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_segment_monitoring_bindings ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.list_segment_monitoring_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_segment_monitoring_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_segment_monitoring_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_segment_monitoring_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-monitoring-profile-binding-maps'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentMonitoringProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_segment_monitoring_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Segment QoS Profile Binding Maps
    # API will list all Segment QoS Profile Binding Maps in current segment id. 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentQoSProfileBindingMapListResult]
    def list_segment_qo_s_bindings(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = list_segment_qo_s_bindings_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # List Segment QoS Profile Binding Maps
    # API will list all Segment QoS Profile Binding Maps in current segment id. 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentQoSProfileBindingMapListResult, Fixnum, Hash)>] SegmentQoSProfileBindingMapListResult data, response status code and response headers
    def list_segment_qo_s_bindings_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_segment_qo_s_bindings ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.list_segment_qo_s_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_segment_qo_s_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_segment_qo_s_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_segment_qo_s_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-qos-profile-binding-maps'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentQoSProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_segment_qo_s_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List segment security profile binding maps
    # API will list all segment security profile binding maps. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentSecurityProfileBindingMapListResult]
    def list_segment_security_profile_bindings(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = list_segment_security_profile_bindings_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # List segment security profile binding maps
    # API will list all segment security profile binding maps. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentSecurityProfileBindingMapListResult, Fixnum, Hash)>] SegmentSecurityProfileBindingMapListResult data, response status code and response headers
    def list_segment_security_profile_bindings_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_segment_security_profile_bindings ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.list_segment_security_profile_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_segment_security_profile_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_segment_security_profile_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_segment_security_profile_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-security-profile-binding-maps'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_segment_security_profile_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List segment security profiles
    # API will list all segment security profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentSecurityProfileListResult]
    def list_segment_security_profiles(opts = {})
      data, _status_code, _headers = list_segment_security_profiles_with_http_info(opts)
      data
    end

    # List segment security profiles
    # API will list all segment security profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentSecurityProfileListResult, Fixnum, Hash)>] SegmentSecurityProfileListResult data, response status code and response headers
    def list_segment_security_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_segment_security_profiles ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_segment_security_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_segment_security_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/segment-security-profiles'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_segment_security_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Paginated list of all fixed segments (identified as /policy/api/v1/infra/tier-1s/<tier-1-id>/segments/<segment-id>) under Tier-1 instance.
    # Paginated list of all fixed segments (identified as /policy/api/v1/infra/tier-1s/<tier-1-id>/segments/<segment-id>) under Tier-1 instance. This API call does not return flexible segments (identified as /policy/api/v1/infra/segments/<segment-id>) connected to the Tier-1. To return all segments connected as a downlink to a Tier-1 one possibility is to use the search API with: https://{{nsx-mgr}}/policy/api/v1/search?query=resource_type:Segment%20AND%20connectivity_path:/infra/tier-1s/<tier-1> Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \"l2_extension\" object in the PUT/PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :segment_type Segment type
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentListResult]
    def list_segments(tier_1_id, opts = {})
      data, _status_code, _headers = list_segments_with_http_info(tier_1_id, opts)
      data
    end

    # Paginated list of all fixed segments (identified as /policy/api/v1/infra/tier-1s/&lt;tier-1-id&gt;/segments/&lt;segment-id&gt;) under Tier-1 instance.
    # Paginated list of all fixed segments (identified as /policy/api/v1/infra/tier-1s/&lt;tier-1-id&gt;/segments/&lt;segment-id&gt;) under Tier-1 instance. This API call does not return flexible segments (identified as /policy/api/v1/infra/segments/&lt;segment-id&gt;) connected to the Tier-1. To return all segments connected as a downlink to a Tier-1 one possibility is to use the search API with: https://{{nsx-mgr}}/policy/api/v1/search?query&#x3D;resource_type:Segment%20AND%20connectivity_path:/infra/tier-1s/&lt;tier-1&gt; Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \&quot;l2_extension\&quot; object in the PUT/PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :segment_type Segment type
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentListResult, Fixnum, Hash)>] SegmentListResult data, response status code and response headers
    def list_segments_with_http_info(tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_segments ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.list_segments"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_segments, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_segments, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'segment_type'] && !['DVPortgroup', 'ALL'].include?(opts[:'segment_type'])
        fail ArgumentError, 'invalid value for "segment_type", must be one of DVPortgroup, ALL'
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'segment_type'] = opts[:'segment_type'] if !opts[:'segment_type'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_segments\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Service Segments
    # Paginated list of all Service Segments 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [ServiceSegmentListResult]
    def list_service_segments(opts = {})
      data, _status_code, _headers = list_service_segments_with_http_info(opts)
      data
    end

    # List Service Segments
    # Paginated list of all Service Segments 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(ServiceSegmentListResult, Fixnum, Hash)>] ServiceSegmentListResult data, response status code and response headers
    def list_service_segments_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_service_segments ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_service_segments, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_service_segments, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/segments/service-segments'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceSegmentListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_service_segments\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List SpoofGuard profiles
    # API will list all SpoofGuard profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SpoofGuardProfileListResult]
    def list_spoof_guard_profiles(opts = {})
      data, _status_code, _headers = list_spoof_guard_profiles_with_http_info(opts)
      data
    end

    # List SpoofGuard profiles
    # API will list all SpoofGuard profiles. 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SpoofGuardProfileListResult, Fixnum, Hash)>] SpoofGuardProfileListResult data, response status code and response headers
    def list_spoof_guard_profiles_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_spoof_guard_profiles ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_spoof_guard_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_spoof_guard_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/spoofguard-profiles'

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SpoofGuardProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_spoof_guard_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List SegmentConnectionBindingMap specific Segment
    # List SegmentConnectionBindingMap specific Segment 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentConnectionBindingMapListResult]
    def list_tier1_segment_connection_binding_map(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = list_tier1_segment_connection_binding_map_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # List SegmentConnectionBindingMap specific Segment
    # List SegmentConnectionBindingMap specific Segment 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentConnectionBindingMapListResult, Fixnum, Hash)>] SegmentConnectionBindingMapListResult data, response status code and response headers
    def list_tier1_segment_connection_binding_map_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_tier1_segment_connection_binding_map ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.list_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_tier1_segment_connection_binding_map"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_tier1_segment_connection_binding_map, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_tier1_segment_connection_binding_map, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-connection-binding-maps'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConnectionBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_tier1_segment_connection_binding_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Tier-1 segment ports
    # List all the ports for a Tier-1 segment. 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentPortListResult]
    def list_tier1_segment_ports(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = list_tier1_segment_ports_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # List Tier-1 segment ports
    # List all the ports for a Tier-1 segment. 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentPortListResult, Fixnum, Hash)>] SegmentPortListResult data, response status code and response headers
    def list_tier1_segment_ports_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_tier1_segment_ports ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.list_tier1_segment_ports"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_tier1_segment_ports"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_tier1_segment_ports, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.list_tier1_segment_ports, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_tier1_segment_ports\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all effective profiles for tier-1 segment port
    # List all effective profiles for this segment port on given enforcement point.
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [EffectiveProfilesResponse]
    def list_tier1_segment_ports_effective_profiles(tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = list_tier1_segment_ports_effective_profiles_with_http_info(tier_1_id, segment_id, port_id, opts)
      data
    end

    # List all effective profiles for tier-1 segment port
    # List all effective profiles for this segment port on given enforcement point.
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [Array<(EffectiveProfilesResponse, Fixnum, Hash)>] EffectiveProfilesResponse data, response status code and response headers
    def list_tier1_segment_ports_effective_profiles_with_http_info(tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.list_tier1_segment_ports_effective_profiles ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.list_tier1_segment_ports_effective_profiles"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.list_tier1_segment_ports_effective_profiles"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.list_tier1_segment_ports_effective_profiles"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/effective-profiles'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EffectiveProfilesResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#list_tier1_segment_ports_effective_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create IP Discovery Profile
    # API will create IP Discovery profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param ip_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_create_ip_discovery_profile(org_id, project_id, ip_discovery_profile_id, ip_discovery_profile, opts = {})
      orgs_org_id_projects_project_id_infra_create_ip_discovery_profile_with_http_info(org_id, project_id, ip_discovery_profile_id, ip_discovery_profile, opts)
      nil
    end

    # Create IP Discovery Profile
    # API will create IP Discovery profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param ip_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_ip_discovery_profile_with_http_info(org_id, project_id, ip_discovery_profile_id, ip_discovery_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_create_ip_discovery_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_ip_discovery_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_ip_discovery_profile"
      end
      # verify the required parameter 'ip_discovery_profile_id' is set
      if @api_client.config.client_side_validation && ip_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'ip_discovery_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_ip_discovery_profile"
      end
      # verify the required parameter 'ip_discovery_profile' is set
      if @api_client.config.client_side_validation && ip_discovery_profile.nil?
        fail ArgumentError, "Missing the required parameter 'ip_discovery_profile' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_ip_discovery_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/ip-discovery-profiles/{ip-discovery-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'ip-discovery-profile-id' + '}', ip_discovery_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(ip_discovery_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_create_ip_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Mac Discovery Profile
    # API will create Mac Discovery profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param mac_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_create_mac_discovery_profile(org_id, project_id, mac_discovery_profile_id, mac_discovery_profile, opts = {})
      orgs_org_id_projects_project_id_infra_create_mac_discovery_profile_with_http_info(org_id, project_id, mac_discovery_profile_id, mac_discovery_profile, opts)
      nil
    end

    # Create Mac Discovery Profile
    # API will create Mac Discovery profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param mac_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_mac_discovery_profile_with_http_info(org_id, project_id, mac_discovery_profile_id, mac_discovery_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_create_mac_discovery_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_mac_discovery_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_mac_discovery_profile"
      end
      # verify the required parameter 'mac_discovery_profile_id' is set
      if @api_client.config.client_side_validation && mac_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'mac_discovery_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_mac_discovery_profile"
      end
      # verify the required parameter 'mac_discovery_profile' is set
      if @api_client.config.client_side_validation && mac_discovery_profile.nil?
        fail ArgumentError, "Missing the required parameter 'mac_discovery_profile' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_mac_discovery_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/mac-discovery-profiles/{mac-discovery-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'mac-discovery-profile-id' + '}', mac_discovery_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(mac_discovery_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_create_mac_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a infra segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, replace the segment with this object. Note: Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \"l2_extension\" object in the PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Segment]
    def orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment(org_id, project_id, segment_id, segment, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_with_http_info(org_id, project_id, segment_id, segment, opts)
      data
    end

    # Create or update a infra segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, replace the segment with this object. Note: Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \&quot;l2_extension\&quot; object in the PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Segment, Fixnum, Hash)>] Segment data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_with_http_info(org_id, project_id, segment_id, segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment"
      end
      # verify the required parameter 'segment' is set
      if @api_client.config.client_side_validation && segment.nil?
        fail ArgumentError, "Missing the required parameter 'segment' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Segment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a infra segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, replace the segment with this object. Note: Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \"l2_extension\" object in the PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Segment]
    def orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_0(org_id, project_id, segment_id, segment, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_0_with_http_info(org_id, project_id, segment_id, segment, opts)
      data
    end

    # Create or update a infra segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, replace the segment with this object. Note: Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \&quot;l2_extension\&quot; object in the PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Segment, Fixnum, Hash)>] Segment data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_0_with_http_info(org_id, project_id, segment_id, segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_0 ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_0"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_0"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_0"
      end
      # verify the required parameter 'segment' is set
      if @api_client.config.client_side_validation && segment.nil?
        fail ArgumentError, "Missing the required parameter 'segment' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_0"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Segment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update an infra segment port
    # Create an infra segment port if it does not exist based on the IDs, or update existing port information by replacing the port object already exists. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [SegmentPort]
    def orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_port(org_id, project_id, segment_id, port_id, segment_port, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_port_with_http_info(org_id, project_id, segment_id, port_id, segment_port, opts)
      data
    end

    # Create or update an infra segment port
    # Create an infra segment port if it does not exist based on the IDs, or update existing port information by replacing the port object already exists. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentPort, Fixnum, Hash)>] SegmentPort data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_port_with_http_info(org_id, project_id, segment_id, port_id, segment_port, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_port ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_port"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_port"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_port"
      end
      # verify the required parameter 'segment_port' is set
      if @api_client.config.client_side_validation && segment_port.nil?
        fail ArgumentError, "Missing the required parameter 'segment_port' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_port"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_port)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPort')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a infra segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, replace the segment with this object.  Force parameter is required when workload connectivity is indirectly impacted with the current replacement. Note:   Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the   \"l2_extension\" object in the PATCH API payload, the path returned in the GET response payload may include the new path   instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.   Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path   instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Segment]
    def orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_with_force(org_id, project_id, segment_id, segment, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_with_force_with_http_info(org_id, project_id, segment_id, segment, opts)
      data
    end

    # Create or update a infra segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, replace the segment with this object.  Force parameter is required when workload connectivity is indirectly impacted with the current replacement. Note:   Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the   \&quot;l2_extension\&quot; object in the PATCH API payload, the path returned in the GET response payload may include the new path   instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.   Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path   instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Segment, Fixnum, Hash)>] Segment data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_with_force_with_http_info(org_id, project_id, segment_id, segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_with_force ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_with_force"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_with_force"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_with_force"
      end
      # verify the required parameter 'segment' is set
      if @api_client.config.client_side_validation && segment.nil?
        fail ArgumentError, "Missing the required parameter 'segment' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_with_force"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}?force=true'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Segment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_with_force\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a infra segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, replace the segment with this object.  Force parameter is required when workload connectivity is indirectly impacted with the current replacement. Note:   Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the   \"l2_extension\" object in the PATCH API payload, the path returned in the GET response payload may include the new path   instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.   Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path   instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Segment]
    def orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_with_force_0(org_id, project_id, segment_id, segment, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_with_force_0_with_http_info(org_id, project_id, segment_id, segment, opts)
      data
    end

    # Create or update a infra segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, replace the segment with this object.  Force parameter is required when workload connectivity is indirectly impacted with the current replacement. Note:   Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the   \&quot;l2_extension\&quot; object in the PATCH API payload, the path returned in the GET response payload may include the new path   instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.   Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path   instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Segment, Fixnum, Hash)>] Segment data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_with_force_0_with_http_info(org_id, project_id, segment_id, segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_with_force_0 ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_with_force_0"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_with_force_0"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_with_force_0"
      end
      # verify the required parameter 'segment' is set
      if @api_client.config.client_side_validation && segment.nil?
        fail ArgumentError, "Missing the required parameter 'segment' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_with_force_0"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}?force=true'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Segment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_create_or_replace_infra_segment_with_force_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or Replace QoS profile.
    # Create or Replace QoS profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param qos_profile_id QoS profile Id
    # @param qo_s_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [QoSProfile]
    def orgs_org_id_projects_project_id_infra_create_or_replace_qo_s_profile(org_id, project_id, qos_profile_id, qo_s_profile, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_create_or_replace_qo_s_profile_with_http_info(org_id, project_id, qos_profile_id, qo_s_profile, opts)
      data
    end

    # Create or Replace QoS profile.
    # Create or Replace QoS profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param qos_profile_id QoS profile Id
    # @param qo_s_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(QoSProfile, Fixnum, Hash)>] QoSProfile data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_or_replace_qo_s_profile_with_http_info(org_id, project_id, qos_profile_id, qo_s_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_qo_s_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_qo_s_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_qo_s_profile"
      end
      # verify the required parameter 'qos_profile_id' is set
      if @api_client.config.client_side_validation && qos_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'qos_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_qo_s_profile"
      end
      # verify the required parameter 'qo_s_profile' is set
      if @api_client.config.client_side_validation && qo_s_profile.nil?
        fail ArgumentError, "Missing the required parameter 'qo_s_profile' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_qo_s_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/qos-profiles/{qos-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'qos-profile-id' + '}', qos_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(qo_s_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'QoSProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_create_or_replace_qo_s_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or Replace Real Time Eth profile.
    # Create or Replace Real Time Eth profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param real_time_eth_profile_id Real Time Eth profile Id
    # @param real_time_eth_profile 
    # @param [Hash] opts the optional parameters
    # @return [RealTimeEthProfile]
    def orgs_org_id_projects_project_id_infra_create_or_replace_real_time_eth_profile(org_id, project_id, real_time_eth_profile_id, real_time_eth_profile, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_create_or_replace_real_time_eth_profile_with_http_info(org_id, project_id, real_time_eth_profile_id, real_time_eth_profile, opts)
      data
    end

    # Create or Replace Real Time Eth profile.
    # Create or Replace Real Time Eth profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param real_time_eth_profile_id Real Time Eth profile Id
    # @param real_time_eth_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(RealTimeEthProfile, Fixnum, Hash)>] RealTimeEthProfile data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_or_replace_real_time_eth_profile_with_http_info(org_id, project_id, real_time_eth_profile_id, real_time_eth_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_real_time_eth_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_real_time_eth_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_real_time_eth_profile"
      end
      # verify the required parameter 'real_time_eth_profile_id' is set
      if @api_client.config.client_side_validation && real_time_eth_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'real_time_eth_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_real_time_eth_profile"
      end
      # verify the required parameter 'real_time_eth_profile' is set
      if @api_client.config.client_side_validation && real_time_eth_profile.nil?
        fail ArgumentError, "Missing the required parameter 'real_time_eth_profile' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_real_time_eth_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/real-time-eth-profiles/{real-time-eth-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'real-time-eth-profile-id' + '}', real_time_eth_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(real_time_eth_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RealTimeEthProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_create_or_replace_real_time_eth_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, replace the segment with this object. Note:   Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the   \"l2_extension\" object in the PUT API payload, the path returned in the PUT/GET response payload may include the new path   instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.   Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path   instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Segment]
    def orgs_org_id_projects_project_id_infra_create_or_replace_segment(org_id, project_id, tier_1_id, segment_id, segment, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_create_or_replace_segment_with_http_info(org_id, project_id, tier_1_id, segment_id, segment, opts)
      data
    end

    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, replace the segment with this object. Note:   Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the   \&quot;l2_extension\&quot; object in the PUT API payload, the path returned in the PUT/GET response payload may include the new path   instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.   Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path   instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Segment, Fixnum, Hash)>] Segment data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_or_replace_segment_with_http_info(org_id, project_id, tier_1_id, segment_id, segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_segment ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_segment"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_segment"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_segment"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_segment"
      end
      # verify the required parameter 'segment' is set
      if @api_client.config.client_side_validation && segment.nil?
        fail ArgumentError, "Missing the required parameter 'segment' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_segment"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Segment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_create_or_replace_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a static ARP config
    # Create static ARP config with Tier-1 and segment IDs provided if it doesn't exist, update with provided config if it's already created. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param static_arp_config 
    # @param [Hash] opts the optional parameters
    # @return [StaticARPConfig]
    def orgs_org_id_projects_project_id_infra_create_or_replace_static_arp_config(org_id, project_id, tier_1_id, segment_id, static_arp_config, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_create_or_replace_static_arp_config_with_http_info(org_id, project_id, tier_1_id, segment_id, static_arp_config, opts)
      data
    end

    # Create or update a static ARP config
    # Create static ARP config with Tier-1 and segment IDs provided if it doesn&#39;t exist, update with provided config if it&#39;s already created. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param static_arp_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(StaticARPConfig, Fixnum, Hash)>] StaticARPConfig data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_or_replace_static_arp_config_with_http_info(org_id, project_id, tier_1_id, segment_id, static_arp_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_static_arp_config ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_static_arp_config"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_static_arp_config"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_static_arp_config"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_static_arp_config"
      end
      # verify the required parameter 'static_arp_config' is set
      if @api_client.config.client_side_validation && static_arp_config.nil?
        fail ArgumentError, "Missing the required parameter 'static_arp_config' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_static_arp_config"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/static-arp'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(static_arp_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticARPConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_create_or_replace_static_arp_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a Tier-1 segment port
    # Create a Tier-1 segment port if it does not exist based on the IDs, or update existing port information by replacing the port object already exists. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [SegmentPort]
    def orgs_org_id_projects_project_id_infra_create_or_replace_tier1_segment_port(org_id, project_id, tier_1_id, segment_id, port_id, segment_port, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_create_or_replace_tier1_segment_port_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, segment_port, opts)
      data
    end

    # Create or update a Tier-1 segment port
    # Create a Tier-1 segment port if it does not exist based on the IDs, or update existing port information by replacing the port object already exists. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentPort, Fixnum, Hash)>] SegmentPort data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_or_replace_tier1_segment_port_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, segment_port, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_tier1_segment_port ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_tier1_segment_port"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_tier1_segment_port"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_tier1_segment_port"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_tier1_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_tier1_segment_port"
      end
      # verify the required parameter 'segment_port' is set
      if @api_client.config.client_side_validation && segment_port.nil?
        fail ArgumentError, "Missing the required parameter 'segment_port' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_replace_tier1_segment_port"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_port)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPort')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_create_or_replace_tier1_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch a infra segment connection binding map
    # Patch the infra segment connection binding map. If binding map corresponding to the the given values is not present, the object will get created and if it is present it will be updated. This is a full replace. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param map_id 
    # @param segment_connection_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [SegmentConnectionBindingMap]
    def orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_connection_binding_map(org_id, project_id, segment_id, map_id, segment_connection_binding_map, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_connection_binding_map_with_http_info(org_id, project_id, segment_id, map_id, segment_connection_binding_map, opts)
      data
    end

    # Patch a infra segment connection binding map
    # Patch the infra segment connection binding map. If binding map corresponding to the the given values is not present, the object will get created and if it is present it will be updated. This is a full replace. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param map_id 
    # @param segment_connection_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentConnectionBindingMap, Fixnum, Hash)>] SegmentConnectionBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_connection_binding_map_with_http_info(org_id, project_id, segment_id, map_id, segment_connection_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_connection_binding_map ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'map_id' is set
      if @api_client.config.client_side_validation && map_id.nil?
        fail ArgumentError, "Missing the required parameter 'map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_connection_binding_map' is set
      if @api_client.config.client_side_validation && segment_connection_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_connection_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_connection_binding_map"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/segment-connection-binding-maps/{map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'map-id' + '}', map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_connection_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConnectionBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_connection_binding_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or replace the infra segment port security profile binding map
    # API will create or replace the port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortSecurityProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_port_security_profile_binding(org_id, project_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_port_security_profile_binding_with_http_info(org_id, project_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts)
      data
    end

    # Create or replace the infra segment port security profile binding map
    # API will create or replace the port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortSecurityProfileBindingMap, Fixnum, Hash)>] PortSecurityProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_port_security_profile_binding_with_http_info(org_id, project_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_port_security_profile_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_security_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or replace infra segment security profile binding map
    # API will create or replace segment security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param segment_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [SegmentSecurityProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_security_profile_binding(org_id, project_id, segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_security_profile_binding_with_http_info(org_id, project_id, segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts)
      data
    end

    # Create or replace infra segment security profile binding map
    # API will create or replace segment security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param segment_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentSecurityProfileBindingMap, Fixnum, Hash)>] SegmentSecurityProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_security_profile_binding_with_http_info(org_id, project_id, segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_security_profile_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_security_profile_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_security_profile_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/segment-security-profile-binding-maps/{segment-security-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-security-profile-binding-map-id' + '}', segment_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_security_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_create_or_update_infra_segment_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or replace the port security profile binding map
    # API will create or replace the port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortSecurityProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_create_or_update_port_security_profile_binding(org_id, project_id, tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_create_or_update_port_security_profile_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts)
      data
    end

    # Create or replace the port security profile binding map
    # API will create or replace the port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortSecurityProfileBindingMap, Fixnum, Hash)>] PortSecurityProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_or_update_port_security_profile_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_port_security_profile_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_port_security_profile_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_port_security_profile_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_port_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_security_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_create_or_update_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # PUT segment security profile id
    # Create or replace a segment security profile 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_security_profile_id Segment security profile id
    # @param segment_security_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [SegmentSecurityProfile]
    def orgs_org_id_projects_project_id_infra_create_or_update_segment_security_profile(org_id, project_id, segment_security_profile_id, segment_security_profile, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_create_or_update_segment_security_profile_with_http_info(org_id, project_id, segment_security_profile_id, segment_security_profile, opts)
      data
    end

    # PUT segment security profile id
    # Create or replace a segment security profile 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_security_profile_id Segment security profile id
    # @param segment_security_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(SegmentSecurityProfile, Fixnum, Hash)>] SegmentSecurityProfile data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_or_update_segment_security_profile_with_http_info(org_id, project_id, segment_security_profile_id, segment_security_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_segment_security_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_segment_security_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_segment_security_profile"
      end
      # verify the required parameter 'segment_security_profile_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_segment_security_profile"
      end
      # verify the required parameter 'segment_security_profile' is set
      if @api_client.config.client_side_validation && segment_security_profile.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_segment_security_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segment-security-profiles/{segment-security-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-security-profile-id' + '}', segment_security_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_security_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_create_or_update_segment_security_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or replace segment security profile binding map
    # API will create or replace segment security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param segment_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [SegmentSecurityProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_create_or_update_segment_security_profile_binding(org_id, project_id, tier_1_id, segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_create_or_update_segment_security_profile_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts)
      data
    end

    # Create or replace segment security profile binding map
    # API will create or replace segment security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param segment_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentSecurityProfileBindingMap, Fixnum, Hash)>] SegmentSecurityProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_or_update_segment_security_profile_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_segment_security_profile_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_segment_security_profile_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_segment_security_profile_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_segment_security_profile_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-security-profile-binding-maps/{segment-security-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-security-profile-binding-map-id' + '}', segment_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_security_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_create_or_update_segment_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or replace SpoofGuard profile
    # API will create or replace SpoofGuard profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param spoof_guard_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [SpoofGuardProfile]
    def orgs_org_id_projects_project_id_infra_create_or_update_spoof_guard_profile(org_id, project_id, spoofguard_profile_id, spoof_guard_profile, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_create_or_update_spoof_guard_profile_with_http_info(org_id, project_id, spoofguard_profile_id, spoof_guard_profile, opts)
      data
    end

    # Create or replace SpoofGuard profile
    # API will create or replace SpoofGuard profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param spoof_guard_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(SpoofGuardProfile, Fixnum, Hash)>] SpoofGuardProfile data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_or_update_spoof_guard_profile_with_http_info(org_id, project_id, spoofguard_profile_id, spoof_guard_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_spoof_guard_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_spoof_guard_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_spoof_guard_profile"
      end
      # verify the required parameter 'spoofguard_profile_id' is set
      if @api_client.config.client_side_validation && spoofguard_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'spoofguard_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_spoof_guard_profile"
      end
      # verify the required parameter 'spoof_guard_profile' is set
      if @api_client.config.client_side_validation && spoof_guard_profile.nil?
        fail ArgumentError, "Missing the required parameter 'spoof_guard_profile' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_spoof_guard_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/spoofguard-profiles/{spoofguard-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'spoofguard-profile-id' + '}', spoofguard_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(spoof_guard_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SpoofGuardProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_create_or_update_spoof_guard_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch a tier1 segment connection binding map
    # Patch the infra segment connection binding map. If binding map corresponding to the the given values is not present, the object will get created and if it is present it will be updated. This is a full replace. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param map_id 
    # @param segment_connection_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [SegmentConnectionBindingMap]
    def orgs_org_id_projects_project_id_infra_create_or_update_tier1_segment_connection_binding_map(org_id, project_id, tier_1_id, segment_id, map_id, segment_connection_binding_map, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_create_or_update_tier1_segment_connection_binding_map_with_http_info(org_id, project_id, tier_1_id, segment_id, map_id, segment_connection_binding_map, opts)
      data
    end

    # Patch a tier1 segment connection binding map
    # Patch the infra segment connection binding map. If binding map corresponding to the the given values is not present, the object will get created and if it is present it will be updated. This is a full replace. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param map_id 
    # @param segment_connection_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentConnectionBindingMap, Fixnum, Hash)>] SegmentConnectionBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_create_or_update_tier1_segment_connection_binding_map_with_http_info(org_id, project_id, tier_1_id, segment_id, map_id, segment_connection_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_tier1_segment_connection_binding_map ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'map_id' is set
      if @api_client.config.client_side_validation && map_id.nil?
        fail ArgumentError, "Missing the required parameter 'map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_connection_binding_map' is set
      if @api_client.config.client_side_validation && segment_connection_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_connection_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_create_or_update_tier1_segment_connection_binding_map"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-connection-binding-maps/{map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'map-id' + '}', map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_connection_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConnectionBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_create_or_update_tier1_segment_connection_binding_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Group discovery profile binding map
    # API will delete Group discovery profile binding map
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param discovery_profile_binding_map_id Group discovery profile binding map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_group_discovery_profile_binding(org_id, project_id, domain_id, group_id, discovery_profile_binding_map_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_group_discovery_profile_binding_with_http_info(org_id, project_id, domain_id, group_id, discovery_profile_binding_map_id, opts)
      nil
    end

    # Delete Group discovery profile binding map
    # API will delete Group discovery profile binding map
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param discovery_profile_binding_map_id Group discovery profile binding map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_group_discovery_profile_binding_with_http_info(org_id, project_id, domain_id, group_id, discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_group_discovery_profile_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_group_discovery_profile_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_group_discovery_profile_binding"
      end
      # verify the required parameter 'domain_id' is set
      if @api_client.config.client_side_validation && domain_id.nil?
        fail ArgumentError, "Missing the required parameter 'domain_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_group_discovery_profile_binding"
      end
      # verify the required parameter 'group_id' is set
      if @api_client.config.client_side_validation && group_id.nil?
        fail ArgumentError, "Missing the required parameter 'group_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_group_discovery_profile_binding"
      end
      # verify the required parameter 'discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'discovery_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_group_discovery_profile_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/domains/{domain-id}/groups/{group-id}/discovery-profile-binding-maps/{discovery-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'domain-id' + '}', domain_id.to_s).sub('{' + 'group-id' + '}', group_id.to_s).sub('{' + 'discovery-profile-binding-map-id' + '}', discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_group_discovery_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Infra Port Discovery Profile Binding Profile
    # API will delete Infra Port Discovery Profile Binding Profile
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_infra_port_discovery_binding(org_id, project_id, infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_infra_port_discovery_binding_with_http_info(org_id, project_id, infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, opts)
      nil
    end

    # Delete Infra Port Discovery Profile Binding Profile
    # API will delete Infra Port Discovery Profile Binding Profile
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_infra_port_discovery_binding_with_http_info(org_id, project_id, infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_port_discovery_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_port_discovery_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_port_discovery_binding"
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_port_discovery_binding"
      end
      # verify the required parameter 'infra_port_id' is set
      if @api_client.config.client_side_validation && infra_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_port_discovery_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{infra-segment-id}/ports/{infra-port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'infra-port-id' + '}', infra_port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_infra_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Port QoS Profile Binding Profile
    # API will delete Port QoS Profile Binding Profile.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_infra_port_qo_s_binding(org_id, project_id, segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_infra_port_qo_s_binding_with_http_info(org_id, project_id, segment_id, port_id, port_qos_profile_binding_map_id, opts)
      nil
    end

    # Delete Port QoS Profile Binding Profile
    # API will delete Port QoS Profile Binding Profile.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_infra_port_qo_s_binding_with_http_info(org_id, project_id, segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_port_qo_s_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_port_qo_s_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_port_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_infra_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Port Real Time Eth Profile Binding Profile
    # API will delete Port Real Time Eth Profile Binding Profile.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_real_time_eth_profile_binding_map_id Port Real Time Eth Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_infra_port_real_time_eth_binding(org_id, project_id, segment_id, port_id, port_real_time_eth_profile_binding_map_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_infra_port_real_time_eth_binding_with_http_info(org_id, project_id, segment_id, port_id, port_real_time_eth_profile_binding_map_id, opts)
      nil
    end

    # Delete Port Real Time Eth Profile Binding Profile
    # API will delete Port Real Time Eth Profile Binding Profile.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_real_time_eth_profile_binding_map_id Port Real Time Eth Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_infra_port_real_time_eth_binding_with_http_info(org_id, project_id, segment_id, port_id, port_real_time_eth_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_port_real_time_eth_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'port_real_time_eth_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_real_time_eth_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_real_time_eth_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_port_real_time_eth_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}/port-real-time-eth-profile-binding-maps/{port-real-time-eth-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-real-time-eth-profile-binding-map-id' + '}', port_real_time_eth_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_infra_port_real_time_eth_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete infra segment
    # Delete infra segment
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_infra_segment(org_id, project_id, segment_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_infra_segment_with_http_info(org_id, project_id, segment_id, opts)
      nil
    end

    # Delete infra segment
    # Delete infra segment
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_infra_segment_with_http_info(org_id, project_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_infra_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete infra segment
    # Delete infra segment
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_infra_segment_0(org_id, project_id, segment_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_infra_segment_0_with_http_info(org_id, project_id, segment_id, opts)
      nil
    end

    # Delete infra segment
    # Delete infra segment
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_infra_segment_0_with_http_info(org_id, project_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_0 ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_0"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_0"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_0"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_infra_segment_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Deletes infra SegmentConnectionBindingMap.
    # Deletes infra SegmentConnectionBindingMap. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param map_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_infra_segment_connection_binding_map(org_id, project_id, segment_id, map_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_infra_segment_connection_binding_map_with_http_info(org_id, project_id, segment_id, map_id, opts)
      nil
    end

    # Deletes infra SegmentConnectionBindingMap.
    # Deletes infra SegmentConnectionBindingMap. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param map_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_infra_segment_connection_binding_map_with_http_info(org_id, project_id, segment_id, map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_connection_binding_map ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'map_id' is set
      if @api_client.config.client_side_validation && map_id.nil?
        fail ArgumentError, "Missing the required parameter 'map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_connection_binding_map"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/segment-connection-binding-maps/{map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'map-id' + '}', map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_infra_segment_connection_binding_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Segment Discovery Profile Binding Profile
    # API will delete Segment Discovery Profile Binding Profile
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param infra_segment_id Infra Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_infra_segment_discovery_binding(org_id, project_id, infra_segment_id, segment_discovery_profile_binding_map_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_infra_segment_discovery_binding_with_http_info(org_id, project_id, infra_segment_id, segment_discovery_profile_binding_map_id, opts)
      nil
    end

    # Delete Segment Discovery Profile Binding Profile
    # API will delete Segment Discovery Profile Binding Profile
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param infra_segment_id Infra Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_infra_segment_discovery_binding_with_http_info(org_id, project_id, infra_segment_id, segment_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_discovery_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_discovery_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_discovery_binding"
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_discovery_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{infra-segment-id}/segment-discovery-profile-binding-maps/{segment-discovery-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'segment-discovery-profile-binding-map-id' + '}', segment_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_infra_segment_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete an infra segment port
    # Delete an infra segment port by giving ID. Please note that this operation will not delete the segment port from vCenter Server if the port was connected to a Virtual Machine. Please connect Virtual Machine to another network for the segment port to be deleted from vCenter Server. Do not provide any parameters to this call unless it is during VIF restore workflow by NSX container plugin(NCP). 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_infra_segment_port(org_id, project_id, segment_id, port_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_infra_segment_port_with_http_info(org_id, project_id, segment_id, port_id, opts)
      nil
    end

    # Delete an infra segment port
    # Delete an infra segment port by giving ID. Please note that this operation will not delete the segment port from vCenter Server if the port was connected to a Virtual Machine. Please connect Virtual Machine to another network for the segment port to be deleted from vCenter Server. Do not provide any parameters to this call unless it is during VIF restore workflow by NSX container plugin(NCP). 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_infra_segment_port_with_http_info(org_id, project_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_port ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_port"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_port"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_port"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_infra_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete the infra segment port security profile binding map
    # API will delete the port security profile binding map. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_infra_segment_port_security_profile_binding(org_id, project_id, segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_infra_segment_port_security_profile_binding_with_http_info(org_id, project_id, segment_id, port_id, port_security_profile_binding_map_id, opts)
      nil
    end

    # Delete the infra segment port security profile binding map
    # API will delete the port security profile binding map. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_infra_segment_port_security_profile_binding_with_http_info(org_id, project_id, segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_port_security_profile_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_infra_segment_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Segment QoS Profile Binding Profile
    # API will delete Segment QoS Profile Binding Profile.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_infra_segment_qo_s_binding(org_id, project_id, segment_id, segment_qos_profile_binding_map_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_infra_segment_qo_s_binding_with_http_info(org_id, project_id, segment_id, segment_qos_profile_binding_map_id, opts)
      nil
    end

    # Delete Segment QoS Profile Binding Profile
    # API will delete Segment QoS Profile Binding Profile.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_infra_segment_qo_s_binding_with_http_info(org_id, project_id, segment_id, segment_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_qo_s_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_qo_s_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qos_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_qo_s_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/segment-qos-profile-binding-maps/{segment-qos-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-qos-profile-binding-map-id' + '}', segment_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_infra_segment_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Segment Real Time Eth Profile Binding Profile
    # API will delete Segment Real Time Eth Profile Binding Profile.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment_real_time_eth_profile_binding_map_id Segment Real Time Eth Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_infra_segment_real_time_eth_binding(org_id, project_id, segment_id, segment_real_time_eth_profile_binding_map_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_infra_segment_real_time_eth_binding_with_http_info(org_id, project_id, segment_id, segment_real_time_eth_profile_binding_map_id, opts)
      nil
    end

    # Delete Segment Real Time Eth Profile Binding Profile
    # API will delete Segment Real Time Eth Profile Binding Profile.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment_real_time_eth_profile_binding_map_id Segment Real Time Eth Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_infra_segment_real_time_eth_binding_with_http_info(org_id, project_id, segment_id, segment_real_time_eth_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_real_time_eth_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_real_time_eth_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_real_time_eth_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_real_time_eth_binding"
      end
      # verify the required parameter 'segment_real_time_eth_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_real_time_eth_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_real_time_eth_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_real_time_eth_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/segment-real-time-eth-profile-binding-maps/{segment-real-time-eth-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-real-time-eth-profile-binding-map-id' + '}', segment_real_time_eth_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_infra_segment_real_time_eth_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete infra segment security profile binding map
    # API will delete segment security profile binding map. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_infra_segment_security_profile_binding(org_id, project_id, segment_id, segment_security_profile_binding_map_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_infra_segment_security_profile_binding_with_http_info(org_id, project_id, segment_id, segment_security_profile_binding_map_id, opts)
      nil
    end

    # Delete infra segment security profile binding map
    # API will delete segment security profile binding map. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_infra_segment_security_profile_binding_with_http_info(org_id, project_id, segment_id, segment_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_security_profile_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_security_profile_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_infra_segment_security_profile_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/segment-security-profile-binding-maps/{segment-security-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-security-profile-binding-map-id' + '}', segment_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_infra_segment_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete IP Discovery Profile
    # API will delete IP Discovery profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_ip_discovery_profile(org_id, project_id, ip_discovery_profile_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_ip_discovery_profile_with_http_info(org_id, project_id, ip_discovery_profile_id, opts)
      nil
    end

    # Delete IP Discovery Profile
    # API will delete IP Discovery profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_ip_discovery_profile_with_http_info(org_id, project_id, ip_discovery_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_ip_discovery_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_ip_discovery_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_ip_discovery_profile"
      end
      # verify the required parameter 'ip_discovery_profile_id' is set
      if @api_client.config.client_side_validation && ip_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'ip_discovery_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_ip_discovery_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/ip-discovery-profiles/{ip-discovery-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'ip-discovery-profile-id' + '}', ip_discovery_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_ip_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Mac Discovery Profile
    # API will delete Mac Discovery profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_mac_discovery_profile(org_id, project_id, mac_discovery_profile_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_mac_discovery_profile_with_http_info(org_id, project_id, mac_discovery_profile_id, opts)
      nil
    end

    # Delete Mac Discovery Profile
    # API will delete Mac Discovery profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_mac_discovery_profile_with_http_info(org_id, project_id, mac_discovery_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_mac_discovery_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_mac_discovery_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_mac_discovery_profile"
      end
      # verify the required parameter 'mac_discovery_profile_id' is set
      if @api_client.config.client_side_validation && mac_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'mac_discovery_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_mac_discovery_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/mac-discovery-profiles/{mac-discovery-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'mac-discovery-profile-id' + '}', mac_discovery_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_mac_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Port Discovery Profile Binding Profile
    # API will delete Port Discovery Profile Binding Profile
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_port_discovery_binding(org_id, project_id, tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_port_discovery_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, opts)
      nil
    end

    # Delete Port Discovery Profile Binding Profile
    # API will delete Port Discovery Profile Binding Profile
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_port_discovery_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_port_discovery_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_port_discovery_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_port_discovery_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_port_discovery_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_port_discovery_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_port_discovery_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Port QoS Profile Binding Profile
    # API will delete Port QoS Profile Binding Profile.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_port_qo_s_binding(org_id, project_id, tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_port_qo_s_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, opts)
      nil
    end

    # Delete Port QoS Profile Binding Profile
    # API will delete Port QoS Profile Binding Profile.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_port_qo_s_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_port_qo_s_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_port_qo_s_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_port_qo_s_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_port_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete the port security profile binding map
    # API will delete the port security profile binding map. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_port_security_profile_binding(org_id, project_id, tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_port_security_profile_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, opts)
      nil
    end

    # Delete the port security profile binding map
    # API will delete the port security profile binding map. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_port_security_profile_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_port_security_profile_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_port_security_profile_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_port_security_profile_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_port_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete QoS profile
    # API will delete QoS profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param qos_profile_id QoS profile Id
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_qo_s_profile(org_id, project_id, qos_profile_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_qo_s_profile_with_http_info(org_id, project_id, qos_profile_id, opts)
      nil
    end

    # Delete QoS profile
    # API will delete QoS profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param qos_profile_id QoS profile Id
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_qo_s_profile_with_http_info(org_id, project_id, qos_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_qo_s_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_qo_s_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_qo_s_profile"
      end
      # verify the required parameter 'qos_profile_id' is set
      if @api_client.config.client_side_validation && qos_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'qos_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_qo_s_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/qos-profiles/{qos-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'qos-profile-id' + '}', qos_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_qo_s_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Real Time Eth profile
    # API will delete Real Time Eth profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param real_time_eth_profile_id Real Time Eth profile Id
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_real_time_eth_profile(org_id, project_id, real_time_eth_profile_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_real_time_eth_profile_with_http_info(org_id, project_id, real_time_eth_profile_id, opts)
      nil
    end

    # Delete Real Time Eth profile
    # API will delete Real Time Eth profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param real_time_eth_profile_id Real Time Eth profile Id
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_real_time_eth_profile_with_http_info(org_id, project_id, real_time_eth_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_real_time_eth_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_real_time_eth_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_real_time_eth_profile"
      end
      # verify the required parameter 'real_time_eth_profile_id' is set
      if @api_client.config.client_side_validation && real_time_eth_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'real_time_eth_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_real_time_eth_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/real-time-eth-profiles/{real-time-eth-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'real-time-eth-profile-id' + '}', real_time_eth_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_real_time_eth_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete segment
    # Delete segment
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_segment(org_id, project_id, tier_1_id, segment_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_segment_with_http_info(org_id, project_id, tier_1_id, segment_id, opts)
      nil
    end

    # Delete segment
    # Delete segment
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_segment_with_http_info(org_id, project_id, tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Segment Discovery Profile Binding Profile
    # API will delete Segment Discovery Profile Binding Profile
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_segment_discovery_binding(org_id, project_id, tier_1_id, segment_id, segment_discovery_profile_binding_map_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_segment_discovery_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_discovery_profile_binding_map_id, opts)
      nil
    end

    # Delete Segment Discovery Profile Binding Profile
    # API will delete Segment Discovery Profile Binding Profile
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_segment_discovery_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_discovery_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_discovery_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_discovery_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_discovery_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_discovery_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-discovery-profile-binding-maps/{segment-discovery-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-discovery-profile-binding-map-id' + '}', segment_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_segment_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete Segment QoS Profile Binding Profile
    # API will delete Segment QoS Profile Binding Profile.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_segment_qo_s_binding(org_id, project_id, tier_1_id, segment_id, segment_qos_profile_binding_map_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_segment_qo_s_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_qos_profile_binding_map_id, opts)
      nil
    end

    # Delete Segment QoS Profile Binding Profile
    # API will delete Segment QoS Profile Binding Profile.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_segment_qo_s_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_qo_s_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_qo_s_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_qo_s_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qos_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_qo_s_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-qos-profile-binding-maps/{segment-qos-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-qos-profile-binding-map-id' + '}', segment_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_segment_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # DELETE segment security profile
    # API will delete segment security profile with the given id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_security_profile_id Segment security profile id
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_segment_security_profile(org_id, project_id, segment_security_profile_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_segment_security_profile_with_http_info(org_id, project_id, segment_security_profile_id, opts)
      nil
    end

    # DELETE segment security profile
    # API will delete segment security profile with the given id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_security_profile_id Segment security profile id
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_segment_security_profile_with_http_info(org_id, project_id, segment_security_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_security_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_security_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_security_profile"
      end
      # verify the required parameter 'segment_security_profile_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_security_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segment-security-profiles/{segment-security-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-security-profile-id' + '}', segment_security_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_segment_security_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete segment security profile binding map
    # API will delete segment security profile binding map. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_segment_security_profile_binding(org_id, project_id, tier_1_id, segment_id, segment_security_profile_binding_map_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_segment_security_profile_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_security_profile_binding_map_id, opts)
      nil
    end

    # Delete segment security profile binding map
    # API will delete segment security profile binding map. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_segment_security_profile_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_security_profile_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_security_profile_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_security_profile_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_segment_security_profile_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-security-profile-binding-maps/{segment-security-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-security-profile-binding-map-id' + '}', segment_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_segment_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete SpoofGuard profile
    # API will delete SpoofGuard profile with the given id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_spoof_guard_profile(org_id, project_id, spoofguard_profile_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_spoof_guard_profile_with_http_info(org_id, project_id, spoofguard_profile_id, opts)
      nil
    end

    # Delete SpoofGuard profile
    # API will delete SpoofGuard profile with the given id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_spoof_guard_profile_with_http_info(org_id, project_id, spoofguard_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_spoof_guard_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_spoof_guard_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_spoof_guard_profile"
      end
      # verify the required parameter 'spoofguard_profile_id' is set
      if @api_client.config.client_side_validation && spoofguard_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'spoofguard_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_spoof_guard_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/spoofguard-profiles/{spoofguard-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'spoofguard-profile-id' + '}', spoofguard_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_spoof_guard_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete static ARP config
    # Delete static ARP config
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_static_arp_config(org_id, project_id, tier_1_id, segment_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_static_arp_config_with_http_info(org_id, project_id, tier_1_id, segment_id, opts)
      nil
    end

    # Delete static ARP config
    # Delete static ARP config
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_static_arp_config_with_http_info(org_id, project_id, tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_static_arp_config ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_static_arp_config"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_static_arp_config"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_static_arp_config"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_static_arp_config"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/static-arp'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_static_arp_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Deletes infra SegmentConnectionBindingMap.
    # Deletes infra SegmentConnectionBindingMap. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param map_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_tier1_segment_connection_binding_map(org_id, project_id, tier_1_id, segment_id, map_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_tier1_segment_connection_binding_map_with_http_info(org_id, project_id, tier_1_id, segment_id, map_id, opts)
      nil
    end

    # Deletes infra SegmentConnectionBindingMap.
    # Deletes infra SegmentConnectionBindingMap. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param map_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_tier1_segment_connection_binding_map_with_http_info(org_id, project_id, tier_1_id, segment_id, map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_tier1_segment_connection_binding_map ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'map_id' is set
      if @api_client.config.client_side_validation && map_id.nil?
        fail ArgumentError, "Missing the required parameter 'map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_tier1_segment_connection_binding_map"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-connection-binding-maps/{map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'map-id' + '}', map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_tier1_segment_connection_binding_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a Tier-1 segment port. Please note that this operation will not delete the segment port from vCenter Server if the port was connected to a Virtual Machine. Please connect Virtual Machine to another network for the segment port to be deleted from vCenter Server. 
    # Delete a Tier-1 segment port by giving ID. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_delete_tier1_segment_port(org_id, project_id, tier_1_id, segment_id, port_id, opts = {})
      orgs_org_id_projects_project_id_infra_delete_tier1_segment_port_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, opts)
      nil
    end

    # Delete a Tier-1 segment port. Please note that this operation will not delete the segment port from vCenter Server if the port was connected to a Virtual Machine. Please connect Virtual Machine to another network for the segment port to be deleted from vCenter Server. 
    # Delete a Tier-1 segment port by giving ID. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_delete_tier1_segment_port_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_delete_tier1_segment_port ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_tier1_segment_port"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_tier1_segment_port"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_tier1_segment_port"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_tier1_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_delete_tier1_segment_port"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_delete_tier1_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Force delete infra segment
    # Force delete bypasses validations during segment deletion. This may result in an inconsistent connectivity.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :cascade Flag to specify whether to delete related segment ports (default to false)
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_force_delete_infra_segment(org_id, project_id, segment_id, opts = {})
      orgs_org_id_projects_project_id_infra_force_delete_infra_segment_with_http_info(org_id, project_id, segment_id, opts)
      nil
    end

    # Force delete infra segment
    # Force delete bypasses validations during segment deletion. This may result in an inconsistent connectivity.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :cascade Flag to specify whether to delete related segment ports
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_force_delete_infra_segment_with_http_info(org_id, project_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_force_delete_infra_segment ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_force_delete_infra_segment"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_force_delete_infra_segment"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_force_delete_infra_segment"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}?force=true'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cascade'] = opts[:'cascade'] if !opts[:'cascade'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_force_delete_infra_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Force delete infra segment
    # Force delete bypasses validations during segment deletion. This may result in an inconsistent connectivity.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :cascade Flag to specify whether to delete related segment ports (default to false)
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_force_delete_infra_segment_0(org_id, project_id, segment_id, opts = {})
      orgs_org_id_projects_project_id_infra_force_delete_infra_segment_0_with_http_info(org_id, project_id, segment_id, opts)
      nil
    end

    # Force delete infra segment
    # Force delete bypasses validations during segment deletion. This may result in an inconsistent connectivity.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :cascade Flag to specify whether to delete related segment ports
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_force_delete_infra_segment_0_with_http_info(org_id, project_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_force_delete_infra_segment_0 ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_force_delete_infra_segment_0"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_force_delete_infra_segment_0"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_force_delete_infra_segment_0"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}?force=true'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cascade'] = opts[:'cascade'] if !opts[:'cascade'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_force_delete_infra_segment_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Force delete segment
    # Force delete bypasses validations during segment deletion. This may result in an inconsistent connectivity. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_force_delete_segment(org_id, project_id, tier_1_id, segment_id, opts = {})
      orgs_org_id_projects_project_id_infra_force_delete_segment_with_http_info(org_id, project_id, tier_1_id, segment_id, opts)
      nil
    end

    # Force delete segment
    # Force delete bypasses validations during segment deletion. This may result in an inconsistent connectivity. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_force_delete_segment_with_http_info(org_id, project_id, tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_force_delete_segment ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_force_delete_segment"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_force_delete_segment"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_force_delete_segment"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_force_delete_segment"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}?force=true'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_force_delete_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get downlink port Address Resolution Protocol Proxies for infra segment
    # Returns ARP proxy table for downlink port on connected to the segment 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyArpProxyTableListResult]
    def orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_infra_segment(org_id, project_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_infra_segment_with_http_info(org_id, project_id, segment_id, opts)
      data
    end

    # Get downlink port Address Resolution Protocol Proxies for infra segment
    # Returns ARP proxy table for downlink port on connected to the segment 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyArpProxyTableListResult, Fixnum, Hash)>] PolicyArpProxyTableListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_infra_segment_with_http_info(org_id, project_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_infra_segment ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_infra_segment"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_infra_segment"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_infra_segment"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_infra_segment, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_infra_segment, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/arp-proxy'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyArpProxyTableListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_infra_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get downlink port Address Resolution Protocol Proxies for infra segment in CSV format
    # Returns ARP proxy table for downlink port on connected to the segment in CSV format 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyArpProxyTableCsvListResult]
    def orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_infra_segment_in_csv(org_id, project_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_infra_segment_in_csv_with_http_info(org_id, project_id, segment_id, opts)
      data
    end

    # Get downlink port Address Resolution Protocol Proxies for infra segment in CSV format
    # Returns ARP proxy table for downlink port on connected to the segment in CSV format 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyArpProxyTableCsvListResult, Fixnum, Hash)>] PolicyArpProxyTableCsvListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_infra_segment_in_csv_with_http_info(org_id, project_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_infra_segment_in_csv ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_infra_segment_in_csv"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_infra_segment_in_csv"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_infra_segment_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/arp-proxy?format=csv'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyArpProxyTableCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_infra_segment_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get downlink port Address Resolution Protocol Proxies for tier-1 segment
    # Returns ARP proxy table for downlink port on connected to the segment 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyArpProxyTableListResult]
    def orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_tier1_segment(org_id, project_id, tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_tier1_segment_with_http_info(org_id, project_id, tier_1_id, segment_id, opts)
      data
    end

    # Get downlink port Address Resolution Protocol Proxies for tier-1 segment
    # Returns ARP proxy table for downlink port on connected to the segment 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyArpProxyTableListResult, Fixnum, Hash)>] PolicyArpProxyTableListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_tier1_segment_with_http_info(org_id, project_id, tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_tier1_segment ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_tier1_segment"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_tier1_segment"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_tier1_segment"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_tier1_segment"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_tier1_segment, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_tier1_segment, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/arp-proxy'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyArpProxyTableListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_tier1_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get downlink port Address Resolution Protocol Proxies for tier-1 segment in CSV
    # Returns ARP proxy table for downlink port on connected to the segment in CSV 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyArpProxyTableCsvListResult]
    def orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_tier1_segment_in_csv(org_id, project_id, tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_tier1_segment_in_csv_with_http_info(org_id, project_id, tier_1_id, segment_id, opts)
      data
    end

    # Get downlink port Address Resolution Protocol Proxies for tier-1 segment in CSV
    # Returns ARP proxy table for downlink port on connected to the segment in CSV 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyArpProxyTableCsvListResult, Fixnum, Hash)>] PolicyArpProxyTableCsvListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_tier1_segment_in_csv_with_http_info(org_id, project_id, tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_tier1_segment_in_csv ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_tier1_segment_in_csv"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_tier1_segment_in_csv"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_tier1_segment_in_csv"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_tier1_segment_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/arp-proxy?format=csv'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyArpProxyTableCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_downlink_port_arp_proxies_for_tier1_segment_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Group discovery profile binding map
    # API will get Group discovery profile binding map
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param discovery_profile_binding_map_id Group discovery profile binding map ID
    # @param [Hash] opts the optional parameters
    # @return [GroupDiscoveryProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_get_group_discovery_profile_binding(org_id, project_id, domain_id, group_id, discovery_profile_binding_map_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_group_discovery_profile_binding_with_http_info(org_id, project_id, domain_id, group_id, discovery_profile_binding_map_id, opts)
      data
    end

    # Get Group discovery profile binding map
    # API will get Group discovery profile binding map
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param discovery_profile_binding_map_id Group discovery profile binding map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(GroupDiscoveryProfileBindingMap, Fixnum, Hash)>] GroupDiscoveryProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_group_discovery_profile_binding_with_http_info(org_id, project_id, domain_id, group_id, discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_group_discovery_profile_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_group_discovery_profile_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_group_discovery_profile_binding"
      end
      # verify the required parameter 'domain_id' is set
      if @api_client.config.client_side_validation && domain_id.nil?
        fail ArgumentError, "Missing the required parameter 'domain_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_group_discovery_profile_binding"
      end
      # verify the required parameter 'group_id' is set
      if @api_client.config.client_side_validation && group_id.nil?
        fail ArgumentError, "Missing the required parameter 'group_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_group_discovery_profile_binding"
      end
      # verify the required parameter 'discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'discovery_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_group_discovery_profile_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/domains/{domain-id}/groups/{group-id}/discovery-profile-binding-maps/{discovery-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'domain-id' + '}', domain_id.to_s).sub('{' + 'group-id' + '}', group_id.to_s).sub('{' + 'discovery-profile-binding-map-id' + '}', discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'GroupDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_group_discovery_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Infra Port Discovery Profile Binding Map
    # API will get Infra Port Discovery Profile Binding Map 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [PortDiscoveryProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_get_infra_port_discovery_binding(org_id, project_id, infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_port_discovery_binding_with_http_info(org_id, project_id, infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, opts)
      data
    end

    # Get Infra Port Discovery Profile Binding Map
    # API will get Infra Port Discovery Profile Binding Map 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortDiscoveryProfileBindingMap, Fixnum, Hash)>] PortDiscoveryProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_port_discovery_binding_with_http_info(org_id, project_id, infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_port_discovery_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_port_discovery_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_port_discovery_binding"
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_port_discovery_binding"
      end
      # verify the required parameter 'infra_port_id' is set
      if @api_client.config.client_side_validation && infra_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_port_discovery_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{infra-segment-id}/ports/{infra-port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'infra-port-id' + '}', infra_port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_infra_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Port QoS Profile Binding Map
    # API will get Port QoS Profile Binding Map. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [PortQoSProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_get_infra_port_qo_s_binding(org_id, project_id, segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_port_qo_s_binding_with_http_info(org_id, project_id, segment_id, port_id, port_qos_profile_binding_map_id, opts)
      data
    end

    # Get Port QoS Profile Binding Map
    # API will get Port QoS Profile Binding Map. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortQoSProfileBindingMap, Fixnum, Hash)>] PortQoSProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_port_qo_s_binding_with_http_info(org_id, project_id, segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_port_qo_s_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_port_qo_s_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_port_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_infra_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Port Real Time Eth Profile Binding Map
    # API will get Port Real Time Eth Profile Binding Map. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_real_time_eth_profile_binding_map_id Port Real Time Eth Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [PortRealTimeEthProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_get_infra_port_real_time_eth_binding(org_id, project_id, segment_id, port_id, port_real_time_eth_profile_binding_map_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_port_real_time_eth_binding_with_http_info(org_id, project_id, segment_id, port_id, port_real_time_eth_profile_binding_map_id, opts)
      data
    end

    # Get Port Real Time Eth Profile Binding Map
    # API will get Port Real Time Eth Profile Binding Map. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_real_time_eth_profile_binding_map_id Port Real Time Eth Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortRealTimeEthProfileBindingMap, Fixnum, Hash)>] PortRealTimeEthProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_port_real_time_eth_binding_with_http_info(org_id, project_id, segment_id, port_id, port_real_time_eth_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_port_real_time_eth_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'port_real_time_eth_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_real_time_eth_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_real_time_eth_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_port_real_time_eth_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}/port-real-time-eth-profile-binding-maps/{port-real-time-eth-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-real-time-eth-profile-binding-map-id' + '}', port_real_time_eth_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortRealTimeEthProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_infra_port_real_time_eth_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Infra Segment Discovery Profile Binding Map
    # API will get Infra Segment Discovery Profile Binding Map 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param infra_segment_id Infra Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [SegmentDiscoveryProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_get_infra_segment_discovery_binding(org_id, project_id, infra_segment_id, segment_discovery_profile_binding_map_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_segment_discovery_binding_with_http_info(org_id, project_id, infra_segment_id, segment_discovery_profile_binding_map_id, opts)
      data
    end

    # Get Infra Segment Discovery Profile Binding Map
    # API will get Infra Segment Discovery Profile Binding Map 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param infra_segment_id Infra Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentDiscoveryProfileBindingMap, Fixnum, Hash)>] SegmentDiscoveryProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_segment_discovery_binding_with_http_info(org_id, project_id, infra_segment_id, segment_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_discovery_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_discovery_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_discovery_binding"
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_discovery_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{infra-segment-id}/segment-discovery-profile-binding-maps/{segment-discovery-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'segment-discovery-profile-binding-map-id' + '}', segment_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_infra_segment_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment MAC table
    # Returns MAC table for a segment 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [SegmentMacAddressListResult]
    def orgs_org_id_projects_project_id_infra_get_infra_segment_mac_table(org_id, project_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_segment_mac_table_with_http_info(org_id, project_id, segment_id, opts)
      data
    end

    # Get infra segment MAC table
    # Returns MAC table for a segment 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(SegmentMacAddressListResult, Fixnum, Hash)>] SegmentMacAddressListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_segment_mac_table_with_http_info(org_id, project_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_mac_table ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_mac_table"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_mac_table"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_mac_table"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_mac_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_mac_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/mac-table'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentMacAddressListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_infra_segment_mac_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment MAC table in CSV
    # Returns MAC table for a segment 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [MacAddressCsvListResult]
    def orgs_org_id_projects_project_id_infra_get_infra_segment_mac_table_in_csv(org_id, project_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_segment_mac_table_in_csv_with_http_info(org_id, project_id, segment_id, opts)
      data
    end

    # Get infra segment MAC table in CSV
    # Returns MAC table for a segment 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(MacAddressCsvListResult, Fixnum, Hash)>] MacAddressCsvListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_segment_mac_table_in_csv_with_http_info(org_id, project_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_mac_table_in_csv ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_mac_table_in_csv"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_mac_table_in_csv"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_mac_table_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/mac-table?format=csv'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MacAddressCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_infra_segment_mac_table_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment port by ID
    # Get detail information on an infra segment port by giving ID. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [SegmentPort]
    def orgs_org_id_projects_project_id_infra_get_infra_segment_port(org_id, project_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_segment_port_with_http_info(org_id, project_id, segment_id, port_id, opts)
      data
    end

    # Get infra segment port by ID
    # Get detail information on an infra segment port by giving ID. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentPort, Fixnum, Hash)>] SegmentPort data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_segment_port_with_http_info(org_id, project_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPort')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_infra_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get MAC table for infra segment port
    # Returns MAC table for a segment port 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [SegmentPortMacAddressListResult]
    def orgs_org_id_projects_project_id_infra_get_infra_segment_port_mac_table(org_id, project_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_segment_port_mac_table_with_http_info(org_id, project_id, segment_id, port_id, opts)
      data
    end

    # Get MAC table for infra segment port
    # Returns MAC table for a segment port 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(SegmentPortMacAddressListResult, Fixnum, Hash)>] SegmentPortMacAddressListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_segment_port_mac_table_with_http_info(org_id, project_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_mac_table ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_mac_table"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_mac_table"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_mac_table"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_mac_table"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_mac_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_mac_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}/mac-table'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortMacAddressListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_infra_segment_port_mac_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment port MAC table in CSV
    # Returns MAC table for a segment port 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [SegmentPortMacAddressCsvListResult]
    def orgs_org_id_projects_project_id_infra_get_infra_segment_port_mac_table_in_csv(org_id, project_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_segment_port_mac_table_in_csv_with_http_info(org_id, project_id, segment_id, port_id, opts)
      data
    end

    # Get infra segment port MAC table in CSV
    # Returns MAC table for a segment port 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(SegmentPortMacAddressCsvListResult, Fixnum, Hash)>] SegmentPortMacAddressCsvListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_segment_port_mac_table_in_csv_with_http_info(org_id, project_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_mac_table_in_csv ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_mac_table_in_csv"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_mac_table_in_csv"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_mac_table_in_csv"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_mac_table_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}/mac-table?format=csv'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortMacAddressCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_infra_segment_port_mac_table_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment port security profile binding map
    # API will return details of the port security profile binding map. If the security profile binding map does not exist, it will return 404. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [PortSecurityProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_get_infra_segment_port_security_profile_binding(org_id, project_id, segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_segment_port_security_profile_binding_with_http_info(org_id, project_id, segment_id, port_id, port_security_profile_binding_map_id, opts)
      data
    end

    # Get infra segment port security profile binding map
    # API will return details of the port security profile binding map. If the security profile binding map does not exist, it will return 404. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortSecurityProfileBindingMap, Fixnum, Hash)>] PortSecurityProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_segment_port_security_profile_binding_with_http_info(org_id, project_id, segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_security_profile_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_infra_segment_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment port state
    # Returns infra segment port state on enforcement point 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [SegmentPortState]
    def orgs_org_id_projects_project_id_infra_get_infra_segment_port_state(org_id, project_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_segment_port_state_with_http_info(org_id, project_id, segment_id, port_id, opts)
      data
    end

    # Get infra segment port state
    # Returns infra segment port state on enforcement point 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(SegmentPortState, Fixnum, Hash)>] SegmentPortState data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_segment_port_state_with_http_info(org_id, project_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_state ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_state"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_state"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_state"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_state"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}/state'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_infra_segment_port_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment port statistics information
    # Get infra segment port statistics information. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentPortStatistics]
    def orgs_org_id_projects_project_id_infra_get_infra_segment_port_statistics(org_id, project_id, segments_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_segment_port_statistics_with_http_info(org_id, project_id, segments_id, port_id, opts)
      data
    end

    # Get infra segment port statistics information
    # Get infra segment port statistics information. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentPortStatistics, Fixnum, Hash)>] SegmentPortStatistics data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_segment_port_statistics_with_http_info(org_id, project_id, segments_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_statistics ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_statistics"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_statistics"
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_statistics"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_statistics, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_statistics, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segments-id}/ports/{port-id}/statistics'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segments-id' + '}', segments_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_infra_segment_port_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment port status information
    # Get infra segment port status information. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentPortStatus]
    def orgs_org_id_projects_project_id_infra_get_infra_segment_port_status(org_id, project_id, segments_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_segment_port_status_with_http_info(org_id, project_id, segments_id, port_id, opts)
      data
    end

    # Get infra segment port status information
    # Get infra segment port status information. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentPortStatus, Fixnum, Hash)>] SegmentPortStatus data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_segment_port_status_with_http_info(org_id, project_id, segments_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_status ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_status"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_status"
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_status"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_status"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_port_status, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segments-id}/ports/{port-id}/status'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segments-id' + '}', segments_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_infra_segment_port_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Segment QoS Profile Binding Map
    # API will get Segment QoS Profile Binding Map. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [SegmentQoSProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_get_infra_segment_qo_s_binding(org_id, project_id, segment_id, segment_qos_profile_binding_map_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_segment_qo_s_binding_with_http_info(org_id, project_id, segment_id, segment_qos_profile_binding_map_id, opts)
      data
    end

    # Get Segment QoS Profile Binding Map
    # API will get Segment QoS Profile Binding Map. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentQoSProfileBindingMap, Fixnum, Hash)>] SegmentQoSProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_segment_qo_s_binding_with_http_info(org_id, project_id, segment_id, segment_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_qo_s_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_qo_s_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qos_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_qo_s_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/segment-qos-profile-binding-maps/{segment-qos-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-qos-profile-binding-map-id' + '}', segment_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_infra_segment_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Segment Real Time Eth Profile Binding Map
    # API will get Segment Real Time Eth Profile Binding Map. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment_real_time_eth_profile_binding_map_id Segment Real Time Eth Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [SegmentRealTimeEthProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_get_infra_segment_real_time_eth_binding(org_id, project_id, segment_id, segment_real_time_eth_profile_binding_map_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_segment_real_time_eth_binding_with_http_info(org_id, project_id, segment_id, segment_real_time_eth_profile_binding_map_id, opts)
      data
    end

    # Get Segment Real Time Eth Profile Binding Map
    # API will get Segment Real Time Eth Profile Binding Map. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment_real_time_eth_profile_binding_map_id Segment Real Time Eth Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentRealTimeEthProfileBindingMap, Fixnum, Hash)>] SegmentRealTimeEthProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_segment_real_time_eth_binding_with_http_info(org_id, project_id, segment_id, segment_real_time_eth_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_real_time_eth_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_real_time_eth_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_real_time_eth_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_real_time_eth_binding"
      end
      # verify the required parameter 'segment_real_time_eth_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_real_time_eth_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_real_time_eth_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_real_time_eth_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/segment-real-time-eth-profile-binding-maps/{segment-real-time-eth-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-real-time-eth-profile-binding-map-id' + '}', segment_real_time_eth_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentRealTimeEthProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_infra_segment_real_time_eth_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment security profile binding map
    # API will return details of the segment security profile binding map. If the binding map does not exist, it will return 404. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [SegmentSecurityProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_get_infra_segment_security_profile_binding(org_id, project_id, segment_id, segment_security_profile_binding_map_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_segment_security_profile_binding_with_http_info(org_id, project_id, segment_id, segment_security_profile_binding_map_id, opts)
      data
    end

    # Get infra segment security profile binding map
    # API will return details of the segment security profile binding map. If the binding map does not exist, it will return 404. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentSecurityProfileBindingMap, Fixnum, Hash)>] SegmentSecurityProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_segment_security_profile_binding_with_http_info(org_id, project_id, segment_id, segment_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_security_profile_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_security_profile_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_security_profile_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/segment-security-profile-binding-maps/{segment-security-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-security-profile-binding-map-id' + '}', segment_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_infra_segment_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment state information
    # Get infra segment state information. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentConfigurationState]
    def orgs_org_id_projects_project_id_infra_get_infra_segment_state(org_id, project_id, segments_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_segment_state_with_http_info(org_id, project_id, segments_id, opts)
      data
    end

    # Get infra segment state information
    # Get infra segment state information. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentConfigurationState, Fixnum, Hash)>] SegmentConfigurationState data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_segment_state_with_http_info(org_id, project_id, segments_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_state ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_state"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_state"
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_state"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_state, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_state, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segments-id}/state'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segments-id' + '}', segments_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConfigurationState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_infra_segment_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment statistics information
    # Get infra segment statistics information. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentStatistics]
    def orgs_org_id_projects_project_id_infra_get_infra_segment_statistics(org_id, project_id, segments_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_segment_statistics_with_http_info(org_id, project_id, segments_id, opts)
      data
    end

    # Get infra segment statistics information
    # Get infra segment statistics information. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentStatistics, Fixnum, Hash)>] SegmentStatistics data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_segment_statistics_with_http_info(org_id, project_id, segments_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_statistics ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_statistics"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_statistics"
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_statistics, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_statistics, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segments-id}/statistics'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segments-id' + '}', segments_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_infra_segment_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segment TEP table
    # Returns TEP table for a segment 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyTepListResult]
    def orgs_org_id_projects_project_id_infra_get_infra_segment_tep_table(org_id, project_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_segment_tep_table_with_http_info(org_id, project_id, segment_id, opts)
      data
    end

    # Get infra segment TEP table
    # Returns TEP table for a segment 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyTepListResult, Fixnum, Hash)>] PolicyTepListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_segment_tep_table_with_http_info(org_id, project_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_tep_table ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_tep_table"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_tep_table"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_tep_table"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_tep_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_tep_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/tep-table'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyTepListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_infra_segment_tep_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get tier-1 segment TEP table in CSV
    # Returns TEP table for a segment in CSV 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyTepCsvListResult]
    def orgs_org_id_projects_project_id_infra_get_infra_segment_tep_table_in_csv(org_id, project_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_segment_tep_table_in_csv_with_http_info(org_id, project_id, segment_id, opts)
      data
    end

    # Get tier-1 segment TEP table in CSV
    # Returns TEP table for a segment in CSV 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyTepCsvListResult, Fixnum, Hash)>] PolicyTepCsvListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_segment_tep_table_in_csv_with_http_info(org_id, project_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_tep_table_in_csv ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_tep_table_in_csv"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_tep_table_in_csv"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segment_tep_table_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/tep-table?format=csv'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyTepCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_infra_segment_tep_table_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get infra segments by configuration state
    # Returns all infra segments with configuration state on the enforcement point specified in the request 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :configuration_state Configuration state of the segment on enforcement point
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [SegmentConfigurationStateListResult]
    def orgs_org_id_projects_project_id_infra_get_infra_segments_by_state(org_id, project_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_infra_segments_by_state_with_http_info(org_id, project_id, opts)
      data
    end

    # Get infra segments by configuration state
    # Returns all infra segments with configuration state on the enforcement point specified in the request 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :configuration_state Configuration state of the segment on enforcement point
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(SegmentConfigurationStateListResult, Fixnum, Hash)>] SegmentConfigurationStateListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_infra_segments_by_state_with_http_info(org_id, project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segments_by_state ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segments_by_state"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_infra_segments_by_state"
      end
      if @api_client.config.client_side_validation && opts[:'configuration_state'] && !['pending', 'in_progress', 'success', 'failed', 'partial_success', 'orphaned', 'unknown'].include?(opts[:'configuration_state'])
        fail ArgumentError, 'invalid value for "configuration_state", must be one of pending, in_progress, success, failed, partial_success, orphaned, unknown'
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/state'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'configuration_state'] = opts[:'configuration_state'] if !opts[:'configuration_state'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConfigurationStateListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_infra_segments_by_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get IP Discovery Profile
    # API will get IP Discovery profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @return [IPDiscoveryProfile]
    def orgs_org_id_projects_project_id_infra_get_ip_discovery_profile(org_id, project_id, ip_discovery_profile_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_ip_discovery_profile_with_http_info(org_id, project_id, ip_discovery_profile_id, opts)
      data
    end

    # Get IP Discovery Profile
    # API will get IP Discovery profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(IPDiscoveryProfile, Fixnum, Hash)>] IPDiscoveryProfile data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_ip_discovery_profile_with_http_info(org_id, project_id, ip_discovery_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_ip_discovery_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_ip_discovery_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_ip_discovery_profile"
      end
      # verify the required parameter 'ip_discovery_profile_id' is set
      if @api_client.config.client_side_validation && ip_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'ip_discovery_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_ip_discovery_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/ip-discovery-profiles/{ip-discovery-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'ip-discovery-profile-id' + '}', ip_discovery_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'IPDiscoveryProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_ip_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List IP Discovery Profiles
    # API will list all IP Discovery Profiles active in current discovery profile id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [IPDiscoveryProfileListResult]
    def orgs_org_id_projects_project_id_infra_get_ip_discovery_profiles(org_id, project_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_ip_discovery_profiles_with_http_info(org_id, project_id, opts)
      data
    end

    # List IP Discovery Profiles
    # API will list all IP Discovery Profiles active in current discovery profile id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(IPDiscoveryProfileListResult, Fixnum, Hash)>] IPDiscoveryProfileListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_ip_discovery_profiles_with_http_info(org_id, project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_ip_discovery_profiles ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_ip_discovery_profiles"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_ip_discovery_profiles"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_ip_discovery_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_ip_discovery_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/ip-discovery-profiles'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'IPDiscoveryProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_ip_discovery_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Mac Discovery Profile
    # API will get Mac Discovery profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @return [MacDiscoveryProfile]
    def orgs_org_id_projects_project_id_infra_get_mac_discovery_profile(org_id, project_id, mac_discovery_profile_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_mac_discovery_profile_with_http_info(org_id, project_id, mac_discovery_profile_id, opts)
      data
    end

    # Get Mac Discovery Profile
    # API will get Mac Discovery profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(MacDiscoveryProfile, Fixnum, Hash)>] MacDiscoveryProfile data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_mac_discovery_profile_with_http_info(org_id, project_id, mac_discovery_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_mac_discovery_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_mac_discovery_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_mac_discovery_profile"
      end
      # verify the required parameter 'mac_discovery_profile_id' is set
      if @api_client.config.client_side_validation && mac_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'mac_discovery_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_mac_discovery_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/mac-discovery-profiles/{mac-discovery-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'mac-discovery-profile-id' + '}', mac_discovery_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MacDiscoveryProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_mac_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Mac Discovery Profiles
    # API will list all Mac Discovery Profiles active in current discovery profile id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [MacDiscoveryProfileListResult]
    def orgs_org_id_projects_project_id_infra_get_mac_discovery_profiles(org_id, project_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_mac_discovery_profiles_with_http_info(org_id, project_id, opts)
      data
    end

    # List Mac Discovery Profiles
    # API will list all Mac Discovery Profiles active in current discovery profile id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(MacDiscoveryProfileListResult, Fixnum, Hash)>] MacDiscoveryProfileListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_mac_discovery_profiles_with_http_info(org_id, project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_mac_discovery_profiles ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_mac_discovery_profiles"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_mac_discovery_profiles"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_mac_discovery_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_mac_discovery_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/mac-discovery-profiles'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MacDiscoveryProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_mac_discovery_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Port Discovery Profile Binding Map
    # API will get Port Discovery Profile Binding Map 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [PortDiscoveryProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_get_port_discovery_binding(org_id, project_id, tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_port_discovery_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, opts)
      data
    end

    # Get Port Discovery Profile Binding Map
    # API will get Port Discovery Profile Binding Map 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortDiscoveryProfileBindingMap, Fixnum, Hash)>] PortDiscoveryProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_port_discovery_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_port_discovery_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_port_discovery_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_port_discovery_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_port_discovery_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_port_discovery_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_port_discovery_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Port QoS Profile Binding Map
    # API will get Port QoS Profile Binding Map. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [PortQoSProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_get_port_qo_s_binding(org_id, project_id, tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_port_qo_s_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, opts)
      data
    end

    # Get Port QoS Profile Binding Map
    # API will get Port QoS Profile Binding Map. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortQoSProfileBindingMap, Fixnum, Hash)>] PortQoSProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_port_qo_s_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_port_qo_s_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_port_qo_s_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_port_qo_s_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_port_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get port security profile binding map
    # API will return details of the port security profile binding map. If the security profile binding map does not exist, it will return 404. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [PortSecurityProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_get_port_security_profile_binding(org_id, project_id, tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_port_security_profile_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, opts)
      data
    end

    # Get port security profile binding map
    # API will return details of the port security profile binding map. If the security profile binding map does not exist, it will return 404. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortSecurityProfileBindingMap, Fixnum, Hash)>] PortSecurityProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_port_security_profile_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_port_security_profile_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_port_security_profile_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_port_security_profile_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_port_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Segment Discovery Profile Binding Map
    # API will get Segment Discovery Profile Binding Map 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [SegmentDiscoveryProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_get_segment_discovery_binding(org_id, project_id, tier_1_id, segment_id, segment_discovery_profile_binding_map_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_segment_discovery_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_discovery_profile_binding_map_id, opts)
      data
    end

    # Get Segment Discovery Profile Binding Map
    # API will get Segment Discovery Profile Binding Map 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentDiscoveryProfileBindingMap, Fixnum, Hash)>] SegmentDiscoveryProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_segment_discovery_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_discovery_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_discovery_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_discovery_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_discovery_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_discovery_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_discovery_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-discovery-profile-binding-maps/{segment-discovery-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-discovery-profile-binding-map-id' + '}', segment_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_segment_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get tier-1 segment port statistics information
    # Get tier-1 segment port statistics information. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentPortStatistics]
    def orgs_org_id_projects_project_id_infra_get_segment_port_statistics(org_id, project_id, tier_1_id, segments_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_segment_port_statistics_with_http_info(org_id, project_id, tier_1_id, segments_id, port_id, opts)
      data
    end

    # Get tier-1 segment port statistics information
    # Get tier-1 segment port statistics information. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentPortStatistics, Fixnum, Hash)>] SegmentPortStatistics data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_segment_port_statistics_with_http_info(org_id, project_id, tier_1_id, segments_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_port_statistics ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_port_statistics"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_port_statistics"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_port_statistics"
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_port_statistics"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_port_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_port_statistics, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_port_statistics, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segments-id}/ports/{port-id}/statistics'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segments-id' + '}', segments_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_segment_port_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get segment port status information
    # Get tier1 segment port status information. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentPortStatus]
    def orgs_org_id_projects_project_id_infra_get_segment_port_status(org_id, project_id, tier_1_id, segments_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_segment_port_status_with_http_info(org_id, project_id, tier_1_id, segments_id, port_id, opts)
      data
    end

    # Get segment port status information
    # Get tier1 segment port status information. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segments_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentPortStatus, Fixnum, Hash)>] SegmentPortStatus data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_segment_port_status_with_http_info(org_id, project_id, tier_1_id, segments_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_port_status ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_port_status"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_port_status"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_port_status"
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_port_status"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_port_status"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_port_status, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_port_status, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segments-id}/ports/{port-id}/status'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segments-id' + '}', segments_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_segment_port_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Segment QoS Profile Binding Map
    # API will get Segment QoS Profile Binding Map. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [SegmentQoSProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_get_segment_qo_s_binding(org_id, project_id, tier_1_id, segment_id, segment_qos_profile_binding_map_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_segment_qo_s_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_qos_profile_binding_map_id, opts)
      data
    end

    # Get Segment QoS Profile Binding Map
    # API will get Segment QoS Profile Binding Map. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentQoSProfileBindingMap, Fixnum, Hash)>] SegmentQoSProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_segment_qo_s_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_qos_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_qo_s_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_qo_s_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_qo_s_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qos_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_qo_s_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-qos-profile-binding-maps/{segment-qos-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-qos-profile-binding-map-id' + '}', segment_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_segment_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # GET Segment security profile id
    # API will return details of the segment security profile with given id. If the profile does not exist, it will return 404. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_security_profile_id Segment security profile id
    # @param [Hash] opts the optional parameters
    # @return [SegmentSecurityProfile]
    def orgs_org_id_projects_project_id_infra_get_segment_security_profile(org_id, project_id, segment_security_profile_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_segment_security_profile_with_http_info(org_id, project_id, segment_security_profile_id, opts)
      data
    end

    # GET Segment security profile id
    # API will return details of the segment security profile with given id. If the profile does not exist, it will return 404. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_security_profile_id Segment security profile id
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentSecurityProfile, Fixnum, Hash)>] SegmentSecurityProfile data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_segment_security_profile_with_http_info(org_id, project_id, segment_security_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_security_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_security_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_security_profile"
      end
      # verify the required parameter 'segment_security_profile_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_security_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segment-security-profiles/{segment-security-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-security-profile-id' + '}', segment_security_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_segment_security_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get segment security profile binding map
    # API will return details of the segment security profile binding map. If the binding map does not exist, it will return 404. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [SegmentSecurityProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_get_segment_security_profile_binding(org_id, project_id, tier_1_id, segment_id, segment_security_profile_binding_map_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_segment_security_profile_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_security_profile_binding_map_id, opts)
      data
    end

    # Get segment security profile binding map
    # API will return details of the segment security profile binding map. If the binding map does not exist, it will return 404. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentSecurityProfileBindingMap, Fixnum, Hash)>] SegmentSecurityProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_segment_security_profile_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_security_profile_binding_map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_security_profile_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_security_profile_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_security_profile_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_security_profile_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-security-profile-binding-maps/{segment-security-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-security-profile-binding-map-id' + '}', segment_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_segment_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get segment state information
    # Get tier1 segment state information. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentConfigurationState]
    def orgs_org_id_projects_project_id_infra_get_segment_state(org_id, project_id, tier_1_id, segments_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_segment_state_with_http_info(org_id, project_id, tier_1_id, segments_id, opts)
      data
    end

    # Get segment state information
    # Get tier1 segment state information. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentConfigurationState, Fixnum, Hash)>] SegmentConfigurationState data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_segment_state_with_http_info(org_id, project_id, tier_1_id, segments_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_state ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_state"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_state"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_state"
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_state"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_state, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_state, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segments-id}/state'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segments-id' + '}', segments_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConfigurationState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_segment_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get segment statistics information
    # Get tier1 segment statistics information. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [SegmentStatistics]
    def orgs_org_id_projects_project_id_infra_get_segment_statistics(org_id, project_id, tier_1_id, segments_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_segment_statistics_with_http_info(org_id, project_id, tier_1_id, segments_id, opts)
      data
    end

    # Get segment statistics information
    # Get tier1 segment statistics information. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segments_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :bgp_neighbor_type Bgp neighbor type
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :edge_path Policy path of edge node
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :stats_type Segment statistics type
    # @option opts [String] :transport_node_id Transport Node Id
    # @return [Array<(SegmentStatistics, Fixnum, Hash)>] SegmentStatistics data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_segment_statistics_with_http_info(org_id, project_id, tier_1_id, segments_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_statistics ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_statistics"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_statistics"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_statistics"
      end
      # verify the required parameter 'segments_id' is set
      if @api_client.config.client_side_validation && segments_id.nil?
        fail ArgumentError, "Missing the required parameter 'segments_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_statistics"
      end
      if @api_client.config.client_side_validation && opts[:'bgp_neighbor_type'] && !['INTER_SR', 'USER'].include?(opts[:'bgp_neighbor_type'])
        fail ArgumentError, 'invalid value for "bgp_neighbor_type", must be one of INTER_SR, USER'
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_statistics, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_segment_statistics, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      if @api_client.config.client_side_validation && opts[:'stats_type'] && !['DATAPATH_STATS'].include?(opts[:'stats_type'])
        fail ArgumentError, 'invalid value for "stats_type", must be one of DATAPATH_STATS'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segments-id}/statistics'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segments-id' + '}', segments_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bgp_neighbor_type'] = opts[:'bgp_neighbor_type'] if !opts[:'bgp_neighbor_type'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'edge_path'] = opts[:'edge_path'] if !opts[:'edge_path'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'stats_type'] = opts[:'stats_type'] if !opts[:'stats_type'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_segment_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get SpoofGuard profile
    # API will return details of the SpoofGuard profile with given id. If the profile does not exist, it will return 404. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param [Hash] opts the optional parameters
    # @return [SpoofGuardProfile]
    def orgs_org_id_projects_project_id_infra_get_spoof_guard_profile(org_id, project_id, spoofguard_profile_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_spoof_guard_profile_with_http_info(org_id, project_id, spoofguard_profile_id, opts)
      data
    end

    # Get SpoofGuard profile
    # API will return details of the SpoofGuard profile with given id. If the profile does not exist, it will return 404. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param [Hash] opts the optional parameters
    # @return [Array<(SpoofGuardProfile, Fixnum, Hash)>] SpoofGuardProfile data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_spoof_guard_profile_with_http_info(org_id, project_id, spoofguard_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_spoof_guard_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_spoof_guard_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_spoof_guard_profile"
      end
      # verify the required parameter 'spoofguard_profile_id' is set
      if @api_client.config.client_side_validation && spoofguard_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'spoofguard_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_spoof_guard_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/spoofguard-profiles/{spoofguard-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'spoofguard-profile-id' + '}', spoofguard_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SpoofGuardProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_spoof_guard_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tier-1 segment MAC table
    # Returns MAC table for a segment 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [SegmentMacAddressListResult]
    def orgs_org_id_projects_project_id_infra_get_tier1_segment_mac_table(org_id, project_id, tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tier1_segment_mac_table_with_http_info(org_id, project_id, tier_1_id, segment_id, opts)
      data
    end

    # Get Tier-1 segment MAC table
    # Returns MAC table for a segment 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(SegmentMacAddressListResult, Fixnum, Hash)>] SegmentMacAddressListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tier1_segment_mac_table_with_http_info(org_id, project_id, tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_mac_table ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_mac_table"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_mac_table"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_mac_table"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_mac_table"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_mac_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_mac_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/mac-table'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentMacAddressListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_tier1_segment_mac_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tier-1 segment MAC table in CSV
    # Returns MAC table for a segment 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [MacAddressCsvListResult]
    def orgs_org_id_projects_project_id_infra_get_tier1_segment_mac_table_in_csv(org_id, project_id, tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tier1_segment_mac_table_in_csv_with_http_info(org_id, project_id, tier_1_id, segment_id, opts)
      data
    end

    # Get Tier-1 segment MAC table in CSV
    # Returns MAC table for a segment 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(MacAddressCsvListResult, Fixnum, Hash)>] MacAddressCsvListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tier1_segment_mac_table_in_csv_with_http_info(org_id, project_id, tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_mac_table_in_csv ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_mac_table_in_csv"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_mac_table_in_csv"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_mac_table_in_csv"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_mac_table_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/mac-table?format=csv'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MacAddressCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_tier1_segment_mac_table_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tier-1 segment port by ID
    # Get detail information on a Tier-1 segment port by giving ID. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [SegmentPort]
    def orgs_org_id_projects_project_id_infra_get_tier1_segment_port(org_id, project_id, tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tier1_segment_port_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, opts)
      data
    end

    # Get Tier-1 segment port by ID
    # Get detail information on a Tier-1 segment port by giving ID. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentPort, Fixnum, Hash)>] SegmentPort data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tier1_segment_port_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPort')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_tier1_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get MAC table for tier-1 segment port
    # Returns MAC table for a segment port 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [SegmentPortMacAddressListResult]
    def orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table(org_id, project_id, tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, opts)
      data
    end

    # Get MAC table for tier-1 segment port
    # Returns MAC table for a segment port 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(SegmentPortMacAddressListResult, Fixnum, Hash)>] SegmentPortMacAddressListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/mac-table'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortMacAddressListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get tier-1 segment port MAC table in CSV
    # Returns MAC table for a segment port 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [SegmentPortMacAddressCsvListResult]
    def orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table_in_csv(org_id, project_id, tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table_in_csv_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, opts)
      data
    end

    # Get tier-1 segment port MAC table in CSV
    # Returns MAC table for a segment port 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(SegmentPortMacAddressCsvListResult, Fixnum, Hash)>] SegmentPortMacAddressCsvListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table_in_csv_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table_in_csv ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table_in_csv"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table_in_csv"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table_in_csv"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table_in_csv"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/mac-table?format=csv'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortMacAddressCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_tier1_segment_port_mac_table_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get tier-1  segment port state
    # Returns tier-1 segment port state on enforcement point 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [SegmentPortState]
    def orgs_org_id_projects_project_id_infra_get_tier1_segment_port_state(org_id, project_id, tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tier1_segment_port_state_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, opts)
      data
    end

    # Get tier-1  segment port state
    # Returns tier-1 segment port state on enforcement point 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(SegmentPortState, Fixnum, Hash)>] SegmentPortState data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tier1_segment_port_state_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port_state ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port_state"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port_state"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port_state"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port_state"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_port_state"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/state'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortState')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_tier1_segment_port_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get tier-1 segment TEP table
    # Returns TEP table for a segment 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyTepListResult]
    def orgs_org_id_projects_project_id_infra_get_tier1_segment_tep_table(org_id, project_id, tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tier1_segment_tep_table_with_http_info(org_id, project_id, tier_1_id, segment_id, opts)
      data
    end

    # Get tier-1 segment TEP table
    # Returns TEP table for a segment 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyTepListResult, Fixnum, Hash)>] PolicyTepListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tier1_segment_tep_table_with_http_info(org_id, project_id, tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_tep_table ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_tep_table"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_tep_table"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_tep_table"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_tep_table"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_tep_table, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_tep_table, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/tep-table'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyTepListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_tier1_segment_tep_table\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get tier-1 segment TEP table in CSV
    # Returns TEP table for a segment in CSV 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [PolicyTepCsvListResult]
    def orgs_org_id_projects_project_id_infra_get_tier1_segment_tep_table_in_csv(org_id, project_id, tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tier1_segment_tep_table_in_csv_with_http_info(org_id, project_id, tier_1_id, segment_id, opts)
      data
    end

    # Get tier-1 segment TEP table in CSV
    # Returns TEP table for a segment in CSV 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @option opts [String] :transport_node_id TransportNode Id
    # @return [Array<(PolicyTepCsvListResult, Fixnum, Hash)>] PolicyTepCsvListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tier1_segment_tep_table_in_csv_with_http_info(org_id, project_id, tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_tep_table_in_csv ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_tep_table_in_csv"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_tep_table_in_csv"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_tep_table_in_csv"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segment_tep_table_in_csv"
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/tep-table?format=csv'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?
      query_params[:'transport_node_id'] = opts[:'transport_node_id'] if !opts[:'transport_node_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/csv'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PolicyTepCsvListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_tier1_segment_tep_table_in_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get tier-1 segments by configuration state
    # Returns all tier-1 segments with configuration state on the enforcement point specified in the request 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :configuration_state Configuration state of the segment on enforcement point
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [SegmentConfigurationStateListResult]
    def orgs_org_id_projects_project_id_infra_get_tier1_segments_by_state(org_id, project_id, tier_1_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_get_tier1_segments_by_state_with_http_info(org_id, project_id, tier_1_id, opts)
      data
    end

    # Get tier-1 segments by configuration state
    # Returns all tier-1 segments with configuration state on the enforcement point specified in the request 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :configuration_state Configuration state of the segment on enforcement point
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @option opts [String] :source Data source type.
    # @return [Array<(SegmentConfigurationStateListResult, Fixnum, Hash)>] SegmentConfigurationStateListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_get_tier1_segments_by_state_with_http_info(org_id, project_id, tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segments_by_state ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segments_by_state"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segments_by_state"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_get_tier1_segments_by_state"
      end
      if @api_client.config.client_side_validation && opts[:'configuration_state'] && !['pending', 'in_progress', 'success', 'failed', 'partial_success', 'orphaned', 'unknown'].include?(opts[:'configuration_state'])
        fail ArgumentError, 'invalid value for "configuration_state", must be one of pending, in_progress, success, failed, partial_success, orphaned, unknown'
      end
      if @api_client.config.client_side_validation && opts[:'source'] && !['realtime', 'cached'].include?(opts[:'source'])
        fail ArgumentError, 'invalid value for "source", must be one of realtime, cached'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/state'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'configuration_state'] = opts[:'configuration_state'] if !opts[:'configuration_state'].nil?
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?
      query_params[:'source'] = opts[:'source'] if !opts[:'source'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConfigurationStateListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_get_tier1_segments_by_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all segments under infra
    # Paginated list of all segments under infra. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :segment_type Segment type
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentListResult]
    def orgs_org_id_projects_project_id_infra_list_all_infra_segments(org_id, project_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_all_infra_segments_with_http_info(org_id, project_id, opts)
      data
    end

    # List all segments under infra
    # Paginated list of all segments under infra. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :segment_type Segment type
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentListResult, Fixnum, Hash)>] SegmentListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_all_infra_segments_with_http_info(org_id, project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_all_infra_segments ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_all_infra_segments"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_all_infra_segments"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_all_infra_segments, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_all_infra_segments, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'segment_type'] && !['DVPortgroup', 'ALL'].include?(opts[:'segment_type'])
        fail ArgumentError, 'invalid value for "segment_type", must be one of DVPortgroup, ALL'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'segment_type'] = opts[:'segment_type'] if !opts[:'segment_type'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_all_infra_segments\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all segments under infra
    # Paginated list of all segments under infra. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :segment_type Segment type
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentListResult]
    def orgs_org_id_projects_project_id_infra_list_all_infra_segments_0(org_id, project_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_all_infra_segments_0_with_http_info(org_id, project_id, opts)
      data
    end

    # List all segments under infra
    # Paginated list of all segments under infra. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :segment_type Segment type
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentListResult, Fixnum, Hash)>] SegmentListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_all_infra_segments_0_with_http_info(org_id, project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_all_infra_segments_0 ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_all_infra_segments_0"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_all_infra_segments_0"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_all_infra_segments_0, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_all_infra_segments_0, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'segment_type'] && !['DVPortgroup', 'ALL'].include?(opts[:'segment_type'])
        fail ArgumentError, 'invalid value for "segment_type", must be one of DVPortgroup, ALL'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'segment_type'] = opts[:'segment_type'] if !opts[:'segment_type'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_all_infra_segments_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Group discovery profile binding map
    # API will get Group discovery profile binding map
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [GroupDiscoveryProfileBindingMapListResult]
    def orgs_org_id_projects_project_id_infra_list_group_discovery_profile_bindings(org_id, project_id, domain_id, group_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_group_discovery_profile_bindings_with_http_info(org_id, project_id, domain_id, group_id, opts)
      data
    end

    # Get Group discovery profile binding map
    # API will get Group discovery profile binding map
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(GroupDiscoveryProfileBindingMapListResult, Fixnum, Hash)>] GroupDiscoveryProfileBindingMapListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_group_discovery_profile_bindings_with_http_info(org_id, project_id, domain_id, group_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_group_discovery_profile_bindings ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_group_discovery_profile_bindings"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_group_discovery_profile_bindings"
      end
      # verify the required parameter 'domain_id' is set
      if @api_client.config.client_side_validation && domain_id.nil?
        fail ArgumentError, "Missing the required parameter 'domain_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_group_discovery_profile_bindings"
      end
      # verify the required parameter 'group_id' is set
      if @api_client.config.client_side_validation && group_id.nil?
        fail ArgumentError, "Missing the required parameter 'group_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_group_discovery_profile_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_group_discovery_profile_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_group_discovery_profile_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/domains/{domain-id}/groups/{group-id}/discovery-profile-binding-maps'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'domain-id' + '}', domain_id.to_s).sub('{' + 'group-id' + '}', group_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'GroupDiscoveryProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_group_discovery_profile_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Infra Port Discovery Profile Binding Maps
    # API will list all Infra Port Discovery Profile Binding Maps in current port id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param infra_segment_id 
    # @param infra_port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortDiscoveryProfileBindingMapListResult]
    def orgs_org_id_projects_project_id_infra_list_infra_port_discovery_bindings(org_id, project_id, infra_segment_id, infra_port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_infra_port_discovery_bindings_with_http_info(org_id, project_id, infra_segment_id, infra_port_id, opts)
      data
    end

    # List Infra Port Discovery Profile Binding Maps
    # API will list all Infra Port Discovery Profile Binding Maps in current port id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param infra_segment_id 
    # @param infra_port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortDiscoveryProfileBindingMapListResult, Fixnum, Hash)>] PortDiscoveryProfileBindingMapListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_infra_port_discovery_bindings_with_http_info(org_id, project_id, infra_segment_id, infra_port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_port_discovery_bindings ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_port_discovery_bindings"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_port_discovery_bindings"
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_port_discovery_bindings"
      end
      # verify the required parameter 'infra_port_id' is set
      if @api_client.config.client_side_validation && infra_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_port_discovery_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_port_discovery_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_port_discovery_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{infra-segment-id}/ports/{infra-port-id}/port-discovery-profile-binding-maps'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'infra-port-id' + '}', infra_port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortDiscoveryProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_infra_port_discovery_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Port QoS Profile Binding Maps
    # API will list all Port QoS Profile Binding Maps in current port id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortQoSProfileBindingMapListResult]
    def orgs_org_id_projects_project_id_infra_list_infra_port_qo_s_bindings(org_id, project_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_infra_port_qo_s_bindings_with_http_info(org_id, project_id, segment_id, port_id, opts)
      data
    end

    # List Port QoS Profile Binding Maps
    # API will list all Port QoS Profile Binding Maps in current port id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortQoSProfileBindingMapListResult, Fixnum, Hash)>] PortQoSProfileBindingMapListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_infra_port_qo_s_bindings_with_http_info(org_id, project_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_port_qo_s_bindings ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_port_qo_s_bindings"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_port_qo_s_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_port_qo_s_bindings"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_port_qo_s_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_port_qo_s_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_port_qo_s_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortQoSProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_infra_port_qo_s_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Port Real Time Eth Profile Binding Maps
    # API will list all Port Real Time Eth Profile Binding Maps in current port id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortRealTimeEthProfileBindingMapListResult]
    def orgs_org_id_projects_project_id_infra_list_infra_port_real_time_eth_bindings(org_id, project_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_infra_port_real_time_eth_bindings_with_http_info(org_id, project_id, segment_id, port_id, opts)
      data
    end

    # List Port Real Time Eth Profile Binding Maps
    # API will list all Port Real Time Eth Profile Binding Maps in current port id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortRealTimeEthProfileBindingMapListResult, Fixnum, Hash)>] PortRealTimeEthProfileBindingMapListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_infra_port_real_time_eth_bindings_with_http_info(org_id, project_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_port_real_time_eth_bindings ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_port_real_time_eth_bindings"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_port_real_time_eth_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_port_real_time_eth_bindings"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_port_real_time_eth_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_port_real_time_eth_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_port_real_time_eth_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}/port-real-time-eth-profile-binding-maps'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortRealTimeEthProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_infra_port_real_time_eth_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List SegmentConnectionBindingMap specific Segment
    # List SegmentConnectionBindingMap specific Segment 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentConnectionBindingMapListResult]
    def orgs_org_id_projects_project_id_infra_list_infra_segment_connection_binding_map(org_id, project_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_infra_segment_connection_binding_map_with_http_info(org_id, project_id, segment_id, opts)
      data
    end

    # List SegmentConnectionBindingMap specific Segment
    # List SegmentConnectionBindingMap specific Segment 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentConnectionBindingMapListResult, Fixnum, Hash)>] SegmentConnectionBindingMapListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_infra_segment_connection_binding_map_with_http_info(org_id, project_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_connection_binding_map ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_connection_binding_map"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_connection_binding_map, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_connection_binding_map, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/segment-connection-binding-maps'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConnectionBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_infra_segment_connection_binding_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Infra Segment Discovery Profile Binding Maps
    # API will list all Infra Segment Discovery Profile Binding Maps in current segment id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param infra_segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentDiscoveryProfileBindingMapListResult]
    def orgs_org_id_projects_project_id_infra_list_infra_segment_discovery_bindings(org_id, project_id, infra_segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_infra_segment_discovery_bindings_with_http_info(org_id, project_id, infra_segment_id, opts)
      data
    end

    # List Infra Segment Discovery Profile Binding Maps
    # API will list all Infra Segment Discovery Profile Binding Maps in current segment id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param infra_segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentDiscoveryProfileBindingMapListResult, Fixnum, Hash)>] SegmentDiscoveryProfileBindingMapListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_infra_segment_discovery_bindings_with_http_info(org_id, project_id, infra_segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_discovery_bindings ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_discovery_bindings"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_discovery_bindings"
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_discovery_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_discovery_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_discovery_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{infra-segment-id}/segment-discovery-profile-binding-maps'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentDiscoveryProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_infra_segment_discovery_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all effective profiles for infra segment
    # List all effective profiles for this segment on given enforcement point.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [EffectiveProfilesResponse]
    def orgs_org_id_projects_project_id_infra_list_infra_segment_effective_profiles(org_id, project_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_infra_segment_effective_profiles_with_http_info(org_id, project_id, segment_id, opts)
      data
    end

    # List all effective profiles for infra segment
    # List all effective profiles for this segment on given enforcement point.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [Array<(EffectiveProfilesResponse, Fixnum, Hash)>] EffectiveProfilesResponse data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_infra_segment_effective_profiles_with_http_info(org_id, project_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_effective_profiles ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_effective_profiles"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_effective_profiles"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_effective_profiles"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/effective-profiles'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EffectiveProfilesResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_infra_segment_effective_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all effective profiles for infra segment
    # List all effective profiles for this segment on given enforcement point.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [EffectiveProfilesResponse]
    def orgs_org_id_projects_project_id_infra_list_infra_segment_effective_profiles_0(org_id, project_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_infra_segment_effective_profiles_0_with_http_info(org_id, project_id, segment_id, opts)
      data
    end

    # List all effective profiles for infra segment
    # List all effective profiles for this segment on given enforcement point.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [Array<(EffectiveProfilesResponse, Fixnum, Hash)>] EffectiveProfilesResponse data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_infra_segment_effective_profiles_0_with_http_info(org_id, project_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_effective_profiles_0 ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_effective_profiles_0"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_effective_profiles_0"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_effective_profiles_0"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/effective-profiles'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EffectiveProfilesResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_infra_segment_effective_profiles_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List infra segment port security profile binding maps
    # API will list all port security profile binding maps. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id segment id
    # @param port_id port id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortSecurityProfileBindingMapListResult]
    def orgs_org_id_projects_project_id_infra_list_infra_segment_port_security_profile_bindings(org_id, project_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_infra_segment_port_security_profile_bindings_with_http_info(org_id, project_id, segment_id, port_id, opts)
      data
    end

    # List infra segment port security profile binding maps
    # API will list all port security profile binding maps. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id segment id
    # @param port_id port id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortSecurityProfileBindingMapListResult, Fixnum, Hash)>] PortSecurityProfileBindingMapListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_infra_segment_port_security_profile_bindings_with_http_info(org_id, project_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_port_security_profile_bindings ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_port_security_profile_bindings"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_port_security_profile_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_port_security_profile_bindings"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_port_security_profile_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_port_security_profile_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_port_security_profile_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortSecurityProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_infra_segment_port_security_profile_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List infra segment ports
    # List all the ports for an infra. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentPortListResult]
    def orgs_org_id_projects_project_id_infra_list_infra_segment_ports(org_id, project_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_infra_segment_ports_with_http_info(org_id, project_id, segment_id, opts)
      data
    end

    # List infra segment ports
    # List all the ports for an infra. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentPortListResult, Fixnum, Hash)>] SegmentPortListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_infra_segment_ports_with_http_info(org_id, project_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_ports ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_ports"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_ports"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_ports"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_ports, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_ports, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_infra_segment_ports\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all effective profiles for infra segment port
    # List all effective profiles for this segment port on given enforcement point.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [EffectiveProfilesResponse]
    def orgs_org_id_projects_project_id_infra_list_infra_segment_ports_effective_profiles(org_id, project_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_infra_segment_ports_effective_profiles_with_http_info(org_id, project_id, segment_id, port_id, opts)
      data
    end

    # List all effective profiles for infra segment port
    # List all effective profiles for this segment port on given enforcement point.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [Array<(EffectiveProfilesResponse, Fixnum, Hash)>] EffectiveProfilesResponse data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_infra_segment_ports_effective_profiles_with_http_info(org_id, project_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_ports_effective_profiles ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_ports_effective_profiles"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_ports_effective_profiles"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_ports_effective_profiles"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_ports_effective_profiles"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}/effective-profiles'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EffectiveProfilesResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_infra_segment_ports_effective_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Segment QoS Profile Binding Maps
    # API will list all Segment QoS Profile Binding Maps in current segment id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentQoSProfileBindingMapListResult]
    def orgs_org_id_projects_project_id_infra_list_infra_segment_qo_s_bindings(org_id, project_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_infra_segment_qo_s_bindings_with_http_info(org_id, project_id, segment_id, opts)
      data
    end

    # List Segment QoS Profile Binding Maps
    # API will list all Segment QoS Profile Binding Maps in current segment id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentQoSProfileBindingMapListResult, Fixnum, Hash)>] SegmentQoSProfileBindingMapListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_infra_segment_qo_s_bindings_with_http_info(org_id, project_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_qo_s_bindings ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_qo_s_bindings"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_qo_s_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_qo_s_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_qo_s_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_qo_s_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/segment-qos-profile-binding-maps'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentQoSProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_infra_segment_qo_s_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Segment Real Time Eth Profile Binding Maps
    # API will list all Segment Real Time Eth Profile Binding Maps in current segment id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentRealTimeEthProfileBindingMapListResult]
    def orgs_org_id_projects_project_id_infra_list_infra_segment_real_time_eth_bindings(org_id, project_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_infra_segment_real_time_eth_bindings_with_http_info(org_id, project_id, segment_id, opts)
      data
    end

    # List Segment Real Time Eth Profile Binding Maps
    # API will list all Segment Real Time Eth Profile Binding Maps in current segment id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentRealTimeEthProfileBindingMapListResult, Fixnum, Hash)>] SegmentRealTimeEthProfileBindingMapListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_infra_segment_real_time_eth_bindings_with_http_info(org_id, project_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_real_time_eth_bindings ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_real_time_eth_bindings"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_real_time_eth_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_real_time_eth_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_real_time_eth_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_real_time_eth_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/segment-real-time-eth-profile-binding-maps'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentRealTimeEthProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_infra_segment_real_time_eth_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List infra segment security profile binding maps
    # API will list all segment security profile binding maps. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id segment id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentSecurityProfileBindingMapListResult]
    def orgs_org_id_projects_project_id_infra_list_infra_segment_security_profile_bindings(org_id, project_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_infra_segment_security_profile_bindings_with_http_info(org_id, project_id, segment_id, opts)
      data
    end

    # List infra segment security profile binding maps
    # API will list all segment security profile binding maps. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id segment id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentSecurityProfileBindingMapListResult, Fixnum, Hash)>] SegmentSecurityProfileBindingMapListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_infra_segment_security_profile_bindings_with_http_info(org_id, project_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_security_profile_bindings ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_security_profile_bindings"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_security_profile_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_security_profile_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_security_profile_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_infra_segment_security_profile_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/segment-security-profile-binding-maps'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_infra_segment_security_profile_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Port Discovery Profile Binding Maps
    # API will list all Port Discovery Profile Binding Maps in current port id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortDiscoveryProfileBindingMapListResult]
    def orgs_org_id_projects_project_id_infra_list_port_discovery_bindings(org_id, project_id, tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_port_discovery_bindings_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, opts)
      data
    end

    # List Port Discovery Profile Binding Maps
    # API will list all Port Discovery Profile Binding Maps in current port id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortDiscoveryProfileBindingMapListResult, Fixnum, Hash)>] PortDiscoveryProfileBindingMapListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_port_discovery_bindings_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_discovery_bindings ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_discovery_bindings"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_discovery_bindings"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_discovery_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_discovery_bindings"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_discovery_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_discovery_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_discovery_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-discovery-profile-binding-maps'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortDiscoveryProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_port_discovery_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Port QoS Profile Binding Maps
    # API will list all Port QoS Profile Binding Maps in current port id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortQoSProfileBindingMapListResult]
    def orgs_org_id_projects_project_id_infra_list_port_qo_s_bindings(org_id, project_id, tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_port_qo_s_bindings_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, opts)
      data
    end

    # List Port QoS Profile Binding Maps
    # API will list all Port QoS Profile Binding Maps in current port id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortQoSProfileBindingMapListResult, Fixnum, Hash)>] PortQoSProfileBindingMapListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_port_qo_s_bindings_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_qo_s_bindings ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_qo_s_bindings"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_qo_s_bindings"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_qo_s_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_qo_s_bindings"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_qo_s_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_qo_s_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_qo_s_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortQoSProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_port_qo_s_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List port security profile binding maps
    # API will list all port security profile binding maps. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [PortSecurityProfileBindingMapListResult]
    def orgs_org_id_projects_project_id_infra_list_port_security_profile_bindings(org_id, project_id, tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_port_security_profile_bindings_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, opts)
      data
    end

    # List port security profile binding maps
    # API will list all port security profile binding maps. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(PortSecurityProfileBindingMapListResult, Fixnum, Hash)>] PortSecurityProfileBindingMapListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_port_security_profile_bindings_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_security_profile_bindings ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_security_profile_bindings"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_security_profile_bindings"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_security_profile_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_security_profile_bindings"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_security_profile_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_security_profile_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_port_security_profile_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortSecurityProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_port_security_profile_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List QoS Profiles
    # API will list all QoS profiles. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [QoSProfileListResult]
    def orgs_org_id_projects_project_id_infra_list_qo_s_profiles(org_id, project_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_qo_s_profiles_with_http_info(org_id, project_id, opts)
      data
    end

    # List QoS Profiles
    # API will list all QoS profiles. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(QoSProfileListResult, Fixnum, Hash)>] QoSProfileListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_qo_s_profiles_with_http_info(org_id, project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_qo_s_profiles ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_qo_s_profiles"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_qo_s_profiles"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_qo_s_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_qo_s_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/qos-profiles'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'QoSProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_qo_s_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Real Time Eth Profiles
    # API will list all Real Time Eth profiles. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [RealTimeEthProfileListResult]
    def orgs_org_id_projects_project_id_infra_list_real_time_eth_profiles(org_id, project_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_real_time_eth_profiles_with_http_info(org_id, project_id, opts)
      data
    end

    # List Real Time Eth Profiles
    # API will list all Real Time Eth profiles. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(RealTimeEthProfileListResult, Fixnum, Hash)>] RealTimeEthProfileListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_real_time_eth_profiles_with_http_info(org_id, project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_real_time_eth_profiles ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_real_time_eth_profiles"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_real_time_eth_profiles"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_real_time_eth_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_real_time_eth_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/real-time-eth-profiles'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RealTimeEthProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_real_time_eth_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Segment Discovery Profile Binding Maps
    # API will list all Segment Discovery Profile Binding Maps in current segment id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentDiscoveryProfileBindingMapListResult]
    def orgs_org_id_projects_project_id_infra_list_segment_discovery_bindings(org_id, project_id, tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_segment_discovery_bindings_with_http_info(org_id, project_id, tier_1_id, segment_id, opts)
      data
    end

    # List Segment Discovery Profile Binding Maps
    # API will list all Segment Discovery Profile Binding Maps in current segment id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentDiscoveryProfileBindingMapListResult, Fixnum, Hash)>] SegmentDiscoveryProfileBindingMapListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_segment_discovery_bindings_with_http_info(org_id, project_id, tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_discovery_bindings ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_discovery_bindings"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_discovery_bindings"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_discovery_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_discovery_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_discovery_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_discovery_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-discovery-profile-binding-maps'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentDiscoveryProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_segment_discovery_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all effective profiles for segment
    # List all effective profiles for this segment on given enforcement point.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [EffectiveProfilesResponse]
    def orgs_org_id_projects_project_id_infra_list_segment_effective_profiles(org_id, project_id, tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_segment_effective_profiles_with_http_info(org_id, project_id, tier_1_id, segment_id, opts)
      data
    end

    # List all effective profiles for segment
    # List all effective profiles for this segment on given enforcement point.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [Array<(EffectiveProfilesResponse, Fixnum, Hash)>] EffectiveProfilesResponse data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_segment_effective_profiles_with_http_info(org_id, project_id, tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_effective_profiles ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_effective_profiles"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_effective_profiles"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_effective_profiles"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_effective_profiles"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/effective-profiles'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EffectiveProfilesResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_segment_effective_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Segment QoS Profile Binding Maps
    # API will list all Segment QoS Profile Binding Maps in current segment id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentQoSProfileBindingMapListResult]
    def orgs_org_id_projects_project_id_infra_list_segment_qo_s_bindings(org_id, project_id, tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_segment_qo_s_bindings_with_http_info(org_id, project_id, tier_1_id, segment_id, opts)
      data
    end

    # List Segment QoS Profile Binding Maps
    # API will list all Segment QoS Profile Binding Maps in current segment id. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentQoSProfileBindingMapListResult, Fixnum, Hash)>] SegmentQoSProfileBindingMapListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_segment_qo_s_bindings_with_http_info(org_id, project_id, tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_qo_s_bindings ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_qo_s_bindings"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_qo_s_bindings"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_qo_s_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_qo_s_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_qo_s_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_qo_s_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-qos-profile-binding-maps'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentQoSProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_segment_qo_s_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List segment security profile binding maps
    # API will list all segment security profile binding maps. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentSecurityProfileBindingMapListResult]
    def orgs_org_id_projects_project_id_infra_list_segment_security_profile_bindings(org_id, project_id, tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_segment_security_profile_bindings_with_http_info(org_id, project_id, tier_1_id, segment_id, opts)
      data
    end

    # List segment security profile binding maps
    # API will list all segment security profile binding maps. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentSecurityProfileBindingMapListResult, Fixnum, Hash)>] SegmentSecurityProfileBindingMapListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_segment_security_profile_bindings_with_http_info(org_id, project_id, tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_security_profile_bindings ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_security_profile_bindings"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_security_profile_bindings"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_security_profile_bindings"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_security_profile_bindings"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_security_profile_bindings, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_security_profile_bindings, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-security-profile-binding-maps'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfileBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_segment_security_profile_bindings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List segment security profiles
    # API will list all segment security profiles. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentSecurityProfileListResult]
    def orgs_org_id_projects_project_id_infra_list_segment_security_profiles(org_id, project_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_segment_security_profiles_with_http_info(org_id, project_id, opts)
      data
    end

    # List segment security profiles
    # API will list all segment security profiles. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentSecurityProfileListResult, Fixnum, Hash)>] SegmentSecurityProfileListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_segment_security_profiles_with_http_info(org_id, project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_security_profiles ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_security_profiles"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_security_profiles"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_security_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segment_security_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segment-security-profiles'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentSecurityProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_segment_security_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Paginated list of all fixed segments (identified as /policy/api/v1/infra/tier-1s/<tier-1-id>/segments/<segment-id>) under Tier-1 instance.
    # Paginated list of all fixed segments (identified as /policy/api/v1/infra/tier-1s/<tier-1-id>/segments/<segment-id>) under Tier-1 instance. This API call does not return flexible segments (identified as /policy/api/v1/infra/segments/<segment-id>) connected to the Tier-1. To return all segments connected as a downlink to a Tier-1 one possibility is to use the search API with: https://{{nsx-mgr}}/policy/api/v1/search?query=resource_type:Segment%20AND%20connectivity_path:/infra/tier-1s/<tier-1> Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \"l2_extension\" object in the PUT/PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [String] :segment_type Segment type
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentListResult]
    def orgs_org_id_projects_project_id_infra_list_segments(org_id, project_id, tier_1_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_segments_with_http_info(org_id, project_id, tier_1_id, opts)
      data
    end

    # Paginated list of all fixed segments (identified as /policy/api/v1/infra/tier-1s/&lt;tier-1-id&gt;/segments/&lt;segment-id&gt;) under Tier-1 instance.
    # Paginated list of all fixed segments (identified as /policy/api/v1/infra/tier-1s/&lt;tier-1-id&gt;/segments/&lt;segment-id&gt;) under Tier-1 instance. This API call does not return flexible segments (identified as /policy/api/v1/infra/segments/&lt;segment-id&gt;) connected to the Tier-1. To return all segments connected as a downlink to a Tier-1 one possibility is to use the search API with: https://{{nsx-mgr}}/policy/api/v1/search?query&#x3D;resource_type:Segment%20AND%20connectivity_path:/infra/tier-1s/&lt;tier-1&gt; Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \&quot;l2_extension\&quot; object in the PUT/PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [String] :segment_type Segment type
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentListResult, Fixnum, Hash)>] SegmentListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_segments_with_http_info(org_id, project_id, tier_1_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_segments ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segments"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segments"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segments"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segments, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_segments, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && opts[:'segment_type'] && !['DVPortgroup', 'ALL'].include?(opts[:'segment_type'])
        fail ArgumentError, 'invalid value for "segment_type", must be one of DVPortgroup, ALL'
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'segment_type'] = opts[:'segment_type'] if !opts[:'segment_type'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_segments\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List SpoofGuard profiles
    # API will list all SpoofGuard profiles. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SpoofGuardProfileListResult]
    def orgs_org_id_projects_project_id_infra_list_spoof_guard_profiles(org_id, project_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_spoof_guard_profiles_with_http_info(org_id, project_id, opts)
      data
    end

    # List SpoofGuard profiles
    # API will list all SpoofGuard profiles. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SpoofGuardProfileListResult, Fixnum, Hash)>] SpoofGuardProfileListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_spoof_guard_profiles_with_http_info(org_id, project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_spoof_guard_profiles ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_spoof_guard_profiles"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_spoof_guard_profiles"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_spoof_guard_profiles, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_spoof_guard_profiles, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/spoofguard-profiles'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SpoofGuardProfileListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_spoof_guard_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List SegmentConnectionBindingMap specific Segment
    # List SegmentConnectionBindingMap specific Segment 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentConnectionBindingMapListResult]
    def orgs_org_id_projects_project_id_infra_list_tier1_segment_connection_binding_map(org_id, project_id, tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_tier1_segment_connection_binding_map_with_http_info(org_id, project_id, tier_1_id, segment_id, opts)
      data
    end

    # List SegmentConnectionBindingMap specific Segment
    # List SegmentConnectionBindingMap specific Segment 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentConnectionBindingMapListResult, Fixnum, Hash)>] SegmentConnectionBindingMapListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_tier1_segment_connection_binding_map_with_http_info(org_id, project_id, tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_tier1_segment_connection_binding_map ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_tier1_segment_connection_binding_map"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_tier1_segment_connection_binding_map, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_tier1_segment_connection_binding_map, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-connection-binding-maps'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConnectionBindingMapListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_tier1_segment_connection_binding_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List Tier-1 segment ports
    # List all the ports for a Tier-1 segment. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results (default to false)
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer) (default to 1000)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [SegmentPortListResult]
    def orgs_org_id_projects_project_id_infra_list_tier1_segment_ports(org_id, project_id, tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_tier1_segment_ports_with_http_info(org_id, project_id, tier_1_id, segment_id, opts)
      data
    end

    # List Tier-1 segment ports
    # List all the ports for a Tier-1 segment. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor Opaque cursor to be used for getting next page of records (supplied by current result page)
    # @option opts [BOOLEAN] :include_mark_for_delete_objects Include objects that are marked for deletion in results
    # @option opts [String] :included_fields Comma separated list of fields that should be included in query result
    # @option opts [Integer] :page_size Maximum number of results to return in this page (server may return fewer)
    # @option opts [BOOLEAN] :sort_ascending 
    # @option opts [String] :sort_by Field by which records are sorted
    # @return [Array<(SegmentPortListResult, Fixnum, Hash)>] SegmentPortListResult data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_tier1_segment_ports_with_http_info(org_id, project_id, tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_tier1_segment_ports ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_tier1_segment_ports"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_tier1_segment_ports"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_tier1_segment_ports"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_tier1_segment_ports"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_tier1_segment_ports, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_tier1_segment_ports, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'include_mark_for_delete_objects'] = opts[:'include_mark_for_delete_objects'] if !opts[:'include_mark_for_delete_objects'].nil?
      query_params[:'included_fields'] = opts[:'included_fields'] if !opts[:'included_fields'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'sort_ascending'] = opts[:'sort_ascending'] if !opts[:'sort_ascending'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentPortListResult')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_tier1_segment_ports\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # List all effective profiles for tier-1 segment port
    # List all effective profiles for this segment port on given enforcement point.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [EffectiveProfilesResponse]
    def orgs_org_id_projects_project_id_infra_list_tier1_segment_ports_effective_profiles(org_id, project_id, tier_1_id, segment_id, port_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_list_tier1_segment_ports_effective_profiles_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, opts)
      data
    end

    # List all effective profiles for tier-1 segment port
    # List all effective profiles for this segment port on given enforcement point.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path Enforcement point path
    # @return [Array<(EffectiveProfilesResponse, Fixnum, Hash)>] EffectiveProfilesResponse data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_list_tier1_segment_ports_effective_profiles_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_list_tier1_segment_ports_effective_profiles ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_tier1_segment_ports_effective_profiles"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_tier1_segment_ports_effective_profiles"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_tier1_segment_ports_effective_profiles"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_tier1_segment_ports_effective_profiles"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_list_tier1_segment_ports_effective_profiles"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/effective-profiles'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'EffectiveProfilesResponse')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_list_tier1_segment_ports_effective_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update Group discovery profile binding map
    # API will create or update Group discovery profile binding map
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param discovery_profile_binding_map_id Group discovery profile binding map ID
    # @param group_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_group_discovery_profile_binding(org_id, project_id, domain_id, group_id, discovery_profile_binding_map_id, group_discovery_profile_binding_map, opts = {})
      orgs_org_id_projects_project_id_infra_patch_group_discovery_profile_binding_with_http_info(org_id, project_id, domain_id, group_id, discovery_profile_binding_map_id, group_discovery_profile_binding_map, opts)
      nil
    end

    # Create or update Group discovery profile binding map
    # API will create or update Group discovery profile binding map
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param discovery_profile_binding_map_id Group discovery profile binding map ID
    # @param group_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_group_discovery_profile_binding_with_http_info(org_id, project_id, domain_id, group_id, discovery_profile_binding_map_id, group_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_group_discovery_profile_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_group_discovery_profile_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_group_discovery_profile_binding"
      end
      # verify the required parameter 'domain_id' is set
      if @api_client.config.client_side_validation && domain_id.nil?
        fail ArgumentError, "Missing the required parameter 'domain_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_group_discovery_profile_binding"
      end
      # verify the required parameter 'group_id' is set
      if @api_client.config.client_side_validation && group_id.nil?
        fail ArgumentError, "Missing the required parameter 'group_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_group_discovery_profile_binding"
      end
      # verify the required parameter 'discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'discovery_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_group_discovery_profile_binding"
      end
      # verify the required parameter 'group_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && group_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'group_discovery_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_group_discovery_profile_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/domains/{domain-id}/groups/{group-id}/discovery-profile-binding-maps/{discovery-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'domain-id' + '}', domain_id.to_s).sub('{' + 'group-id' + '}', group_id.to_s).sub('{' + 'discovery-profile-binding-map-id' + '}', discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(group_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_group_discovery_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Infra Port Discovery Profile Binding Map
    # API will create Infra Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_infra_port_discovery_binding(org_id, project_id, infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      orgs_org_id_projects_project_id_infra_patch_infra_port_discovery_binding_with_http_info(org_id, project_id, infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts)
      nil
    end

    # Create Infra Port Discovery Profile Binding Map
    # API will create Infra Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_infra_port_discovery_binding_with_http_info(org_id, project_id, infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_port_discovery_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_port_discovery_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_port_discovery_binding"
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_port_discovery_binding"
      end
      # verify the required parameter 'infra_port_id' is set
      if @api_client.config.client_side_validation && infra_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_port_discovery_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{infra-segment-id}/ports/{infra-port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'infra-port-id' + '}', infra_port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_infra_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Port QoS Profile Binding Map
    # API will create Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_infra_port_qo_s_binding(org_id, project_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      orgs_org_id_projects_project_id_infra_patch_infra_port_qo_s_binding_with_http_info(org_id, project_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts)
      nil
    end

    # Create Port QoS Profile Binding Map
    # API will create Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_infra_port_qo_s_binding_with_http_info(org_id, project_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_port_qo_s_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_port_qo_s_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_port_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_qo_s_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_qo_s_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_qo_s_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_qo_s_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_infra_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Port Real Time Eth Profile Binding Map
    # API will create Port Real Time Eth Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_real_time_eth_profile_binding_map_id Port Real Time Eth Profile Binding Map ID
    # @param port_real_time_eth_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_infra_port_real_time_eth_binding(org_id, project_id, segment_id, port_id, port_real_time_eth_profile_binding_map_id, port_real_time_eth_profile_binding_map, opts = {})
      orgs_org_id_projects_project_id_infra_patch_infra_port_real_time_eth_binding_with_http_info(org_id, project_id, segment_id, port_id, port_real_time_eth_profile_binding_map_id, port_real_time_eth_profile_binding_map, opts)
      nil
    end

    # Create Port Real Time Eth Profile Binding Map
    # API will create Port Real Time Eth Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_real_time_eth_profile_binding_map_id Port Real Time Eth Profile Binding Map ID
    # @param port_real_time_eth_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_infra_port_real_time_eth_binding_with_http_info(org_id, project_id, segment_id, port_id, port_real_time_eth_profile_binding_map_id, port_real_time_eth_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_port_real_time_eth_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'port_real_time_eth_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_real_time_eth_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_real_time_eth_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'port_real_time_eth_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_real_time_eth_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_real_time_eth_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_port_real_time_eth_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}/port-real-time-eth-profile-binding-maps/{port-real-time-eth-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-real-time-eth-profile-binding-map-id' + '}', port_real_time_eth_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_real_time_eth_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_infra_port_real_time_eth_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, update the segment with specified attributes. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_infra_segment(org_id, project_id, segment_id, segment, opts = {})
      orgs_org_id_projects_project_id_infra_patch_infra_segment_with_http_info(org_id, project_id, segment_id, segment, opts)
      nil
    end

    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, update the segment with specified attributes. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_infra_segment_with_http_info(org_id, project_id, segment_id, segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment"
      end
      # verify the required parameter 'segment' is set
      if @api_client.config.client_side_validation && segment.nil?
        fail ArgumentError, "Missing the required parameter 'segment' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_infra_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, update the segment with specified attributes. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_infra_segment_0(org_id, project_id, segment_id, segment, opts = {})
      orgs_org_id_projects_project_id_infra_patch_infra_segment_0_with_http_info(org_id, project_id, segment_id, segment, opts)
      nil
    end

    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, update the segment with specified attributes. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_infra_segment_0_with_http_info(org_id, project_id, segment_id, segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_0 ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_0"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_0"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_0"
      end
      # verify the required parameter 'segment' is set
      if @api_client.config.client_side_validation && segment.nil?
        fail ArgumentError, "Missing the required parameter 'segment' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_0"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_infra_segment_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch a infra segment connection binding map
    # Patch the infra segment connection binding map. If binding map corresponding to the the given values is not present, the object will get created and if it is present it will be updated. This is a full replace. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param map_id 
    # @param segment_connection_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_infra_segment_connection_binding_map(org_id, project_id, segment_id, map_id, segment_connection_binding_map, opts = {})
      orgs_org_id_projects_project_id_infra_patch_infra_segment_connection_binding_map_with_http_info(org_id, project_id, segment_id, map_id, segment_connection_binding_map, opts)
      nil
    end

    # Patch a infra segment connection binding map
    # Patch the infra segment connection binding map. If binding map corresponding to the the given values is not present, the object will get created and if it is present it will be updated. This is a full replace. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param map_id 
    # @param segment_connection_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_infra_segment_connection_binding_map_with_http_info(org_id, project_id, segment_id, map_id, segment_connection_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_connection_binding_map ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'map_id' is set
      if @api_client.config.client_side_validation && map_id.nil?
        fail ArgumentError, "Missing the required parameter 'map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_connection_binding_map' is set
      if @api_client.config.client_side_validation && segment_connection_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_connection_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_connection_binding_map"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/segment-connection-binding-maps/{map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'map-id' + '}', map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_connection_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_infra_segment_connection_binding_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Infra Segment Discovery Profile Binding Map
    # API will create Infra Segment Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param infra_segment_id Infra Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param segment_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_infra_segment_discovery_binding(org_id, project_id, infra_segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts = {})
      orgs_org_id_projects_project_id_infra_patch_infra_segment_discovery_binding_with_http_info(org_id, project_id, infra_segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts)
      nil
    end

    # Create Infra Segment Discovery Profile Binding Map
    # API will create Infra Segment Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param infra_segment_id Infra Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param segment_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_infra_segment_discovery_binding_with_http_info(org_id, project_id, infra_segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_discovery_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_discovery_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_discovery_binding"
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_discovery_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{infra-segment-id}/segment-discovery-profile-binding-maps/{segment-discovery-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'segment-discovery-profile-binding-map-id' + '}', segment_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_infra_segment_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch an infra segment port
    # Create an infra segment port if it does not exist based on the IDs, or update existing port information by replacing the port object fields which presents in the request body. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_infra_segment_port(org_id, project_id, segment_id, port_id, segment_port, opts = {})
      orgs_org_id_projects_project_id_infra_patch_infra_segment_port_with_http_info(org_id, project_id, segment_id, port_id, segment_port, opts)
      nil
    end

    # Patch an infra segment port
    # Create an infra segment port if it does not exist based on the IDs, or update existing port information by replacing the port object fields which presents in the request body. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_infra_segment_port_with_http_info(org_id, project_id, segment_id, port_id, segment_port, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_port ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_port"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_port"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_port"
      end
      # verify the required parameter 'segment_port' is set
      if @api_client.config.client_side_validation && segment_port.nil?
        fail ArgumentError, "Missing the required parameter 'segment_port' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_port"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_port)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_infra_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch infra segment port security profile binding map
    # Create a new port security profile binding map if the given security profile binding map does not exist. Otherwise, patch the existing port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_infra_segment_port_security_profile_binding(org_id, project_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      orgs_org_id_projects_project_id_infra_patch_infra_segment_port_security_profile_binding_with_http_info(org_id, project_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts)
      nil
    end

    # Patch infra segment port security profile binding map
    # Create a new port security profile binding map if the given security profile binding map does not exist. Otherwise, patch the existing port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_infra_segment_port_security_profile_binding_with_http_info(org_id, project_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_port_security_profile_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_security_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_infra_segment_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Segment QoS Profile Binding Map
    # API will create segment QoS profile binding map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param segment_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_infra_segment_qo_s_binding(org_id, project_id, segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts = {})
      orgs_org_id_projects_project_id_infra_patch_infra_segment_qo_s_binding_with_http_info(org_id, project_id, segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts)
      nil
    end

    # Create Segment QoS Profile Binding Map
    # API will create segment QoS profile binding map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param segment_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_infra_segment_qo_s_binding_with_http_info(org_id, project_id, segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_qo_s_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_qo_s_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qos_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qo_s_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_qo_s_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qo_s_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_qo_s_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/segment-qos-profile-binding-maps/{segment-qos-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-qos-profile-binding-map-id' + '}', segment_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_qo_s_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_infra_segment_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Segment Real Time Eth Profile Binding Map
    # API will create Segment Real Time Eth profile binding map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment_real_time_eth_profile_binding_map_id Segment Real Time Eth Profile Binding Map ID
    # @param segment_real_time_eth_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_infra_segment_real_time_eth_binding(org_id, project_id, segment_id, segment_real_time_eth_profile_binding_map_id, segment_real_time_eth_profile_binding_map, opts = {})
      orgs_org_id_projects_project_id_infra_patch_infra_segment_real_time_eth_binding_with_http_info(org_id, project_id, segment_id, segment_real_time_eth_profile_binding_map_id, segment_real_time_eth_profile_binding_map, opts)
      nil
    end

    # Create Segment Real Time Eth Profile Binding Map
    # API will create Segment Real Time Eth profile binding map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment_real_time_eth_profile_binding_map_id Segment Real Time Eth Profile Binding Map ID
    # @param segment_real_time_eth_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_infra_segment_real_time_eth_binding_with_http_info(org_id, project_id, segment_id, segment_real_time_eth_profile_binding_map_id, segment_real_time_eth_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_real_time_eth_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_real_time_eth_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_real_time_eth_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_real_time_eth_binding"
      end
      # verify the required parameter 'segment_real_time_eth_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_real_time_eth_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_real_time_eth_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_real_time_eth_binding"
      end
      # verify the required parameter 'segment_real_time_eth_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_real_time_eth_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_real_time_eth_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_real_time_eth_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/segment-real-time-eth-profile-binding-maps/{segment-real-time-eth-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-real-time-eth-profile-binding-map-id' + '}', segment_real_time_eth_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_real_time_eth_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_infra_segment_real_time_eth_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch infra segment security profile binding map
    # Create a new segment security profile binding map if the given security profile binding map does not exist. Otherwise, patch the existing segment security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param segment_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_infra_segment_security_profile_binding(org_id, project_id, segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts = {})
      orgs_org_id_projects_project_id_infra_patch_infra_segment_security_profile_binding_with_http_info(org_id, project_id, segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts)
      nil
    end

    # Patch infra segment security profile binding map
    # Create a new segment security profile binding map if the given security profile binding map does not exist. Otherwise, patch the existing segment security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param segment_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_infra_segment_security_profile_binding_with_http_info(org_id, project_id, segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_security_profile_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_security_profile_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_security_profile_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/segment-security-profile-binding-maps/{segment-security-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-security-profile-binding-map-id' + '}', segment_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_security_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_infra_segment_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, update the segment with specified attributes.  Force parameter is required when workload connectivity is indirectly impacted with the current update. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_infra_segment_with_force(org_id, project_id, segment_id, segment, opts = {})
      orgs_org_id_projects_project_id_infra_patch_infra_segment_with_force_with_http_info(org_id, project_id, segment_id, segment, opts)
      nil
    end

    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, update the segment with specified attributes.  Force parameter is required when workload connectivity is indirectly impacted with the current update. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_infra_segment_with_force_with_http_info(org_id, project_id, segment_id, segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_with_force ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_with_force"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_with_force"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_with_force"
      end
      # verify the required parameter 'segment' is set
      if @api_client.config.client_side_validation && segment.nil?
        fail ArgumentError, "Missing the required parameter 'segment' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_with_force"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}?force=true'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_infra_segment_with_force\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, update the segment with specified attributes.  Force parameter is required when workload connectivity is indirectly impacted with the current update. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_infra_segment_with_force_0(org_id, project_id, segment_id, segment, opts = {})
      orgs_org_id_projects_project_id_infra_patch_infra_segment_with_force_0_with_http_info(org_id, project_id, segment_id, segment, opts)
      nil
    end

    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, update the segment with specified attributes.  Force parameter is required when workload connectivity is indirectly impacted with the current update. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_infra_segment_with_force_0_with_http_info(org_id, project_id, segment_id, segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_with_force_0 ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_with_force_0"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_with_force_0"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_with_force_0"
      end
      # verify the required parameter 'segment' is set
      if @api_client.config.client_side_validation && segment.nil?
        fail ArgumentError, "Missing the required parameter 'segment' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_infra_segment_with_force_0"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}?force=true'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_infra_segment_with_force_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Port Discovery Profile Binding Map
    # API will create Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_port_discovery_binding(org_id, project_id, tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      orgs_org_id_projects_project_id_infra_patch_port_discovery_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts)
      nil
    end

    # Create Port Discovery Profile Binding Map
    # API will create Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_port_discovery_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_discovery_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_discovery_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_discovery_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_discovery_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_discovery_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_discovery_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Port QoS Profile Binding Map
    # API will create Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_port_qo_s_binding(org_id, project_id, tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      orgs_org_id_projects_project_id_infra_patch_port_qo_s_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts)
      nil
    end

    # Create Port QoS Profile Binding Map
    # API will create Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_port_qo_s_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_qo_s_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_qo_s_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_qo_s_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_qo_s_binding"
      end
      # verify the required parameter 'port_qo_s_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_qo_s_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_qo_s_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_qo_s_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch port security profile binding map
    # Create a new port security profile binding map if the given security profile binding map does not exist. Otherwise, patch the existing port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_port_security_profile_binding(org_id, project_id, tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      orgs_org_id_projects_project_id_infra_patch_port_security_profile_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts)
      nil
    end

    # Patch port security profile binding map
    # Create a new port security profile binding map if the given security profile binding map does not exist. Otherwise, patch the existing port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_port_security_profile_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_security_profile_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_security_profile_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_security_profile_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_security_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch QoS profile.
    # Create a new QoS profile if the QoS profile with given id does not already exist. If the QoS profile with the given id already exists, patch with the existing QoS profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param qos_profile_id QoS profile Id
    # @param qo_s_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_qo_s_profile(org_id, project_id, qos_profile_id, qo_s_profile, opts = {})
      orgs_org_id_projects_project_id_infra_patch_qo_s_profile_with_http_info(org_id, project_id, qos_profile_id, qo_s_profile, opts)
      nil
    end

    # Patch QoS profile.
    # Create a new QoS profile if the QoS profile with given id does not already exist. If the QoS profile with the given id already exists, patch with the existing QoS profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param qos_profile_id QoS profile Id
    # @param qo_s_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_qo_s_profile_with_http_info(org_id, project_id, qos_profile_id, qo_s_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_qo_s_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_qo_s_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_qo_s_profile"
      end
      # verify the required parameter 'qos_profile_id' is set
      if @api_client.config.client_side_validation && qos_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'qos_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_qo_s_profile"
      end
      # verify the required parameter 'qo_s_profile' is set
      if @api_client.config.client_side_validation && qo_s_profile.nil?
        fail ArgumentError, "Missing the required parameter 'qo_s_profile' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_qo_s_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/qos-profiles/{qos-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'qos-profile-id' + '}', qos_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(qo_s_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_qo_s_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch Real Time Eth profile.
    # Create a new Real Time Eth profile if the Real Time Eth profile with given id does not already exist. If the Real Time Eth profile with the given id already exists, patch with the existing Real Time Eth profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param real_time_eth_profile_id Real Time Eth profile Id
    # @param real_time_eth_profile 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_real_time_eth_profile(org_id, project_id, real_time_eth_profile_id, real_time_eth_profile, opts = {})
      orgs_org_id_projects_project_id_infra_patch_real_time_eth_profile_with_http_info(org_id, project_id, real_time_eth_profile_id, real_time_eth_profile, opts)
      nil
    end

    # Patch Real Time Eth profile.
    # Create a new Real Time Eth profile if the Real Time Eth profile with given id does not already exist. If the Real Time Eth profile with the given id already exists, patch with the existing Real Time Eth profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param real_time_eth_profile_id Real Time Eth profile Id
    # @param real_time_eth_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_real_time_eth_profile_with_http_info(org_id, project_id, real_time_eth_profile_id, real_time_eth_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_real_time_eth_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_real_time_eth_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_real_time_eth_profile"
      end
      # verify the required parameter 'real_time_eth_profile_id' is set
      if @api_client.config.client_side_validation && real_time_eth_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'real_time_eth_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_real_time_eth_profile"
      end
      # verify the required parameter 'real_time_eth_profile' is set
      if @api_client.config.client_side_validation && real_time_eth_profile.nil?
        fail ArgumentError, "Missing the required parameter 'real_time_eth_profile' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_real_time_eth_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/real-time-eth-profiles/{real-time-eth-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'real-time-eth-profile-id' + '}', real_time_eth_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(real_time_eth_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_real_time_eth_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, update the segment with specified attributes. Note:  Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the  \"l2_extension\" object in the PATCH API payload, the path returned in the GET response payload may include the new path  instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.  Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path  instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_segment(org_id, project_id, tier_1_id, segment_id, segment, opts = {})
      orgs_org_id_projects_project_id_infra_patch_segment_with_http_info(org_id, project_id, tier_1_id, segment_id, segment, opts)
      nil
    end

    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, update the segment with specified attributes. Note:  Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the  \&quot;l2_extension\&quot; object in the PATCH API payload, the path returned in the GET response payload may include the new path  instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.  Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path  instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_segment_with_http_info(org_id, project_id, tier_1_id, segment_id, segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment"
      end
      # verify the required parameter 'segment' is set
      if @api_client.config.client_side_validation && segment.nil?
        fail ArgumentError, "Missing the required parameter 'segment' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Segment Discovery Profile Binding Map
    # API will create Segment Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param segment_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_segment_discovery_binding(org_id, project_id, tier_1_id, segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts = {})
      orgs_org_id_projects_project_id_infra_patch_segment_discovery_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts)
      nil
    end

    # Create Segment Discovery Profile Binding Map
    # API will create Segment Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param segment_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_segment_discovery_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_discovery_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_discovery_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_discovery_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_discovery_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_discovery_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-discovery-profile-binding-maps/{segment-discovery-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-discovery-profile-binding-map-id' + '}', segment_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_segment_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Segment QoS Profile Binding Map
    # API will create segment QoS profile binding map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param segment_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_segment_qo_s_binding(org_id, project_id, tier_1_id, segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts = {})
      orgs_org_id_projects_project_id_infra_patch_segment_qo_s_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts)
      nil
    end

    # Create Segment QoS Profile Binding Map
    # API will create segment QoS profile binding map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param segment_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_segment_qo_s_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_qo_s_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_qo_s_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_qo_s_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qos_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qo_s_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_qo_s_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qo_s_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_qo_s_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-qos-profile-binding-maps/{segment-qos-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-qos-profile-binding-map-id' + '}', segment_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_qo_s_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_segment_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # PATCH segment security profile id
    # Create a new segment security profile if the segment security profile with given id does not exist. Otherwise, PATCH the existing segment security profile 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_security_profile_id Segment security profile id
    # @param segment_security_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_segment_security_profile(org_id, project_id, segment_security_profile_id, segment_security_profile, opts = {})
      orgs_org_id_projects_project_id_infra_patch_segment_security_profile_with_http_info(org_id, project_id, segment_security_profile_id, segment_security_profile, opts)
      nil
    end

    # PATCH segment security profile id
    # Create a new segment security profile if the segment security profile with given id does not exist. Otherwise, PATCH the existing segment security profile 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_security_profile_id Segment security profile id
    # @param segment_security_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_segment_security_profile_with_http_info(org_id, project_id, segment_security_profile_id, segment_security_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_security_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_security_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_security_profile"
      end
      # verify the required parameter 'segment_security_profile_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_security_profile"
      end
      # verify the required parameter 'segment_security_profile' is set
      if @api_client.config.client_side_validation && segment_security_profile.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_security_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segment-security-profiles/{segment-security-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-security-profile-id' + '}', segment_security_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_security_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_segment_security_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch segment security profile binding map
    # Create a new segment security profile binding map if the given security profile binding map does not exist. Otherwise, patch the existing segment security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param segment_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_segment_security_profile_binding(org_id, project_id, tier_1_id, segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts = {})
      orgs_org_id_projects_project_id_infra_patch_segment_security_profile_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts)
      nil
    end

    # Patch segment security profile binding map
    # Create a new segment security profile binding map if the given security profile binding map does not exist. Otherwise, patch the existing segment security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param segment_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_segment_security_profile_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_security_profile_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_security_profile_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_security_profile_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_segment_security_profile_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-security-profile-binding-maps/{segment-security-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-security-profile-binding-map-id' + '}', segment_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_security_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_segment_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch SpoofGuard profile
    # Create a new SpoofGuard profile if the SpoofGuard profile with the given id does not exist. Otherwise, patch with the existing SpoofGuard profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param spoof_guard_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_spoof_guard_profile(org_id, project_id, spoofguard_profile_id, spoof_guard_profile, opts = {})
      orgs_org_id_projects_project_id_infra_patch_spoof_guard_profile_with_http_info(org_id, project_id, spoofguard_profile_id, spoof_guard_profile, opts)
      nil
    end

    # Patch SpoofGuard profile
    # Create a new SpoofGuard profile if the SpoofGuard profile with the given id does not exist. Otherwise, patch with the existing SpoofGuard profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param spoof_guard_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_spoof_guard_profile_with_http_info(org_id, project_id, spoofguard_profile_id, spoof_guard_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_spoof_guard_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_spoof_guard_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_spoof_guard_profile"
      end
      # verify the required parameter 'spoofguard_profile_id' is set
      if @api_client.config.client_side_validation && spoofguard_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'spoofguard_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_spoof_guard_profile"
      end
      # verify the required parameter 'spoof_guard_profile' is set
      if @api_client.config.client_side_validation && spoof_guard_profile.nil?
        fail ArgumentError, "Missing the required parameter 'spoof_guard_profile' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_spoof_guard_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/spoofguard-profiles/{spoofguard-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'spoofguard-profile-id' + '}', spoofguard_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(spoof_guard_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_spoof_guard_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a static ARP config
    # Create static ARP config with Tier-1 and segment IDs provided if it doesn't exist, update with provided config if it's already created. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param static_arp_config 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_static_arp_config(org_id, project_id, tier_1_id, segment_id, static_arp_config, opts = {})
      orgs_org_id_projects_project_id_infra_patch_static_arp_config_with_http_info(org_id, project_id, tier_1_id, segment_id, static_arp_config, opts)
      nil
    end

    # Create or update a static ARP config
    # Create static ARP config with Tier-1 and segment IDs provided if it doesn&#39;t exist, update with provided config if it&#39;s already created. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param static_arp_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_static_arp_config_with_http_info(org_id, project_id, tier_1_id, segment_id, static_arp_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_static_arp_config ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_static_arp_config"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_static_arp_config"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_static_arp_config"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_static_arp_config"
      end
      # verify the required parameter 'static_arp_config' is set
      if @api_client.config.client_side_validation && static_arp_config.nil?
        fail ArgumentError, "Missing the required parameter 'static_arp_config' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_static_arp_config"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/static-arp'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(static_arp_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_static_arp_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch a tier1 segment connection binding map
    # Patch the infra segment connection binding map. If binding map corresponding to the the given values is not present, the object will get created and if it is present it will be updated. This is a full replace. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param map_id 
    # @param segment_connection_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_tier1_segment_connection_binding_map(org_id, project_id, tier_1_id, segment_id, map_id, segment_connection_binding_map, opts = {})
      orgs_org_id_projects_project_id_infra_patch_tier1_segment_connection_binding_map_with_http_info(org_id, project_id, tier_1_id, segment_id, map_id, segment_connection_binding_map, opts)
      nil
    end

    # Patch a tier1 segment connection binding map
    # Patch the infra segment connection binding map. If binding map corresponding to the the given values is not present, the object will get created and if it is present it will be updated. This is a full replace. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param map_id 
    # @param segment_connection_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_tier1_segment_connection_binding_map_with_http_info(org_id, project_id, tier_1_id, segment_id, map_id, segment_connection_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_tier1_segment_connection_binding_map ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'map_id' is set
      if @api_client.config.client_side_validation && map_id.nil?
        fail ArgumentError, "Missing the required parameter 'map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_connection_binding_map' is set
      if @api_client.config.client_side_validation && segment_connection_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_connection_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_tier1_segment_connection_binding_map"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-connection-binding-maps/{map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'map-id' + '}', map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_connection_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_tier1_segment_connection_binding_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch a Tier-1 segment port
    # Create a Tier-1 segment port if it does not exist based on the IDs, or update existing port information by replacing the port object fields which presents in the request body. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def orgs_org_id_projects_project_id_infra_patch_tier1_segment_port(org_id, project_id, tier_1_id, segment_id, port_id, segment_port, opts = {})
      orgs_org_id_projects_project_id_infra_patch_tier1_segment_port_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, segment_port, opts)
      nil
    end

    # Patch a Tier-1 segment port
    # Create a Tier-1 segment port if it does not exist based on the IDs, or update existing port information by replacing the port object fields which presents in the request body. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def orgs_org_id_projects_project_id_infra_patch_tier1_segment_port_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, segment_port, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_patch_tier1_segment_port ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_tier1_segment_port"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_tier1_segment_port"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_tier1_segment_port"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_tier1_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_tier1_segment_port"
      end
      # verify the required parameter 'segment_port' is set
      if @api_client.config.client_side_validation && segment_port.nil?
        fail ArgumentError, "Missing the required parameter 'segment_port' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_patch_tier1_segment_port"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_port)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_patch_tier1_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read infra segment
    # Read infra segment Note: Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \"l2_extension\" object in the PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the  error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param [Hash] opts the optional parameters
    # @return [Segment]
    def orgs_org_id_projects_project_id_infra_read_infra_segment(org_id, project_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_read_infra_segment_with_http_info(org_id, project_id, segment_id, opts)
      data
    end

    # Read infra segment
    # Read infra segment Note: Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \&quot;l2_extension\&quot; object in the PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the  error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(Segment, Fixnum, Hash)>] Segment data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_read_infra_segment_with_http_info(org_id, project_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_read_infra_segment ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_infra_segment"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_infra_segment"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_infra_segment"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Segment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_read_infra_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read infra segment
    # Read infra segment Note: Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \"l2_extension\" object in the PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the  error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param [Hash] opts the optional parameters
    # @return [Segment]
    def orgs_org_id_projects_project_id_infra_read_infra_segment_0(org_id, project_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_read_infra_segment_0_with_http_info(org_id, project_id, segment_id, opts)
      data
    end

    # Read infra segment
    # Read infra segment Note: Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \&quot;l2_extension\&quot; object in the PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the  error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(Segment, Fixnum, Hash)>] Segment data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_read_infra_segment_0_with_http_info(org_id, project_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_read_infra_segment_0 ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_infra_segment_0"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_infra_segment_0"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_infra_segment_0"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Segment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_read_infra_segment_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read infra SegmentConnectionBindingMap
    # Read infra SegmentConnectionBindingMap. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param map_id 
    # @param [Hash] opts the optional parameters
    # @return [SegmentConnectionBindingMap]
    def orgs_org_id_projects_project_id_infra_read_infra_segment_connection_binding_map(org_id, project_id, segment_id, map_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_read_infra_segment_connection_binding_map_with_http_info(org_id, project_id, segment_id, map_id, opts)
      data
    end

    # Read infra SegmentConnectionBindingMap
    # Read infra SegmentConnectionBindingMap. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id 
    # @param map_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentConnectionBindingMap, Fixnum, Hash)>] SegmentConnectionBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_read_infra_segment_connection_binding_map_with_http_info(org_id, project_id, segment_id, map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_read_infra_segment_connection_binding_map ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'map_id' is set
      if @api_client.config.client_side_validation && map_id.nil?
        fail ArgumentError, "Missing the required parameter 'map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_infra_segment_connection_binding_map"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/segment-connection-binding-maps/{map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'map-id' + '}', map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConnectionBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_read_infra_segment_connection_binding_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Details of QoS profile 
    # API will return details of QoS profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param qos_profile_id QoS profile Id
    # @param [Hash] opts the optional parameters
    # @return [QoSProfile]
    def orgs_org_id_projects_project_id_infra_read_qo_s_profile(org_id, project_id, qos_profile_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_read_qo_s_profile_with_http_info(org_id, project_id, qos_profile_id, opts)
      data
    end

    # Details of QoS profile 
    # API will return details of QoS profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param qos_profile_id QoS profile Id
    # @param [Hash] opts the optional parameters
    # @return [Array<(QoSProfile, Fixnum, Hash)>] QoSProfile data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_read_qo_s_profile_with_http_info(org_id, project_id, qos_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_read_qo_s_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_qo_s_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_qo_s_profile"
      end
      # verify the required parameter 'qos_profile_id' is set
      if @api_client.config.client_side_validation && qos_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'qos_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_qo_s_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/qos-profiles/{qos-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'qos-profile-id' + '}', qos_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'QoSProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_read_qo_s_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Details of Real Time Eth profile 
    # API will return details of Real Time Eth profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param real_time_eth_profile_id Real Time Eth profile Id
    # @param [Hash] opts the optional parameters
    # @return [RealTimeEthProfile]
    def orgs_org_id_projects_project_id_infra_read_real_time_eth_profile(org_id, project_id, real_time_eth_profile_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_read_real_time_eth_profile_with_http_info(org_id, project_id, real_time_eth_profile_id, opts)
      data
    end

    # Details of Real Time Eth profile 
    # API will return details of Real Time Eth profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param real_time_eth_profile_id Real Time Eth profile Id
    # @param [Hash] opts the optional parameters
    # @return [Array<(RealTimeEthProfile, Fixnum, Hash)>] RealTimeEthProfile data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_read_real_time_eth_profile_with_http_info(org_id, project_id, real_time_eth_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_read_real_time_eth_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_real_time_eth_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_real_time_eth_profile"
      end
      # verify the required parameter 'real_time_eth_profile_id' is set
      if @api_client.config.client_side_validation && real_time_eth_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'real_time_eth_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_real_time_eth_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/real-time-eth-profiles/{real-time-eth-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'real-time-eth-profile-id' + '}', real_time_eth_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RealTimeEthProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_read_real_time_eth_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read segment
    # Read segment Note:   Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the   \"l2_extension\" object in the PUT/PATCH API payload, the path returned in the GET response payload may include the new path   instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.   Also note that l2vpn path included in the error messages returned from validation may include the new VPN path   instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [Segment]
    def orgs_org_id_projects_project_id_infra_read_segment(org_id, project_id, tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_read_segment_with_http_info(org_id, project_id, tier_1_id, segment_id, opts)
      data
    end

    # Read segment
    # Read segment Note:   Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the   \&quot;l2_extension\&quot; object in the PUT/PATCH API payload, the path returned in the GET response payload may include the new path   instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.   Also note that l2vpn path included in the error messages returned from validation may include the new VPN path   instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Segment, Fixnum, Hash)>] Segment data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_read_segment_with_http_info(org_id, project_id, tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_read_segment ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_segment"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_segment"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_segment"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_segment"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Segment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_read_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read static ARP config
    # Read static ARP config
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [StaticARPConfig]
    def orgs_org_id_projects_project_id_infra_read_static_arp_config(org_id, project_id, tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_read_static_arp_config_with_http_info(org_id, project_id, tier_1_id, segment_id, opts)
      data
    end

    # Read static ARP config
    # Read static ARP config
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(StaticARPConfig, Fixnum, Hash)>] StaticARPConfig data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_read_static_arp_config_with_http_info(org_id, project_id, tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_read_static_arp_config ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_static_arp_config"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_static_arp_config"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_static_arp_config"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_static_arp_config"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/static-arp'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticARPConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_read_static_arp_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read Tier1 SegmentConnectionBindingMap
    # Read Tier1 SegmentConnectionBindingMap. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param map_id 
    # @param [Hash] opts the optional parameters
    # @return [SegmentConnectionBindingMap]
    def orgs_org_id_projects_project_id_infra_read_tier1_segment_connection_binding_map(org_id, project_id, tier_1_id, segment_id, map_id, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_read_tier1_segment_connection_binding_map_with_http_info(org_id, project_id, tier_1_id, segment_id, map_id, opts)
      data
    end

    # Read Tier1 SegmentConnectionBindingMap
    # Read Tier1 SegmentConnectionBindingMap. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id 
    # @param segment_id 
    # @param map_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentConnectionBindingMap, Fixnum, Hash)>] SegmentConnectionBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_read_tier1_segment_connection_binding_map_with_http_info(org_id, project_id, tier_1_id, segment_id, map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_read_tier1_segment_connection_binding_map ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'map_id' is set
      if @api_client.config.client_side_validation && map_id.nil?
        fail ArgumentError, "Missing the required parameter 'map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_read_tier1_segment_connection_binding_map"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-connection-binding-maps/{map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'map-id' + '}', map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConnectionBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_read_tier1_segment_connection_binding_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Group discovery profile binding map
    # API will update Group discovery profile binding map
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param discovery_profile_binding_map_id Group discovery profile binding map ID
    # @param group_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [GroupDiscoveryProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_update_group_discovery_profile_binding(org_id, project_id, domain_id, group_id, discovery_profile_binding_map_id, group_discovery_profile_binding_map, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_update_group_discovery_profile_binding_with_http_info(org_id, project_id, domain_id, group_id, discovery_profile_binding_map_id, group_discovery_profile_binding_map, opts)
      data
    end

    # Update Group discovery profile binding map
    # API will update Group discovery profile binding map
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param discovery_profile_binding_map_id Group discovery profile binding map ID
    # @param group_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(GroupDiscoveryProfileBindingMap, Fixnum, Hash)>] GroupDiscoveryProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_update_group_discovery_profile_binding_with_http_info(org_id, project_id, domain_id, group_id, discovery_profile_binding_map_id, group_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_update_group_discovery_profile_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_group_discovery_profile_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_group_discovery_profile_binding"
      end
      # verify the required parameter 'domain_id' is set
      if @api_client.config.client_side_validation && domain_id.nil?
        fail ArgumentError, "Missing the required parameter 'domain_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_group_discovery_profile_binding"
      end
      # verify the required parameter 'group_id' is set
      if @api_client.config.client_side_validation && group_id.nil?
        fail ArgumentError, "Missing the required parameter 'group_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_group_discovery_profile_binding"
      end
      # verify the required parameter 'discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'discovery_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_group_discovery_profile_binding"
      end
      # verify the required parameter 'group_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && group_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'group_discovery_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_group_discovery_profile_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/domains/{domain-id}/groups/{group-id}/discovery-profile-binding-maps/{discovery-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'domain-id' + '}', domain_id.to_s).sub('{' + 'group-id' + '}', group_id.to_s).sub('{' + 'discovery-profile-binding-map-id' + '}', discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(group_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'GroupDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_update_group_discovery_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Infra Port Discovery Profile Binding Map
    # API will update Infra Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortDiscoveryProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_update_infra_port_discovery_binding(org_id, project_id, infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_update_infra_port_discovery_binding_with_http_info(org_id, project_id, infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts)
      data
    end

    # Update Infra Port Discovery Profile Binding Map
    # API will update Infra Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortDiscoveryProfileBindingMap, Fixnum, Hash)>] PortDiscoveryProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_update_infra_port_discovery_binding_with_http_info(org_id, project_id, infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_port_discovery_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_port_discovery_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_port_discovery_binding"
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_port_discovery_binding"
      end
      # verify the required parameter 'infra_port_id' is set
      if @api_client.config.client_side_validation && infra_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_port_discovery_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{infra-segment-id}/ports/{infra-port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'infra-port-id' + '}', infra_port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_update_infra_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Port QoS Profile Binding Map
    # API will update Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortQoSProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_update_infra_port_qo_s_binding(org_id, project_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_update_infra_port_qo_s_binding_with_http_info(org_id, project_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts)
      data
    end

    # Update Port QoS Profile Binding Map
    # API will update Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortQoSProfileBindingMap, Fixnum, Hash)>] PortQoSProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_update_infra_port_qo_s_binding_with_http_info(org_id, project_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_port_qo_s_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_port_qo_s_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_port_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_qo_s_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_qo_s_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_qo_s_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_qo_s_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_update_infra_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Port Real Time Eth Profile Binding Map
    # API will update Port Real Time Eth Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_real_time_eth_profile_binding_map_id Port Real Time Eth Profile Binding Map ID
    # @param port_real_time_eth_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortRealTimeEthProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_update_infra_port_real_time_eth_binding(org_id, project_id, segment_id, port_id, port_real_time_eth_profile_binding_map_id, port_real_time_eth_profile_binding_map, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_update_infra_port_real_time_eth_binding_with_http_info(org_id, project_id, segment_id, port_id, port_real_time_eth_profile_binding_map_id, port_real_time_eth_profile_binding_map, opts)
      data
    end

    # Update Port Real Time Eth Profile Binding Map
    # API will update Port Real Time Eth Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_real_time_eth_profile_binding_map_id Port Real Time Eth Profile Binding Map ID
    # @param port_real_time_eth_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortRealTimeEthProfileBindingMap, Fixnum, Hash)>] PortRealTimeEthProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_update_infra_port_real_time_eth_binding_with_http_info(org_id, project_id, segment_id, port_id, port_real_time_eth_profile_binding_map_id, port_real_time_eth_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_port_real_time_eth_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'port_real_time_eth_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_real_time_eth_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_real_time_eth_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'port_real_time_eth_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_real_time_eth_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_real_time_eth_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_port_real_time_eth_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/ports/{port-id}/port-real-time-eth-profile-binding-maps/{port-real-time-eth-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-real-time-eth-profile-binding-map-id' + '}', port_real_time_eth_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_real_time_eth_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortRealTimeEthProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_update_infra_port_real_time_eth_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Infra Segment Discovery Profile Binding Map
    # API will update Infra Segment Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param infra_segment_id Infra Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param segment_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [SegmentDiscoveryProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_update_infra_segment_discovery_binding(org_id, project_id, infra_segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_update_infra_segment_discovery_binding_with_http_info(org_id, project_id, infra_segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts)
      data
    end

    # Update Infra Segment Discovery Profile Binding Map
    # API will update Infra Segment Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param infra_segment_id Infra Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param segment_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentDiscoveryProfileBindingMap, Fixnum, Hash)>] SegmentDiscoveryProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_update_infra_segment_discovery_binding_with_http_info(org_id, project_id, infra_segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_segment_discovery_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_segment_discovery_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_segment_discovery_binding"
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_segment_discovery_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{infra-segment-id}/segment-discovery-profile-binding-maps/{segment-discovery-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'segment-discovery-profile-binding-map-id' + '}', segment_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_update_infra_segment_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Segment QoS Profile Binding Map
    # API will update Segment QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param segment_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [SegmentQoSProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_update_infra_segment_qo_s_binding(org_id, project_id, segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_update_infra_segment_qo_s_binding_with_http_info(org_id, project_id, segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts)
      data
    end

    # Update Segment QoS Profile Binding Map
    # API will update Segment QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param segment_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentQoSProfileBindingMap, Fixnum, Hash)>] SegmentQoSProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_update_infra_segment_qo_s_binding_with_http_info(org_id, project_id, segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_segment_qo_s_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_segment_qo_s_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qos_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qo_s_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_qo_s_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qo_s_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_segment_qo_s_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/segment-qos-profile-binding-maps/{segment-qos-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-qos-profile-binding-map-id' + '}', segment_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_qo_s_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_update_infra_segment_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Segment Real Time Eth Profile Binding Map
    # API will update Segment Real Time Eth Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment_real_time_eth_profile_binding_map_id Segment Real Time Eth Profile Binding Map ID
    # @param segment_real_time_eth_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [SegmentRealTimeEthProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_update_infra_segment_real_time_eth_binding(org_id, project_id, segment_id, segment_real_time_eth_profile_binding_map_id, segment_real_time_eth_profile_binding_map, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_update_infra_segment_real_time_eth_binding_with_http_info(org_id, project_id, segment_id, segment_real_time_eth_profile_binding_map_id, segment_real_time_eth_profile_binding_map, opts)
      data
    end

    # Update Segment Real Time Eth Profile Binding Map
    # API will update Segment Real Time Eth Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param segment_id Segment ID
    # @param segment_real_time_eth_profile_binding_map_id Segment Real Time Eth Profile Binding Map ID
    # @param segment_real_time_eth_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentRealTimeEthProfileBindingMap, Fixnum, Hash)>] SegmentRealTimeEthProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_update_infra_segment_real_time_eth_binding_with_http_info(org_id, project_id, segment_id, segment_real_time_eth_profile_binding_map_id, segment_real_time_eth_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_segment_real_time_eth_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_segment_real_time_eth_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_segment_real_time_eth_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_segment_real_time_eth_binding"
      end
      # verify the required parameter 'segment_real_time_eth_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_real_time_eth_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_real_time_eth_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_segment_real_time_eth_binding"
      end
      # verify the required parameter 'segment_real_time_eth_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_real_time_eth_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_real_time_eth_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_infra_segment_real_time_eth_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/segments/{segment-id}/segment-real-time-eth-profile-binding-maps/{segment-real-time-eth-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-real-time-eth-profile-binding-map-id' + '}', segment_real_time_eth_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_real_time_eth_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentRealTimeEthProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_update_infra_segment_real_time_eth_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update IP Discovery Profile
    # API will update IP Discovery profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param ip_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [IPDiscoveryProfile]
    def orgs_org_id_projects_project_id_infra_update_ip_discovery_profile(org_id, project_id, ip_discovery_profile_id, ip_discovery_profile, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_update_ip_discovery_profile_with_http_info(org_id, project_id, ip_discovery_profile_id, ip_discovery_profile, opts)
      data
    end

    # Update IP Discovery Profile
    # API will update IP Discovery profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param ip_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(IPDiscoveryProfile, Fixnum, Hash)>] IPDiscoveryProfile data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_update_ip_discovery_profile_with_http_info(org_id, project_id, ip_discovery_profile_id, ip_discovery_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_update_ip_discovery_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_ip_discovery_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_ip_discovery_profile"
      end
      # verify the required parameter 'ip_discovery_profile_id' is set
      if @api_client.config.client_side_validation && ip_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'ip_discovery_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_ip_discovery_profile"
      end
      # verify the required parameter 'ip_discovery_profile' is set
      if @api_client.config.client_side_validation && ip_discovery_profile.nil?
        fail ArgumentError, "Missing the required parameter 'ip_discovery_profile' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_ip_discovery_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/ip-discovery-profiles/{ip-discovery-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'ip-discovery-profile-id' + '}', ip_discovery_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(ip_discovery_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'IPDiscoveryProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_update_ip_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Mac Discovery Profile
    # API will update Mac Discovery profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param mac_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [MacDiscoveryProfile]
    def orgs_org_id_projects_project_id_infra_update_mac_discovery_profile(org_id, project_id, mac_discovery_profile_id, mac_discovery_profile, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_update_mac_discovery_profile_with_http_info(org_id, project_id, mac_discovery_profile_id, mac_discovery_profile, opts)
      data
    end

    # Update Mac Discovery Profile
    # API will update Mac Discovery profile. 
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param mac_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(MacDiscoveryProfile, Fixnum, Hash)>] MacDiscoveryProfile data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_update_mac_discovery_profile_with_http_info(org_id, project_id, mac_discovery_profile_id, mac_discovery_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_update_mac_discovery_profile ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_mac_discovery_profile"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_mac_discovery_profile"
      end
      # verify the required parameter 'mac_discovery_profile_id' is set
      if @api_client.config.client_side_validation && mac_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'mac_discovery_profile_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_mac_discovery_profile"
      end
      # verify the required parameter 'mac_discovery_profile' is set
      if @api_client.config.client_side_validation && mac_discovery_profile.nil?
        fail ArgumentError, "Missing the required parameter 'mac_discovery_profile' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_mac_discovery_profile"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/mac-discovery-profiles/{mac-discovery-profile-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'mac-discovery-profile-id' + '}', mac_discovery_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(mac_discovery_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MacDiscoveryProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_update_mac_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Port Discovery Profile Binding Map
    # API will update Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortDiscoveryProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_update_port_discovery_binding(org_id, project_id, tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_update_port_discovery_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts)
      data
    end

    # Update Port Discovery Profile Binding Map
    # API will update Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortDiscoveryProfileBindingMap, Fixnum, Hash)>] PortDiscoveryProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_update_port_discovery_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_update_port_discovery_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_port_discovery_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_port_discovery_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_port_discovery_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_port_discovery_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_port_discovery_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_update_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Port QoS Profile Binding Map
    # API will update Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortQoSProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_update_port_qo_s_binding(org_id, project_id, tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_update_port_qo_s_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts)
      data
    end

    # Update Port QoS Profile Binding Map
    # API will update Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortQoSProfileBindingMap, Fixnum, Hash)>] PortQoSProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_update_port_qo_s_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_update_port_qo_s_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_port_qo_s_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_port_qo_s_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_port_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_port_qo_s_binding"
      end
      # verify the required parameter 'port_qo_s_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_qo_s_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_qo_s_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_qo_s_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_update_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Segment Discovery Profile Binding Map
    # API will update Segment Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param segment_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [SegmentDiscoveryProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_update_segment_discovery_binding(org_id, project_id, tier_1_id, segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_update_segment_discovery_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts)
      data
    end

    # Update Segment Discovery Profile Binding Map
    # API will update Segment Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param segment_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentDiscoveryProfileBindingMap, Fixnum, Hash)>] SegmentDiscoveryProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_update_segment_discovery_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_update_segment_discovery_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_segment_discovery_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_segment_discovery_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_segment_discovery_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_segment_discovery_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-discovery-profile-binding-maps/{segment-discovery-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-discovery-profile-binding-map-id' + '}', segment_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_update_segment_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Segment QoS Profile Binding Map
    # API will update Segment QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param segment_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [SegmentQoSProfileBindingMap]
    def orgs_org_id_projects_project_id_infra_update_segment_qo_s_binding(org_id, project_id, tier_1_id, segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts = {})
      data, _status_code, _headers = orgs_org_id_projects_project_id_infra_update_segment_qo_s_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts)
      data
    end

    # Update Segment QoS Profile Binding Map
    # API will update Segment QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param org_id The organization ID
    # @param project_id The project ID
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param segment_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentQoSProfileBindingMap, Fixnum, Hash)>] SegmentQoSProfileBindingMap data, response status code and response headers
    def orgs_org_id_projects_project_id_infra_update_segment_qo_s_binding_with_http_info(org_id, project_id, tier_1_id, segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.orgs_org_id_projects_project_id_infra_update_segment_qo_s_binding ...'
      end
      # verify the required parameter 'org_id' is set
      if @api_client.config.client_side_validation && org_id.nil?
        fail ArgumentError, "Missing the required parameter 'org_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_segment_qo_s_binding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_segment_qo_s_binding"
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qos_profile_binding_map_id' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qo_s_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_qo_s_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qo_s_profile_binding_map' when calling SegmentsApi.orgs_org_id_projects_project_id_infra_update_segment_qo_s_binding"
      end
      # resource path
      local_var_path = '/orgs/{org-id}/projects/{project-id}/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-qos-profile-binding-maps/{segment-qos-profile-binding-map-id}'.sub('{' + 'org-id' + '}', org_id.to_s).sub('{' + 'project-id' + '}', project_id.to_s).sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-qos-profile-binding-map-id' + '}', segment_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_qo_s_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#orgs_org_id_projects_project_id_infra_update_segment_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update Group discovery profile binding map
    # API will create or update Group discovery profile binding map
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param discovery_profile_binding_map_id Group discovery profile binding map ID
    # @param group_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_group_discovery_profile_binding(domain_id, group_id, discovery_profile_binding_map_id, group_discovery_profile_binding_map, opts = {})
      patch_group_discovery_profile_binding_with_http_info(domain_id, group_id, discovery_profile_binding_map_id, group_discovery_profile_binding_map, opts)
      nil
    end

    # Create or update Group discovery profile binding map
    # API will create or update Group discovery profile binding map
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param discovery_profile_binding_map_id Group discovery profile binding map ID
    # @param group_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_group_discovery_profile_binding_with_http_info(domain_id, group_id, discovery_profile_binding_map_id, group_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_group_discovery_profile_binding ...'
      end
      # verify the required parameter 'domain_id' is set
      if @api_client.config.client_side_validation && domain_id.nil?
        fail ArgumentError, "Missing the required parameter 'domain_id' when calling SegmentsApi.patch_group_discovery_profile_binding"
      end
      # verify the required parameter 'group_id' is set
      if @api_client.config.client_side_validation && group_id.nil?
        fail ArgumentError, "Missing the required parameter 'group_id' when calling SegmentsApi.patch_group_discovery_profile_binding"
      end
      # verify the required parameter 'discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'discovery_profile_binding_map_id' when calling SegmentsApi.patch_group_discovery_profile_binding"
      end
      # verify the required parameter 'group_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && group_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'group_discovery_profile_binding_map' when calling SegmentsApi.patch_group_discovery_profile_binding"
      end
      # resource path
      local_var_path = '/infra/domains/{domain-id}/groups/{group-id}/discovery-profile-binding-maps/{discovery-profile-binding-map-id}'.sub('{' + 'domain-id' + '}', domain_id.to_s).sub('{' + 'group-id' + '}', group_id.to_s).sub('{' + 'discovery-profile-binding-map-id' + '}', discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(group_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_group_discovery_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Infra Port Discovery Profile Binding Map
    # API will create Infra Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_infra_port_discovery_binding(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      patch_infra_port_discovery_binding_with_http_info(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts)
      nil
    end

    # Create Infra Port Discovery Profile Binding Map
    # API will create Infra Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_infra_port_discovery_binding_with_http_info(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_infra_port_discovery_binding ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.patch_infra_port_discovery_binding"
      end
      # verify the required parameter 'infra_port_id' is set
      if @api_client.config.client_side_validation && infra_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_port_id' when calling SegmentsApi.patch_infra_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.patch_infra_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map' when calling SegmentsApi.patch_infra_port_discovery_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/ports/{infra-port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'infra-port-id' + '}', infra_port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_infra_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Infra Port Monitoring Profile Binding Map
    # API will create Infra Port Monitoring Profile Binding Map.
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_monitoring_profile_binding_map_id Port Monitoring Profile Binding Map ID
    # @param port_monitoring_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_infra_port_monitoring_binding(infra_segment_id, infra_port_id, port_monitoring_profile_binding_map_id, port_monitoring_profile_binding_map, opts = {})
      patch_infra_port_monitoring_binding_with_http_info(infra_segment_id, infra_port_id, port_monitoring_profile_binding_map_id, port_monitoring_profile_binding_map, opts)
      nil
    end

    # Create Infra Port Monitoring Profile Binding Map
    # API will create Infra Port Monitoring Profile Binding Map.
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_monitoring_profile_binding_map_id Port Monitoring Profile Binding Map ID
    # @param port_monitoring_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_infra_port_monitoring_binding_with_http_info(infra_segment_id, infra_port_id, port_monitoring_profile_binding_map_id, port_monitoring_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_infra_port_monitoring_binding ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.patch_infra_port_monitoring_binding"
      end
      # verify the required parameter 'infra_port_id' is set
      if @api_client.config.client_side_validation && infra_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_port_id' when calling SegmentsApi.patch_infra_port_monitoring_binding"
      end
      # verify the required parameter 'port_monitoring_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_monitoring_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_monitoring_profile_binding_map_id' when calling SegmentsApi.patch_infra_port_monitoring_binding"
      end
      # verify the required parameter 'port_monitoring_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_monitoring_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_monitoring_profile_binding_map' when calling SegmentsApi.patch_infra_port_monitoring_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/ports/{infra-port-id}/port-monitoring-profile-binding-maps/{port-monitoring-profile-binding-map-id}'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'infra-port-id' + '}', infra_port_id.to_s).sub('{' + 'port-monitoring-profile-binding-map-id' + '}', port_monitoring_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_monitoring_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_infra_port_monitoring_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Port QoS Profile Binding Map
    # API will create Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_infra_port_qo_s_binding(segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      patch_infra_port_qo_s_binding_with_http_info(segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts)
      nil
    end

    # Create Port QoS Profile Binding Map
    # API will create Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_infra_port_qo_s_binding_with_http_info(segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_infra_port_qo_s_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.patch_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.patch_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_qo_s_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_qo_s_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_qo_s_profile_binding_map' when calling SegmentsApi.patch_infra_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_qo_s_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_infra_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Port Real Time Eth Profile Binding Map
    # API will create Port Real Time Eth Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_real_time_eth_profile_binding_map_id Port Real Time Eth Profile Binding Map ID
    # @param port_real_time_eth_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_infra_port_real_time_eth_binding(segment_id, port_id, port_real_time_eth_profile_binding_map_id, port_real_time_eth_profile_binding_map, opts = {})
      patch_infra_port_real_time_eth_binding_with_http_info(segment_id, port_id, port_real_time_eth_profile_binding_map_id, port_real_time_eth_profile_binding_map, opts)
      nil
    end

    # Create Port Real Time Eth Profile Binding Map
    # API will create Port Real Time Eth Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_real_time_eth_profile_binding_map_id Port Real Time Eth Profile Binding Map ID
    # @param port_real_time_eth_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_infra_port_real_time_eth_binding_with_http_info(segment_id, port_id, port_real_time_eth_profile_binding_map_id, port_real_time_eth_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_infra_port_real_time_eth_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.patch_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'port_real_time_eth_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_real_time_eth_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_real_time_eth_profile_binding_map_id' when calling SegmentsApi.patch_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'port_real_time_eth_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_real_time_eth_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_real_time_eth_profile_binding_map' when calling SegmentsApi.patch_infra_port_real_time_eth_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}/port-real-time-eth-profile-binding-maps/{port-real-time-eth-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-real-time-eth-profile-binding-map-id' + '}', port_real_time_eth_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_real_time_eth_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_infra_port_real_time_eth_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, update the segment with specified attributes. 
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_infra_segment(segment_id, segment, opts = {})
      patch_infra_segment_with_http_info(segment_id, segment, opts)
      nil
    end

    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, update the segment with specified attributes. 
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_infra_segment_with_http_info(segment_id, segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_infra_segment ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_infra_segment"
      end
      # verify the required parameter 'segment' is set
      if @api_client.config.client_side_validation && segment.nil?
        fail ArgumentError, "Missing the required parameter 'segment' when calling SegmentsApi.patch_infra_segment"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_infra_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, update the segment with specified attributes. 
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_infra_segment_0(segment_id, segment, opts = {})
      patch_infra_segment_0_with_http_info(segment_id, segment, opts)
      nil
    end

    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, update the segment with specified attributes. 
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_infra_segment_0_with_http_info(segment_id, segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_infra_segment_0 ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_infra_segment_0"
      end
      # verify the required parameter 'segment' is set
      if @api_client.config.client_side_validation && segment.nil?
        fail ArgumentError, "Missing the required parameter 'segment' when calling SegmentsApi.patch_infra_segment_0"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_infra_segment_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch a infra segment connection binding map
    # Patch the infra segment connection binding map. If binding map corresponding to the the given values is not present, the object will get created and if it is present it will be updated. This is a full replace. 
    # @param segment_id 
    # @param map_id 
    # @param segment_connection_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_infra_segment_connection_binding_map(segment_id, map_id, segment_connection_binding_map, opts = {})
      patch_infra_segment_connection_binding_map_with_http_info(segment_id, map_id, segment_connection_binding_map, opts)
      nil
    end

    # Patch a infra segment connection binding map
    # Patch the infra segment connection binding map. If binding map corresponding to the the given values is not present, the object will get created and if it is present it will be updated. This is a full replace. 
    # @param segment_id 
    # @param map_id 
    # @param segment_connection_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_infra_segment_connection_binding_map_with_http_info(segment_id, map_id, segment_connection_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_infra_segment_connection_binding_map ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'map_id' is set
      if @api_client.config.client_side_validation && map_id.nil?
        fail ArgumentError, "Missing the required parameter 'map_id' when calling SegmentsApi.patch_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_connection_binding_map' is set
      if @api_client.config.client_side_validation && segment_connection_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_connection_binding_map' when calling SegmentsApi.patch_infra_segment_connection_binding_map"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/segment-connection-binding-maps/{map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'map-id' + '}', map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_connection_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_infra_segment_connection_binding_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Infra Segment Discovery Profile Binding Map
    # API will create Infra Segment Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param infra_segment_id Infra Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param segment_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_infra_segment_discovery_binding(infra_segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts = {})
      patch_infra_segment_discovery_binding_with_http_info(infra_segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts)
      nil
    end

    # Create Infra Segment Discovery Profile Binding Map
    # API will create Infra Segment Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param infra_segment_id Infra Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param segment_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_infra_segment_discovery_binding_with_http_info(infra_segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_infra_segment_discovery_binding ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.patch_infra_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map_id' when calling SegmentsApi.patch_infra_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map' when calling SegmentsApi.patch_infra_segment_discovery_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/segment-discovery-profile-binding-maps/{segment-discovery-profile-binding-map-id}'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'segment-discovery-profile-binding-map-id' + '}', segment_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_infra_segment_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Infra Segment Monitoring Profile Binding Map
    # API will create infra segment monitoring profile binding map.
    # @param infra_segment_id Infra Segment ID
    # @param segment_monitoring_profile_binding_map_id Segment Monitoring Profile Binding Map ID
    # @param segment_monitoring_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_infra_segment_monitoring_binding(infra_segment_id, segment_monitoring_profile_binding_map_id, segment_monitoring_profile_binding_map, opts = {})
      patch_infra_segment_monitoring_binding_with_http_info(infra_segment_id, segment_monitoring_profile_binding_map_id, segment_monitoring_profile_binding_map, opts)
      nil
    end

    # Create Infra Segment Monitoring Profile Binding Map
    # API will create infra segment monitoring profile binding map.
    # @param infra_segment_id Infra Segment ID
    # @param segment_monitoring_profile_binding_map_id Segment Monitoring Profile Binding Map ID
    # @param segment_monitoring_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_infra_segment_monitoring_binding_with_http_info(infra_segment_id, segment_monitoring_profile_binding_map_id, segment_monitoring_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_infra_segment_monitoring_binding ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.patch_infra_segment_monitoring_binding"
      end
      # verify the required parameter 'segment_monitoring_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_monitoring_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_monitoring_profile_binding_map_id' when calling SegmentsApi.patch_infra_segment_monitoring_binding"
      end
      # verify the required parameter 'segment_monitoring_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_monitoring_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_monitoring_profile_binding_map' when calling SegmentsApi.patch_infra_segment_monitoring_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/segment-monitoring-profile-binding-maps/{segment-monitoring-profile-binding-map-id}'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'segment-monitoring-profile-binding-map-id' + '}', segment_monitoring_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_monitoring_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_infra_segment_monitoring_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch an infra segment port
    # Create an infra segment port if it does not exist based on the IDs, or update existing port information by replacing the port object fields which presents in the request body. 
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_infra_segment_port(segment_id, port_id, segment_port, opts = {})
      patch_infra_segment_port_with_http_info(segment_id, port_id, segment_port, opts)
      nil
    end

    # Patch an infra segment port
    # Create an infra segment port if it does not exist based on the IDs, or update existing port information by replacing the port object fields which presents in the request body. 
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_infra_segment_port_with_http_info(segment_id, port_id, segment_port, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_infra_segment_port ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_infra_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.patch_infra_segment_port"
      end
      # verify the required parameter 'segment_port' is set
      if @api_client.config.client_side_validation && segment_port.nil?
        fail ArgumentError, "Missing the required parameter 'segment_port' when calling SegmentsApi.patch_infra_segment_port"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_port)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_infra_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch infra segment port security profile binding map
    # Create a new port security profile binding map if the given security profile binding map does not exist. Otherwise, patch the existing port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_infra_segment_port_security_profile_binding(segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      patch_infra_segment_port_security_profile_binding_with_http_info(segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts)
      nil
    end

    # Patch infra segment port security profile binding map
    # Create a new port security profile binding map if the given security profile binding map does not exist. Otherwise, patch the existing port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_infra_segment_port_security_profile_binding_with_http_info(segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_infra_segment_port_security_profile_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.patch_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.patch_infra_segment_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map' when calling SegmentsApi.patch_infra_segment_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_security_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_infra_segment_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Segment QoS Profile Binding Map
    # API will create segment QoS profile binding map. For objects with no binding maps, default profile is applied.
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param segment_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_infra_segment_qo_s_binding(segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts = {})
      patch_infra_segment_qo_s_binding_with_http_info(segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts)
      nil
    end

    # Create Segment QoS Profile Binding Map
    # API will create segment QoS profile binding map. For objects with no binding maps, default profile is applied.
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param segment_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_infra_segment_qo_s_binding_with_http_info(segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_infra_segment_qo_s_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_infra_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qos_profile_binding_map_id' when calling SegmentsApi.patch_infra_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qo_s_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_qo_s_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qo_s_profile_binding_map' when calling SegmentsApi.patch_infra_segment_qo_s_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/segment-qos-profile-binding-maps/{segment-qos-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-qos-profile-binding-map-id' + '}', segment_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_qo_s_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_infra_segment_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Segment Real Time Eth Profile Binding Map
    # API will create Segment Real Time Eth profile binding map. For objects with no binding maps, default profile is applied.
    # @param segment_id Segment ID
    # @param segment_real_time_eth_profile_binding_map_id Segment Real Time Eth Profile Binding Map ID
    # @param segment_real_time_eth_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_infra_segment_real_time_eth_binding(segment_id, segment_real_time_eth_profile_binding_map_id, segment_real_time_eth_profile_binding_map, opts = {})
      patch_infra_segment_real_time_eth_binding_with_http_info(segment_id, segment_real_time_eth_profile_binding_map_id, segment_real_time_eth_profile_binding_map, opts)
      nil
    end

    # Create Segment Real Time Eth Profile Binding Map
    # API will create Segment Real Time Eth profile binding map. For objects with no binding maps, default profile is applied.
    # @param segment_id Segment ID
    # @param segment_real_time_eth_profile_binding_map_id Segment Real Time Eth Profile Binding Map ID
    # @param segment_real_time_eth_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_infra_segment_real_time_eth_binding_with_http_info(segment_id, segment_real_time_eth_profile_binding_map_id, segment_real_time_eth_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_infra_segment_real_time_eth_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_infra_segment_real_time_eth_binding"
      end
      # verify the required parameter 'segment_real_time_eth_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_real_time_eth_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_real_time_eth_profile_binding_map_id' when calling SegmentsApi.patch_infra_segment_real_time_eth_binding"
      end
      # verify the required parameter 'segment_real_time_eth_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_real_time_eth_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_real_time_eth_profile_binding_map' when calling SegmentsApi.patch_infra_segment_real_time_eth_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/segment-real-time-eth-profile-binding-maps/{segment-real-time-eth-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-real-time-eth-profile-binding-map-id' + '}', segment_real_time_eth_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_real_time_eth_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_infra_segment_real_time_eth_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch infra segment security profile binding map
    # Create a new segment security profile binding map if the given security profile binding map does not exist. Otherwise, patch the existing segment security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param segment_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_infra_segment_security_profile_binding(segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts = {})
      patch_infra_segment_security_profile_binding_with_http_info(segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts)
      nil
    end

    # Patch infra segment security profile binding map
    # Create a new segment security profile binding map if the given security profile binding map does not exist. Otherwise, patch the existing segment security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param segment_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_infra_segment_security_profile_binding_with_http_info(segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_infra_segment_security_profile_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_infra_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map_id' when calling SegmentsApi.patch_infra_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map' when calling SegmentsApi.patch_infra_segment_security_profile_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/segment-security-profile-binding-maps/{segment-security-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-security-profile-binding-map-id' + '}', segment_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_security_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_infra_segment_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, update the segment with specified attributes.  Force parameter is required when workload connectivity is indirectly impacted with the current update. 
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_infra_segment_with_force(segment_id, segment, opts = {})
      patch_infra_segment_with_force_with_http_info(segment_id, segment, opts)
      nil
    end

    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, update the segment with specified attributes.  Force parameter is required when workload connectivity is indirectly impacted with the current update. 
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_infra_segment_with_force_with_http_info(segment_id, segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_infra_segment_with_force ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_infra_segment_with_force"
      end
      # verify the required parameter 'segment' is set
      if @api_client.config.client_side_validation && segment.nil?
        fail ArgumentError, "Missing the required parameter 'segment' when calling SegmentsApi.patch_infra_segment_with_force"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}?force=true'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_infra_segment_with_force\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, update the segment with specified attributes.  Force parameter is required when workload connectivity is indirectly impacted with the current update. 
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_infra_segment_with_force_0(segment_id, segment, opts = {})
      patch_infra_segment_with_force_0_with_http_info(segment_id, segment, opts)
      nil
    end

    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, update the segment with specified attributes.  Force parameter is required when workload connectivity is indirectly impacted with the current update. 
    # @param segment_id Segment ID
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_infra_segment_with_force_0_with_http_info(segment_id, segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_infra_segment_with_force_0 ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_infra_segment_with_force_0"
      end
      # verify the required parameter 'segment' is set
      if @api_client.config.client_side_validation && segment.nil?
        fail ArgumentError, "Missing the required parameter 'segment' when calling SegmentsApi.patch_infra_segment_with_force_0"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}?force=true'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_infra_segment_with_force_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update L2 Bridge Endpoint Profile
    # API will create or update L2 bridge profile with ID profile-id. L2 Bridge profile is only allowed under an enforcement-point with path /infra/sites/default/enforcement-points/default. 
    # @param site_id site ID
    # @param enforcement_point_id enforcement point ID
    # @param profile_id profile ID
    # @param l2_bridge_endpoint_profile 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_l2_bridge_profile(site_id, enforcement_point_id, profile_id, l2_bridge_endpoint_profile, opts = {})
      patch_l2_bridge_profile_with_http_info(site_id, enforcement_point_id, profile_id, l2_bridge_endpoint_profile, opts)
      nil
    end

    # Create or update L2 Bridge Endpoint Profile
    # API will create or update L2 bridge profile with ID profile-id. L2 Bridge profile is only allowed under an enforcement-point with path /infra/sites/default/enforcement-points/default. 
    # @param site_id site ID
    # @param enforcement_point_id enforcement point ID
    # @param profile_id profile ID
    # @param l2_bridge_endpoint_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_l2_bridge_profile_with_http_info(site_id, enforcement_point_id, profile_id, l2_bridge_endpoint_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_l2_bridge_profile ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SegmentsApi.patch_l2_bridge_profile"
      end
      # verify the required parameter 'enforcement_point_id' is set
      if @api_client.config.client_side_validation && enforcement_point_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcement_point_id' when calling SegmentsApi.patch_l2_bridge_profile"
      end
      # verify the required parameter 'profile_id' is set
      if @api_client.config.client_side_validation && profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'profile_id' when calling SegmentsApi.patch_l2_bridge_profile"
      end
      # verify the required parameter 'l2_bridge_endpoint_profile' is set
      if @api_client.config.client_side_validation && l2_bridge_endpoint_profile.nil?
        fail ArgumentError, "Missing the required parameter 'l2_bridge_endpoint_profile' when calling SegmentsApi.patch_l2_bridge_profile"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcement-point-id}/edge-bridge-profiles/{profile-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcement-point-id' + '}', enforcement_point_id.to_s).sub('{' + 'profile-id' + '}', profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(l2_bridge_endpoint_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_l2_bridge_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Port Discovery Profile Binding Map
    # API will create Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_port_discovery_binding(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      patch_port_discovery_binding_with_http_info(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts)
      nil
    end

    # Create Port Discovery Profile Binding Map
    # API will create Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_port_discovery_binding_with_http_info(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_port_discovery_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.patch_port_discovery_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_port_discovery_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.patch_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.patch_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map' when calling SegmentsApi.patch_port_discovery_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Port Monitoring Profile Binding Map
    # API will create Port Monitoring Profile Binding Map.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_monitoring_profile_binding_map_id Port Monitoring Profile Binding Map ID
    # @param port_monitoring_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_port_monitoring_binding(tier_1_id, segment_id, port_id, port_monitoring_profile_binding_map_id, port_monitoring_profile_binding_map, opts = {})
      patch_port_monitoring_binding_with_http_info(tier_1_id, segment_id, port_id, port_monitoring_profile_binding_map_id, port_monitoring_profile_binding_map, opts)
      nil
    end

    # Create Port Monitoring Profile Binding Map
    # API will create Port Monitoring Profile Binding Map.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_monitoring_profile_binding_map_id Port Monitoring Profile Binding Map ID
    # @param port_monitoring_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_port_monitoring_binding_with_http_info(tier_1_id, segment_id, port_id, port_monitoring_profile_binding_map_id, port_monitoring_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_port_monitoring_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.patch_port_monitoring_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_port_monitoring_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.patch_port_monitoring_binding"
      end
      # verify the required parameter 'port_monitoring_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_monitoring_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_monitoring_profile_binding_map_id' when calling SegmentsApi.patch_port_monitoring_binding"
      end
      # verify the required parameter 'port_monitoring_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_monitoring_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_monitoring_profile_binding_map' when calling SegmentsApi.patch_port_monitoring_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-monitoring-profile-binding-maps/{port-monitoring-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-monitoring-profile-binding-map-id' + '}', port_monitoring_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_monitoring_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_port_monitoring_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Port QoS Profile Binding Map
    # API will create Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_port_qo_s_binding(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      patch_port_qo_s_binding_with_http_info(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts)
      nil
    end

    # Create Port QoS Profile Binding Map
    # API will create Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_port_qo_s_binding_with_http_info(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_port_qo_s_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.patch_port_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.patch_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.patch_port_qo_s_binding"
      end
      # verify the required parameter 'port_qo_s_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_qo_s_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_qo_s_profile_binding_map' when calling SegmentsApi.patch_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_qo_s_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch port security profile binding map
    # Create a new port security profile binding map if the given security profile binding map does not exist. Otherwise, patch the existing port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_port_security_profile_binding(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      patch_port_security_profile_binding_with_http_info(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts)
      nil
    end

    # Patch port security profile binding map
    # Create a new port security profile binding map if the given security profile binding map does not exist. Otherwise, patch the existing port security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param port_id port id
    # @param port_security_profile_binding_map_id port security profile binding map id
    # @param port_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_port_security_profile_binding_with_http_info(tier_1_id, segment_id, port_id, port_security_profile_binding_map_id, port_security_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_port_security_profile_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.patch_port_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_port_security_profile_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.patch_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map_id' when calling SegmentsApi.patch_port_security_profile_binding"
      end
      # verify the required parameter 'port_security_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_security_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_security_profile_binding_map' when calling SegmentsApi.patch_port_security_profile_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-security-profile-binding-maps/{port-security-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-security-profile-binding-map-id' + '}', port_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_security_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_port_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch QoS profile.
    # Create a new QoS profile if the QoS profile with given id does not already exist. If the QoS profile with the given id already exists, patch with the existing QoS profile. 
    # @param qos_profile_id QoS profile Id
    # @param qo_s_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def patch_qo_s_profile(qos_profile_id, qo_s_profile, opts = {})
      patch_qo_s_profile_with_http_info(qos_profile_id, qo_s_profile, opts)
      nil
    end

    # Patch QoS profile.
    # Create a new QoS profile if the QoS profile with given id does not already exist. If the QoS profile with the given id already exists, patch with the existing QoS profile. 
    # @param qos_profile_id QoS profile Id
    # @param qo_s_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_qo_s_profile_with_http_info(qos_profile_id, qo_s_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_qo_s_profile ...'
      end
      # verify the required parameter 'qos_profile_id' is set
      if @api_client.config.client_side_validation && qos_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'qos_profile_id' when calling SegmentsApi.patch_qo_s_profile"
      end
      # verify the required parameter 'qo_s_profile' is set
      if @api_client.config.client_side_validation && qo_s_profile.nil?
        fail ArgumentError, "Missing the required parameter 'qo_s_profile' when calling SegmentsApi.patch_qo_s_profile"
      end
      # resource path
      local_var_path = '/infra/qos-profiles/{qos-profile-id}'.sub('{' + 'qos-profile-id' + '}', qos_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(qo_s_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_qo_s_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch Real Time Eth profile.
    # Create a new Real Time Eth profile if the Real Time Eth profile with given id does not already exist. If the Real Time Eth profile with the given id already exists, patch with the existing Real Time Eth profile. 
    # @param real_time_eth_profile_id Real Time Eth profile Id
    # @param real_time_eth_profile 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_real_time_eth_profile(real_time_eth_profile_id, real_time_eth_profile, opts = {})
      patch_real_time_eth_profile_with_http_info(real_time_eth_profile_id, real_time_eth_profile, opts)
      nil
    end

    # Patch Real Time Eth profile.
    # Create a new Real Time Eth profile if the Real Time Eth profile with given id does not already exist. If the Real Time Eth profile with the given id already exists, patch with the existing Real Time Eth profile. 
    # @param real_time_eth_profile_id Real Time Eth profile Id
    # @param real_time_eth_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_real_time_eth_profile_with_http_info(real_time_eth_profile_id, real_time_eth_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_real_time_eth_profile ...'
      end
      # verify the required parameter 'real_time_eth_profile_id' is set
      if @api_client.config.client_side_validation && real_time_eth_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'real_time_eth_profile_id' when calling SegmentsApi.patch_real_time_eth_profile"
      end
      # verify the required parameter 'real_time_eth_profile' is set
      if @api_client.config.client_side_validation && real_time_eth_profile.nil?
        fail ArgumentError, "Missing the required parameter 'real_time_eth_profile' when calling SegmentsApi.patch_real_time_eth_profile"
      end
      # resource path
      local_var_path = '/infra/real-time-eth-profiles/{real-time-eth-profile-id}'.sub('{' + 'real-time-eth-profile-id' + '}', real_time_eth_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(real_time_eth_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_real_time_eth_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, update the segment with specified attributes. Note:  Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the  \"l2_extension\" object in the PATCH API payload, the path returned in the GET response payload may include the new path  instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.  Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path  instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param tier_1_id 
    # @param segment_id 
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_segment(tier_1_id, segment_id, segment, opts = {})
      patch_segment_with_http_info(tier_1_id, segment_id, segment, opts)
      nil
    end

    # Create or update a segment
    # If segment with the segment-id is not already present, create a new segment. If it already exists, update the segment with specified attributes. Note:  Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the  \&quot;l2_extension\&quot; object in the PATCH API payload, the path returned in the GET response payload may include the new path  instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.  Also note that l2vpn path included in the Alarm, GPRR, error messages returned from validation may include the new VPN path  instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param tier_1_id 
    # @param segment_id 
    # @param segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_segment_with_http_info(tier_1_id, segment_id, segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_segment ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.patch_segment"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_segment"
      end
      # verify the required parameter 'segment' is set
      if @api_client.config.client_side_validation && segment.nil?
        fail ArgumentError, "Missing the required parameter 'segment' when calling SegmentsApi.patch_segment"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Segment Discovery Profile Binding Map
    # API will create Segment Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param segment_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_segment_discovery_binding(tier_1_id, segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts = {})
      patch_segment_discovery_binding_with_http_info(tier_1_id, segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts)
      nil
    end

    # Create Segment Discovery Profile Binding Map
    # API will create Segment Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param segment_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_segment_discovery_binding_with_http_info(tier_1_id, segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_segment_discovery_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.patch_segment_discovery_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map_id' when calling SegmentsApi.patch_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map' when calling SegmentsApi.patch_segment_discovery_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-discovery-profile-binding-maps/{segment-discovery-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-discovery-profile-binding-map-id' + '}', segment_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_segment_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Segment Monitoring Profile Binding Map
    # API will create segment monitoring profile binding map.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_monitoring_profile_binding_map_id Segment Monitoring Profile Binding Map ID
    # @param segment_monitoring_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_segment_monitoring_binding(tier_1_id, segment_id, segment_monitoring_profile_binding_map_id, segment_monitoring_profile_binding_map, opts = {})
      patch_segment_monitoring_binding_with_http_info(tier_1_id, segment_id, segment_monitoring_profile_binding_map_id, segment_monitoring_profile_binding_map, opts)
      nil
    end

    # Create Segment Monitoring Profile Binding Map
    # API will create segment monitoring profile binding map.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_monitoring_profile_binding_map_id Segment Monitoring Profile Binding Map ID
    # @param segment_monitoring_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_segment_monitoring_binding_with_http_info(tier_1_id, segment_id, segment_monitoring_profile_binding_map_id, segment_monitoring_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_segment_monitoring_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.patch_segment_monitoring_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_segment_monitoring_binding"
      end
      # verify the required parameter 'segment_monitoring_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_monitoring_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_monitoring_profile_binding_map_id' when calling SegmentsApi.patch_segment_monitoring_binding"
      end
      # verify the required parameter 'segment_monitoring_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_monitoring_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_monitoring_profile_binding_map' when calling SegmentsApi.patch_segment_monitoring_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-monitoring-profile-binding-maps/{segment-monitoring-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-monitoring-profile-binding-map-id' + '}', segment_monitoring_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_monitoring_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_segment_monitoring_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create Segment QoS Profile Binding Map
    # API will create segment QoS profile binding map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param segment_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_segment_qo_s_binding(tier_1_id, segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts = {})
      patch_segment_qo_s_binding_with_http_info(tier_1_id, segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts)
      nil
    end

    # Create Segment QoS Profile Binding Map
    # API will create segment QoS profile binding map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param segment_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_segment_qo_s_binding_with_http_info(tier_1_id, segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_segment_qo_s_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.patch_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qos_profile_binding_map_id' when calling SegmentsApi.patch_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qo_s_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_qo_s_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qo_s_profile_binding_map' when calling SegmentsApi.patch_segment_qo_s_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-qos-profile-binding-maps/{segment-qos-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-qos-profile-binding-map-id' + '}', segment_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_qo_s_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_segment_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # PATCH segment security profile id
    # Create a new segment security profile if the segment security profile with given id does not exist. Otherwise, PATCH the existing segment security profile 
    # @param segment_security_profile_id Segment security profile id
    # @param segment_security_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def patch_segment_security_profile(segment_security_profile_id, segment_security_profile, opts = {})
      patch_segment_security_profile_with_http_info(segment_security_profile_id, segment_security_profile, opts)
      nil
    end

    # PATCH segment security profile id
    # Create a new segment security profile if the segment security profile with given id does not exist. Otherwise, PATCH the existing segment security profile 
    # @param segment_security_profile_id Segment security profile id
    # @param segment_security_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_segment_security_profile_with_http_info(segment_security_profile_id, segment_security_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_segment_security_profile ...'
      end
      # verify the required parameter 'segment_security_profile_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_id' when calling SegmentsApi.patch_segment_security_profile"
      end
      # verify the required parameter 'segment_security_profile' is set
      if @api_client.config.client_side_validation && segment_security_profile.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile' when calling SegmentsApi.patch_segment_security_profile"
      end
      # resource path
      local_var_path = '/infra/segment-security-profiles/{segment-security-profile-id}'.sub('{' + 'segment-security-profile-id' + '}', segment_security_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_security_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_segment_security_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch segment security profile binding map
    # Create a new segment security profile binding map if the given security profile binding map does not exist. Otherwise, patch the existing segment security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param segment_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_segment_security_profile_binding(tier_1_id, segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts = {})
      patch_segment_security_profile_binding_with_http_info(tier_1_id, segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts)
      nil
    end

    # Patch segment security profile binding map
    # Create a new segment security profile binding map if the given security profile binding map does not exist. Otherwise, patch the existing segment security profile binding map. For objects with no binding maps, default profile is applied. 
    # @param tier_1_id tier-1 gateway id
    # @param segment_id segment id
    # @param segment_security_profile_binding_map_id segment security profile binding map id
    # @param segment_security_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_segment_security_profile_binding_with_http_info(tier_1_id, segment_id, segment_security_profile_binding_map_id, segment_security_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_segment_security_profile_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.patch_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map_id' when calling SegmentsApi.patch_segment_security_profile_binding"
      end
      # verify the required parameter 'segment_security_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_security_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_security_profile_binding_map' when calling SegmentsApi.patch_segment_security_profile_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-security-profile-binding-maps/{segment-security-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-security-profile-binding-map-id' + '}', segment_security_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_security_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_segment_security_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create a service segment
    # A service segment with the service-segment-id is created. Modification of service segment is not supported. 
    # @param service_segment_id Service Segment ID
    # @param service_segment 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_service_segment(service_segment_id, service_segment, opts = {})
      patch_service_segment_with_http_info(service_segment_id, service_segment, opts)
      nil
    end

    # Create a service segment
    # A service segment with the service-segment-id is created. Modification of service segment is not supported. 
    # @param service_segment_id Service Segment ID
    # @param service_segment 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_service_segment_with_http_info(service_segment_id, service_segment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_service_segment ...'
      end
      # verify the required parameter 'service_segment_id' is set
      if @api_client.config.client_side_validation && service_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_segment_id' when calling SegmentsApi.patch_service_segment"
      end
      # verify the required parameter 'service_segment' is set
      if @api_client.config.client_side_validation && service_segment.nil?
        fail ArgumentError, "Missing the required parameter 'service_segment' when calling SegmentsApi.patch_service_segment"
      end
      # resource path
      local_var_path = '/infra/segments/service-segments/{service-segment-id}'.sub('{' + 'service-segment-id' + '}', service_segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(service_segment)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_service_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch SpoofGuard profile
    # Create a new SpoofGuard profile if the SpoofGuard profile with the given id does not exist. Otherwise, patch with the existing SpoofGuard profile. 
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param spoof_guard_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [nil]
    def patch_spoof_guard_profile(spoofguard_profile_id, spoof_guard_profile, opts = {})
      patch_spoof_guard_profile_with_http_info(spoofguard_profile_id, spoof_guard_profile, opts)
      nil
    end

    # Patch SpoofGuard profile
    # Create a new SpoofGuard profile if the SpoofGuard profile with the given id does not exist. Otherwise, patch with the existing SpoofGuard profile. 
    # @param spoofguard_profile_id SpoofGuard profile id
    # @param spoof_guard_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_spoof_guard_profile_with_http_info(spoofguard_profile_id, spoof_guard_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_spoof_guard_profile ...'
      end
      # verify the required parameter 'spoofguard_profile_id' is set
      if @api_client.config.client_side_validation && spoofguard_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'spoofguard_profile_id' when calling SegmentsApi.patch_spoof_guard_profile"
      end
      # verify the required parameter 'spoof_guard_profile' is set
      if @api_client.config.client_side_validation && spoof_guard_profile.nil?
        fail ArgumentError, "Missing the required parameter 'spoof_guard_profile' when calling SegmentsApi.patch_spoof_guard_profile"
      end
      # resource path
      local_var_path = '/infra/spoofguard-profiles/{spoofguard-profile-id}'.sub('{' + 'spoofguard-profile-id' + '}', spoofguard_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(spoof_guard_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_spoof_guard_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update a static ARP config
    # Create static ARP config with Tier-1 and segment IDs provided if it doesn't exist, update with provided config if it's already created. 
    # @param tier_1_id 
    # @param segment_id 
    # @param static_arp_config 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_static_arp_config(tier_1_id, segment_id, static_arp_config, opts = {})
      patch_static_arp_config_with_http_info(tier_1_id, segment_id, static_arp_config, opts)
      nil
    end

    # Create or update a static ARP config
    # Create static ARP config with Tier-1 and segment IDs provided if it doesn&#39;t exist, update with provided config if it&#39;s already created. 
    # @param tier_1_id 
    # @param segment_id 
    # @param static_arp_config 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_static_arp_config_with_http_info(tier_1_id, segment_id, static_arp_config, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_static_arp_config ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.patch_static_arp_config"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_static_arp_config"
      end
      # verify the required parameter 'static_arp_config' is set
      if @api_client.config.client_side_validation && static_arp_config.nil?
        fail ArgumentError, "Missing the required parameter 'static_arp_config' when calling SegmentsApi.patch_static_arp_config"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/static-arp'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(static_arp_config)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_static_arp_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch a tier1 segment connection binding map
    # Patch the infra segment connection binding map. If binding map corresponding to the the given values is not present, the object will get created and if it is present it will be updated. This is a full replace. 
    # @param tier_1_id 
    # @param segment_id 
    # @param map_id 
    # @param segment_connection_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_tier1_segment_connection_binding_map(tier_1_id, segment_id, map_id, segment_connection_binding_map, opts = {})
      patch_tier1_segment_connection_binding_map_with_http_info(tier_1_id, segment_id, map_id, segment_connection_binding_map, opts)
      nil
    end

    # Patch a tier1 segment connection binding map
    # Patch the infra segment connection binding map. If binding map corresponding to the the given values is not present, the object will get created and if it is present it will be updated. This is a full replace. 
    # @param tier_1_id 
    # @param segment_id 
    # @param map_id 
    # @param segment_connection_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_tier1_segment_connection_binding_map_with_http_info(tier_1_id, segment_id, map_id, segment_connection_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_tier1_segment_connection_binding_map ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.patch_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'map_id' is set
      if @api_client.config.client_side_validation && map_id.nil?
        fail ArgumentError, "Missing the required parameter 'map_id' when calling SegmentsApi.patch_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_connection_binding_map' is set
      if @api_client.config.client_side_validation && segment_connection_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_connection_binding_map' when calling SegmentsApi.patch_tier1_segment_connection_binding_map"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-connection-binding-maps/{map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'map-id' + '}', map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_connection_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_tier1_segment_connection_binding_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Patch a Tier-1 segment port
    # Create a Tier-1 segment port if it does not exist based on the IDs, or update existing port information by replacing the port object fields which presents in the request body. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def patch_tier1_segment_port(tier_1_id, segment_id, port_id, segment_port, opts = {})
      patch_tier1_segment_port_with_http_info(tier_1_id, segment_id, port_id, segment_port, opts)
      nil
    end

    # Patch a Tier-1 segment port
    # Create a Tier-1 segment port if it does not exist based on the IDs, or update existing port information by replacing the port object fields which presents in the request body. 
    # @param tier_1_id 
    # @param segment_id 
    # @param port_id 
    # @param segment_port 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Fixnum, Hash)>] nil, response status code and response headers
    def patch_tier1_segment_port_with_http_info(tier_1_id, segment_id, port_id, segment_port, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.patch_tier1_segment_port ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.patch_tier1_segment_port"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.patch_tier1_segment_port"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.patch_tier1_segment_port"
      end
      # verify the required parameter 'segment_port' is set
      if @api_client.config.client_side_validation && segment_port.nil?
        fail ArgumentError, "Missing the required parameter 'segment_port' when calling SegmentsApi.patch_tier1_segment_port"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_port)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#patch_tier1_segment_port\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read infra segment
    # Read infra segment Note: Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \"l2_extension\" object in the PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the  error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param segment_id Segment ID
    # @param [Hash] opts the optional parameters
    # @return [Segment]
    def read_infra_segment(segment_id, opts = {})
      data, _status_code, _headers = read_infra_segment_with_http_info(segment_id, opts)
      data
    end

    # Read infra segment
    # Read infra segment Note: Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \&quot;l2_extension\&quot; object in the PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the  error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param segment_id Segment ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(Segment, Fixnum, Hash)>] Segment data, response status code and response headers
    def read_infra_segment_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.read_infra_segment ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.read_infra_segment"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Segment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#read_infra_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read infra segment
    # Read infra segment Note: Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \"l2_extension\" object in the PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the  error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param segment_id Segment ID
    # @param [Hash] opts the optional parameters
    # @return [Segment]
    def read_infra_segment_0(segment_id, opts = {})
      data, _status_code, _headers = read_infra_segment_0_with_http_info(segment_id, opts)
      data
    end

    # Read infra segment
    # Read infra segment Note: Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the \&quot;l2_extension\&quot; object in the PATCH API payload, the path returned in the GET response payload may include the new path instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact. Also note that l2vpn path included in the  error messages returned from validation may include the new VPN path instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param segment_id Segment ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(Segment, Fixnum, Hash)>] Segment data, response status code and response headers
    def read_infra_segment_0_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.read_infra_segment_0 ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.read_infra_segment_0"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Segment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#read_infra_segment_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read infra SegmentConnectionBindingMap
    # Read infra SegmentConnectionBindingMap. 
    # @param segment_id 
    # @param map_id 
    # @param [Hash] opts the optional parameters
    # @return [SegmentConnectionBindingMap]
    def read_infra_segment_connection_binding_map(segment_id, map_id, opts = {})
      data, _status_code, _headers = read_infra_segment_connection_binding_map_with_http_info(segment_id, map_id, opts)
      data
    end

    # Read infra SegmentConnectionBindingMap
    # Read infra SegmentConnectionBindingMap. 
    # @param segment_id 
    # @param map_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentConnectionBindingMap, Fixnum, Hash)>] SegmentConnectionBindingMap data, response status code and response headers
    def read_infra_segment_connection_binding_map_with_http_info(segment_id, map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.read_infra_segment_connection_binding_map ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.read_infra_segment_connection_binding_map"
      end
      # verify the required parameter 'map_id' is set
      if @api_client.config.client_side_validation && map_id.nil?
        fail ArgumentError, "Missing the required parameter 'map_id' when calling SegmentsApi.read_infra_segment_connection_binding_map"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/segment-connection-binding-maps/{map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'map-id' + '}', map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConnectionBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#read_infra_segment_connection_binding_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get L2 Bridge Endpoint Profile
    # Read L2 bridge profile with ID profile-id
    # @param site_id site ID
    # @param enforcement_point_id enforcement point ID
    # @param profile_id profile ID
    # @param [Hash] opts the optional parameters
    # @return [L2BridgeEndpointProfile]
    def read_l2_bridge_profile(site_id, enforcement_point_id, profile_id, opts = {})
      data, _status_code, _headers = read_l2_bridge_profile_with_http_info(site_id, enforcement_point_id, profile_id, opts)
      data
    end

    # Get L2 Bridge Endpoint Profile
    # Read L2 bridge profile with ID profile-id
    # @param site_id site ID
    # @param enforcement_point_id enforcement point ID
    # @param profile_id profile ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(L2BridgeEndpointProfile, Fixnum, Hash)>] L2BridgeEndpointProfile data, response status code and response headers
    def read_l2_bridge_profile_with_http_info(site_id, enforcement_point_id, profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.read_l2_bridge_profile ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SegmentsApi.read_l2_bridge_profile"
      end
      # verify the required parameter 'enforcement_point_id' is set
      if @api_client.config.client_side_validation && enforcement_point_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcement_point_id' when calling SegmentsApi.read_l2_bridge_profile"
      end
      # verify the required parameter 'profile_id' is set
      if @api_client.config.client_side_validation && profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'profile_id' when calling SegmentsApi.read_l2_bridge_profile"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcement-point-id}/edge-bridge-profiles/{profile-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcement-point-id' + '}', enforcement_point_id.to_s).sub('{' + 'profile-id' + '}', profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'L2BridgeEndpointProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#read_l2_bridge_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Details of QoS profile 
    # API will return details of QoS profile. 
    # @param qos_profile_id QoS profile Id
    # @param [Hash] opts the optional parameters
    # @return [QoSProfile]
    def read_qo_s_profile(qos_profile_id, opts = {})
      data, _status_code, _headers = read_qo_s_profile_with_http_info(qos_profile_id, opts)
      data
    end

    # Details of QoS profile 
    # API will return details of QoS profile. 
    # @param qos_profile_id QoS profile Id
    # @param [Hash] opts the optional parameters
    # @return [Array<(QoSProfile, Fixnum, Hash)>] QoSProfile data, response status code and response headers
    def read_qo_s_profile_with_http_info(qos_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.read_qo_s_profile ...'
      end
      # verify the required parameter 'qos_profile_id' is set
      if @api_client.config.client_side_validation && qos_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'qos_profile_id' when calling SegmentsApi.read_qo_s_profile"
      end
      # resource path
      local_var_path = '/infra/qos-profiles/{qos-profile-id}'.sub('{' + 'qos-profile-id' + '}', qos_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'QoSProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#read_qo_s_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Details of Real Time Eth profile 
    # API will return details of Real Time Eth profile. 
    # @param real_time_eth_profile_id Real Time Eth profile Id
    # @param [Hash] opts the optional parameters
    # @return [RealTimeEthProfile]
    def read_real_time_eth_profile(real_time_eth_profile_id, opts = {})
      data, _status_code, _headers = read_real_time_eth_profile_with_http_info(real_time_eth_profile_id, opts)
      data
    end

    # Details of Real Time Eth profile 
    # API will return details of Real Time Eth profile. 
    # @param real_time_eth_profile_id Real Time Eth profile Id
    # @param [Hash] opts the optional parameters
    # @return [Array<(RealTimeEthProfile, Fixnum, Hash)>] RealTimeEthProfile data, response status code and response headers
    def read_real_time_eth_profile_with_http_info(real_time_eth_profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.read_real_time_eth_profile ...'
      end
      # verify the required parameter 'real_time_eth_profile_id' is set
      if @api_client.config.client_side_validation && real_time_eth_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'real_time_eth_profile_id' when calling SegmentsApi.read_real_time_eth_profile"
      end
      # resource path
      local_var_path = '/infra/real-time-eth-profiles/{real-time-eth-profile-id}'.sub('{' + 'real-time-eth-profile-id' + '}', real_time_eth_profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'RealTimeEthProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#read_real_time_eth_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read segment
    # Read segment Note:   Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the   \"l2_extension\" object in the PUT/PATCH API payload, the path returned in the GET response payload may include the new path   instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.   Also note that l2vpn path included in the error messages returned from validation may include the new VPN path   instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [Segment]
    def read_segment(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = read_segment_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # Read segment
    # Read segment Note:   Extended Segment: Please note that old vpn path deprecated. If user specify old l2vpn path in the   \&quot;l2_extension\&quot; object in the PUT/PATCH API payload, the path returned in the GET response payload may include the new path   instead of the deprecated l2vpn path. Both old and new l2vpn path refer to same resource. there is no functional impact.   Also note that l2vpn path included in the error messages returned from validation may include the new VPN path   instead of the deprecated l2vpn path. Both new path and old vpn path refer to same resource. 
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Segment, Fixnum, Hash)>] Segment data, response status code and response headers
    def read_segment_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.read_segment ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.read_segment"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.read_segment"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'Segment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#read_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read Service Segment
    # Read a Service Segment with the given id
    # @param service_segment_id Service Segment ID
    # @param [Hash] opts the optional parameters
    # @return [ServiceSegment]
    def read_service_segment(service_segment_id, opts = {})
      data, _status_code, _headers = read_service_segment_with_http_info(service_segment_id, opts)
      data
    end

    # Read Service Segment
    # Read a Service Segment with the given id
    # @param service_segment_id Service Segment ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(ServiceSegment, Fixnum, Hash)>] ServiceSegment data, response status code and response headers
    def read_service_segment_with_http_info(service_segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.read_service_segment ...'
      end
      # verify the required parameter 'service_segment_id' is set
      if @api_client.config.client_side_validation && service_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'service_segment_id' when calling SegmentsApi.read_service_segment"
      end
      # resource path
      local_var_path = '/infra/segments/service-segments/{service-segment-id}'.sub('{' + 'service-segment-id' + '}', service_segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ServiceSegment')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#read_service_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read static ARP config
    # Read static ARP config
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [StaticARPConfig]
    def read_static_arp_config(tier_1_id, segment_id, opts = {})
      data, _status_code, _headers = read_static_arp_config_with_http_info(tier_1_id, segment_id, opts)
      data
    end

    # Read static ARP config
    # Read static ARP config
    # @param tier_1_id 
    # @param segment_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(StaticARPConfig, Fixnum, Hash)>] StaticARPConfig data, response status code and response headers
    def read_static_arp_config_with_http_info(tier_1_id, segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.read_static_arp_config ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.read_static_arp_config"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.read_static_arp_config"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/static-arp'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'StaticARPConfig')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#read_static_arp_config\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Read Tier1 SegmentConnectionBindingMap
    # Read Tier1 SegmentConnectionBindingMap. 
    # @param tier_1_id 
    # @param segment_id 
    # @param map_id 
    # @param [Hash] opts the optional parameters
    # @return [SegmentConnectionBindingMap]
    def read_tier1_segment_connection_binding_map(tier_1_id, segment_id, map_id, opts = {})
      data, _status_code, _headers = read_tier1_segment_connection_binding_map_with_http_info(tier_1_id, segment_id, map_id, opts)
      data
    end

    # Read Tier1 SegmentConnectionBindingMap
    # Read Tier1 SegmentConnectionBindingMap. 
    # @param tier_1_id 
    # @param segment_id 
    # @param map_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentConnectionBindingMap, Fixnum, Hash)>] SegmentConnectionBindingMap data, response status code and response headers
    def read_tier1_segment_connection_binding_map_with_http_info(tier_1_id, segment_id, map_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.read_tier1_segment_connection_binding_map ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.read_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.read_tier1_segment_connection_binding_map"
      end
      # verify the required parameter 'map_id' is set
      if @api_client.config.client_side_validation && map_id.nil?
        fail ArgumentError, "Missing the required parameter 'map_id' when calling SegmentsApi.read_tier1_segment_connection_binding_map"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-connection-binding-maps/{map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'map-id' + '}', map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentConnectionBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#read_tier1_segment_connection_binding_map\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tier-1 segment bridge end point statistics using segment ID and profile path.
    # Get detailed information on Tier-1 segment bridge end point statistics using segment ID and profile path. 
    # @param tier_1_id 
    # @param segment_id 
    # @param bridge_profile_path Bridge profile path
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @return [BridgeEndpointStatistics]
    def tier1_segment_bridge_endpoint_statistics(tier_1_id, segment_id, bridge_profile_path, opts = {})
      data, _status_code, _headers = tier1_segment_bridge_endpoint_statistics_with_http_info(tier_1_id, segment_id, bridge_profile_path, opts)
      data
    end

    # Get Tier-1 segment bridge end point statistics using segment ID and profile path.
    # Get detailed information on Tier-1 segment bridge end point statistics using segment ID and profile path. 
    # @param tier_1_id 
    # @param segment_id 
    # @param bridge_profile_path Bridge profile path
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @return [Array<(BridgeEndpointStatistics, Fixnum, Hash)>] BridgeEndpointStatistics data, response status code and response headers
    def tier1_segment_bridge_endpoint_statistics_with_http_info(tier_1_id, segment_id, bridge_profile_path, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.tier1_segment_bridge_endpoint_statistics ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.tier1_segment_bridge_endpoint_statistics"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.tier1_segment_bridge_endpoint_statistics"
      end
      # verify the required parameter 'bridge_profile_path' is set
      if @api_client.config.client_side_validation && bridge_profile_path.nil?
        fail ArgumentError, "Missing the required parameter 'bridge_profile_path' when calling SegmentsApi.tier1_segment_bridge_endpoint_statistics"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/bep-statistics'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bridge_profile_path'] = bridge_profile_path
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BridgeEndpointStatistics')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#tier1_segment_bridge_endpoint_statistics\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Tier-1 segment bridge end point status using segment ID and profile path.
    # Get detailed information on Tier-1 segment bridge end point status using segment ID and profile path. 
    # @param tier_1_id 
    # @param segment_id 
    # @param bridge_profile_path Bridge profile path
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @return [BridgeEndpointStatus]
    def tier1_segment_bridge_endpoint_status(tier_1_id, segment_id, bridge_profile_path, opts = {})
      data, _status_code, _headers = tier1_segment_bridge_endpoint_status_with_http_info(tier_1_id, segment_id, bridge_profile_path, opts)
      data
    end

    # Get Tier-1 segment bridge end point status using segment ID and profile path.
    # Get detailed information on Tier-1 segment bridge end point status using segment ID and profile path. 
    # @param tier_1_id 
    # @param segment_id 
    # @param bridge_profile_path Bridge profile path
    # @param [Hash] opts the optional parameters
    # @option opts [String] :enforcement_point_path String Path of the enforcement point
    # @return [Array<(BridgeEndpointStatus, Fixnum, Hash)>] BridgeEndpointStatus data, response status code and response headers
    def tier1_segment_bridge_endpoint_status_with_http_info(tier_1_id, segment_id, bridge_profile_path, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.tier1_segment_bridge_endpoint_status ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.tier1_segment_bridge_endpoint_status"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.tier1_segment_bridge_endpoint_status"
      end
      # verify the required parameter 'bridge_profile_path' is set
      if @api_client.config.client_side_validation && bridge_profile_path.nil?
        fail ArgumentError, "Missing the required parameter 'bridge_profile_path' when calling SegmentsApi.tier1_segment_bridge_endpoint_status"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/bep-status'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'bridge_profile_path'] = bridge_profile_path
      query_params[:'enforcement_point_path'] = opts[:'enforcement_point_path'] if !opts[:'enforcement_point_path'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'BridgeEndpointStatus')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#tier1_segment_bridge_endpoint_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Group discovery profile binding map
    # API will update Group discovery profile binding map
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param discovery_profile_binding_map_id Group discovery profile binding map ID
    # @param group_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [GroupDiscoveryProfileBindingMap]
    def update_group_discovery_profile_binding(domain_id, group_id, discovery_profile_binding_map_id, group_discovery_profile_binding_map, opts = {})
      data, _status_code, _headers = update_group_discovery_profile_binding_with_http_info(domain_id, group_id, discovery_profile_binding_map_id, group_discovery_profile_binding_map, opts)
      data
    end

    # Update Group discovery profile binding map
    # API will update Group discovery profile binding map
    # @param domain_id Domain ID
    # @param group_id Group ID
    # @param discovery_profile_binding_map_id Group discovery profile binding map ID
    # @param group_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(GroupDiscoveryProfileBindingMap, Fixnum, Hash)>] GroupDiscoveryProfileBindingMap data, response status code and response headers
    def update_group_discovery_profile_binding_with_http_info(domain_id, group_id, discovery_profile_binding_map_id, group_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.update_group_discovery_profile_binding ...'
      end
      # verify the required parameter 'domain_id' is set
      if @api_client.config.client_side_validation && domain_id.nil?
        fail ArgumentError, "Missing the required parameter 'domain_id' when calling SegmentsApi.update_group_discovery_profile_binding"
      end
      # verify the required parameter 'group_id' is set
      if @api_client.config.client_side_validation && group_id.nil?
        fail ArgumentError, "Missing the required parameter 'group_id' when calling SegmentsApi.update_group_discovery_profile_binding"
      end
      # verify the required parameter 'discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'discovery_profile_binding_map_id' when calling SegmentsApi.update_group_discovery_profile_binding"
      end
      # verify the required parameter 'group_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && group_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'group_discovery_profile_binding_map' when calling SegmentsApi.update_group_discovery_profile_binding"
      end
      # resource path
      local_var_path = '/infra/domains/{domain-id}/groups/{group-id}/discovery-profile-binding-maps/{discovery-profile-binding-map-id}'.sub('{' + 'domain-id' + '}', domain_id.to_s).sub('{' + 'group-id' + '}', group_id.to_s).sub('{' + 'discovery-profile-binding-map-id' + '}', discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(group_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'GroupDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#update_group_discovery_profile_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Infra Port Discovery Profile Binding Map
    # API will update Infra Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortDiscoveryProfileBindingMap]
    def update_infra_port_discovery_binding(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      data, _status_code, _headers = update_infra_port_discovery_binding_with_http_info(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts)
      data
    end

    # Update Infra Port Discovery Profile Binding Map
    # API will update Infra Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param infra_segment_id Infra Segment ID
    # @param infra_port_id Infra Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortDiscoveryProfileBindingMap, Fixnum, Hash)>] PortDiscoveryProfileBindingMap data, response status code and response headers
    def update_infra_port_discovery_binding_with_http_info(infra_segment_id, infra_port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.update_infra_port_discovery_binding ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.update_infra_port_discovery_binding"
      end
      # verify the required parameter 'infra_port_id' is set
      if @api_client.config.client_side_validation && infra_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_port_id' when calling SegmentsApi.update_infra_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.update_infra_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map' when calling SegmentsApi.update_infra_port_discovery_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/ports/{infra-port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'infra-port-id' + '}', infra_port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#update_infra_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Infra Port Monitoring Profile Binding Map
    # API will update Infra Port Monitoring Profile Binding Map.
    # @param infra_segment_id InfraSegment ID
    # @param infra_port_id Infra Port ID
    # @param port_monitoring_profile_binding_map_id Port Monitoring Profile Binding Map ID
    # @param port_monitoring_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortMonitoringProfileBindingMap]
    def update_infra_port_monitoring_binding(infra_segment_id, infra_port_id, port_monitoring_profile_binding_map_id, port_monitoring_profile_binding_map, opts = {})
      data, _status_code, _headers = update_infra_port_monitoring_binding_with_http_info(infra_segment_id, infra_port_id, port_monitoring_profile_binding_map_id, port_monitoring_profile_binding_map, opts)
      data
    end

    # Update Infra Port Monitoring Profile Binding Map
    # API will update Infra Port Monitoring Profile Binding Map.
    # @param infra_segment_id InfraSegment ID
    # @param infra_port_id Infra Port ID
    # @param port_monitoring_profile_binding_map_id Port Monitoring Profile Binding Map ID
    # @param port_monitoring_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortMonitoringProfileBindingMap, Fixnum, Hash)>] PortMonitoringProfileBindingMap data, response status code and response headers
    def update_infra_port_monitoring_binding_with_http_info(infra_segment_id, infra_port_id, port_monitoring_profile_binding_map_id, port_monitoring_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.update_infra_port_monitoring_binding ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.update_infra_port_monitoring_binding"
      end
      # verify the required parameter 'infra_port_id' is set
      if @api_client.config.client_side_validation && infra_port_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_port_id' when calling SegmentsApi.update_infra_port_monitoring_binding"
      end
      # verify the required parameter 'port_monitoring_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_monitoring_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_monitoring_profile_binding_map_id' when calling SegmentsApi.update_infra_port_monitoring_binding"
      end
      # verify the required parameter 'port_monitoring_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_monitoring_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_monitoring_profile_binding_map' when calling SegmentsApi.update_infra_port_monitoring_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/ports/{infra-port-id}/port-monitoring-profile-binding-maps/{port-monitoring-profile-binding-map-id}'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'infra-port-id' + '}', infra_port_id.to_s).sub('{' + 'port-monitoring-profile-binding-map-id' + '}', port_monitoring_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_monitoring_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortMonitoringProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#update_infra_port_monitoring_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Port QoS Profile Binding Map
    # API will update Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortQoSProfileBindingMap]
    def update_infra_port_qo_s_binding(segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      data, _status_code, _headers = update_infra_port_qo_s_binding_with_http_info(segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts)
      data
    end

    # Update Port QoS Profile Binding Map
    # API will update Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortQoSProfileBindingMap, Fixnum, Hash)>] PortQoSProfileBindingMap data, response status code and response headers
    def update_infra_port_qo_s_binding_with_http_info(segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.update_infra_port_qo_s_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.update_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.update_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.update_infra_port_qo_s_binding"
      end
      # verify the required parameter 'port_qo_s_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_qo_s_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_qo_s_profile_binding_map' when calling SegmentsApi.update_infra_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_qo_s_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#update_infra_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Port Real Time Eth Profile Binding Map
    # API will update Port Real Time Eth Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_real_time_eth_profile_binding_map_id Port Real Time Eth Profile Binding Map ID
    # @param port_real_time_eth_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortRealTimeEthProfileBindingMap]
    def update_infra_port_real_time_eth_binding(segment_id, port_id, port_real_time_eth_profile_binding_map_id, port_real_time_eth_profile_binding_map, opts = {})
      data, _status_code, _headers = update_infra_port_real_time_eth_binding_with_http_info(segment_id, port_id, port_real_time_eth_profile_binding_map_id, port_real_time_eth_profile_binding_map, opts)
      data
    end

    # Update Port Real Time Eth Profile Binding Map
    # API will update Port Real Time Eth Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_real_time_eth_profile_binding_map_id Port Real Time Eth Profile Binding Map ID
    # @param port_real_time_eth_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortRealTimeEthProfileBindingMap, Fixnum, Hash)>] PortRealTimeEthProfileBindingMap data, response status code and response headers
    def update_infra_port_real_time_eth_binding_with_http_info(segment_id, port_id, port_real_time_eth_profile_binding_map_id, port_real_time_eth_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.update_infra_port_real_time_eth_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.update_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.update_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'port_real_time_eth_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_real_time_eth_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_real_time_eth_profile_binding_map_id' when calling SegmentsApi.update_infra_port_real_time_eth_binding"
      end
      # verify the required parameter 'port_real_time_eth_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_real_time_eth_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_real_time_eth_profile_binding_map' when calling SegmentsApi.update_infra_port_real_time_eth_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/ports/{port-id}/port-real-time-eth-profile-binding-maps/{port-real-time-eth-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-real-time-eth-profile-binding-map-id' + '}', port_real_time_eth_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_real_time_eth_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortRealTimeEthProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#update_infra_port_real_time_eth_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Infra Segment Discovery Profile Binding Map
    # API will update Infra Segment Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param infra_segment_id Infra Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param segment_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [SegmentDiscoveryProfileBindingMap]
    def update_infra_segment_discovery_binding(infra_segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts = {})
      data, _status_code, _headers = update_infra_segment_discovery_binding_with_http_info(infra_segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts)
      data
    end

    # Update Infra Segment Discovery Profile Binding Map
    # API will update Infra Segment Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param infra_segment_id Infra Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param segment_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentDiscoveryProfileBindingMap, Fixnum, Hash)>] SegmentDiscoveryProfileBindingMap data, response status code and response headers
    def update_infra_segment_discovery_binding_with_http_info(infra_segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.update_infra_segment_discovery_binding ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.update_infra_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map_id' when calling SegmentsApi.update_infra_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map' when calling SegmentsApi.update_infra_segment_discovery_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/segment-discovery-profile-binding-maps/{segment-discovery-profile-binding-map-id}'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'segment-discovery-profile-binding-map-id' + '}', segment_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#update_infra_segment_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Infra Segment Monitoring Profile Binding Map
    # API will update Infra Segment Monitoring Profile Binding Map.
    # @param infra_segment_id Infra Segment ID
    # @param segment_monitoring_profile_binding_map_id Segment Monitoring Profile Binding Map ID
    # @param segment_monitoring_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [SegmentMonitoringProfileBindingMap]
    def update_infra_segment_monitoring_binding(infra_segment_id, segment_monitoring_profile_binding_map_id, segment_monitoring_profile_binding_map, opts = {})
      data, _status_code, _headers = update_infra_segment_monitoring_binding_with_http_info(infra_segment_id, segment_monitoring_profile_binding_map_id, segment_monitoring_profile_binding_map, opts)
      data
    end

    # Update Infra Segment Monitoring Profile Binding Map
    # API will update Infra Segment Monitoring Profile Binding Map.
    # @param infra_segment_id Infra Segment ID
    # @param segment_monitoring_profile_binding_map_id Segment Monitoring Profile Binding Map ID
    # @param segment_monitoring_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentMonitoringProfileBindingMap, Fixnum, Hash)>] SegmentMonitoringProfileBindingMap data, response status code and response headers
    def update_infra_segment_monitoring_binding_with_http_info(infra_segment_id, segment_monitoring_profile_binding_map_id, segment_monitoring_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.update_infra_segment_monitoring_binding ...'
      end
      # verify the required parameter 'infra_segment_id' is set
      if @api_client.config.client_side_validation && infra_segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'infra_segment_id' when calling SegmentsApi.update_infra_segment_monitoring_binding"
      end
      # verify the required parameter 'segment_monitoring_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_monitoring_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_monitoring_profile_binding_map_id' when calling SegmentsApi.update_infra_segment_monitoring_binding"
      end
      # verify the required parameter 'segment_monitoring_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_monitoring_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_monitoring_profile_binding_map' when calling SegmentsApi.update_infra_segment_monitoring_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{infra-segment-id}/segment-monitoring-profile-binding-maps/{segment-monitoring-profile-binding-map-id}'.sub('{' + 'infra-segment-id' + '}', infra_segment_id.to_s).sub('{' + 'segment-monitoring-profile-binding-map-id' + '}', segment_monitoring_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_monitoring_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentMonitoringProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#update_infra_segment_monitoring_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Segment QoS Profile Binding Map
    # API will update Segment QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param segment_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [SegmentQoSProfileBindingMap]
    def update_infra_segment_qo_s_binding(segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts = {})
      data, _status_code, _headers = update_infra_segment_qo_s_binding_with_http_info(segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts)
      data
    end

    # Update Segment QoS Profile Binding Map
    # API will update Segment QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param segment_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentQoSProfileBindingMap, Fixnum, Hash)>] SegmentQoSProfileBindingMap data, response status code and response headers
    def update_infra_segment_qo_s_binding_with_http_info(segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.update_infra_segment_qo_s_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.update_infra_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qos_profile_binding_map_id' when calling SegmentsApi.update_infra_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qo_s_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_qo_s_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qo_s_profile_binding_map' when calling SegmentsApi.update_infra_segment_qo_s_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/segment-qos-profile-binding-maps/{segment-qos-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-qos-profile-binding-map-id' + '}', segment_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_qo_s_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#update_infra_segment_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Segment Real Time Eth Profile Binding Map
    # API will update Segment Real Time Eth Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param segment_id Segment ID
    # @param segment_real_time_eth_profile_binding_map_id Segment Real Time Eth Profile Binding Map ID
    # @param segment_real_time_eth_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [SegmentRealTimeEthProfileBindingMap]
    def update_infra_segment_real_time_eth_binding(segment_id, segment_real_time_eth_profile_binding_map_id, segment_real_time_eth_profile_binding_map, opts = {})
      data, _status_code, _headers = update_infra_segment_real_time_eth_binding_with_http_info(segment_id, segment_real_time_eth_profile_binding_map_id, segment_real_time_eth_profile_binding_map, opts)
      data
    end

    # Update Segment Real Time Eth Profile Binding Map
    # API will update Segment Real Time Eth Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param segment_id Segment ID
    # @param segment_real_time_eth_profile_binding_map_id Segment Real Time Eth Profile Binding Map ID
    # @param segment_real_time_eth_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentRealTimeEthProfileBindingMap, Fixnum, Hash)>] SegmentRealTimeEthProfileBindingMap data, response status code and response headers
    def update_infra_segment_real_time_eth_binding_with_http_info(segment_id, segment_real_time_eth_profile_binding_map_id, segment_real_time_eth_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.update_infra_segment_real_time_eth_binding ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.update_infra_segment_real_time_eth_binding"
      end
      # verify the required parameter 'segment_real_time_eth_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_real_time_eth_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_real_time_eth_profile_binding_map_id' when calling SegmentsApi.update_infra_segment_real_time_eth_binding"
      end
      # verify the required parameter 'segment_real_time_eth_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_real_time_eth_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_real_time_eth_profile_binding_map' when calling SegmentsApi.update_infra_segment_real_time_eth_binding"
      end
      # resource path
      local_var_path = '/infra/segments/{segment-id}/segment-real-time-eth-profile-binding-maps/{segment-real-time-eth-profile-binding-map-id}'.sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-real-time-eth-profile-binding-map-id' + '}', segment_real_time_eth_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_real_time_eth_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentRealTimeEthProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#update_infra_segment_real_time_eth_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update IP Discovery Profile
    # API will update IP Discovery profile. 
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param ip_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [IPDiscoveryProfile]
    def update_ip_discovery_profile(ip_discovery_profile_id, ip_discovery_profile, opts = {})
      data, _status_code, _headers = update_ip_discovery_profile_with_http_info(ip_discovery_profile_id, ip_discovery_profile, opts)
      data
    end

    # Update IP Discovery Profile
    # API will update IP Discovery profile. 
    # @param ip_discovery_profile_id IP Discovery Profile ID
    # @param ip_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(IPDiscoveryProfile, Fixnum, Hash)>] IPDiscoveryProfile data, response status code and response headers
    def update_ip_discovery_profile_with_http_info(ip_discovery_profile_id, ip_discovery_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.update_ip_discovery_profile ...'
      end
      # verify the required parameter 'ip_discovery_profile_id' is set
      if @api_client.config.client_side_validation && ip_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'ip_discovery_profile_id' when calling SegmentsApi.update_ip_discovery_profile"
      end
      # verify the required parameter 'ip_discovery_profile' is set
      if @api_client.config.client_side_validation && ip_discovery_profile.nil?
        fail ArgumentError, "Missing the required parameter 'ip_discovery_profile' when calling SegmentsApi.update_ip_discovery_profile"
      end
      # resource path
      local_var_path = '/infra/ip-discovery-profiles/{ip-discovery-profile-id}'.sub('{' + 'ip-discovery-profile-id' + '}', ip_discovery_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(ip_discovery_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'IPDiscoveryProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#update_ip_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create or update L2 Bridge Endpoint Profile
    # API will create or update L2 bridge profile with ID profile-id. L2 Bridge profile is only allowed under an enforcement-point with path /infra/sites/default/enforcement-points/default. 
    # @param site_id site ID
    # @param enforcement_point_id enforcement point ID
    # @param profile_id profile ID
    # @param l2_bridge_endpoint_profile 
    # @param [Hash] opts the optional parameters
    # @return [L2BridgeEndpointProfile]
    def update_l2_bridge_profile(site_id, enforcement_point_id, profile_id, l2_bridge_endpoint_profile, opts = {})
      data, _status_code, _headers = update_l2_bridge_profile_with_http_info(site_id, enforcement_point_id, profile_id, l2_bridge_endpoint_profile, opts)
      data
    end

    # Create or update L2 Bridge Endpoint Profile
    # API will create or update L2 bridge profile with ID profile-id. L2 Bridge profile is only allowed under an enforcement-point with path /infra/sites/default/enforcement-points/default. 
    # @param site_id site ID
    # @param enforcement_point_id enforcement point ID
    # @param profile_id profile ID
    # @param l2_bridge_endpoint_profile 
    # @param [Hash] opts the optional parameters
    # @return [Array<(L2BridgeEndpointProfile, Fixnum, Hash)>] L2BridgeEndpointProfile data, response status code and response headers
    def update_l2_bridge_profile_with_http_info(site_id, enforcement_point_id, profile_id, l2_bridge_endpoint_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.update_l2_bridge_profile ...'
      end
      # verify the required parameter 'site_id' is set
      if @api_client.config.client_side_validation && site_id.nil?
        fail ArgumentError, "Missing the required parameter 'site_id' when calling SegmentsApi.update_l2_bridge_profile"
      end
      # verify the required parameter 'enforcement_point_id' is set
      if @api_client.config.client_side_validation && enforcement_point_id.nil?
        fail ArgumentError, "Missing the required parameter 'enforcement_point_id' when calling SegmentsApi.update_l2_bridge_profile"
      end
      # verify the required parameter 'profile_id' is set
      if @api_client.config.client_side_validation && profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'profile_id' when calling SegmentsApi.update_l2_bridge_profile"
      end
      # verify the required parameter 'l2_bridge_endpoint_profile' is set
      if @api_client.config.client_side_validation && l2_bridge_endpoint_profile.nil?
        fail ArgumentError, "Missing the required parameter 'l2_bridge_endpoint_profile' when calling SegmentsApi.update_l2_bridge_profile"
      end
      # resource path
      local_var_path = '/infra/sites/{site-id}/enforcement-points/{enforcement-point-id}/edge-bridge-profiles/{profile-id}'.sub('{' + 'site-id' + '}', site_id.to_s).sub('{' + 'enforcement-point-id' + '}', enforcement_point_id.to_s).sub('{' + 'profile-id' + '}', profile_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(l2_bridge_endpoint_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'L2BridgeEndpointProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#update_l2_bridge_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Mac Discovery Profile
    # API will update Mac Discovery profile. 
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param mac_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object (default to false)
    # @return [MacDiscoveryProfile]
    def update_mac_discovery_profile(mac_discovery_profile_id, mac_discovery_profile, opts = {})
      data, _status_code, _headers = update_mac_discovery_profile_with_http_info(mac_discovery_profile_id, mac_discovery_profile, opts)
      data
    end

    # Update Mac Discovery Profile
    # API will update Mac Discovery profile. 
    # @param mac_discovery_profile_id Mac Discovery Profile ID
    # @param mac_discovery_profile 
    # @param [Hash] opts the optional parameters
    # @option opts [BOOLEAN] :override Locally override the global object
    # @return [Array<(MacDiscoveryProfile, Fixnum, Hash)>] MacDiscoveryProfile data, response status code and response headers
    def update_mac_discovery_profile_with_http_info(mac_discovery_profile_id, mac_discovery_profile, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.update_mac_discovery_profile ...'
      end
      # verify the required parameter 'mac_discovery_profile_id' is set
      if @api_client.config.client_side_validation && mac_discovery_profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'mac_discovery_profile_id' when calling SegmentsApi.update_mac_discovery_profile"
      end
      # verify the required parameter 'mac_discovery_profile' is set
      if @api_client.config.client_side_validation && mac_discovery_profile.nil?
        fail ArgumentError, "Missing the required parameter 'mac_discovery_profile' when calling SegmentsApi.update_mac_discovery_profile"
      end
      # resource path
      local_var_path = '/infra/mac-discovery-profiles/{mac-discovery-profile-id}'.sub('{' + 'mac-discovery-profile-id' + '}', mac_discovery_profile_id.to_s)

      # query parameters
      query_params = {}
      query_params[:'override'] = opts[:'override'] if !opts[:'override'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(mac_discovery_profile)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'MacDiscoveryProfile')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#update_mac_discovery_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Port Discovery Profile Binding Map
    # API will update Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortDiscoveryProfileBindingMap]
    def update_port_discovery_binding(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      data, _status_code, _headers = update_port_discovery_binding_with_http_info(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts)
      data
    end

    # Update Port Discovery Profile Binding Map
    # API will update Port Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_discovery_profile_binding_map_id Port Discovery Profile Binding Map ID
    # @param port_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortDiscoveryProfileBindingMap, Fixnum, Hash)>] PortDiscoveryProfileBindingMap data, response status code and response headers
    def update_port_discovery_binding_with_http_info(tier_1_id, segment_id, port_id, port_discovery_profile_binding_map_id, port_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.update_port_discovery_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.update_port_discovery_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.update_port_discovery_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.update_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map_id' when calling SegmentsApi.update_port_discovery_binding"
      end
      # verify the required parameter 'port_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_discovery_profile_binding_map' when calling SegmentsApi.update_port_discovery_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-discovery-profile-binding-maps/{port-discovery-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-discovery-profile-binding-map-id' + '}', port_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#update_port_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Port Monitoring Profile Binding Map
    # API will update Port Monitoring Profile Binding Map.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_monitoring_profile_binding_map_id Port Monitoring Profile Binding Map ID
    # @param port_monitoring_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortMonitoringProfileBindingMap]
    def update_port_monitoring_binding(tier_1_id, segment_id, port_id, port_monitoring_profile_binding_map_id, port_monitoring_profile_binding_map, opts = {})
      data, _status_code, _headers = update_port_monitoring_binding_with_http_info(tier_1_id, segment_id, port_id, port_monitoring_profile_binding_map_id, port_monitoring_profile_binding_map, opts)
      data
    end

    # Update Port Monitoring Profile Binding Map
    # API will update Port Monitoring Profile Binding Map.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_monitoring_profile_binding_map_id Port Monitoring Profile Binding Map ID
    # @param port_monitoring_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortMonitoringProfileBindingMap, Fixnum, Hash)>] PortMonitoringProfileBindingMap data, response status code and response headers
    def update_port_monitoring_binding_with_http_info(tier_1_id, segment_id, port_id, port_monitoring_profile_binding_map_id, port_monitoring_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.update_port_monitoring_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.update_port_monitoring_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.update_port_monitoring_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.update_port_monitoring_binding"
      end
      # verify the required parameter 'port_monitoring_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_monitoring_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_monitoring_profile_binding_map_id' when calling SegmentsApi.update_port_monitoring_binding"
      end
      # verify the required parameter 'port_monitoring_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_monitoring_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_monitoring_profile_binding_map' when calling SegmentsApi.update_port_monitoring_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-monitoring-profile-binding-maps/{port-monitoring-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-monitoring-profile-binding-map-id' + '}', port_monitoring_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_monitoring_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortMonitoringProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#update_port_monitoring_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Port QoS Profile Binding Map
    # API will update Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [PortQoSProfileBindingMap]
    def update_port_qo_s_binding(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      data, _status_code, _headers = update_port_qo_s_binding_with_http_info(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts)
      data
    end

    # Update Port QoS Profile Binding Map
    # API will update Port QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param port_id Port ID
    # @param port_qos_profile_binding_map_id Port QoS Profile Binding Map ID
    # @param port_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PortQoSProfileBindingMap, Fixnum, Hash)>] PortQoSProfileBindingMap data, response status code and response headers
    def update_port_qo_s_binding_with_http_info(tier_1_id, segment_id, port_id, port_qos_profile_binding_map_id, port_qo_s_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.update_port_qo_s_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.update_port_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.update_port_qo_s_binding"
      end
      # verify the required parameter 'port_id' is set
      if @api_client.config.client_side_validation && port_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_id' when calling SegmentsApi.update_port_qo_s_binding"
      end
      # verify the required parameter 'port_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && port_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'port_qos_profile_binding_map_id' when calling SegmentsApi.update_port_qo_s_binding"
      end
      # verify the required parameter 'port_qo_s_profile_binding_map' is set
      if @api_client.config.client_side_validation && port_qo_s_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'port_qo_s_profile_binding_map' when calling SegmentsApi.update_port_qo_s_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}/port-qos-profile-binding-maps/{port-qos-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'port-id' + '}', port_id.to_s).sub('{' + 'port-qos-profile-binding-map-id' + '}', port_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(port_qo_s_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'PortQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#update_port_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Segment Discovery Profile Binding Map
    # API will update Segment Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param segment_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [SegmentDiscoveryProfileBindingMap]
    def update_segment_discovery_binding(tier_1_id, segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts = {})
      data, _status_code, _headers = update_segment_discovery_binding_with_http_info(tier_1_id, segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts)
      data
    end

    # Update Segment Discovery Profile Binding Map
    # API will update Segment Discovery Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_discovery_profile_binding_map_id Segment Discovery Profile Binding Map ID
    # @param segment_discovery_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentDiscoveryProfileBindingMap, Fixnum, Hash)>] SegmentDiscoveryProfileBindingMap data, response status code and response headers
    def update_segment_discovery_binding_with_http_info(tier_1_id, segment_id, segment_discovery_profile_binding_map_id, segment_discovery_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.update_segment_discovery_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.update_segment_discovery_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.update_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map_id' when calling SegmentsApi.update_segment_discovery_binding"
      end
      # verify the required parameter 'segment_discovery_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_discovery_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_discovery_profile_binding_map' when calling SegmentsApi.update_segment_discovery_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-discovery-profile-binding-maps/{segment-discovery-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-discovery-profile-binding-map-id' + '}', segment_discovery_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_discovery_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentDiscoveryProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#update_segment_discovery_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Segment Monitoring Profile Binding Map
    # API will update Segment Monitoring Profile Binding Map.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_monitoring_profile_binding_map_id Segment Monitoring Profile Binding Map ID
    # @param segment_monitoring_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [SegmentMonitoringProfileBindingMap]
    def update_segment_monitoring_binding(tier_1_id, segment_id, segment_monitoring_profile_binding_map_id, segment_monitoring_profile_binding_map, opts = {})
      data, _status_code, _headers = update_segment_monitoring_binding_with_http_info(tier_1_id, segment_id, segment_monitoring_profile_binding_map_id, segment_monitoring_profile_binding_map, opts)
      data
    end

    # Update Segment Monitoring Profile Binding Map
    # API will update Segment Monitoring Profile Binding Map.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_monitoring_profile_binding_map_id Segment Monitoring Profile Binding Map ID
    # @param segment_monitoring_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentMonitoringProfileBindingMap, Fixnum, Hash)>] SegmentMonitoringProfileBindingMap data, response status code and response headers
    def update_segment_monitoring_binding_with_http_info(tier_1_id, segment_id, segment_monitoring_profile_binding_map_id, segment_monitoring_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.update_segment_monitoring_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.update_segment_monitoring_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.update_segment_monitoring_binding"
      end
      # verify the required parameter 'segment_monitoring_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_monitoring_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_monitoring_profile_binding_map_id' when calling SegmentsApi.update_segment_monitoring_binding"
      end
      # verify the required parameter 'segment_monitoring_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_monitoring_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_monitoring_profile_binding_map' when calling SegmentsApi.update_segment_monitoring_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-monitoring-profile-binding-maps/{segment-monitoring-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-monitoring-profile-binding-map-id' + '}', segment_monitoring_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_monitoring_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentMonitoringProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#update_segment_monitoring_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update Segment QoS Profile Binding Map
    # API will update Segment QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param segment_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [SegmentQoSProfileBindingMap]
    def update_segment_qo_s_binding(tier_1_id, segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts = {})
      data, _status_code, _headers = update_segment_qo_s_binding_with_http_info(tier_1_id, segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts)
      data
    end

    # Update Segment QoS Profile Binding Map
    # API will update Segment QoS Profile Binding Map. For objects with no binding maps, default profile is applied.
    # @param tier_1_id Tier-1 ID
    # @param segment_id Segment ID
    # @param segment_qos_profile_binding_map_id Segment QoS Profile Binding Map ID
    # @param segment_qo_s_profile_binding_map 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SegmentQoSProfileBindingMap, Fixnum, Hash)>] SegmentQoSProfileBindingMap data, response status code and response headers
    def update_segment_qo_s_binding_with_http_info(tier_1_id, segment_id, segment_qos_profile_binding_map_id, segment_qo_s_profile_binding_map, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.update_segment_qo_s_binding ...'
      end
      # verify the required parameter 'tier_1_id' is set
      if @api_client.config.client_side_validation && tier_1_id.nil?
        fail ArgumentError, "Missing the required parameter 'tier_1_id' when calling SegmentsApi.update_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.update_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qos_profile_binding_map_id' is set
      if @api_client.config.client_side_validation && segment_qos_profile_binding_map_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qos_profile_binding_map_id' when calling SegmentsApi.update_segment_qo_s_binding"
      end
      # verify the required parameter 'segment_qo_s_profile_binding_map' is set
      if @api_client.config.client_side_validation && segment_qo_s_profile_binding_map.nil?
        fail ArgumentError, "Missing the required parameter 'segment_qo_s_profile_binding_map' when calling SegmentsApi.update_segment_qo_s_binding"
      end
      # resource path
      local_var_path = '/infra/tier-1s/{tier-1-id}/segments/{segment-id}/segment-qos-profile-binding-maps/{segment-qos-profile-binding-map-id}'.sub('{' + 'tier-1-id' + '}', tier_1_id.to_s).sub('{' + 'segment-id' + '}', segment_id.to_s).sub('{' + 'segment-qos-profile-binding-map-id' + '}', segment_qos_profile_binding_map_id.to_s)

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = @api_client.object_to_http_body(segment_qo_s_profile_binding_map)
      auth_names = ['BasicAuth']
      data, status_code, headers = @api_client.call_api(:PUT, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'SegmentQoSProfileBindingMap')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#update_segment_qo_s_binding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
