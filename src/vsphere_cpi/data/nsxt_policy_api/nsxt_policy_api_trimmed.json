{
  "info": {
    "version": "3.1.0.0.0",
    "description": "VMware NSX-T Data Center Policy REST API",
    "title": "NSX-T Data Center Policy API"
  },
  "schemes": [
    "https"
  ],
  "produces": [
    "application/json"
  ],
  "securityDefinitions": {
    "BasicAuth": {
      "type": "basic",
      "description": "HTTP Basic Authentication"
    }
  },
  "host": "nsxmanager.your.domain",
  "security": [
    {
      "BasicAuth": []
    }
  ],
  "swagger": "2.0",
  "basePath": "/policy/api/v1",
  "paths": {
    "/infra/domains/{domain-id}/groups/{group-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/Group"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "If a group with the group-id is not already present, create a new group.\nIf it already exists, update the group.\nAvoid creating groups with multiple MACAddressExpression and IPAddressExpression.\nIn future releases, group will be restricted to contain a single\nMACAddressExpression and IPAddressExpression along with other expressions.\nTo group IPAddresses or MACAddresses, use nested groups instead of multiple\nIPAddressExpressions/MACAddressExpression.\n",
        "parameters": [
          {
            "description": "Domain ID",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          },
          {
            "description": "Group ID",
            "required": true,
            "type": "string",
            "name": "group-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/Group"
            },
            "required": true,
            "name": "Group",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy, Inventory, Groups, Groups"
        ],
        "summary": "Create or update a group",
        "x-vmw-nsx-module": "Policy",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateGroupForDomain"
      },
      "patch": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "If a group with the group-id is not already present, create a new group.\nIf it already exists, patch the group.\n",
        "parameters": [
          {
            "description": "Domain ID",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          },
          {
            "description": "Group ID",
            "required": true,
            "type": "string",
            "name": "group-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/Group"
            },
            "required": true,
            "name": "Group",
            "in": "body"
          }
        ],
        "tags": [
          "Policy, Inventory, Groups, Groups"
        ],
        "summary": "Patch a group",
        "x-vmw-nsx-module": "Policy",
        "consumes": [
          "application/json"
        ],
        "operationId": "PatchGroupForDomain"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/Group"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read group",
        "parameters": [
          {
            "description": "Domain ID",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          },
          {
            "description": "Group ID",
            "required": true,
            "type": "string",
            "name": "group-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy, Inventory, Groups, Groups"
        ],
        "summary": "Read group",
        "x-vmw-nsx-module": "Policy",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadGroupForDomain"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete Group",
        "parameters": [
          {
            "description": "Domain ID",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          },
          {
            "description": "Group ID",
            "required": true,
            "type": "string",
            "name": "group-id",
            "in": "path"
          },
          {
            "default": false,
            "description": "Do not delete if the group subtree has any entities",
            "type": "boolean",
            "name": "fail_if_subtree_exists",
            "in": "query"
          },
          {
            "default": false,
            "description": "Force delete the resource even if it is being used somewhere\n",
            "type": "boolean",
            "name": "force",
            "in": "query"
          }
        ],
        "tags": [
          "Policy, Inventory, Groups, Groups"
        ],
        "summary": "Delete Group",
        "x-vmw-nsx-module": "Policy",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteGroup"
      }
    },
    "/infra/domains/{domain-id}/groups/{group-id}/members/virtual-machines": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RealizedVirtualMachineListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get Virtual machines that belong to this Group.\nThis API is applicable for Groups containing VirtualMachine,member type.\nFor Groups containing other member types,an empty list is returned.\n",
        "parameters": [
          {
            "description": "Domain id",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          },
          {
            "description": "Group Id",
            "required": true,
            "type": "string",
            "name": "group-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "String Path of the enforcement point",
            "required": false,
            "type": "string",
            "name": "enforcement_point_path",
            "in": "query"
          },
          {
            "description": "Include objects that are marked for deletion in results",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "include_mark_for_delete_objects"
          },
          {
            "description": "Comma separated list of fields that should be included in query result",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy, Inventory, Groups, Group Members"
        ],
        "summary": "Get Virtual machines that belong to this Group",
        "x-vmw-nsx-module": "PolicyGroupRealization",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetGroupVMMembers"
      }
    },
    "/infra/lb-pools": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LBPoolListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Paginated list of all LBPools.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Include objects that are marked for deletion in results",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "include_mark_for_delete_objects"
          },
          {
            "description": "Comma separated list of fields that should be included in query result",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy, Networking, Network Services, Load Balancing, Load Balancer Pools"
        ],
        "summary": "List LBPools",
        "x-vmw-nsx-module": "PolicyLoadBalancer",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListLBPools"
      }
    },
    "/infra/lb-pools/{lb-pool-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LBPool"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "If a LBPool with the lb-pool-id is not already present,\ncreate a new LBPool. If it already exists, update the\nLBPool. This is a full replace.\n",
        "parameters": [
          {
            "description": "LBPool ID",
            "required": true,
            "type": "string",
            "name": "lb-pool-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/LBPool"
            },
            "required": true,
            "name": "LBPool",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy, Networking, Network Services, Load Balancing, Load Balancer Pools"
        ],
        "summary": "Create or update a LBPool",
        "x-vmw-nsx-module": "PolicyLoadBalancer",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateLBPool"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LBPool"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read a LBPool.\n",
        "parameters": [
          {
            "description": "LBPool ID",
            "required": true,
            "type": "string",
            "name": "lb-pool-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy, Networking, Network Services, Load Balancing, Load Balancer Pools"
        ],
        "summary": "Read LBPool",
        "x-vmw-nsx-module": "PolicyLoadBalancer",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadLBPool"
      },
      "patch": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "If a LBPool with the lb-pool-id is not already present,\ncreate a new LBPool. If it already exists, update the\nLBPool. This is a full replace.\n",
        "parameters": [
          {
            "description": "LBPool ID",
            "required": true,
            "type": "string",
            "name": "lb-pool-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/LBPool"
            },
            "required": true,
            "name": "LBPool",
            "in": "body"
          }
        ],
        "tags": [
          "Policy, Networking, Network Services, Load Balancing, Load Balancer Pools"
        ],
        "summary": "Create or update a LBPool",
        "x-vmw-nsx-module": "PolicyLoadBalancer",
        "consumes": [
          "application/json"
        ],
        "operationId": "PatchLBPool"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete the LBPool along with all the entities contained\nby this LBPool.\n",
        "parameters": [
          {
            "description": "LBPool ID",
            "required": true,
            "type": "string",
            "name": "lb-pool-id",
            "in": "path"
          },
          {
            "default": false,
            "description": "Force delete the resource even if it is being used somewhere\n",
            "type": "boolean",
            "name": "force",
            "in": "query"
          }
        ],
        "tags": [
          "Policy, Networking, Network Services, Load Balancing, Load Balancer Pools"
        ],
        "summary": "Delete LBPool and all the entities contained by this LBPool",
        "x-vmw-nsx-module": "PolicyLoadBalancer",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteLBPool"
      }
    },
    "/infra/realized-state/enforcement-points/{enforcement-point-name}/virtual-machines": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/SearchResponse"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "description": "Bad Request"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "This API filters objects of type virtual machines from the specified NSX Manager.\nThis API has been deprecated. Please use the new API\nGET /infra/realized-state/virtual-machines\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "enforcement-point-name",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Search DSL (domain specific language) query",
            "required": false,
            "type": "string",
            "name": "dsl",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included in query result",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "Search query",
            "required": false,
            "type": "string",
            "name": "query",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy, Infra, Realized State"
        ],
        "summary": "Listing of Virtual machines on the NSX Manager",
        "x-vmw-nsx-module": "PolicyRealizedState",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListVirtualMachinesOnEnforcementPoint"
      }
    },
    "/infra/segments/{segment-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/Segment"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "If segment with the segment-id is not already present, create a new segment.\nIf it already exists, replace the segment with this object.\n",
        "parameters": [
          {
            "description": "Segment ID",
            "required": true,
            "type": "string",
            "name": "segment-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/Segment"
            },
            "required": true,
            "name": "Segment",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy, Networking, Connectivity, Segments, Segments"
        ],
        "summary": "Create or update a infra segment",
        "x-vmw-nsx-module": "PolicyConnectivity",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateOrReplaceInfraSegment"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete infra segment",
        "parameters": [
          {
            "description": "Segment ID",
            "required": true,
            "type": "string",
            "name": "segment-id",
            "in": "path"
          }
        ],
        "tags": [
          "Policy, Networking, Connectivity, Segments, Segments"
        ],
        "summary": "Delete infra segment",
        "x-vmw-nsx-module": "PolicyConnectivity",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteInfraSegment"
      },
      "patch": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "If segment with the segment-id is not already present, create a new segment.\nIf it already exists, update the segment with specified attributes.\n",
        "parameters": [
          {
            "description": "Segment ID",
            "required": true,
            "type": "string",
            "name": "segment-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/Segment"
            },
            "required": true,
            "name": "Segment",
            "in": "body"
          }
        ],
        "tags": [
          "Policy, Networking, Connectivity, Segments, Segments"
        ],
        "summary": "Create or update a segment",
        "x-vmw-nsx-module": "PolicyConnectivity",
        "consumes": [
          "application/json"
        ],
        "operationId": "PatchInfraSegment"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/Segment"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read infra segment",
        "parameters": [
          {
            "description": "Segment ID",
            "required": true,
            "type": "string",
            "name": "segment-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy, Networking, Connectivity, Segments, Segments"
        ],
        "summary": "Read infra segment",
        "x-vmw-nsx-module": "PolicyConnectivity",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadInfraSegment"
      }
    },
    "/infra/segments/{segment-id}/ports": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/SegmentPortListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "List all the ports for an infra.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "segment-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Include objects that are marked for deletion in results",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "include_mark_for_delete_objects"
          },
          {
            "description": "Comma separated list of fields that should be included in query result",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy, Networking, Connectivity, Segments, Ports"
        ],
        "summary": "List infra segment ports",
        "x-vmw-nsx-module": "PolicyConnectivity",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListInfraSegmentPorts"
      }
    },
    "/infra/segments/{segment-id}/ports/{port-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/SegmentPort"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create an infra segment port if it does not exist based on the IDs, or update existing port\ninformation by replacing the port object already exists.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "segment-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "port-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/SegmentPort"
            },
            "required": true,
            "name": "SegmentPort",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy, Networking, Connectivity, Segments, Ports"
        ],
        "summary": "Create or update an infra segment port",
        "x-vmw-nsx-module": "PolicyConnectivity",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateOrReplaceInfraSegmentPort"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete an infra segment port by giving ID.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "segment-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "port-id",
            "in": "path"
          }
        ],
        "tags": [
          "Policy, Networking, Connectivity, Segments, Ports"
        ],
        "summary": "Delete an infra segment port",
        "x-vmw-nsx-module": "PolicyConnectivity",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteInfraSegmentPort"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/SegmentPort"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get detail information on an infra segment port by giving ID.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "segment-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "port-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy, Networking, Connectivity, Segments, Ports"
        ],
        "summary": "Get infra segment port by ID",
        "x-vmw-nsx-module": "PolicyConnectivity",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetInfraSegmentPort"
      },
      "patch": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create an infra segment port if it does not exist based on the IDs, or update existing port\ninformation by replacing the port object fields which presents in the request body.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "segment-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "port-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/SegmentPort"
            },
            "required": true,
            "name": "SegmentPort",
            "in": "body"
          }
        ],
        "tags": [
          "Policy, Networking, Connectivity, Segments, Ports"
        ],
        "summary": "Patch an infra segment port",
        "x-vmw-nsx-module": "PolicyConnectivity",
        "consumes": [
          "application/json"
        ],
        "operationId": "PatchInfraSegmentPort"
      }
    },
    "/infra/sites/{site-id}/enforcement-points/{enforcementpoint-id}/transport-zones": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/PolicyTransportZoneListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Paginated list of all Transport Zones under an Enforcement Point\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "site-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "enforcementpoint-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Include objects that are marked for deletion in results",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "include_mark_for_delete_objects"
          },
          {
            "description": "Comma separated list of fields that should be included in query result",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy, Infra, Enforcement Points"
        ],
        "summary": "List Transport Zones under an Enforcement Point",
        "x-vmw-nsx-module": "PolicyEnforcementPointManagement",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListTransportZonesForEnforcementPoint"
      }
    },
    "/infra/tier-1s/{tier-1-id}/segments/{segment-id}/ports/{port-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/SegmentPort"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a Tier-1 segment port if it does not exist based on the IDs, or update existing port\ninformation by replacing the port object already exists.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "tier-1-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "segment-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "port-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/SegmentPort"
            },
            "required": true,
            "name": "SegmentPort",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy, Networking, Connectivity, Segments, Ports"
        ],
        "summary": "Create or update a Tier-1 segment port",
        "x-vmw-nsx-module": "PolicyConnectivity",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateOrReplaceTier1SegmentPort"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a Tier-1 segment port by giving ID.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "tier-1-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "segment-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "port-id",
            "in": "path"
          }
        ],
        "tags": [
          "Policy, Networking, Connectivity, Segments, Ports"
        ],
        "summary": "Delete a Tier-1 segment port",
        "x-vmw-nsx-module": "PolicyConnectivity",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteTier1SegmentPort"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/SegmentPort"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get detail information on a Tier-1 segment port by giving ID.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "tier-1-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "segment-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "port-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy, Networking, Connectivity, Segments, Ports"
        ],
        "summary": "Get Tier-1 segment port by ID",
        "x-vmw-nsx-module": "PolicyConnectivity",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetTier1SegmentPort"
      },
      "patch": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a Tier-1 segment port if it does not exist based on the IDs, or update existing port\ninformation by replacing the port object fields which presents in the request body.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "tier-1-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "segment-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "port-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/SegmentPort"
            },
            "required": true,
            "name": "SegmentPort",
            "in": "body"
          }
        ],
        "tags": [
          "Policy, Networking, Connectivity, Segments, Ports"
        ],
        "summary": "Patch a Tier-1 segment port",
        "x-vmw-nsx-module": "PolicyConnectivity",
        "consumes": [
          "application/json"
        ],
        "operationId": "PatchTier1SegmentPort"
      }
    },
    "/infra/virtual-machine-group-associations": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/PolicyResourceReferenceForEPListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get policy groups for which the given VM is a member.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "String Path of the enforcement point",
            "required": false,
            "type": "string",
            "name": "enforcement_point_path",
            "in": "query"
          },
          {
            "description": "Include objects that are marked for deletion in results",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "include_mark_for_delete_objects"
          },
          {
            "description": "Comma separated list of fields that should be included in query result",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "Virtual machine external ID",
            "required": true,
            "type": "string",
            "name": "vm_external_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy, Inventory, Groups, Group Members"
        ],
        "summary": "Get groups for which the given VM is a member",
        "x-vmw-nsx-module": "PolicyGroupRealization",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetGroupsForVM"
      }
    },
    "/search/query": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/SearchResponse"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "description": "Bad Request"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Full text search API",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included in query result",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "Search query",
            "required": true,
            "type": "string",
            "name": "query",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Search, Search API"
        ],
        "summary": "Full text search API",
        "x-vmw-nsx-module": "Search",
        "consumes": [
          "application/json"
        ],
        "operationId": "QuerySearch"
      }
    }
  },
  "definitions": {
    "ApiError": {
      "x-vmw-nsx-module": "Common",
      "allOf": [
        {
          "$ref": "#/definitions/RelatedApiError"
        },
        {
          "x-vmw-nsx-module": "Common",
          "type": "object",
          "properties": {
            "related_errors": {
              "items": {
                "$ref": "#/definitions/RelatedApiError"
              },
              "type": "array",
              "description": "Other errors related to this error",
              "title": "Other errors related to this error"
            }
          }
        }
      ],
      "description": "Detailed information about an API Error",
      "title": "Detailed information about an API Error"
    },
    "AttachedInterfaceEntry": {
      "description": "The Attached interface is only effective for the segment port on Bare metal server.\n",
      "title": "Attached interface information for Bare metal server",
      "required": [
        "app_intf_name"
      ],
      "x-vmw-nsx-module": "PolicyConnectivity",
      "type": "object",
      "properties": {
        "routing_table": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Routing rules",
          "title": "Routing rules"
        },
        "migrate_intf": {
          "type": "string",
          "description": "IP configuration on migrate_intf will migrate to app_intf_name. It is used for Management and Application sharing the same IP.",
          "title": "Interface name to migrate"
        },
        "app_intf_name": {
          "type": "string",
          "description": "The name of application interface",
          "title": "The name of application interface"
        },
        "default_gateway": {
          "description": "Gateway IP",
          "format": "ip",
          "type": "string"
        }
      }
    },
    "BridgeProfileConfig": {
      "description": "configuration parameters for Bridge Profile",
      "title": "Bridge Profile Configuration",
      "required": [
        "vlan_transport_zone_path",
        "bridge_profile_path"
      ],
      "x-vmw-nsx-module": "PolicyConnectivity",
      "type": "object",
      "properties": {
        "uplink_teaming_policy_name": {
          "type": "string",
          "description": "The name of the switching uplink teaming policy for the bridge endpoint. This name corresponds to one fot he switching uplink teaming policy names listed in teh transport zone. When this property is not specified, the teaming policy is assigned by MP.",
          "title": "Uplink Teaming Policy Name"
        },
        "vlan_ids": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "VLAN specification for bridge endpoint. Either VLAN ID or VLAN ranges can be specified. Not both.",
          "title": "VLAN IDs"
        },
        "bridge_profile_path": {
          "type": "string",
          "description": "Same bridge profile can be configured on different segments. Each bridge profile on a segment must unique.",
          "title": "Policy path to L2 Bridge profile"
        },
        "vlan_transport_zone_path": {
          "type": "string",
          "description": "VLAN transport zone should belong to the enforcment-point as the transport zone specified in the segment.",
          "title": "Policy path to VLAN Transport Zone"
        }
      }
    },
    "ChildPolicyConfigResource": {
      "x-vmw-nsx-module": "Policy",
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "resource_type"
          ],
          "discriminator": "resource_type",
          "x-vmw-nsx-module": "Policy",
          "type": "object",
          "properties": {
            "mark_for_override": {
              "default": false,
              "type": "boolean",
              "description": "Indicates whether this object is the overridden intent object Global intent objects cannot be modified by the user. However, certain global intent objects can be overridden locally by use of this property. In such cases, the overridden local values take precedence over the globally defined values for the properties.",
              "title": "Indicates whether this object is the overridden intent object Global intent objects cannot be modified by the user. However, certain global intent objects can be overridden locally by use of this property. In such cases, the overridden local values take precedence over the globally defined values for the properties."
            },
            "resource_type": {
              "type": "string"
            },
            "marked_for_delete": {
              "default": false,
              "type": "boolean",
              "description": "If this field is set to true, delete operation is triggered on the\nintent tree. This resource along with its all children in intent tree\nwill be deleted. This is a cascade delete and should only be used if\nintent object along with its all children are to be deleted. This does\nnot support deletion of single non-leaf node within the tree and should\nbe used carefully.\n",
              "title": "Indicates whether the intent object is marked for deletion"
            }
          }
        }
      ],
      "description": "Represents an object on the desired state",
      "title": "Represents the desired state object as child resource"
    },
    "ClasslessStaticRoute": {
      "description": "DHCP classless static route option.",
      "title": "DHCP classless static route option",
      "required": [
        "next_hop",
        "network"
      ],
      "x-vmw-nsx-module": "Dhcp",
      "type": "object",
      "properties": {
        "next_hop": {
          "description": "IP address of next hop of the route.",
          "format": "ip",
          "type": "string"
        },
        "network": {
          "description": "Destination network in CIDR format.",
          "format": "address-or-block-or-range",
          "type": "string"
        }
      }
    },
    "CloudNativeServiceInstance": {
      "x-vmw-nsx-module": "InventoryCloudObj",
      "description": "Stores the information about cloud native service instance.",
      "allOf": [
        {
          "$ref": "#/definitions/DiscoveredResource"
        },
        {
          "x-vmw-nsx-module": "InventoryCloudObj",
          "type": "object",
          "properties": {
            "service_type": {
              "readOnly": true,
              "type": "string",
              "description": "Type of cloud native service.",
              "title": "Type of cloud native service; possible values are ELB, RDS"
            },
            "source": {
              "readOnly": true,
              "title": "Reference of the public cloud gateway",
              "description": "Reference of the public cloud gateway that reported the service instance.",
              "$ref": "#/definitions/ResourceReference"
            },
            "external_id": {
              "readOnly": true,
              "type": "string",
              "description": "Id of service instance fetched from public cloud.\n",
              "title": "External id of cloud native service instance in the system."
            }
          }
        }
      ]
    },
    "Condition": {
      "x-vmw-nsx-module": "Policy",
      "allOf": [
        {
          "$ref": "#/definitions/Expression"
        },
        {
          "required": [
            "operator",
            "value",
            "key",
            "member_type"
          ],
          "x-vmw-nsx-module": "Policy",
          "type": "object",
          "properties": {
            "operator": {
              "enum": [
                "EQUALS",
                "CONTAINS",
                "STARTSWITH",
                "ENDSWITH",
                "NOTEQUALS"
              ],
              "type": "string",
              "description": "operator",
              "title": "operator"
            },
            "value": {
              "minLength": 1,
              "type": "string",
              "description": "Value",
              "title": "Value"
            },
            "key": {
              "enum": [
                "Tag",
                "Name",
                "OSName",
                "ComputerName"
              ],
              "type": "string",
              "description": "Key",
              "title": "Key"
            },
            "member_type": {
              "enum": [
                "IPSet",
                "VirtualMachine",
                "LogicalPort",
                "LogicalSwitch",
                "Segment",
                "SegmentPort"
              ],
              "type": "string",
              "description": "Group member type",
              "title": "Group member type"
            }
          }
        }
      ],
      "description": "Represents the leaf level condition. Evaluation of the condition expression\nwill be case insensitive.\n",
      "title": "Represents the leaf level condition"
    },
    "ConjunctionOperator": {
      "x-vmw-nsx-module": "Policy",
      "allOf": [
        {
          "$ref": "#/definitions/Expression"
        },
        {
          "required": [
            "conjunction_operator"
          ],
          "x-vmw-nsx-module": "Policy",
          "type": "object",
          "properties": {
            "conjunction_operator": {
              "enum": [
                "OR",
                "AND"
              ],
              "type": "string",
              "description": "Conjunction Operator Node",
              "title": "Conjunction Operator Node"
            }
          }
        }
      ],
      "description": "Represents the operators AND or OR.",
      "title": "Represents the operators AND or OR"
    },
    "ConnectivityAdvancedConfig": {
      "x-vmw-nsx-module": "PolicyConnectivity",
      "type": "object",
      "description": "Advanced configuration for Policy connectivity",
      "properties": {
        "connectivity": {
          "default": "ON",
          "enum": [
            "ON",
            "OFF"
          ],
          "type": "string",
          "description": "Connectivity configuration to manually connect (ON) or disconnect (OFF)\na Tier1 segment from corresponding Tier1 gateway. Only valid for Tier1\nSegments.\nThis property is ignored for L2 VPN extended segments when subnets\nproperty is not specified.\n",
          "title": "Connectivity configuration"
        }
      },
      "title": "Advanced configuration for Policy connectivity"
    },
    "DhcpOption121": {
      "description": "DHCP option 121 to define classless static route.",
      "title": "DHCP option 121",
      "required": [
        "static_routes"
      ],
      "x-vmw-nsx-module": "Dhcp",
      "type": "object",
      "properties": {
        "static_routes": {
          "description": "Classless static route of DHCP option 121.",
          "title": "DHCP classless static routes",
          "minItems": 1,
          "items": {
            "$ref": "#/definitions/ClasslessStaticRoute"
          },
          "maxItems": 27,
          "type": "array"
        }
      }
    },
    "DhcpV4Options": {
      "x-vmw-nsx-module": "PolicyConnectivity",
      "type": "object",
      "description": "DHCP options for IPv4 server.",
      "properties": {
        "option121": {
          "title": "DHCP option 121",
          "description": "DHCP option 121 to define classless static routes.\n",
          "$ref": "#/definitions/DhcpOption121"
        },
        "others": {
          "description": "To define DHCP options other than option 121 in generic format.\nPlease note, only the following options can be defined in generic\nformat. Those other options will be accepted without validation\nbut will not take effect.\n--------------------------\n  Code    Name\n--------------------------\n    2   Time Offset\n    6   Domain Name Server\n    13  Boot File Size\n    19  Forward On/Off\n    26  MTU Interface\n    28  Broadcast Address\n    35  ARP Timeout\n    40  NIS Domain\n    41  NIS Servers\n    42  NTP Servers\n    44  NETBIOS Name Srv\n    45  NETBIOS Dist Srv\n    46  NETBIOS Node Type\n    47  NETBIOS Scope\n    58  Renewal Time\n    59  Rebinding Time\n    64  NIS+-Domain-Name\n    65  NIS+-Server-Addr\n    66  TFTP Server-Name (used by PXE)\n    67  Bootfile-Name (used by PXE)\n    93  PXE: Client system architecture\n    94  PXE: Client NDI\n    97  PXE: UUID/UNDI\n    117 Name Service Search\n    119 Domain Search\n    150 TFTP server address (used by PXE)\n    175 Etherboot\n    209 PXE Configuration File\n    210 PXE Path Prefix\n    211 PXE Reboot Time\n",
          "title": "Other DHCP options",
          "minItems": 0,
          "items": {
            "$ref": "#/definitions/GenericDhcpOption"
          },
          "maxItems": 255,
          "type": "array"
        }
      },
      "title": "DHCP options for IPv4 address family"
    },
    "DiscoveredResource": {
      "x-vmw-nsx-module": "Common",
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "required": [
            "resource_type"
          ],
          "discriminator": "resource_type",
          "x-vmw-nsx-module": "Common",
          "type": "object",
          "properties": {
            "_last_sync_time": {
              "description": "Timestamp of last modification",
              "format": "int64",
              "readOnly": true,
              "type": "integer"
            },
            "display_name": {
              "maxLength": 255,
              "type": "string",
              "description": "Defaults to ID if not set",
              "title": "Identifier to use when displaying entity in logs or GUI"
            },
            "description": {
              "maxLength": 1024,
              "type": "string",
              "description": "Description of this resource",
              "title": "Description of this resource"
            },
            "resource_type": {
              "readOnly": false,
              "type": "string",
              "description": "The type of this resource."
            },
            "tags": {
              "items": {
                "$ref": "#/definitions/Tag"
              },
              "type": "array",
              "description": "Opaque identifiers meaningful to the API user",
              "maxItems": 30,
              "title": "Opaque identifiers meaningful to the API user"
            }
          }
        }
      ],
      "description": "Base class for resources that are discovered and automatically updated",
      "title": "Base class for resources that are discovered and automatically updated"
    },
    "Expression": {
      "x-vmw-nsx-module": "Policy",
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "required": [
            "resource_type"
          ],
          "discriminator": "resource_type",
          "x-vmw-nsx-module": "Policy",
          "type": "object",
          "properties": {
            "resource_type": {
              "enum": [
                "Condition",
                "ConjunctionOperator",
                "NestedExpression",
                "IPAddressExpression",
                "MACAddressExpression",
                "ExternalIDExpression",
                "PathExpression",
                "IdentityGroupExpression"
              ],
              "type": "string"
            }
          }
        }
      ],
      "description": "All the nodes of the expression extend from this abstract class. This\nis present for extensibility.\n",
      "title": "Base class for each node of the expression"
    },
    "ExternalIDExpression": {
      "x-vmw-nsx-module": "Policy",
      "allOf": [
        {
          "$ref": "#/definitions/Expression"
        },
        {
          "required": [
            "external_ids",
            "member_type"
          ],
          "x-vmw-nsx-module": "Policy",
          "type": "object",
          "properties": {
            "external_ids": {
              "minItems": 1,
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "This array can consist of one or more external IDs for the specified member type.",
              "title": "Array of external IDs for the specified member type"
            },
            "member_type": {
              "enum": [
                "VirtualMachine",
                "VirtualNetworkInterface",
                "CloudNativeServiceInstance",
                "PhysicalServer"
              ],
              "type": "string",
              "description": "External ID member type",
              "title": "External ID member type"
            }
          }
        }
      ],
      "description": "Represents external ID expressions in the form of an array, to support addition of objects like virtual interfaces, virtual machines, CloudNativeServiceInstance PhysicalServer to a group.",
      "title": "External ID expression node"
    },
    "FederationConnectivityConfig": {
      "x-vmw-nsx-module": "PolicyConnectivity",
      "type": "object",
      "description": "Additional configuration required for federation.",
      "properties": {
        "global_overlay_id": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Global id for by Layer3 services for federation usecases.\n",
          "title": "Auto generated federation global 24-bit id"
        }
      },
      "title": "Federation connectivity configuration"
    },
    "GenericDhcpOption": {
      "description": "Define DHCP options other than option 121.",
      "title": "Generic DHCP option",
      "required": [
        "code",
        "values"
      ],
      "x-vmw-nsx-module": "Dhcp",
      "type": "object",
      "properties": {
        "code": {
          "description": "Code of the dhcp option.",
          "format": "int64",
          "title": "DHCP option code, [0-255]",
          "maximum": 255,
          "minimum": 0,
          "type": "integer"
        },
        "values": {
          "description": "Value of the option.",
          "title": "DHCP option value",
          "minItems": 1,
          "items": {
            "type": "string"
          },
          "maxItems": 10,
          "type": "array"
        }
      }
    },
    "Group": {
      "x-vmw-nsx-module": "Policy",
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "x-vmw-nsx-module": "Policy",
          "type": "object",
          "properties": {
            "state": {
              "enum": [
                "IN_PROGRESS",
                "SUCCESS",
                "FAILURE"
              ],
              "type": "string",
              "description": "Realization state of this group",
              "title": "Realization state of this group"
            },
            "extended_expression": {
              "items": {
                "$ref": "#/definitions/Expression"
              },
              "type": "array",
              "description": "Extended Expression allows additional higher level context to be\nspecified for grouping criteria. (e.g. user AD group)\nThis field allow users to specified user context as the source of a\nfirewall rule for IDFW feature.\nCurrent version only support a single IdentityGroupExpression. In the\nfuture, this might expand to support other conjunction and non-conjunction\nexpression.\n\nThe extended expression list must follow below criteria:\n1. Contains a single IdentityGroupExpression. No conjunction expression is\nsupported.\n2. No other non-conjunction expression is supported, except for\nIdentityGroupExpression.\n3. Each expression must be a valid Expression. See the definition of\nthe Expression type for more information.\n4. Extended expression are implicitly AND with expression.\n5. No nesting can be supported if this value is used.\n6. If a Group is using extended expression, this group must be the only\nmember in the source field of an communication map.\n",
              "maxItems": 1,
              "title": "Extended Expression"
            },
            "expression": {
              "items": {
                "$ref": "#/definitions/Expression"
              },
              "type": "array",
              "description": "The expression list must follow below criteria:\n  1. A non-empty expression list, must be of odd size. In a list, with\n  indices starting from 0, all non-conjunction expressions must be at\n  even indices, separated by a conjunction expression at odd\n  indices.\n  2. The total of ConditionExpression and NestedExpression in a list\n  should not exceed 5.\n  3. The total of IPAddressExpression, MACAddressExpression, external\n  IDs in an ExternalIDExpression and paths in a PathExpression must not exceed\n  500.\n  4. Each expression must be a valid Expression. See the definition of\n  the Expression type for more information.\n",
              "title": "Expression"
            },
            "reference": {
              "default": false,
              "readOnly": true,
              "type": "boolean",
              "description": "If true, indicates that this is a remote reference group. Such group will have\nspan different from the its parent domain. Default value is false.\n",
              "title": "Indicates if the group is a reference."
            }
          }
        }
      ],
      "description": "Group.",
      "title": "Group"
    },
    "GuestInfo": {
      "x-vmw-nsx-module": "Inventory",
      "type": "object",
      "description": "Guest virtual machine details include OS name and computer name of guest VM.\n",
      "properties": {
        "os_name": {
          "readOnly": true,
          "type": "string",
          "description": "OS name of guest virtual machine. Currently this is supported for guests\non ESXi that have VMware Tools installed.\n",
          "title": "OS name"
        },
        "computer_name": {
          "readOnly": true,
          "type": "string",
          "description": "Computer name of guest virtual machine, which is set inside guest OS.\nCurrently this is supported for guests on ESXi that have VMware Tools installed.\n",
          "title": "Computer name"
        }
      },
      "title": "Guest virtual machine details"
    },
    "IPAddressExpression": {
      "x-vmw-nsx-module": "Policy",
      "allOf": [
        {
          "$ref": "#/definitions/Expression"
        },
        {
          "required": [
            "ip_addresses"
          ],
          "x-vmw-nsx-module": "Policy",
          "type": "object",
          "properties": {
            "ip_addresses": {
              "description": "This array can consist of a single IP address, IP address range or a subnet. Its type can be of either IPv4 or IPv6. Both IPv4 and IPv6 addresses within one expression is not allowed. Supported list of formats are, \"192.168.1.1\", \"192.168.1.1-192.168.1.100\", \"192.168.0.0/24\", \"fe80::250:56ff:fe83:318c\", \"fe80::250:56ff:fe83:3181-fe80::250:56ff:fe83:318c\", \"fe80::250:56ff:fe83:318c/64\".",
              "title": "Array of IP addresses",
              "minItems": 1,
              "items": {
                "description": "IPElement can be a single IP address, IP address range or a Subnet. Its\ntype can be of IPv4 or IPv6. Supported list of formats are \"192.168.1.1\",\n\"192.168.1.1-192.168.1.100\", \"192.168.0.0/24\",\n\"fe80::250:56ff:fe83:318c\",\n\"fe80::250:56ff:fe83:3181-fe80::250:56ff:fe83:318c\",\n\"fe80::250:56ff:fe83:318c/64\"\n",
                "format": "address-or-block-or-range",
                "type": "string"
              },
              "maxItems": 4000,
              "type": "array"
            }
          }
        }
      ],
      "description": "Represents IP address expressions in the form of an array, to support addition of IP addresses in a group. Avoid creating groups with multiple IPAddressExpression. In future releases, group will be restricted to contain a single IPAddressExpression. To group IPAddresses, use nested groups instead of multiple IPAddressExpressions.",
      "title": "IP address expression node"
    },
    "IdentityGroupExpression": {
      "x-vmw-nsx-module": "Policy",
      "allOf": [
        {
          "$ref": "#/definitions/Expression"
        },
        {
          "required": [
            "identity_groups"
          ],
          "x-vmw-nsx-module": "Policy",
          "type": "object",
          "properties": {
            "identity_groups": {
              "description": "This array consists of set of identity group object. All members within this array are implicitly OR'ed together.",
              "title": "Array of identity group",
              "minItems": 1,
              "items": {
                "$ref": "#/definitions/IdentityGroupInfo"
              },
              "maxItems": 500,
              "type": "array"
            }
          }
        }
      ],
      "description": "Represents a list of identity group (Ad group SID) expressions.",
      "title": "IdentityGroup expression node"
    },
    "IdentityGroupInfo": {
      "description": "Identity (Directory) group",
      "title": "Identity (Directory) group",
      "required": [
        "distinguished_name",
        "domain_base_distinguished_name"
      ],
      "x-vmw-nsx-module": "PolicyIdentity",
      "type": "object",
      "properties": {
        "distinguished_name": {
          "type": "string",
          "description": "Each LDAP object is uniquely identified by its distinguished name (DN).\nA DN is a sequence of relative distinguished names (RDN) connected by commas.\ne.g. CN=Larry Cole,CN=admin,DC=corp,DC=acme,DC=com.\nA valid fully qualified distinguished name should be provided to include specific groups else\nthe create / update realization of the Group containing an invalid/ partial DN will fail.\nThis value is valid only if it matches to exactly 1 LDAP object on the LDAP server.\n",
          "title": "LDAP distinguished name"
        },
        "domain_base_distinguished_name": {
          "type": "string",
          "description": "This is the base distinguished name for the domain where this particular group\nresides. (e.g. dc=example,dc=com)\nEach active directory domain has a domain naming context\n(NC), which contains domain-specific data. The root of\nthis naming context is represented by a domain's\ndistinguished name (DN) and is typically referred to as\nthe NC head.\n",
          "title": "Identity (Directory) domain base distinguished name"
        },
        "sid": {
          "type": "string",
          "description": "A security identifier (SID) is a unique value of variable length\nused to identify a trustee. A SID consists of the following components:\nThe revision level of the SID structure;\nA 48-bit identifier authority value that identifies the\nauthority that issued the SID;\nA variable number of subauthority or relative identifier\n(RID) values that uniquely identify the trustee relative\nto the authority that issued the SID.\nThis field is only populated for Microsoft Active Directory identity store.\n",
          "title": "Identity (Directory) Group SID (security identifier)"
        }
      }
    },
    "IpAddressInfo": {
      "x-vmw-nsx-module": "Inventory",
      "type": "object",
      "description": "Ipaddress information of the fabric node.",
      "properties": {
        "source": {
          "readOnly": true,
          "enum": [
            "VM_TOOLS"
          ],
          "type": "string",
          "description": "Source of the ipaddress information.",
          "title": "Source of the ipaddress information."
        },
        "ip_addresses": {
          "items": {
            "description": "IPv4 or IPv6 address",
            "format": "ip",
            "type": "string"
          },
          "readOnly": true,
          "type": "array",
          "description": "IP Addresses of the the virtual network interface, as discovered in the source.",
          "title": "IP Addresses of the the virtual network interface, as discovered in the source."
        }
      },
      "title": "Ipaddress information of the fabric node."
    },
    "L2Extension": {
      "x-vmw-nsx-module": "PolicyConnectivity",
      "type": "object",
      "description": "Segment specific L2 VPN configuration",
      "properties": {
        "l2vpn_paths": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Policy paths corresponding to the associated L2 VPN sessions\n",
          "title": "Policy paths of associated L2 VPN sessions"
        },
        "local_egress": {
          "title": "Local Egress",
          "description": "Local Egress.",
          "$ref": "#/definitions/LocalEgress"
        },
        "l2vpn_path": {
          "type": "string",
          "description": "This property has been deprecated. Please use the property l2vpn_paths\nfor setting the paths of associated L2 VPN session. This property will\ncontinue to work as expected to provide backwards compatibility.\nHowever, when both l2vpn_path and l2vpn_paths properties\nare specified, only l2vpn_paths is used.\n",
          "x-deprecated": true,
          "title": "Policy path of associated L2 VPN session"
        },
        "tunnel_id": {
          "description": "Tunnel ID",
          "format": "int32",
          "title": "Tunnel ID",
          "maximum": 4093,
          "minimum": 1,
          "type": "integer"
        }
      },
      "title": "Segment specific L2 VPN configuration"
    },
    "LBPool": {
      "x-vmw-nsx-module": "PolicyLoadBalancer",
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "x-vmw-nsx-module": "PolicyLoadBalancer",
          "type": "object",
          "properties": {
            "active_monitor_paths": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "In case of active healthchecks, load balancer itself initiates new\nconnections (or sends ICMP ping) to the servers periodically to check\ntheir health, completely independent of any data traffic. Active\nhealthchecks are disabled by default and can be enabled for a server\npool by binding a health monitor to the pool. If multiple active\nmonitors are configured, the pool member status is UP only when the\nhealth check status for all the monitors are UP.\n",
              "title": "Active monitor path list"
            },
            "tcp_multiplexing_enabled": {
              "default": false,
              "type": "boolean",
              "description": "TCP multiplexing allows the same TCP connection between load balancer\nand the backend server to be used for sending multiple client requests\nfrom different client TCP connections.\n",
              "title": "TCP multiplexing enable flag"
            },
            "snat_translation": {
              "title": "Snat translation configuration",
              "description": "Depending on the topology, Source NAT (SNAT) may be required to ensure\ntraffic from the server destined to the client is received by the load\nbalancer. SNAT can be enabled per pool. If SNAT is not enabled for a\npool, then load balancer uses the client IP and port (spoofing) while\nestablishing connections to the servers. This is referred to as no-SNAT\nor TRANSPARENT mode.  By default Source NAT is enabled as LBSnatAutoMap.\n",
              "$ref": "#/definitions/LBSnatTranslation"
            },
            "member_group": {
              "title": "Load balancer member setting with grouping object",
              "description": "Load balancer pool support grouping object as dynamic pool members.\nWhen member group is defined, members setting should not be specified.\n",
              "$ref": "#/definitions/LBPoolMemberGroup"
            },
            "algorithm": {
              "default": "ROUND_ROBIN",
              "enum": [
                "ROUND_ROBIN",
                "WEIGHTED_ROUND_ROBIN",
                "LEAST_CONNECTION",
                "WEIGHTED_LEAST_CONNECTION",
                "IP_HASH"
              ],
              "type": "string",
              "description": "Load Balancing algorithm chooses a server for each new connection by going\nthrough the list of servers in the pool. Currently, following load balancing\nalgorithms are supported with ROUND_ROBIN as the default.\nROUND_ROBIN means that a server is selected in a round-robin fashion. The\nweight would be ignored even if it is configured.\nWEIGHTED_ROUND_ROBIN means that a server is selected in a weighted\nround-robin fashion. Default weight of 1 is used if weight is not configured.\nLEAST_CONNECTION means that a server is selected when it has the least\nnumber of connections. The weight would be ignored even if it is configured.\nSlow start would be enabled by default.\nWEIGHTED_LEAST_CONNECTION means that a server is selected in a weighted\nleast connection fashion. Default weight of 1 is used if weight is not\nconfigured. Slow start would be enabled by default.\nIP_HASH means that consistent hash is performed on the source IP address of\nthe incoming connection. This ensures that the same client IP address will\nalways reach the same server as long as no server goes down or up. It may\nbe used on the Internet to provide a best-effort stickiness to clients\nwhich refuse session cookies.\n",
              "title": "Load balancing algorithm"
            },
            "tcp_multiplexing_number": {
              "description": "The maximum number of TCP connections per pool that are idly kept alive\nfor sending future client requests.\n",
              "title": "Maximum number of TCP connections for multiplexing",
              "default": 6,
              "format": "int64",
              "maximum": 2147483647,
              "minimum": 0,
              "type": "integer"
            },
            "members": {
              "items": {
                "$ref": "#/definitions/LBPoolMember"
              },
              "type": "array",
              "description": "Server pool consists of one or more pool members. Each pool member\nis identified, typically, by an IP address and a port.\n",
              "title": "Load balancer pool members"
            },
            "passive_monitor_path": {
              "type": "string",
              "description": "Passive healthchecks are disabled by default and can be enabled by\nattaching a passive health monitor to a server pool.\nEach time a client connection to a pool member fails, its failed count\nis incremented. For pools bound to L7 virtual servers, a connection is\nconsidered to be failed and failed count is incremented if any TCP\nconnection errors (e.g. TCP RST or failure to send data) or SSL\nhandshake failures occur. For pools bound to L4 virtual servers, if no\nresponse is received to a TCP SYN sent to the pool member or if a TCP\nRST is received in response to a TCP SYN, then the pool member is\nconsidered to have failed and the failed count is incremented.\n",
              "title": "Passive monitor path"
            },
            "min_active_members": {
              "description": "A pool is considered active if there are at least certain\nminimum number of members.\n",
              "title": "Minimum number of active pool members to consider pool as active",
              "default": 1,
              "format": "int64",
              "maximum": 2147483647,
              "minimum": 1,
              "type": "integer"
            }
          }
        }
      ],
      "description": "Defining access of a Group from a LBVirtualServer and binding to\nLBMonitorProfile.\n",
      "title": "Defining access a Group from a LBVirtualServer and binding to LBMonitorProfile"
    },
    "LBPoolListResult": {
      "x-vmw-nsx-module": "PolicyLoadBalancer",
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "x-vmw-nsx-module": "PolicyLoadBalancer",
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LBPool"
              },
              "type": "array",
              "description": "LBPool list results.",
              "title": "LBPool list results"
            }
          }
        }
      ],
      "description": "Paged Collection of LBPool.",
      "title": "Paged Collection of LBPool"
    },
    "LBPoolMember": {
      "description": "Pool member.",
      "title": "Pool member",
      "required": [
        "ip_address"
      ],
      "x-vmw-nsx-module": "PolicyLoadBalancer",
      "type": "object",
      "properties": {
        "max_concurrent_connections": {
          "description": "To ensure members are not overloaded, connections to a member can be\ncapped by the load balancer. When a member reaches this limit, it is\nskipped during server selection.\nIf it is not specified, it means that connections are unlimited.\n",
          "format": "int64",
          "title": "Maximum concurrent connection number",
          "maximum": 2147483647,
          "minimum": 1,
          "type": "integer"
        },
        "admin_state": {
          "description": "Member admin state.",
          "default": "ENABLED",
          "enum": [
            "ENABLED",
            "DISABLED",
            "GRACEFUL_DISABLED"
          ],
          "type": "string"
        },
        "backup_member": {
          "default": false,
          "type": "boolean",
          "description": "Backup servers are typically configured with a sorry page indicating to\nthe user that the application is currently unavailable. While the pool\nis active (a specified minimum number of pool members are active)\nBACKUP members are skipped during server selection. When the pool is\ninactive, incoming connections are sent to only the BACKUP member(s).\n",
          "title": "Determine whether the pool member is for backup usage"
        },
        "weight": {
          "description": "Pool member weight is used for WEIGHTED_ROUND_ROBIN balancing\nalgorithm. The weight value would be ignored in other algorithms.\n",
          "title": "Pool member weight",
          "default": 1,
          "format": "int64",
          "maximum": 256,
          "minimum": 1,
          "type": "integer"
        },
        "display_name": {
          "type": "string",
          "description": "Pool member name.",
          "title": "Pool member name"
        },
        "ip_address": {
          "description": "Pool member IP address.",
          "format": "ip",
          "type": "string"
        },
        "port": {
          "description": "If port is specified, all connections will be sent to this port. Only\nsingle port is supported.\nIf unset, the same port the client connected to will be used, it could\nbe overrode by default_pool_member_port setting in virtual server.\nThe port should not specified for port range case.\n",
          "format": "port-or-range",
          "type": "string"
        }
      }
    },
    "LBPoolMemberGroup": {
      "description": "Pool member group.",
      "title": "Pool member group",
      "required": [
        "group_path"
      ],
      "x-vmw-nsx-module": "PolicyLoadBalancer",
      "type": "object",
      "properties": {
        "ip_revision_filter": {
          "default": "IPV4",
          "enum": [
            "IPV4",
            "IPV6",
            "IPV4_IPV6"
          ],
          "type": "string",
          "description": "Ip revision filter is used to filter IPv4 or IPv6 addresses from the\ngrouping object.\nIf the filter is not specified, both IPv4 and IPv6 addresses would be\nused as server IPs.\nThe link local and loopback addresses would be always filtered out.\n",
          "title": "Filter of ipv4 or ipv6 address of grouping object IP list"
        },
        "customized_members": {
          "items": {
            "$ref": "#/definitions/PoolMemberSetting"
          },
          "readOnly": false,
          "type": "array",
          "description": "The list is used to show the customized pool member settings. User can\nonly user pool member action API to update the admin state for a specific\nIP address.\n",
          "title": "List of customized pool member settings"
        },
        "max_ip_list_size": {
          "description": "The size is used to define the maximum number of grouping object IP\naddress list. These IP addresses would be used as pool members.\nIf the grouping object includes more than certain number of\nIP addresses, the redundant parts would be ignored and those IP\naddresses would not be treated as pool members.\nIf the size is not specified, one member is budgeted for this dynamic\npool so that the pool has at least one member even if some other\ndynamic pools grow beyond the capacity of load balancer service. Other\nmembers are picked according to available dynamic capacity. The unused\nmembers would be set to DISABLED so that the load balancer system\nitself is not overloaded during runtime.\n",
          "format": "int64",
          "title": "Maximum number of grouping object IP address list",
          "maximum": 2147483647,
          "minimum": 0,
          "type": "integer"
        },
        "group_path": {
          "type": "string",
          "description": "Load balancer pool support Group as dynamic pool members.\nThe IP list of the Group would be used as pool member IP setting.\n",
          "title": "Grouping object path"
        },
        "port": {
          "description": "If port is specified, all connections will be sent to this port.\nIf unset, the same port the client connected to will be used, it could\nbe overridden by default_pool_member_ports setting in virtual server.\nThe port should not specified for multiple ports case.\n",
          "format": "int32",
          "title": "Pool member port for all IP addresses of the grouping object",
          "maximum": 65535,
          "minimum": 1,
          "type": "integer"
        }
      }
    },
    "LBSnatAutoMap": {
      "x-vmw-nsx-module": "PolicyLoadBalancer",
      "allOf": [
        {
          "$ref": "#/definitions/LBSnatTranslation"
        },
        {
          "x-vmw-nsx-module": "PolicyLoadBalancer",
          "type": "object"
        }
      ],
      "description": "Snat auto map.",
      "title": "Snat auto map"
    },
    "LBSnatDisabled": {
      "x-vmw-nsx-module": "PolicyLoadBalancer",
      "allOf": [
        {
          "$ref": "#/definitions/LBSnatTranslation"
        },
        {
          "x-vmw-nsx-module": "PolicyLoadBalancer",
          "type": "object"
        }
      ],
      "description": "Snat disabled.",
      "title": "Snat disabled"
    },
    "LBSnatIpElement": {
      "description": "Snat Ip element.",
      "title": "Snat Ip element",
      "required": [
        "ip_address"
      ],
      "x-vmw-nsx-module": "PolicyLoadBalancer",
      "type": "object",
      "properties": {
        "ip_address": {
          "description": "Ip address or ip range such as 1.1.1.1 or 1.1.1.101-1.1.1.160.",
          "format": "address-or-block-or-range",
          "type": "string"
        },
        "prefix_length": {
          "format": "int64",
          "type": "integer",
          "description": "Subnet prefix length should be not specified if there is only one single\nIP address or IP range.\n",
          "title": "Subnet prefix length"
        }
      }
    },
    "LBSnatIpPool": {
      "x-vmw-nsx-module": "PolicyLoadBalancer",
      "allOf": [
        {
          "$ref": "#/definitions/LBSnatTranslation"
        },
        {
          "required": [
            "ip_addresses"
          ],
          "x-vmw-nsx-module": "PolicyLoadBalancer",
          "type": "object",
          "properties": {
            "ip_addresses": {
              "items": {
                "$ref": "#/definitions/LBSnatIpElement"
              },
              "type": "array",
              "description": "If an IP range is specified, the range may contain no more than 64\nIP addresses.\n",
              "maxItems": 64,
              "title": "List of Ip address or ip range"
            }
          }
        }
      ],
      "description": "Snat Ip pool.",
      "title": "Snat Ip pool"
    },
    "LBSnatTranslation": {
      "description": "Snat Translation.",
      "title": "Snat Translation",
      "required": [
        "type"
      ],
      "discriminator": "type",
      "x-vmw-nsx-module": "PolicyLoadBalancer",
      "type": "object",
      "properties": {
        "type": {
          "description": "Snat translation type.",
          "enum": [
            "LBSnatAutoMap",
            "LBSnatIpPool",
            "LBSnatDisabled"
          ],
          "type": "string"
        }
      }
    },
    "ListResult": {
      "x-vmw-nsx-module": "Common",
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "x-vmw-nsx-module": "Common",
          "type": "object",
          "properties": {
            "cursor": {
              "readOnly": true,
              "type": "string",
              "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
              "title": "Opaque cursor to be used for getting next page of records (supplied by current result page)"
            },
            "sort_ascending": {
              "readOnly": true,
              "type": "boolean",
              "description": "If true, results are sorted in ascending order",
              "title": "If true, results are sorted in ascending order"
            },
            "sort_by": {
              "readOnly": true,
              "type": "string",
              "description": "Field by which records are sorted",
              "title": "Field by which records are sorted"
            },
            "result_count": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Count of results found (across all pages), set only on first page",
              "title": "Count of results found (across all pages), set only on first page"
            }
          }
        }
      ],
      "description": "Base class for list results from collections",
      "title": "Base class for list results from collections"
    },
    "LocalEgress": {
      "x-vmw-nsx-module": "PolicyConnectivity",
      "type": "object",
      "description": "Local Egress is used on both server and client sites so that the gateway\nis used for N-S traffic and overhead on L2VPN tunnel is reduced.\n",
      "properties": {
        "optimized_ips": {
          "description": "Gateway IP for Local Egress. Local egress is enabled only when this\nlist is not empty.\n",
          "title": "Gateway IP for Local Egress",
          "minItems": 1,
          "items": {
            "description": "IPv4 or IPv6 address",
            "format": "ip",
            "type": "string"
          },
          "maxItems": 1,
          "type": "array"
        }
      },
      "title": "Local Egress"
    },
    "LocalEgressRoutingEntry": {
      "description": "Local egress routing policy",
      "title": "Local egress routing policy",
      "required": [
        "nexthop_address",
        "prefix_list_paths"
      ],
      "x-vmw-nsx-module": "PolicyConnectivity",
      "type": "object",
      "properties": {
        "nexthop_address": {
          "type": "string",
          "description": "Next hop address for proximity routing.\n",
          "title": "Next hop address"
        },
        "prefix_list_paths": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "The destination address of traffic matching a prefix-list is forwarded\nto the nexthop_address. Traffic matching a prefix list with Action\nDENY will be dropped.\nIndividual prefix-lists specified could have different actions.\n",
          "maxItems": 1,
          "title": "Policy path to prefix lists"
        }
      }
    },
    "MACAddressExpression": {
      "x-vmw-nsx-module": "Policy",
      "allOf": [
        {
          "$ref": "#/definitions/Expression"
        },
        {
          "required": [
            "mac_addresses"
          ],
          "x-vmw-nsx-module": "Policy",
          "type": "object",
          "properties": {
            "mac_addresses": {
              "description": "This array can consist of one or more MAC addresses.",
              "title": "Array of MAC addresses",
              "minItems": 1,
              "items": {
                "description": "A MAC address. Must be 6 pairs of hexadecimal digits, upper or lower case,\nseparated by colons or dashes. Examples: 01:23:45:67:89:ab, 01-23-45-67-89-AB.\n",
                "format": "mac-address",
                "type": "string"
              },
              "maxItems": 4000,
              "type": "array"
            }
          }
        }
      ],
      "description": "Represents MAC address expressions in the form of an array, to support addition of MAC addresses in a group. Avoid creating groups with multiple MACAddressExpression. In future releases, group will be restricted to contain a single MACAddressExpression. To group MAC addresses, use nested groups instead of multiple MACAddressExpression.",
      "title": "MAC address expression node"
    },
    "ManagedResource": {
      "x-vmw-nsx-module": "Common",
      "allOf": [
        {
          "$ref": "#/definitions/RevisionedResource"
        },
        {
          "x-vmw-nsx-module": "Common",
          "type": "object",
          "properties": {
            "_system_owned": {
              "readOnly": true,
              "type": "boolean",
              "description": "Indicates system owned resource"
            },
            "display_name": {
              "maxLength": 255,
              "type": "string",
              "description": "Defaults to ID if not set",
              "title": "Identifier to use when displaying entity in logs or GUI"
            },
            "description": {
              "maxLength": 1024,
              "type": "string",
              "description": "Description of this resource",
              "title": "Description of this resource"
            },
            "tags": {
              "items": {
                "$ref": "#/definitions/Tag"
              },
              "type": "array",
              "description": "Opaque identifiers meaningful to the API user",
              "maxItems": 30,
              "title": "Opaque identifiers meaningful to the API user"
            },
            "_create_user": {
              "readOnly": true,
              "type": "string",
              "description": "ID of the user who created this resource"
            },
            "_protection": {
              "readOnly": true,
              "type": "string",
              "description": "Protection status is one of the following:\nPROTECTED - the client who retrieved the entity is not allowed\n            to modify it.\nNOT_PROTECTED - the client who retrieved the entity is allowed\n                to modify it\nREQUIRE_OVERRIDE - the client who retrieved the entity is a super\n                   user and can modify it, but only when providing\n                   the request header X-Allow-Overwrite=true.\nUNKNOWN - the _protection field could not be determined for this\n          entity.\n",
              "title": "Indicates protection status of this resource"
            },
            "_create_time": {
              "description": "Timestamp of resource creation",
              "format": "int64",
              "readOnly": true,
              "type": "integer"
            },
            "_last_modified_time": {
              "description": "Timestamp of last modification",
              "format": "int64",
              "readOnly": true,
              "type": "integer"
            },
            "_last_modified_user": {
              "readOnly": true,
              "type": "string",
              "description": "ID of the user who last modified this resource"
            },
            "id": {
              "type": "string",
              "description": "Unique identifier of this resource",
              "title": "Unique identifier of this resource"
            },
            "resource_type": {
              "readOnly": false,
              "type": "string",
              "description": "The type of this resource."
            }
          }
        }
      ],
      "description": "Base type for resources that are managed by API clients",
      "title": "Base type for resources that are managed by API clients"
    },
    "NestedExpression": {
      "x-vmw-nsx-module": "Policy",
      "allOf": [
        {
          "$ref": "#/definitions/Expression"
        },
        {
          "required": [
            "expressions"
          ],
          "x-vmw-nsx-module": "Policy",
          "type": "object",
          "properties": {
            "expressions": {
              "minItems": 1,
              "items": {
                "$ref": "#/definitions/Expression"
              },
              "type": "array",
              "description": "Expression.",
              "title": "Expression"
            }
          }
        }
      ],
      "description": "Nested expressions is a list of condition expressions that must follow the\nbelow criteria:\n0. Only allowed expressions in a NestedExpression are Condition and\nConjunctionOperator.\n1. A non-empty expression list, must be of odd size. In a list, with\nindices starting from 0, all condition expressions must be at even indices,\nseparated by the conjunction expressions AND at odd indices.\n2. There may be at most 5 condition expressions inside a list.\n3. NestedExpressions are homogeneous in nature, i.e, all expressions inside\na nested expression must have the same member type.\n",
      "title": "NestedExpression"
    },
    "PathExpression": {
      "x-vmw-nsx-module": "Policy",
      "allOf": [
        {
          "$ref": "#/definitions/Expression"
        },
        {
          "required": [
            "paths"
          ],
          "x-vmw-nsx-module": "Policy",
          "type": "object",
          "properties": {
            "paths": {
              "minItems": 1,
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "This array can consist of one or more policy paths. Only policy paths of groups, segments and policy logical ports are allowed.",
              "title": "Array of policy paths"
            }
          }
        }
      ],
      "description": "Represents policy path expressions in the form of an array, to support addition of objects like groups, segments and policy logical ports in a group.",
      "title": "Path expression node"
    },
    "PolicyAlarmResource": {
      "x-vmw-nsx-module": "PolicyRealizedState",
      "allOf": [
        {
          "$ref": "#/definitions/PolicyResource"
        },
        {
          "x-vmw-nsx-module": "PolicyRealizedState",
          "type": "object",
          "properties": {
            "source_reference": {
              "type": "string",
              "description": "path of the object on which alarm is created",
              "title": "path of the object on which alarm is created"
            },
            "message": {
              "type": "string",
              "description": "error message to describe the issue",
              "title": "error message to describe the issue"
            },
            "error_details": {
              "title": "Detailed information about errors from an API call made to the\nenforcement point, if any.\n",
              "description": "Detailed information about errors from an API call made to the\nenforcement point, if any.\n",
              "$ref": "#/definitions/PolicyApiError"
            },
            "source_site_id": {
              "readOnly": true,
              "type": "string",
              "description": "This field will refer to the source site on which the alarm is\ngenerated. This field is populated by GM, when it receives\ncorresponding notification from LM.\n",
              "title": "source site(LM) id."
            }
          }
        }
      ],
      "description": "Alarm base class of realized policy object",
      "title": "Alarm base class of realized policy object"
    },
    "PolicyApiError": {
      "x-vmw-nsx-module": "PolicyRealizedState",
      "allOf": [
        {
          "$ref": "#/definitions/PolicyRelatedApiError"
        },
        {
          "x-vmw-nsx-module": "PolicyRealizedState",
          "type": "object",
          "properties": {
            "related_errors": {
              "items": {
                "$ref": "#/definitions/PolicyRelatedApiError"
              },
              "type": "array",
              "description": "Other errors related to this error",
              "title": "Other errors related to this error"
            }
          }
        }
      ],
      "description": "Detailed information about an API Error",
      "title": "Detailed information about an API Error"
    },
    "PolicyConfigResource": {
      "x-vmw-nsx-module": "Policy",
      "allOf": [
        {
          "$ref": "#/definitions/PolicyResource"
        },
        {
          "x-vmw-nsx-module": "Policy",
          "type": "object",
          "properties": {
            "children": {
              "items": {
                "$ref": "#/definitions/ChildPolicyConfigResource"
              },
              "type": "array",
              "description": "subtree for this type within policy tree containing nested elements.\n",
              "title": "subtree for this type within policy tree"
            },
            "overridden": {
              "default": false,
              "readOnly": true,
              "type": "boolean",
              "description": "Global intent objects cannot be modified by the user.\nHowever, certain global intent objects can be overridden locally by use\nof this property. In such cases, the overridden local values take\nprecedence over the globally defined values for the properties.\n",
              "title": "Indicates whether this object is the overridden intent object"
            },
            "marked_for_delete": {
              "default": false,
              "readOnly": true,
              "type": "boolean",
              "description": "Intent objects are not directly deleted from the system when a delete\nis invoked on them. They are marked for deletion and only when all the\nrealized entities for that intent object gets deleted, the intent object\nis deleted. Objects that are marked for deletion are not returned in\nGET call. One can use the search API to get these objects.\n",
              "title": "Indicates whether the intent object is marked for deletion"
            }
          }
        }
      ],
      "description": "Represents an object on the desired state.",
      "title": "Represents an object on the desired state"
    },
    "PolicyRealizedResource": {
      "x-vmw-nsx-module": "PolicyRealizedState",
      "allOf": [
        {
          "$ref": "#/definitions/PolicyResource"
        },
        {
          "required": [
            "state"
          ],
          "x-vmw-nsx-module": "PolicyRealizedState",
          "type": "object",
          "properties": {
            "realization_specific_identifier": {
              "type": "string",
              "description": "Realization id of this object",
              "title": "Realization id of this object"
            },
            "intent_reference": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "Desire state paths of this object",
              "title": "Desire state paths of this object"
            },
            "state": {
              "enum": [
                "UNAVAILABLE",
                "UNREALIZED",
                "REALIZED",
                "ERROR"
              ],
              "type": "string",
              "description": "Realization state of this object",
              "title": "Realization state of this object"
            },
            "realization_api": {
              "type": "string",
              "description": "Realization API of this object on enforcement point",
              "title": "Realization API of this object on enforcement point"
            },
            "alarms": {
              "items": {
                "$ref": "#/definitions/PolicyAlarmResource"
              },
              "type": "array",
              "description": "Alarm info detail",
              "title": "Alarm info detail"
            },
            "runtime_error": {
              "type": "string",
              "description": "It define the root cause for runtime error.\n",
              "title": "String representation of runtime error"
            },
            "runtime_status": {
              "type": "string",
              "description": "Possible values could be UP, DOWN, UNKNOWN, DEGRADED\nThis list is not exhaustive.\n",
              "title": "String representation of runtime status"
            }
          }
        }
      ],
      "description": "Abstract base class for all the realized policy objects",
      "title": "Abstract base class for all the realized policy objects"
    },
    "PolicyRelatedApiError": {
      "x-vmw-nsx-module": "PolicyRealizedState",
      "type": "object",
      "description": "Detailed information about errors from API call to an enforcement point",
      "properties": {
        "module_name": {
          "type": "string",
          "description": "The module name where the error occurred",
          "title": "The module name where the error occurred"
        },
        "error_message": {
          "type": "string",
          "description": "A description of the error",
          "title": "A description of the error"
        },
        "error_code": {
          "format": "int64",
          "type": "integer",
          "description": "A numeric error code",
          "title": "A numeric error code"
        },
        "details": {
          "type": "string",
          "description": "Further details about the error",
          "title": "Further details about the error"
        },
        "error_data": {
          "type": "object",
          "description": "Additional data about the error",
          "title": "Additional data about the error"
        }
      },
      "title": "Detailed information about errors from API call to an enforcement point"
    },
    "PolicyResource": {
      "x-vmw-nsx-module": "Policy",
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "x-vmw-nsx-module": "Policy",
          "type": "object",
          "properties": {
            "path": {
              "readOnly": true,
              "type": "string",
              "description": "Absolute path of this object",
              "title": "Absolute path of this object"
            },
            "parent_path": {
              "readOnly": true,
              "type": "string",
              "description": "Path of its parent",
              "title": "Path of its parent"
            },
            "unique_id": {
              "readOnly": true,
              "type": "string",
              "description": "This is a UUID generated by the GM/LM to uniquely identify\nentites in a federated environment. For entities that are\nstretched across multiple sites, the same ID will be used\non all the stretched sites.\n",
              "title": "A unique identifier assigned by the system"
            },
            "relative_path": {
              "readOnly": true,
              "type": "string",
              "description": "Path relative from its parent",
              "title": "Relative path of this object"
            }
          }
        }
      ],
      "description": "Abstract base class for all the policy objects.",
      "title": "Abstract base class for all the policy objects"
    },
    "PolicyResourceReference": {
      "x-vmw-nsx-module": "Policy",
      "allOf": [
        {
          "$ref": "#/definitions/ResourceReference"
        },
        {
          "x-vmw-nsx-module": "Policy",
          "type": "object",
          "properties": {
            "path": {
              "readOnly": true,
              "type": "string",
              "description": "Absolute path of this object.",
              "title": "Absolute path of this object"
            }
          }
        }
      ],
      "description": "Policy resource reference.",
      "title": "Policy resource reference"
    },
    "PolicyResourceReferenceForEP": {
      "x-vmw-nsx-module": "PolicyGroupRealization",
      "allOf": [
        {
          "$ref": "#/definitions/PolicyResourceReference"
        },
        {
          "x-vmw-nsx-module": "PolicyGroupRealization",
          "type": "object"
        }
      ],
      "description": "Policy resource reference for enforcement point\n",
      "title": "Policy resource reference for enforcement point"
    },
    "PolicyResourceReferenceForEPListResult": {
      "x-vmw-nsx-module": "PolicyGroupRealization",
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "x-vmw-nsx-module": "PolicyGroupRealization",
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/PolicyResourceReferenceForEP"
              },
              "type": "array",
              "description": "Paged Collection of policy resource references for enforcement point",
              "title": "Paged Collection of policy resource references for enforcement point"
            }
          }
        }
      ],
      "description": "Paginated collection of policy resource references for enforcement point\n",
      "title": "Policy resource reference list for enforcement point"
    },
    "PolicyTransportZone": {
      "x-vmw-nsx-module": "PolicyEnforcementPointManagement",
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "x-vmw-nsx-module": "PolicyEnforcementPointManagement",
          "type": "object",
          "properties": {
            "is_default": {
              "default": false,
              "type": "boolean",
              "description": "Flag to indicate if the transport zone is the default one. Only one\ntransport zone can be the default one for a given transport zone type.\n",
              "title": "Flag to indicate if the transport zone is the default one"
            },
            "tz_type": {
              "readOnly": true,
              "enum": [
                "OVERLAY_STANDARD",
                "OVERLAY_ENS",
                "VLAN_BACKED",
                "UNKNOWN"
              ],
              "type": "string",
              "description": "Transport Zone Type.\n",
              "title": "Transport Zone Type"
            },
            "nsx_id": {
              "readOnly": true,
              "type": "string",
              "description": "UUID of transport zone on NSX-T enforcement point.",
              "title": "Transport Zone UUID on NSX-T Enforcement Point"
            },
            "uplink_teaming_policy_names": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "The names of switching uplink teaming policies that all transport nodes in this transport zone support. Uplinkin teaming policies are only valid for VLAN backed transport zones.",
              "title": "Names of the switching uplink teaming policies that are supported by this transport zone."
            }
          }
        }
      ],
      "description": "Transport Zone.",
      "title": "Transport Zone"
    },
    "PolicyTransportZoneListResult": {
      "x-vmw-nsx-module": "PolicyEnforcementPointManagement",
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "x-vmw-nsx-module": "PolicyEnforcementPointManagement",
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/PolicyTransportZone"
              },
              "type": "array",
              "description": "Transport Zone list result.",
              "title": "Transport Zone List Result"
            }
          }
        }
      ],
      "description": "Paged Collection of Transport Zone",
      "title": "Paged Collection of Transport Zone"
    },
    "PoolMemberSetting": {
      "description": "The setting is used to add, update or remove pool members from pool.\nFor static pool members, admin_state, display_name and weight can be\nupdated.\nFor dynamic pool members, only admin_state can be updated.\n",
      "title": "Pool member setting",
      "required": [
        "ip_address"
      ],
      "x-vmw-nsx-module": "LoadBalancer",
      "type": "object",
      "properties": {
        "admin_state": {
          "description": "Member admin state",
          "default": "ENABLED",
          "enum": [
            "ENABLED",
            "DISABLED",
            "GRACEFUL_DISABLED"
          ],
          "type": "string"
        },
        "ip_address": {
          "description": "Pool member IP address",
          "format": "ip",
          "type": "string"
        },
        "port": {
          "description": "Pool member port number",
          "format": "port-or-range",
          "type": "string"
        },
        "weight": {
          "description": "Only applicable to static pool members. If supplied for a pool defined\nby a grouping object, update API would fail.\n",
          "format": "int64",
          "title": "Pool member weight",
          "maximum": 255,
          "minimum": 1,
          "type": "integer"
        },
        "display_name": {
          "type": "string",
          "description": "Only applicable to static pool members. If supplied for a pool defined\nby a grouping object, update API would fail.\n",
          "title": "Pool member display name"
        }
      }
    },
    "PortAddressBindingEntry": {
      "x-vmw-nsx-module": "PolicyConnectivity",
      "type": "object",
      "description": "Detailed information about static address for the port.",
      "properties": {
        "ip_address": {
          "type": "string",
          "description": "IP Address for port binding",
          "title": "IP address"
        },
        "vlan_id": {
          "type": "integer",
          "description": "VLAN ID for port binding",
          "format": "int64"
        },
        "mac_address": {
          "description": "Mac address for port binding",
          "format": "mac-address",
          "type": "string"
        }
      },
      "title": "Address binding information"
    },
    "PortAttachment": {
      "x-vmw-nsx-module": "PolicyConnectivity",
      "type": "object",
      "description": "Detail information about port attachment",
      "properties": {
        "traffic_tag": {
          "type": "integer",
          "description": "Not valid when type field is INDEPENDENT, mainly used to identify\ntraffic from different ports in container use case.\n",
          "format": "int64"
        },
        "allocate_addresses": {
          "enum": [
            "IP_POOL",
            "MAC_POOL",
            "BOTH",
            "NONE",
            "DHCP"
          ],
          "type": "string",
          "description": "Indicate how IP will be allocated for the port",
          "title": "Allocate addresses"
        },
        "hyperbus_mode": {
          "default": "DISABLE",
          "enum": [
            "ENABLE",
            "DISABLE"
          ],
          "type": "string",
          "description": "Flag to indicate if hyperbus configuration is required.",
          "title": "Hyperbus mode"
        },
        "context_type": {
          "readOnly": true,
          "enum": [
            "PARENT"
          ],
          "type": "string",
          "description": "Set to PARENT when type field is CHILD. Read only field.",
          "title": "Context Type"
        },
        "context_id": {
          "type": "string",
          "description": "If type is CHILD and the parent port is on the same segment as the child port, then this\nfield should be VIF ID of the parent port.\nIf type is CHILD and the parent port is on a different segment, then this\nfield should be policy path of the parent port.\nIf type is INDEPENDENT/STATIC, then this field should be transport node ID.\n",
          "title": "Context ID based on the type"
        },
        "evpn_vlans": {
          "description": "List of Evpn tenant VLAN IDs the Parent logical-port serves in Evpn Route-Server mode. Only effective when attachment type is PARENT and the logical-port is attached to vRouter VM.",
          "title": "Evpn tenant VLAN IDs the Parent logical-port serves.",
          "minItems": 0,
          "items": {
            "type": "string"
          },
          "maxItems": 1000,
          "type": "array"
        },
        "bms_interface_config": {
          "title": "Application interface configuration for Bare metal server",
          "description": "Indicate application interface configuration for Bare Metal Server.",
          "$ref": "#/definitions/AttachedInterfaceEntry"
        },
        "type": {
          "enum": [
            "PARENT",
            "CHILD",
            "INDEPENDENT",
            "STATIC"
          ],
          "type": "string",
          "description": "Type of port attachment. STATIC is added to replace INDEPENDENT. INDEPENDENT type and PARENT type are deprecated.",
          "title": "Attachement type"
        },
        "app_id": {
          "type": "string",
          "description": "ID used to identify/look up a child attachment behind a parent attachment\n",
          "title": "App Id"
        },
        "id": {
          "type": "string",
          "description": "VIF UUID on NSX Manager. If the attachement type is PARENT, this property is required.",
          "title": "Port attachment ID"
        }
      },
      "title": "Attachment information on the port"
    },
    "RealizedVirtualMachine": {
      "x-vmw-nsx-module": "PolicyRealizedState",
      "allOf": [
        {
          "$ref": "#/definitions/PolicyRealizedResource"
        },
        {
          "x-vmw-nsx-module": "PolicyRealizedState",
          "type": "object",
          "properties": {
            "host_id": {
              "readOnly": true,
              "type": "string",
              "description": "Id of the host on which the vm exists.",
              "title": "Id of the host on which the vm exists."
            },
            "local_id_on_host": {
              "readOnly": true,
              "type": "string",
              "description": "Id of the vm unique within the host.",
              "title": "Id of the vm unique within the host."
            },
            "power_state": {
              "readOnly": true,
              "enum": [
                "VM_RUNNING",
                "VM_STOPPED",
                "VM_SUSPENDED",
                "UNKNOWN"
              ],
              "type": "string",
              "description": "Current power state of this virtual machine in the system.",
              "title": "Current power state of this virtual machine in the system."
            },
            "compute_ids": {
              "items": {
                "type": "string"
              },
              "readOnly": true,
              "type": "array",
              "description": "List of external compute ids of the virtual machine in the format 'id-type-key:value' , list of external compute ids ['uuid:xxxx-xxxx-xxxx-xxxx', 'moIdOnHost:moref-11', 'instanceUuid:xxxx-xxxx-xxxx-xxxx']",
              "title": "List of external compute ids of the virtual machine in the format 'id-type-key:value' , list of external compute ids ['uuid:xxxx-xxxx-xxxx-xxxx', 'moIdOnHost:moref-11', 'instanceUuid:xxxx-xxxx-xxxx-xxxx']"
            }
          }
        }
      ],
      "description": "Realized Virtual Machine",
      "title": "Realized Virtual Machine"
    },
    "RealizedVirtualMachineListResult": {
      "x-vmw-nsx-module": "PolicyGroupStatistics",
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "x-vmw-nsx-module": "PolicyGroupStatistics",
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "title": "Virtual machine list result",
                "$ref": "#/definitions/RealizedVirtualMachine"
              },
              "type": "array",
              "description": "Paged Collection of VMs",
              "title": "Paged Collection of VMs"
            }
          }
        }
      ]
    },
    "RelatedApiError": {
      "x-vmw-nsx-module": "Common",
      "type": "object",
      "description": "Detailed information about a related API error",
      "properties": {
        "module_name": {
          "type": "string",
          "description": "The module name where the error occurred",
          "title": "The module name where the error occurred"
        },
        "error_message": {
          "type": "string",
          "description": "A description of the error",
          "title": "A description of the error"
        },
        "error_code": {
          "format": "int64",
          "type": "integer",
          "description": "A numeric error code",
          "title": "A numeric error code"
        },
        "details": {
          "type": "string",
          "description": "Further details about the error",
          "title": "Further details about the error"
        },
        "error_data": {
          "type": "object",
          "description": "Additional data about the error",
          "title": "Additional data about the error"
        }
      },
      "title": "Detailed information about a related API error"
    },
    "Resource": {
      "x-vmw-nsx-module": "Common",
      "type": "object",
      "description": "Base class for resources",
      "properties": {
        "_self": {
          "readOnly": true,
          "title": "Link to this resource",
          "description": "Link to this resource",
          "$ref": "#/definitions/SelfResourceLink"
        },
        "_links": {
          "items": {
            "$ref": "#/definitions/ResourceLink"
          },
          "readOnly": true,
          "type": "array",
          "description": "The server will populate this field when returing the resource. Ignored on PUT and POST.",
          "title": "References related to this resource"
        },
        "_schema": {
          "readOnly": true,
          "type": "string",
          "description": "Schema for this resource",
          "title": "Schema for this resource"
        }
      },
      "title": "Base class for resources"
    },
    "ResourceLink": {
      "x-vmw-nsx-module": "Common",
      "type": "object",
      "description": "A link to a related resource",
      "properties": {
        "action": {
          "readOnly": true,
          "type": "string",
          "description": "Optional action",
          "title": "Optional action"
        },
        "href": {
          "readOnly": true,
          "type": "string",
          "description": "Link to resource",
          "title": "Link to resource"
        },
        "rel": {
          "readOnly": true,
          "type": "string",
          "description": "Custom relation type (follows RFC 5988 where appropriate definitions exist)",
          "title": "Link relation type"
        }
      },
      "title": "A link to a related resource"
    },
    "ResourceReference": {
      "x-vmw-nsx-module": "Common",
      "type": "object",
      "description": "A weak reference to an NSX resource.",
      "properties": {
        "target_display_name": {
          "readOnly": true,
          "maxLength": 255,
          "type": "string",
          "description": "Display name of the NSX resource.",
          "title": "Target display name"
        },
        "is_valid": {
          "readOnly": true,
          "type": "boolean",
          "description": "Will be set to false if the referenced NSX resource has been deleted.",
          "title": "Target validity"
        },
        "target_id": {
          "readOnly": false,
          "maxLength": 64,
          "type": "string",
          "description": "Identifier of the NSX resource.",
          "title": "Target ID"
        },
        "target_type": {
          "readOnly": false,
          "maxLength": 255,
          "type": "string",
          "description": "Type of the NSX resource.",
          "title": "Target type"
        }
      }
    },
    "RevisionedResource": {
      "x-vmw-nsx-module": "Common",
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "x-vmw-nsx-module": "Common",
          "type": "object",
          "properties": {
            "_revision": {
              "format": "int32",
              "type": "integer",
              "description": "The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected.",
              "title": "Generation of this resource config"
            }
          }
        }
      ],
      "description": "A base class for types that track revisions",
      "title": "A base class for types that track revisions"
    },
    "SearchResponse": {
      "x-vmw-nsx-module": "Search",
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "x-vmw-nsx-module": "Search",
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "type": "object"
              },
              "readOnly": true,
              "type": "array",
              "description": "List of records matching the search query.",
              "title": "Search results"
            }
          }
        }
      ],
      "description": "Search response",
      "title": "SearchResponse"
    },
    "Segment": {
      "x-vmw-nsx-module": "PolicyConnectivity",
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "x-vmw-nsx-module": "PolicyConnectivity",
          "type": "object",
          "properties": {
            "subnets": {
              "items": {
                "$ref": "#/definitions/SegmentSubnet"
              },
              "type": "array",
              "description": "Subnet configuration. Max 1 subnet",
              "title": "Subnet configuration. Max 1 subnet"
            },
            "connectivity_path": {
              "type": "string",
              "description": "Policy path to the connecting Tier-0 or Tier-1. Valid only for\nsegments created under Infra.\n",
              "title": "Policy path to the connecting Tier-0 or Tier-1"
            },
            "extra_configs": {
              "items": {
                "$ref": "#/definitions/SegmentExtraConfig"
              },
              "type": "array",
              "description": "This property could be used for vendor specific configuration in key value\nstring pairs, the setting in extra_configs will be automatically inheritted\nby segment ports in the Segment.\n",
              "title": "Extra configs on Segment"
            },
            "advanced_config": {
              "title": "Advanced configuration for Segment",
              "description": "Advanced configuration for Segment.\n",
              "$ref": "#/definitions/SegmentAdvancedConfig"
            },
            "address_bindings": {
              "description": "Static address binding used for the Segment. This field is deprecated and will be removed in a future release. Please use address_bindings in SegmentPort to configure static bindings.",
              "title": "Address bindings for the Segment",
              "items": {
                "$ref": "#/definitions/PortAddressBindingEntry"
              },
              "x-deprecated": true,
              "maxItems": 512,
              "type": "array"
            },
            "federation_config": {
              "readOnly": true,
              "title": "Federation releated config",
              "description": "Additional config for federation.",
              "$ref": "#/definitions/FederationConnectivityConfig"
            },
            "evpn_tenant_config_path": {
              "type": "string",
              "description": "Policy path to the EvpnTenantConfig resource. Supported only for Route-Server Evpn Mode.\nSupported only for Overlay Segments. This will be populated for both Parent and Child segments\nparticipating in Evpn Route-Server Mode.\n",
              "title": "Policy path to the EvpnTenantConfig"
            },
            "mac_pool_id": {
              "type": "string",
              "description": "Mac pool id that associated with a Segment.",
              "title": "Allocation mac pool associated with the Segment"
            },
            "bridge_profiles": {
              "items": {
                "$ref": "#/definitions/BridgeProfileConfig"
              },
              "type": "array",
              "description": "Multiple distinct L2 bridge profiles can be configured.",
              "title": "Bridge Profile Configuration"
            },
            "vlan_ids": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "VLAN ids for a VLAN backed Segment.\nCan be a VLAN id or a range of VLAN ids specified with '-' in between.\n",
              "title": "VLAN ids for VLAN backed Segment"
            },
            "domain_name": {
              "type": "string",
              "description": "DNS domain name",
              "title": "DNS domain name"
            },
            "overlay_id": {
              "description": "Used for overlay connectivity of segments. The overlay_id\nshould be allocated from the pool as definied by enforcement-point.\nIf not provided, it is auto-allocated from the default pool on the\nenforcement-point.\n",
              "format": "int32",
              "title": "Overlay connectivity ID for this Segment",
              "maximum": 2147483647,
              "minimum": 0,
              "type": "integer"
            },
            "dhcp_config_path": {
              "type": "string",
              "description": "Policy path to DHCP server or relay configuration to use for all\nIPv4 & IPv6 subnets configured on this segment.\n",
              "title": "Policy path to DHCP configuration"
            },
            "ls_id": {
              "type": "string",
              "description": "This property is deprecated. The property will continue to work as\nexpected for existing segments. The segments that are newly created\nwith ls_id will be ignored.\nSepcify pre-creted logical switch id for Segment.\n",
              "x-deprecated": true,
              "title": "Pre-created logical switch id for Segment"
            },
            "evpn_segment": {
              "readOnly": true,
              "type": "boolean",
              "description": "Flag to indicate if the Segment is a Child-Segment of type EVPN.",
              "title": "Evpn Segment Flag."
            },
            "admin_state": {
              "default": "UP",
              "enum": [
                "UP",
                "DOWN"
              ],
              "type": "string",
              "description": "Represents Desired state of the Segment",
              "title": "Represents Desired state of the Segment"
            },
            "metadata_proxy_paths": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "Policy path to metadata proxy configuration. Multiple distinct MD proxies can be configured.",
              "title": "Metadata Proxy Configuration Paths"
            },
            "type": {
              "readOnly": true,
              "enum": [
                "ROUTED",
                "EXTENDED",
                "ROUTED_AND_EXTENDED",
                "DISCONNECTED"
              ],
              "type": "string",
              "description": "Segment type based on configuration.\n",
              "title": "Segment type"
            },
            "l2_extension": {
              "title": "Configuration for extending Segment through L2 VPN",
              "description": "Configuration for extending Segment through L2 VPN",
              "$ref": "#/definitions/L2Extension"
            },
            "transport_zone_path": {
              "type": "string",
              "description": "Policy path to the transport zone. Supported for VLAN backed segments\nas well as Overlay Segments.\n- This field is required for VLAN backed Segments.\n- For overlay Segments, it is auto assigned if only one transport zone\n  exists in the enforcement point. Default transport zone is auto\n  assigned for  overlay segments if none specified.\n",
              "title": "Policy path to the transport zone"
            },
            "replication_mode": {
              "default": "MTEP",
              "enum": [
                "MTEP",
                "SOURCE"
              ],
              "type": "string",
              "description": "If this field is not set for overlay segment, then the default of MTEP\nwill be used.\n",
              "title": "Replication mode of the Segment"
            }
          }
        }
      ],
      "description": "Segment configuration to attach workloads.\n",
      "title": "Segment configuration"
    },
    "SegmentAdvancedConfig": {
      "x-vmw-nsx-module": "PolicyConnectivity",
      "allOf": [
        {
          "$ref": "#/definitions/ConnectivityAdvancedConfig"
        },
        {
          "x-vmw-nsx-module": "PolicyConnectivity",
          "type": "object",
          "properties": {
            "local_egress_routing_policies": {
              "minItems": 1,
              "items": {
                "$ref": "#/definitions/LocalEgressRoutingEntry"
              },
              "type": "array",
              "description": "An ordered list of routing policies to forward traffic to the next hop.\n",
              "title": "Local egress routing policies"
            },
            "multicast": {
              "type": "boolean",
              "description": "Enable multicast on the downlink LRP created to connect the segment to Tier0/Tier1 gateway.\n\nEnabled by default, even when segment.advanced_config property is not specified.\n",
              "title": "Enable multicast on the downlink"
            },
            "inter_router": {
              "default": false,
              "type": "boolean",
              "description": "When set to true, any port attached to this logical switch will\nnot be visible through VC/ESX UI\n",
              "title": "Flag to indicate if the logical switch will provide inter-router connectivity"
            },
            "uplink_teaming_policy_name": {
              "type": "string",
              "description": "The name of the switching uplink teaming policy for the Segment. This name corresponds to one of the switching uplink teaming policy names listed in TransportZone associated with the Segment. See transport_zone_path property above for more details. When this property is not specified, the segment will not have a teaming policy associated with it and the host switch's default teaming policy will be used by MP.",
              "title": "Uplink Teaming Policy Name"
            },
            "address_pool_paths": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "Policy path to IP address pools.\n",
              "maxItems": 1,
              "title": "Policy path to IP address pools"
            },
            "ndra_profile_path": {
              "type": "string",
              "description": "This profile is applie dto the downlink logical router port created\nwhile attaching this semgnet to tier-0 or tier-1. If this field is\nempty, NDRA profile of the router is applied to the newly created\nport.\n",
              "title": "Policy path of Neighbor Discovery Router Advertisement profile"
            },
            "hybrid": {
              "default": false,
              "type": "boolean",
              "description": "When set to true, all the ports created on this segment will behave\nin a hybrid fashion. The hybrid port indicates to NSX that the\nVM intends to operate in underlay mode, but retains the ability to\nforward egress traffic to the NSX overlay network.\nThis property is only applicable for segment created with transport\nzone type OVERLAY_STANDARD.\nThis property cannot be modified after segment is created.\n",
              "title": "Flag to identify a hybrid logical switch"
            },
            "urpf_mode": {
              "default": "STRICT",
              "enum": [
                "NONE",
                "STRICT"
              ],
              "type": "string",
              "description": "This URPF mode is applied to the downlink logical router port created\nwhile attaching this segment to tier-0 or tier-1.\n",
              "title": "Unicast Reverse Path Forwarding mode"
            },
            "local_egress": {
              "default": false,
              "type": "boolean",
              "description": "This property is used to enable proximity routing with local egress.\nWhen set to true, logical router interface (downlink) connecting\nSegment to Tier0/Tier1 gateway is configured with prefix-length 32.\n",
              "title": "Flag to enable local egress"
            }
          }
        }
      ],
      "description": "Advanced configuration for Segment",
      "title": "Advanced configuration for Segment"
    },
    "SegmentDhcpConfig": {
      "description": "DHCP IPv4 and IPv6 configurations are extended from this abstract class.\n",
      "title": "DHCP configuration for segment subnet",
      "required": [
        "resource_type"
      ],
      "discriminator": "resource_type",
      "x-vmw-nsx-module": "PolicyConnectivity",
      "type": "object",
      "properties": {
        "server_address": {
          "description": "IP address of the DHCP server in CIDR format.\nThe server_address is mandatory in case this segment has provided a\ndhcp_config_path and it represents a DHCP server config.\nIf this SegmentDhcpConfig is a SegmentDhcpV4Config, the address must\nbe an IPv4 address. If this is a SegmentDhcpV6Config, the address must\nbe an IPv6 address.\nThis address must not overlap the ip-ranges of the subnet, or the\ngateway address of the subnet, or the DHCP static-binding addresses\nof this segment.\n",
          "format": "ip-cidr-block",
          "type": "string"
        },
        "dns_servers": {
          "items": {
            "description": "IPv4 or IPv6 address",
            "format": "ip",
            "type": "string"
          },
          "type": "array",
          "description": "IP address of DNS servers for subnet. DNS server IP address must\nbelong to the same address family as segment gateway_address\nproperty.\n",
          "maxItems": 2,
          "title": "DNS servers for subnet"
        },
        "lease_time": {
          "description": "DHCP lease time in seconds. When specified, this property overwrites\nlease time configured DHCP server config.\n",
          "title": "DHCP lease time for subnet",
          "default": 86400,
          "format": "int64",
          "maximum": 4294967295,
          "minimum": 60,
          "type": "integer"
        },
        "resource_type": {
          "enum": [
            "SegmentDhcpV4Config",
            "SegmentDhcpV6Config"
          ],
          "type": "string"
        }
      }
    },
    "SegmentDhcpV4Config": {
      "x-vmw-nsx-module": "PolicyConnectivity",
      "allOf": [
        {
          "$ref": "#/definitions/SegmentDhcpConfig"
        },
        {
          "x-vmw-nsx-module": "PolicyConnectivity",
          "type": "object",
          "properties": {
            "options": {
              "title": "DHCP options",
              "description": "IPv4 DHCP options for segment subnet.\n",
              "$ref": "#/definitions/DhcpV4Options"
            }
          }
        }
      ],
      "description": "DHCP configuration of IPv4 subnet in a segment",
      "title": "DHCP configuration of IPv4 subnet in a segment"
    },
    "SegmentDhcpV6Config": {
      "x-vmw-nsx-module": "PolicyConnectivity",
      "allOf": [
        {
          "$ref": "#/definitions/SegmentDhcpConfig"
        },
        {
          "x-vmw-nsx-module": "PolicyConnectivity",
          "type": "object",
          "properties": {
            "excluded_ranges": {
              "description": "Excluded addresses to define dynamic ip allocation ranges.",
              "title": "Excluded range of IPv6 addresses",
              "minItems": 0,
              "items": {
                "description": "IPElement can be a single IP address, IP address range or a Subnet. Its\ntype can be of IPv4 or IPv6. Supported list of formats are \"192.168.1.1\",\n\"192.168.1.1-192.168.1.100\", \"192.168.0.0/24\",\n\"fe80::250:56ff:fe83:318c\",\n\"fe80::250:56ff:fe83:3181-fe80::250:56ff:fe83:318c\",\n\"fe80::250:56ff:fe83:318c/64\"\n",
                "format": "address-or-block-or-range",
                "type": "string"
              },
              "maxItems": 128,
              "type": "array"
            },
            "sntp_servers": {
              "items": {
                "description": "IPv6 address",
                "format": "ipv6",
                "type": "string"
              },
              "type": "array",
              "description": "IPv6 address of SNTP servers for subnet.\n",
              "maxItems": 2,
              "title": "SNTP servers for subnet"
            },
            "preferred_time": {
              "description": "The length of time that a valid address is preferred. When the\npreferred lifetime expires, the address becomes deprecated.\n",
              "format": "int64",
              "title": "Preferred time",
              "maximum": 4294967295,
              "minimum": 60,
              "type": "integer"
            },
            "domain_names": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "Domain names for subnet.\n",
              "title": "Domain names for subnet"
            }
          }
        }
      ],
      "description": "DHCP configuration of IPv6 subnet in a segment",
      "title": "DHCP configuration of IPv6 subnet in a segment"
    },
    "SegmentExtraConfig": {
      "description": "Segment extra config is intended for supporting vendor specific configuration on the\ndata path, it can be set as key value string pairs on either segment or segment port.\n",
      "title": "Vendor specific configuration on segment or Segment port",
      "required": [
        "config_pair"
      ],
      "x-vmw-nsx-module": "PolicyConnectivity",
      "type": "object",
      "properties": {
        "config_pair": {
          "title": "Key value pair in string for the configuration",
          "description": "Key value pair in string for the configuration",
          "$ref": "#/definitions/UnboundedKeyValuePair"
        }
      }
    },
    "SegmentPort": {
      "x-vmw-nsx-module": "PolicyConnectivity",
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "x-vmw-nsx-module": "PolicyConnectivity",
          "type": "object",
          "properties": {
            "init_state": {
              "enum": [
                "UNBLOCKED_VLAN",
                "RESTORE_VIF"
              ],
              "type": "string",
              "description": "Set initial state when a new logical port is created. 'UNBLOCKED_VLAN'\nmeans new port will be unblocked on traffic in creation, also VLAN will\nbe set with corresponding logical switch setting. This port setting\ncan only be configured at port creation, and cannot be modified.\n'RESTORE_VIF' fetches and restores VIF attachment from ESX host.\n",
              "title": "Initial state of this logical ports"
            },
            "admin_state": {
              "default": "UP",
              "enum": [
                "UP",
                "DOWN"
              ],
              "type": "string",
              "description": "Represents desired state of the segment port",
              "title": "Represents desired state of the segment port"
            },
            "attachment": {
              "title": "VIF attachment",
              "description": "Only VIF attachment is supported",
              "$ref": "#/definitions/PortAttachment"
            },
            "extra_configs": {
              "items": {
                "$ref": "#/definitions/SegmentExtraConfig"
              },
              "type": "array",
              "description": "This property could be used for vendor specific configuration in key value\nstring pairs. Segment port setting will override segment setting if\nthe same key was set on both segment and segment port.\n",
              "title": "Extra configs on segment port"
            },
            "ignored_address_bindings": {
              "description": "IP Discovery module uses various mechanisms to discover address\nbindings being used on each segment port. If a user would like to\nignore any specific discovered address bindings or prevent the\ndiscovery of a particular set of discovered bindings, then those\naddress bindings can be provided here. Currently IP range in CIDR format\nis not supported.\n",
              "title": "Address bindings to be ignored by IP Discovery module",
              "minItems": 0,
              "items": {
                "$ref": "#/definitions/PortAddressBindingEntry"
              },
              "maxItems": 16,
              "type": "array"
            },
            "address_bindings": {
              "items": {
                "$ref": "#/definitions/PortAddressBindingEntry"
              },
              "type": "array",
              "description": "Static address binding used for the port.",
              "maxItems": 512,
              "title": "Address bindings for the port"
            },
            "source_site_id": {
              "readOnly": true,
              "type": "string",
              "description": "This field will refer to the source site on which the segment\nport is discovered. This field is populated by GM, when it\nreceives corresponding notification from LM.\n",
              "title": "source site(LM) id."
            }
          }
        }
      ],
      "description": "Policy port will create LogicalPort on LogicalSwitch corresponding to the Segment. Address bindings cannot be removed after realization.",
      "title": "Policy port object for segment"
    },
    "SegmentPortListResult": {
      "x-vmw-nsx-module": "PolicyConnectivity",
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "x-vmw-nsx-module": "PolicyConnectivity",
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/SegmentPort"
              },
              "type": "array",
              "description": "Place holder for the list result",
              "title": "SegmentPort list results"
            }
          }
        }
      ],
      "description": "List SegmentPort objects",
      "title": "Paged collection of SegmentPort"
    },
    "SegmentSubnet": {
      "x-vmw-nsx-module": "PolicyConnectivity",
      "type": "object",
      "description": "Subnet configuration for segment",
      "properties": {
        "dhcp_config": {
          "title": "Additional DHCP configuration",
          "description": "Additional DHCP configuration for current subnet.\n",
          "$ref": "#/definitions/SegmentDhcpConfig"
        },
        "gateway_address": {
          "format": "ip-cidr-block",
          "type": "string",
          "description": "Gateway IP address in CIDR format for both IPv4 and IPv6.\n",
          "title": "Gateway IP address."
        },
        "dhcp_ranges": {
          "minItems": 1,
          "items": {
            "description": "IPElement can be a single IP address, IP address range or a Subnet. Its\ntype can be of IPv4 or IPv6. Supported list of formats are \"192.168.1.1\",\n\"192.168.1.1-192.168.1.100\", \"192.168.0.0/24\",\n\"fe80::250:56ff:fe83:318c\",\n\"fe80::250:56ff:fe83:3181-fe80::250:56ff:fe83:318c\",\n\"fe80::250:56ff:fe83:318c/64\"\n",
            "format": "address-or-block-or-range",
            "type": "string"
          },
          "type": "array",
          "description": "DHCP address ranges are used for dynamic IP allocation.\nSupports address range and CIDR formats. First valid\nhost address from the first value is assigned to DHCP server\nIP address. Existing values cannot be deleted or modified,\nbut additional DHCP ranges can be added.\n",
          "title": "DHCP address ranges for dynamic IP allocation"
        },
        "network": {
          "readOnly": true,
          "type": "string",
          "description": "Network CIDR for this subnet calculated from gateway_addresses and\nprefix_len.\n",
          "title": "Network CIDR for subnet"
        }
      },
      "title": "Subnet configuration for segment"
    },
    "SelfResourceLink": {
      "x-vmw-nsx-module": "Common",
      "allOf": [
        {
          "$ref": "#/definitions/ResourceLink"
        },
        {
          "x-vmw-nsx-module": "Common",
          "type": "object"
        }
      ],
      "description": "The server will populate this field when returing the resource. Ignored on PUT and POST.",
      "title": "Link to this resource"
    },
    "Tag": {
      "x-vmw-nsx-module": "Common",
      "type": "object",
      "description": "Arbitrary key-value pairs that may be attached to an entity",
      "properties": {
        "scope": {
          "description": "Tag searches may optionally be restricted by scope",
          "title": "Tag scope",
          "default": "",
          "readOnly": false,
          "maxLength": 128,
          "type": "string"
        },
        "tag": {
          "default": "",
          "readOnly": false,
          "type": "string",
          "description": "Identifier meaningful to user with maximum length of 256 characters",
          "title": "Tag value"
        }
      },
      "title": "Arbitrary key-value pairs that may be attached to an entity"
    },
    "UnboundedKeyValuePair": {
      "description": "A key-value pair with no limitations on size",
      "title": "A key-value pair with no limitations on size",
      "required": [
        "value",
        "key"
      ],
      "x-vmw-nsx-module": "Common",
      "type": "object",
      "properties": {
        "value": {
          "readOnly": false,
          "type": "string",
          "description": "Value",
          "title": "Value"
        },
        "key": {
          "readOnly": false,
          "type": "string",
          "description": "Key",
          "title": "Key"
        }
      }
    },
    "VirtualMachine": {
      "x-vmw-nsx-module": "Inventory",
      "allOf": [
        {
          "$ref": "#/definitions/DiscoveredResource"
        },
        {
          "x-vmw-nsx-module": "Inventory",
          "required": [
            "local_id_on_host",
            "external_id",
            "power_state",
            "compute_ids"
          ],
          "type": "object",
          "properties": {
            "source": {
              "title": "Reference of the Host or Public Cloud Gateway that reported the VM",
              "description": "Reference of the Host or Public Cloud Gateway that reported the VM",
              "$ref": "#/definitions/ResourceReference"
            },
            "local_id_on_host": {
              "type": "string",
              "description": "Id of the vm unique within the host.",
              "title": "Id of the vm unique within the host."
            },
            "type": {
              "readOnly": true,
              "enum": [
                "EDGE",
                "SERVICE",
                "REGULAR"
              ],
              "type": "string",
              "description": "Virtual Machine type; Edge, Service VM or other.",
              "title": "Virtual Machine type; Edge, Service VM or other."
            },
            "guest_info": {
              "title": "Guest virtual machine details",
              "description": "Guest virtual machine details include OS name, computer name of guest VM. Currently\nthis is supported for guests on ESXi that have VMware Tools installed.\n",
              "$ref": "#/definitions/GuestInfo"
            },
            "power_state": {
              "enum": [
                "VM_RUNNING",
                "VM_STOPPED",
                "VM_SUSPENDED",
                "UNKNOWN"
              ],
              "type": "string",
              "description": "Current power state of this virtual machine in the system.",
              "title": "Current power state of this virtual machine in the system."
            },
            "compute_ids": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "List of external compute ids of the virtual machine in the format 'id-type-key:value' , list of external compute ids ['uuid:xxxx-xxxx-xxxx-xxxx', 'moIdOnHost:moref-11', 'instanceUuid:xxxx-xxxx-xxxx-xxxx']",
              "title": "List of external compute ids of the virtual machine in the format 'id-type-key:value' , list of external compute ids ['uuid:xxxx-xxxx-xxxx-xxxx', 'moIdOnHost:moref-11', 'instanceUuid:xxxx-xxxx-xxxx-xxxx']"
            },
            "host_id": {
              "type": "string",
              "description": "Id of the host in which this virtual machine exists.",
              "title": "Id of the host in which this virtual machine exists."
            },
            "external_id": {
              "type": "string",
              "description": "Current external id of this virtual machine in the system.",
              "title": "Current external id of this virtual machine in the system."
            }
          }
        }
      ]
    },
    "VirtualNetworkInterface": {
      "x-vmw-nsx-module": "Inventory",
      "allOf": [
        {
          "$ref": "#/definitions/DiscoveredResource"
        },
        {
          "x-vmw-nsx-module": "Inventory",
          "required": [
            "device_key",
            "owner_vm_id",
            "vm_local_id_on_host",
            "mac_address",
            "host_id",
            "external_id"
          ],
          "type": "object",
          "properties": {
            "mac_address": {
              "type": "string",
              "description": "MAC address of the virtual network interface.",
              "title": "MAC address of the virtual network interface."
            },
            "owner_vm_type": {
              "readOnly": true,
              "enum": [
                "EDGE",
                "SERVICE",
                "REGULAR"
              ],
              "type": "string",
              "description": "Owner virtual machine type; Edge, Service VM or other.",
              "title": "Owner virtual machine type; Edge, Service VM or other."
            },
            "device_key": {
              "type": "string",
              "description": "Device key of the virtual network interface.",
              "title": "Device key of the virtual network interface."
            },
            "host_id": {
              "type": "string",
              "description": "Id of the host on which the vm exists.",
              "title": "Id of the host on which the vm exists."
            },
            "owner_vm_id": {
              "type": "string",
              "description": "Id of the vm to which this virtual network interface belongs.",
              "title": "Id of the vm to which this virtual network interface belongs."
            },
            "vm_local_id_on_host": {
              "type": "string",
              "description": "Id of the vm unique within the host.",
              "title": "Id of the vm unique within the host."
            },
            "external_id": {
              "type": "string",
              "description": "External Id of the virtual network inferface.",
              "title": "External Id of the virtual network inferface."
            },
            "lport_attachment_id": {
              "type": "string",
              "description": "LPort Attachment Id of the virtual network interface.",
              "title": "LPort Attachment Id of the virtual network interface."
            },
            "ip_address_info": {
              "items": {
                "$ref": "#/definitions/IpAddressInfo"
              },
              "type": "array",
              "description": "IP Addresses of the the virtual network interface, from various sources.",
              "title": "IP Addresses of the the virtual network interface, from various sources."
            },
            "device_name": {
              "type": "string",
              "description": "Device name of the virtual network interface.",
              "title": "Device name of the virtual network interface."
            }
          }
        }
      ]
    }
  },
  "parameters": {},
  "responses": {
    "NotExtended": {
      "description": "Not Extended",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "RequestTimeout": {
      "description": "Request Timeout",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "RequestEntityTooLarge": {
      "description": "Request Entity Too Large",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "EnhanceYourCalm": {
      "description": "Enhance Your Calm",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "NetworkAuthenticationRequired": {
      "description": "Network Authentication Required",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "Conflict": {
      "description": "Conflict",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "ExpectationFailed": {
      "description": "Expectation Failed",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "PaymentRequired": {
      "description": "Payment Required",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "PreconditionRequired": {
      "description": "Precondition Required",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "BandwidthLimitExceeded": {
      "description": "Bandwidth Limit Exceeded",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "ReservedforWebDAV": {
      "description": "Reserved for WebDAV",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "RequestedRangeNotSatisfiable": {
      "description": "Requested Range Not Satisfiable",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "InsufficientStorage": {
      "description": "Insufficient Storage",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "NotFound": {
      "description": "Not Found",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "InternalServerError": {
      "description": "Internal Server Error",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "ClientClosedRequest": {
      "description": "Client Closed Request",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "UpgradeRequired": {
      "description": "Upgrade Required",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "MethodNotAllowed": {
      "description": "Method Not Allowed",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "LengthRequired": {
      "description": "Length Required",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "UnavailableForLegalReasons": {
      "description": "Unavailable For Legal Reasons",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "Iamateapot": {
      "description": "I am a teapot",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "FailedDependency": {
      "description": "Failed Dependency",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "GatewayTimeout": {
      "description": "Gateway Timeout",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "NoResponse": {
      "description": "No Response",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "ServiceUnavailable": {
      "description": "Service Unavailable",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "UnsupportedMediaType": {
      "description": "Unsupported Media Type",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "Locked": {
      "description": "Locked",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "BadGateway": {
      "description": "Bad Gateway",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "BadRequest": {
      "description": "Bad Request",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "NotAcceptable": {
      "description": "Not Acceptable",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "HTTPVersionNotSupported": {
      "description": "HTTP Version Not Supported",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "UnprocessableEntity": {
      "description": "Unprocessable Entity",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "RetryWith": {
      "description": "Retry With",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "NotImplemented": {
      "description": "Not Implemented",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "Request-URITooLong": {
      "description": "Request-URI Too Long",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "Unauthorized": {
      "description": "Unauthorized",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "PreconditionFailed": {
      "description": "Precondition Failed",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "LoopDetected": {
      "description": "Loop Detected",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "Gone": {
      "description": "Gone",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "Forbidden": {
      "description": "Forbidden",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "TooManyRequests": {
      "description": "Too Many Requests",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "BlockedbyWindowsParentalControls": {
      "description": "Blocked by Windows Parental Controls",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "ProxyAuthenticationRequired": {
      "description": "Proxy Authentication Required",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "VariantAlsoNegotiates": {
      "description": "Variant Also Negotiates",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "RequestHeaderFieldsTooLarge": {
      "description": "Request Header Fields Too Large",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    }
  }
}
