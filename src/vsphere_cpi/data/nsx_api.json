{
  "info": {
    "version": "1.0.0",
    "description": "VMware NSX REST API",
    "title": "NSX API"
  },
  "schemes": [
    "https"
  ],
  "produces": [
    "application/json"
  ],
  "basePath": "/api/v1",
  "securityDefinitions": {
    "BasicAuth": {
      "type": "basic",
      "description": "HTTP Basic Authentication"
    }
  },
  "host": "nsxmanager.your.domain",
  "security": [
    {
      "BasicAuth": []
    }
  ],
  "swagger": "2.0",
  "paths": {
    "/hpm/features/{feature-stack-name}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FeatureStackCollectionConfiguration"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Apply the data collection configuration for the specified\nfeature stack.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "feature-stack-name",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/FeatureStackCollectionConfiguration"
            },
            "required": true,
            "name": "FeatureStackCollectionConfiguration",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Aggregation Service"
        ],
        "summary": "Update health performance monitoring configuration for feature stack",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateFeatureStackConfiguration"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FeatureStackCollectionConfiguration"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the complete set of client type data collection\nconfiguration records for the specified feature stack.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "feature-stack-name",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Aggregation Service"
        ],
        "summary": "Read health performance monitoring configuration for feature stack",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetFeatureStackConfiguration"
      }
    },
    "/logical-switches/{lswitch-id}/vtep-table": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/VtepListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the virtual tunnel endpoint table of a specified logical switch\nfrom the given transport node if a transport node id is given in the\nquery parameter, from the Central Controller Plane.\nThe query parameter \"source=cached\" is not supported.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "lswitch-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "TransportNode Id",
            "required": false,
            "type": "string",
            "name": "transport_node_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Get virtual tunnel endpoint table for logical switch of the given\nID (lswitch-id)\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalSwitchVtepTable"
      }
    },
    "/app-discovery/sessions/{session-id}/installed-apps": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AppInfoListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the details of the installed apps for the app profile ID in that session\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "session-id",
            "in": "path"
          },
          {
            "type": "string",
            "name": "app_profile_id",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "type": "string",
            "name": "vm_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "App Discovery"
        ],
        "summary": "Returns the details of the installed apps for the app profile ID in that session",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetAppDiscoverySessionInstalledApps"
      }
    },
    "/mac-sets/{mac-set-id}/members/{mac-address}": {
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Remove an individual MAC address from a MACSet\n",
        "parameters": [
          {
            "description": "MACSet Id",
            "required": true,
            "type": "string",
            "name": "mac-set-id",
            "in": "path"
          },
          {
            "description": "MAC address to be removed",
            "required": true,
            "type": "string",
            "name": "mac-address",
            "in": "path"
          }
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Remove a MAC address from given MACSet",
        "consumes": [
          "application/json"
        ],
        "operationId": "RemoveMACAddress"
      }
    },
    "/ipfix-obs-points/switch-global": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IpfixObsPointConfig"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update global switch IPFIX export configuration",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/IpfixObsPointConfig"
            },
            "required": true,
            "name": "IpfixObsPointConfig",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Update global switch IPFIX export configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateSwitchIpfixConfig"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IpfixObsPointConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read global switch IPFIX export configuration",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Read global switch IPFIX export configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetSwitchIpfixConfig"
      }
    },
    "/logical-routers/{logical-router-id}/routing/static-routes": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/StaticRoute"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Adds a new static route on a Logical Router\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/StaticRoute"
            },
            "required": true,
            "name": "StaticRoute",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Add Static Routes on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddStaticRoute"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/StaticRouteListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about configured static routes, including the\nnetwork address and next hops for each static route.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Paginated List of Static Routes",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListStaticRoutes"
      }
    },
    "/cluster/nodes/{node-id}/network/interfaces": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeInterfacePropertiesListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the number of interfaces on the node and detailed\ninformation about each interface. Interface information includes MTU,\nbroadcast and host IP addresses, link and admin status, MAC address, network\nmask, and the IP configuration method (static or DHCP).\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "List the specified node's Network Interfaces",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListClusterNodeInterfaces"
      }
    },
    "/node/services/syslog/exporters": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/NodeSyslogExporterProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Adds a rule for exporting syslog information to a specified server. The\nrequired parameters are the rule name (exporter_name); severity level\n(emerg, alert, crit, and so on); transmission protocol (TCP or UDP); and\nserver IP address or hostname. The optional parameters are the syslog port\nnumber, which can be 1 through 65,535 (514, by default); facility level to\nuse when logging messages to syslog (kern, user, mail, and so on); and\nmessage IDs (msgids), which identify the types of messages to export.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/NodeSyslogExporterProperties"
            },
            "required": true,
            "name": "NodeSyslogExporterProperties",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Add node syslog exporter",
        "consumes": [
          "application/json"
        ],
        "operationId": "PostNodeSyslogExporter"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeSyslogExporterPropertiesListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the collection of registered syslog exporter rules, if any. The\nrules specify the collector IP address and port, and the protocol to use.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "List node syslog exporters",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListNodeSyslogExporters"
      }
    },
    "/upgrade/nodes-summary": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeSummaryList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get summary of nodes",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Get summary of nodes",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetNodesSummary"
      }
    },
    "/traceflows/{traceflow-id}": {
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete the Traceflow round",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "traceflow-id",
            "in": "path"
          }
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Delete the Traceflow round",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteTraceflow"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/Traceflow"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get the Traceflow round status and result summary",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "traceflow-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Get the Traceflow round status and result summary",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetTraceflow"
      }
    },
    "/node/services/cm-inventory?action=stop": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the manager service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the manager service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateCminventoryServiceActionStop"
      }
    },
    "/logical-routers": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/LogicalRouter"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a logical router. The required parameters are router_type (TIER0 or\nTIER1) and edge_cluster_id (TIER0 only). Optional parameters include\ninternal and external transit network addresses.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/LogicalRouter"
            },
            "required": true,
            "name": "LogicalRouter",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Create a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateLogicalRouter"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalRouterListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all logical routers, including the UUID, internal\nand external transit network addresses, and the router type (TIER0 or\nTIER1). You can get information for only TIER0 routers or only the TIER1\nrouters by including the router_type query parameter.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "enum": [
              "TIER0",
              "TIER1"
            ],
            "description": "Type of Logical Router",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "router_type"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "List Logical Routers",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListLogicalRouters"
      }
    },
    "/logical-routers/{logical-router-id}/routing/forwarding-table": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalRouterRouteTable"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the FIB for the logical router on a node of the given transport-node-id.\nQuery parameter \"transport_node_id=<transport-node-id>\" is required.\nTo filter the result by network address, paramter \"network_prefix=<a.b.c.d/mask>\"\nneeds to be specified.\nThe query parameter \"source=cached\" is not supported.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "IPv4 CIDR Block",
            "format": "ipv4-cidr-block",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "network_prefix"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "TransportNode Id",
            "required": true,
            "type": "string",
            "name": "transport_node_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Get FIB table on a specified node for a logical router",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalRouterForwardingTable"
      }
    },
    "/logical-routers/{logical-router-id}/routing/route-maps": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RouteMap"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Adds a new RouteMap on a Logical Router\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/RouteMap"
            },
            "required": true,
            "name": "RouteMap",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Add RouteMap on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddRouteMap"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RouteMapListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Paginated List of RouteMaps",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Paginated List of RouteMaps",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListRouteMaps"
      }
    },
    "/node/network": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeNetworkProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read network configuration properties",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read network configuration properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNetworkProperties"
      }
    },
    "/dhcp/servers/{server-id}/ip-pools": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/DhcpIpPool"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create an IP pool for a DHCP server",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "server-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/DhcpIpPool"
            },
            "required": true,
            "name": "DhcpIpPool",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Create an IP pool for a DHCP server",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateDhcpIpPool"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DhcpIpPoolListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get a paginated list of a DHCP server's IP pools",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "server-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get a paginated list of a DHCP server's IP pools",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListDhcpIpPools"
      }
    },
    "/cluster/nodes/{node-id}/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ClusterNodeStatus"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read Cluster Node Status",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read Cluster Node Status",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadClusterNodeStatus"
      }
    },
    "/eula/content": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/EULAContent"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Return the content of end user license agreement in the specified format.\nBy default, it's pure string without line break\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "End User License Agreement content output format",
            "type": "string",
            "name": "format",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Licensing"
        ],
        "summary": "Return the content of end user license agreement\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetEULAContent"
      }
    },
    "/node/services/mgmt-plane-bus?action=restart": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the Rabbit MQ service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the Rabbit MQ service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateRabbitMQServiceActionRestart"
      }
    },
    "/app-discovery/sessions/{session-id}/re-classify": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AppDiscoverySessionResultSummary"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Re-classify completed application discovery session against input \nAppProfiles. If no AppProfiles are specified then we use the previous \nAppProfiles of that session.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "session-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/SessionReclassificationParameter"
            },
            "required": true,
            "name": "SessionReclassificationParameter",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "App Discovery"
        ],
        "summary": "Re-classify a completed application discovery session.",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReclassifyAppDiscoverySession"
      }
    },
    "/logical-routers/{logical-router-id}/nat/rules/{rule-id}/statistics": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NatStatisticsPerRule"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the summation of statistics from all nodes for the Specified\nLogical Router NAT Rule. Query parameter \"source=realtime\" is the only supported source.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "rule-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Get the statistics of a specified logical router NAT Rule",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetNatStatisticsPerRule"
      }
    },
    "/dhcp/server-profiles": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/DhcpProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a DHCP server profile",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/DhcpProfile"
            },
            "required": true,
            "name": "DhcpProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Create a DHCP server profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateDhcpProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DhcpProfileListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get a paginated list of DHCP server profiles",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get a paginated list of DHCP server profiles",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListDhcpProfiles"
      }
    },
    "/infra/realized-state/enforcement-points/{enforcement-point-name}/services/nsservices/{nsservice-name}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RealizedNSService"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read a NSService.\n",
        "parameters": [
          {
            "description": "Enforcement Point Name",
            "required": true,
            "type": "string",
            "name": "enforcement-point-name",
            "in": "path"
          },
          {
            "description": "NSService Name",
            "required": true,
            "type": "string",
            "name": "nsservice-name",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Read NSService",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNSServiceRealizedState"
      }
    },
    "/logical-routers/{logical-router-id}/routing/route-table?format=csv": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalRouterRouteTableInCsvFormat"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deprecated - Please use /logical-routers/<logical-router-id>/routing/routing-table for RIB and\n/logical-routers/<logical-router-id>/routing/forwarding-table for FIB.\nReturns the route table in CSV format for the logical router on a node of the given\ntransport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required.\nThe query parameter \"source=cached\" is not supported.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "TransportNode Id",
            "required": true,
            "type": "string",
            "name": "transport_node_id",
            "in": "query"
          }
        ],
        "produces": [
          "text/csv"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Get route table on a node for a logical router",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalRouterRouteTableInCsvFormatCsv"
      }
    },
    "/network-encryption/key-policies/{key-policy-id}/stats": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneKeyPolicyStats"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get the statistics for a network encryption key policy",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "key-policy-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get the statistics for a network encryption key policy",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetDneKeyPolicyStats"
      }
    },
    "/node/network/name-servers": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeNameServersProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies the list of servers that the NSX Manager node uses to look up IP\naddresses associated with given domain names. If DHCP is configured, this\nmethod returns a 409 CONFLICT error, because DHCP manages the list of name\nservers.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/NodeNameServersProperties"
            },
            "required": true,
            "name": "NodeNameServersProperties",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Update the NSX Manager's Name Servers",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateNodeNameServers"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeNameServersProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the list of servers that the NSX Manager node uses to look up IP\naddresses associated with given domain names.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read the NSX Manager's Name Servers",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNodeNameServers"
      }
    },
    "/ns-services/{ns-service-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NSService"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Updates the specified NSService. Modifiable parameters include the description,\ndisplay_name and the NSService element. The system defined NSServices can't be\nmodified\n",
        "parameters": [
          {
            "description": "NSService Id",
            "required": true,
            "type": "string",
            "name": "ns-service-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/NSService"
            },
            "required": true,
            "name": "NSService",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Update NSService",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateNSService"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes the specified NSService. By default, if the NSService is being\nreferred in an NSServiceGroup, it can't be deleted. In such situations,\npass \"force=true\" as a parameter to force delete the NSService. System\ndefined NSServices can't be deleted using \"force\" flag.\n",
        "parameters": [
          {
            "description": "NSService Id",
            "required": true,
            "type": "string",
            "name": "ns-service-id",
            "in": "path"
          },
          {
            "default": false,
            "description": "Force delete the resource even if it is being used somewhere\n",
            "type": "boolean",
            "name": "force",
            "in": "query"
          }
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Delete NSService",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteNSService"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NSService"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the specified NSService\n",
        "parameters": [
          {
            "description": "NSService Id",
            "required": true,
            "type": "string",
            "name": "ns-service-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Read NSService",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNSService"
      }
    },
    "/aaa/roles/{role}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RoleWithFeatures"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get role information",
        "parameters": [
          {
            "description": "Role Name",
            "required": true,
            "type": "string",
            "name": "role",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Aaa"
        ],
        "summary": "Get role information",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetRoleInfo"
      }
    },
    "/cluster/nodes": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/ClusterNodeConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Adds a new management node or controller node to the NSX cluster. A single\nnode can perform one role, either management or control, not both.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/AddClusterNodeSpec"
            },
            "required": true,
            "name": "AddClusterNodeSpec",
            "in": "body"
          },
          {
            "required": true,
            "type": "string",
            "name": "action",
            "enum": [
              "add_cluster_node"
            ],
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Add a Node to the Cluster",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddClusterNode"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ClusterNodeConfigListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all NSX cluster nodes.",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "List Cluster Node Configurations",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListClusterNodeConfigs"
      }
    },
    "/node/file-store/{file-name}?action=copy_to_remote_file": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "504": {
            "description": "Gateway Timeout"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Copy a file in the file store to a remote server. If you use scp or\nsftp, you must provide the remote server's SSH fingerprint. See the\n<i>NSX-T Administration Guide</i> for information and instructions\nabout finding the SSH fingerprint.\n",
        "parameters": [
          {
            "description": "Destination filename",
            "required": true,
            "type": "string",
            "name": "file-name",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/CopyToRemoteFileProperties"
            },
            "required": true,
            "name": "CopyToRemoteFileProperties",
            "in": "body"
          }
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Copy file in the file store to a remote file store",
        "consumes": [
          "application/json"
        ],
        "operationId": "CopyToRemoteFileCopy_to_remote_file"
      }
    },
    "/license": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/License"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deprecated. Use the POST /licenses API instead\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/License"
            },
            "required": true,
            "name": "License",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Licensing"
        ],
        "summary": "Deprecated. Assign an Updated Enterprise License Key\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateLicense"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/License"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deprecated. Use the GET /licenses API instead.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Licensing"
        ],
        "summary": "Deprecated. Return the Enterprise License\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLicense"
      }
    },
    "/logical-routers/{logical-router-id}/routing/static-routes/bfd-peers/{bfd-peer-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/StaticHopBfdPeer"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies the static route BFD peer.\nModifiable parameters includes peer IP, enable flag and configuration of the BFD peer.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "bfd-peer-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/StaticHopBfdPeer"
            },
            "required": true,
            "name": "StaticHopBfdPeer",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Update a static route BFD peer",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateStaticHopBfdPeer"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/StaticHopBfdPeer"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read the BFD peer having specified ID.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "bfd-peer-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Read a static route BFD peer",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadStaticHopBfdPeer"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes the specified BFD peer present on specified logical router.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "bfd-peer-id",
            "in": "path"
          },
          {
            "default": false,
            "description": "Force delete the resource even if it is being used somewhere\n",
            "type": "boolean",
            "name": "force",
            "in": "query"
          }
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Delete a specified static route BFD peer cofigured on a specified logical router",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteStaticHopBfdPeer"
      }
    },
    "/pools/vni-pools": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/VniPoolListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the default and configured virtual\nnetwork identifier (VNI) pools for use when building logical network\nsegments. Each virtual network has a unique ID called a VNI. Instead\nof creating a new VNI each time you need a new logical switch, you\ncan instead allocate a VNI from a VNI pool. VNI pools are sometimes\ncalled segment ID pools. Each VNI pool has a range of usable VNIs. By\ndefault, there is one pool with the range 5000 through 65535. To\ncreate multiple smaller pools, specify a smaller range for each\npool, such as 5000-5200 and 5201-5400. The VNI range determines\nthe maximum number of logical switches that can be created in each\nnetwork segment.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "List VNI Pools",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListVNIPools"
      }
    },
    "/node/file-store/{file-name}/data": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FileProperties"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Replace file contents",
        "parameters": [
          {
            "description": "Name of the file to replace",
            "required": true,
            "type": "string",
            "name": "file-name",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Replace file contents",
        "consumes": [
          "application/octet-stream"
        ],
        "operationId": "UpdateFile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read file contents",
        "parameters": [
          {
            "description": "Name of the file to read",
            "required": true,
            "type": "string",
            "name": "file-name",
            "in": "path"
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read file contents",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadFile"
      }
    },
    "/upgrade/upgrade-unit-groups": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/UpgradeUnitGroup"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a group",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/UpgradeUnitGroup"
            },
            "required": true,
            "name": "UpgradeUnitGroup",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Create a group",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateUpgradeUnitGroup"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/UpgradeUnitGroupListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Return information of all upgrade unit groups",
        "parameters": [
          {
            "description": "Component type based on which upgrade unit groups to be filtered",
            "required": false,
            "type": "string",
            "name": "component_type",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "Flag indicating whether to return summary",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "summary"
          },
          {
            "description": "Synchronize before returning upgrade unit groups",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "sync"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Return information of all upgrade unit groups",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetUpgradeUnitGroups"
      }
    },
    "/transport-zones/{zone-id}/transport-node-status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TransportNodeStatusListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read status of transport nodes in a transport zone",
        "parameters": [
          {
            "description": "ID of transport zone",
            "required": true,
            "type": "string",
            "name": "zone-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "Transport node",
            "enum": [
              "UP",
              "DOWN",
              "DEGRADED",
              "UNKNOWN"
            ],
            "type": "string",
            "name": "status",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Read status of transport nodes in a transport zone",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListTransportNodeStatusForTransportZone"
      }
    },
    "/node/services/nsx-upgrade-agent?action=restart": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the NSX upgrade agent service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the NSX upgrade agent service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateNsxUpgradeAgentServiceActionRestart"
      }
    },
    "/loadbalancer/application-profiles/{application-profile-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbAppProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a load balancer application profile.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "application-profile-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/LbAppProfile"
            },
            "required": true,
            "name": "LbAppProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update a load balancer application profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateLoadBalancerApplicationProfile"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a load balancer application profile.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "application-profile-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Delete a load balancer application profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteLoadBalancerApplicationProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbAppProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Retrieve a load balancer application profile.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "application-profile-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Retrieve a load balancer application profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadLoadBalancerApplicationProfile"
      }
    },
    "/node/services/search/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read NSX Search service status",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read NSX Search service status",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadSearchServiceStatus"
      }
    },
    "/node/services/ntp?action=restart": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the NTP service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the NTP service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateNTPServiceActionRestart"
      }
    },
    "/node/services/manager?action=restart": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateProtonServiceActionRestart"
      }
    },
    "/node/services/snmp": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeSnmpServiceProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update SNMP service properties",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/NodeSnmpServiceProperties"
            },
            "required": true,
            "name": "NodeSnmpServiceProperties",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Update SNMP service properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateSNMPService"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read SNMP service properties",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read SNMP service properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadSNMPService"
      }
    },
    "/infra/realized-state/enforcement-points/{enforcement-point-name}/ip-sets/ip-sets-nsxt": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RealizedIPSetListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Paginated list of all Realized IPSets\n",
        "parameters": [
          {
            "description": "Enforcement Point Name",
            "required": true,
            "type": "string",
            "name": "enforcement-point-name",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "List IPSets",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListIPSetRealizedStates"
      }
    },
    "/pools/mac-pools": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/MacPoolListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns a list of all the MAC pools\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "List MAC Pools",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListMacPools"
      }
    },
    "/firewall/sections": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/FirewallSection"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates new empty firewall section in the system.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/FirewallSection"
            },
            "required": true,
            "name": "FirewallSection",
            "in": "body"
          },
          {
            "in": "query",
            "description": "Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.",
            "required": false,
            "maxLength": 64,
            "type": "string",
            "name": "id"
          },
          {
            "enum": [
              "insert_top",
              "insert_bottom",
              "insert_after",
              "insert_before"
            ],
            "description": "Operation",
            "default": "insert_top",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "operation"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Create a New Empty Section",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddSection"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FirewallSectionListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "List all firewall section in paginated form. A default page size is limited\nto 1000 firewall sections. By default list of section is filtered by LAYER3\ntype.\n",
        "parameters": [
          {
            "description": "AppliedTo's  referenced by this section or section's Firewall Rules .",
            "required": false,
            "type": "string",
            "name": "applied_tos",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Destinations referenced by this section's Firewall Rules .",
            "required": false,
            "type": "string",
            "name": "destinations",
            "in": "query"
          },
          {
            "enum": [
              "NSGroup",
              "LogicalSwitch",
              "LogicalRouter",
              "LogicalPort"
            ],
            "description": "Resource type valid for use as AppliedTo filter in section API",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "exclude_applied_to_type"
          },
          {
            "enum": [
              "FILTER",
              "SEARCH"
            ],
            "description": "Filter type",
            "default": "FILTER",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "filter_type"
          },
          {
            "enum": [
              "NSGroup",
              "LogicalSwitch",
              "LogicalRouter",
              "LogicalPort"
            ],
            "description": "Resource type valid for use as AppliedTo filter in section API",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "include_applied_to_type"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "NSService referenced by this section's Firewall Rules .",
            "required": false,
            "type": "string",
            "name": "services",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "Sources referenced by this section's Firewall Rules .",
            "required": false,
            "type": "string",
            "name": "sources",
            "in": "query"
          },
          {
            "enum": [
              "LAYER2",
              "LAYER3"
            ],
            "description": "Section Type",
            "default": "LAYER3",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "type"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "List All Firewall Sections",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListSections"
      }
    },
    "/mac-sets/{mac-set-id}/members": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/MACAddressElement"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Add an individual MAC address to a MACSet\n",
        "parameters": [
          {
            "description": "MAC Set Id",
            "required": true,
            "type": "string",
            "name": "mac-set-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/MACAddressElement"
            },
            "required": true,
            "name": "MACAddressElement",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Add a MAC address to a MACSet",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddMACAddress"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/MACAddressElementListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "List all MAC addresses in a MACSet\n",
        "parameters": [
          {
            "description": "MAC Set Id",
            "required": true,
            "type": "string",
            "name": "mac-set-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Get all MACAddresses in a MACSet",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetMACAddresses"
      }
    },
    "/logical-routers/{logical-router-id}/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalRouterStatus"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns status for the Logical Router of the given id.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Get the status for the Logical Router of the given id",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalRouterStatus"
      }
    },
    "/cluster/restore/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ClusterRestoreStatus"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/ClusterRestoreStatus"
            }
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "description": "Service Unavailable",
            "schema": {
              "$ref": "#/definitions/ClusterRestoreStatus"
            }
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns status information for the specified NSX cluster restore request.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Query Restore Request Status",
        "consumes": [
          "application/json"
        ],
        "operationId": "QueryClusterRestoreStatus"
      }
    },
    "/csm/aws/gateway-amis": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AwsGatewayAmiInfo"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Registers a AWS Gateway AMI for the region specified in the body. One can\nregister only one gateway AMI ID per region. If a gateway AMI is already\nregistered with a region, user is expected to use update API to overwrite\nthe registerd AMI for a region.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/AwsGatewayAmiInfo"
            },
            "required": true,
            "name": "AwsGatewayAmiInfo",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Registers a AWS Gateway AMI for the region specified in the body. One can\nregister only one gateway AMI ID per region. If a gateway AMI is already\nregistered with a region, user is expected to use update API to overwrite\nthe registerd AMI for a region.\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "RegisterAwsGatewayAmi"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AwsGatewayAmisListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns a list of Aws Gateway Amis",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "Identifier for region based on which list of AWS Gateway AMIs\nwill be obtained\n",
            "required": false,
            "type": "string",
            "name": "region_id",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Returns a list of Aws Gateway Amis",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListAwsGatewayAmis"
      }
    },
    "/trust-management": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TrustManagementData"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the supported algorithms and key sizes.",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Return the Properties of a Trust Manager",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetTrustObjects"
      }
    },
    "/logical-routers/{logical-router-id}/routing/ip-prefix-lists": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IPPrefixList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Adds a new IPPrefixList on a Logical Router\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/IPPrefixList"
            },
            "required": true,
            "name": "IPPrefixList",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Add IPPrefixList on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddIPPrefixList"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IPPrefixListListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Paginated List of IPPrefixLists",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Paginated List of IPPrefixLists",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListIPPrefixLists"
      }
    },
    "/infra/deployment-zones/{deployment-zone-id}/enforcement-points": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/EnforcementPointListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Paginated list of all enforcementpoints for infra.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "deployment-zone-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "List enforcementpoints for infra",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListEnforcementPointForInfra"
      }
    },
    "/loadbalancer/server-ssl-profiles": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbServerSslProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a load balancer server-ssl profile.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/LbServerSslProfile"
            },
            "required": true,
            "name": "LbServerSslProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Create a load balancer server-ssl profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateLoadBalancerServerSslProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbServerSslProfileListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Retrieve a paginated list of load balancer server-ssl profiles.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Retrieve a paginated list of load balancer server-ssl profiles",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListLoadBalancerServerSslProfiles"
      }
    },
    "/csm/aws/key-pairs": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AwsKeyPairList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns a list of Aws Key Pairs",
        "parameters": [
          {
            "description": "Identifier for account based on which list of key pairs will be obtained\n",
            "required": true,
            "type": "string",
            "name": "account_id",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "Identifier for region based on which list of key pairs will be obtained\n",
            "required": true,
            "type": "string",
            "name": "region_id",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Returns a list of Aws Key Pairs",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListAwsKeyPairs"
      }
    },
    "/cluster/backups/history": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BackupOperationHistory"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get history of previous backup operations\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Get backup history",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetBackupHistory"
      }
    },
    "/hpm/features/{feature-stack-name}?action=reset_collection_frequency": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FeatureStackCollectionConfiguration"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Reset the data collection frequency configuration setting to the default values",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "feature-stack-name",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "action",
            "enum": [
              "reset_collection_frequency"
            ],
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Aggregation Service"
        ],
        "summary": "Reset the data collection frequency configuration setting to the default values",
        "consumes": [
          "application/json"
        ],
        "operationId": "ResetAggregationServiceFeatureStackConfigurationReset_collection_frequency"
      }
    },
    "/fabric/nodes/{node-id}/modules": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/SoftwareModuleResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get the module details of a Fabric Node",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Get the module details of a Fabric Node",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetFabricNodeModules"
      }
    },
    "/fabric/virtual-machines?action=update_tags": {
      "post": {
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update tags applied to the virtual machine. External id of the virtual machine will be specified in the request body. Request body should contain all the tags to be applied. To clear all tags, provide an empty list. User can apply maximum 10 tags on a virtual machine. The remaining 5 are reserved for system defined tags.",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/VirtualMachineTagUpdate"
            },
            "required": true,
            "name": "VirtualMachineTagUpdate",
            "in": "body"
          }
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Update tags applied to a virtual machine",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateVirtualMachineTagsUpdate_tags"
      }
    },
    "/upgrade/upgrade-unit-groups/{group-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/UpgradeUnitGroup"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update the upgrade unit group",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "group-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/UpgradeUnitGroup"
            },
            "required": true,
            "name": "UpgradeUnitGroup",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Update the upgrade unit group",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateUpgradeUnitGroup"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "description": "Bad Request"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete the upgrade unit group",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "group-id",
            "in": "path"
          }
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Delete the upgrade unit group",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteUpgradeUnitGroup"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/UpgradeUnitGroup"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Return upgrade unit group information",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "group-id",
            "in": "path"
          },
          {
            "description": "Flag indicating whether to return the summary",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "summary"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Return upgrade unit group information",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetUpgradeUnitGroup"
      }
    },
    "/eula/acceptance": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/EULAAcceptance"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Return the acceptance status of end user license agreement\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Licensing"
        ],
        "summary": "Return the acceptance status of end user license agreement\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetEULAAcceptance"
      }
    },
    "/upgrade/version-whitelist": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AcceptableComponentVersionList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get whitelist of versions for different components",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Get the version whitelist",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetVersionWhitelist"
      }
    },
    "/node/services/liagent?action=stop": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the liagent service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the liagent service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateLiagentServiceActionStop"
      }
    },
    "/node/services/ntp": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeNtpServiceProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update NTP service properties",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/NodeNtpServiceProperties"
            },
            "required": true,
            "name": "NodeNtpServiceProperties",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Update NTP service properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateNTPService"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeNtpServiceProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read NTP service properties",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read NTP service properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNTPService"
      }
    },
    "/csm/aws/gateways/{vpc-id}/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AwsGatewayStatus"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns status information for primary gateway and secondary gateway\nfor the vpc, if exists.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "vpc-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Returns status information for primary gateway and secondary gateway\nfor the vpc, if exists.\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetAwsGatewayStatus"
      }
    },
    "/loadbalancer/services/{service-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbService"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a load balancer service.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/LbService"
            },
            "required": true,
            "name": "LbService",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update a load balancer service",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateLoadBalancerService"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a load balancer service.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Delete a load balancer service",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteLoadBalancerService"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbService"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Retrieve a load balancer service.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Retrieve a load balancer service",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadLoadBalancerService"
      }
    },
    "/ns-groups/{nsgroup-id}/service-associations": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ServiceAssociationListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about services that are associated with the given NSGroup.\nThe service name is passed by service_type parameter\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "nsgroup-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Fetch complete list of associated resources considering\nnesting\n",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "fetch_parentgroup_associations"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "required": true,
            "type": "string",
            "name": "service_type",
            "enum": [
              "firewall",
              "network_encryption",
              "ipfix"
            ],
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Get services to which the given nsgroup belongs to\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetServiceAssociations"
      }
    },
    "/node/services/http?action=stop": {
      "post": {
        "responses": {
          "202": {
            "description": "Accepted"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Stop the http service",
        "operationId": "CreateProxyServiceActionStop",
        "consumes": [
          "application/json"
        ],
        "description": "Stop the http service"
      }
    },
    "/csm/aws/gateways/{vpc-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AwsGatewayDeployConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Updates configuration for primary gateway and secondary gateway\nfor the vpc, if exists.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "vpc-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/AwsGatewayDeployConfig"
            },
            "required": true,
            "name": "AwsGatewayDeployConfig",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Updates configuration for primary gateway and secondary gateway\nfor the vpc, if exists.\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateAwsGatewayConfig"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AwsGatewayDeployConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns configuration for primary gateway and secondary gateway\nfor the vpc,if exists.\n",
        "parameters": [
          {
            "description": "ID of the Vpc",
            "required": true,
            "type": "string",
            "name": "vpc-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Returns configuration for primary gateway and secondary gateway\nfor the vpc,if exists.\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetAwsGatewayConfig"
      }
    },
    "/loadbalancer/rules/{rule-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbRule"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a load balancer rule.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "rule-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/LbRule"
            },
            "required": true,
            "name": "LbRule",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update a load balancer rule",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateLoadBalancerRule"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbRule"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Retrieve a load balancer rule.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "rule-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Retrieve a load balancer rule",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadLoadBalancerRule"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a load balancer rule.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "rule-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Delete a load balancer rule",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteLoadBalancerRule"
      }
    },
    "/dhcp/servers/{server-id}/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DhcpServerStatus"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the service status of the given dhcp server.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "server-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get DHCP service status with given dhcp server id",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetDhcpStatus"
      }
    },
    "/node/services/nsx-upgrade-agent?action=start": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the NSX upgrade agent service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the NSX upgrade agent service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateNsxUpgradeAgentServiceActionStart"
      }
    },
    "/aaa/user-info": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/UserInfo"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get information about logged-in user",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Aaa"
        ],
        "summary": "Get information about logged-in user",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetCurrentUserInfo"
      }
    },
    "/upgrade/upgrade-units-stats": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/UpgradeUnitTypeStatsList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get upgrade units stats",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "Synchronize before returning upgrade unit stats",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "sync"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Get upgrade units stats",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetUpgradeUnitsStats"
      }
    },
    "/infra/realized-state/enforcement-points/{enforcement-point-name}/firewalls/firewall-sections/{firewall-section-id}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RealizedFirewallSection"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read a Firewall and the complete tree underneath. Returns the\npopulated Firewall object.\n",
        "parameters": [
          {
            "description": "Enforcement Point Name",
            "required": true,
            "type": "string",
            "name": "enforcement-point-name",
            "in": "path"
          },
          {
            "description": "Firewall Section Id",
            "required": true,
            "type": "string",
            "name": "firewall-section-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Read Firewall",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadFirewallSectionRealizedState"
      }
    },
    "/node/services/ssh?action=start": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the ssh service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the ssh service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateSSHServiceActionStart"
      }
    },
    "/node/services/liagent": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read liagent service properties",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read liagent service properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadLiagentService"
      }
    },
    "/dhcp/servers": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/LogicalDhcpServer"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a DHCP server",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/LogicalDhcpServer"
            },
            "required": true,
            "name": "LogicalDhcpServer",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Create a DHCP server",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateDhcpServer"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalDhcpServerListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get a paginated list of DHCP servers",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get a paginated list of DHCP servers",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListDhcpServers"
      }
    },
    "/trust-management/crls?action=import": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/CrlList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Adds a new certificate revocation list (CRL). The CRL is used to verify the\nclient certificate status against the revocation lists published by the CA.\nFor this reason, the administrator needs to add the CRL in certificate\nrepository as well.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/CrlObjectData"
            },
            "required": true,
            "name": "CrlObjectData",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Add a New Certificate Revocation List",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddCrlImport"
      }
    },
    "/dhcp/servers/{server-id}/ip-pools/{pool-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DhcpIpPool"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a DHCP server's IP pool",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "server-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "pool-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/DhcpIpPool"
            },
            "required": true,
            "name": "DhcpIpPool",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update a DHCP server's IP pool",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateDhcpIpPool"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DhcpIpPool"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get a DHCP server's IP pool with the specified pool ID",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "server-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "pool-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get a DHCP server's IP pool with the specified pool ID",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadDhcpIpPool"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a DHCP server's IP pool",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "server-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "pool-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Delete a DHCP server's IP pool",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteDhcpIpPool"
      }
    },
    "/firewall/sections/{section-id}?action=revise_with_rules": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FirewallSectionRuleList"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies an existing firewall section along with its relative position\namong other firewall sections with rules. When invoked on a large number\nof rules, this API is supported only at low rates of invocation (not more\nthan 2 times per minute). The typical latency of this API with about 1024\nrules is about 15 seconds in a cluster setup. This API should not be\ninvoked with large payloads at automation speeds.\n\nInstead, to move a section above or below another section, use:\nPOST /api/v1/firewall/sections/&lt;section-id&gt;?action=revise\n\nTo modify rules, use:\nPUT /api/v1/firewall/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt;\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/FirewallSectionRuleList"
            },
            "required": true,
            "name": "FirewallSectionRuleList",
            "in": "body"
          },
          {
            "in": "query",
            "description": "Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.",
            "required": false,
            "maxLength": 64,
            "type": "string",
            "name": "id"
          },
          {
            "enum": [
              "insert_top",
              "insert_bottom",
              "insert_after",
              "insert_before"
            ],
            "description": "Operation",
            "default": "insert_top",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "operation"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update an Existing Section with Rules",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReviseSectionWithRulesRevise_with_rules"
      }
    },
    "/transport-nodes/{transportnode-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TransportNode"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies the transport node information. Modifiable parameters include the\nhost_switch_spec and transport_zone_endpoints. The host_switch_name field must\nmatch the host_switch_name value specified in the transport zone\n(API: transport-zones). You must create the associated uplink profile\n(API: host-switch-profiles) before you can specify an uplink_name here.\nIf the host is an ESX and has only one physical NIC being used by a vSphere\nstandard switch, TransportNodeUpdateParameters should be used to migrate\nthe management interface and the physical NIC into a logical switch that\nis in a transport zone this transport node will join or has already joined.\nIf the migration is already done, TransportNodeUpdateParameters can also be\nused to migrate the management interface and the physical NIC back to a\nvSphere standard switch.\nIn other cases, the TransportNodeUpdateParameters should NOT be used.\nWhen updating transport node user should follow pattern where he should fetch\nthe existing transport node and then only modify the required properties\nkeeping other properties as is. For API backward compatibility, property\nhost_switches will be still returned in response and will contain the configuration\nmatching the one in host_switch_spec. In update call user should only\nmodify configuration in either host_switch_spec or host_switches, but\nnot both. Property host_switch_spec should be preferred over deprecated\nhost_switches property when creating or updating transport nodes.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "transportnode-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/TransportNode"
            },
            "required": true,
            "name": "TransportNode",
            "in": "body"
          },
          {
            "description": "The network ids to which the ESX vmk interfaces will be migrated",
            "required": false,
            "type": "string",
            "name": "esx_mgmt_if_migration_dest",
            "in": "query"
          },
          {
            "description": "The ESX vmk interfaces to migrate",
            "required": false,
            "type": "string",
            "name": "if_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Update a Transport Node",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateTransportNode"
      },
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Put transport node into maintenance mode or exit from maintenance mode.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "transportnode-id",
            "in": "path"
          },
          {
            "enum": [
              "enter_maintenance_mode",
              "forced_enter_maintenance_mode",
              "exit_maintenance_mode"
            ],
            "type": "string",
            "name": "action",
            "in": "query"
          }
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Update transport node maintenance mode",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateTransportNodeMaintenanceMode"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes the specified transport node.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "transportnode-id",
            "in": "path"
          }
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Delete a Transport Node",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteTransportNode"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TransportNode"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about a specified transport node.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "transportnode-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Get a Transport Node",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetTransportNode"
      }
    },
    "/fabric/compute-managers/{compute-manager-id}/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ComputeManagerStatus"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns connection and version information about a compute manager\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "compute-manager-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Return runtime status information for a compute manager",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadComputeManagerStatus"
      }
    },
    "/logical-routers/{logical-router-id}/routing/redistribution": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RedistributionConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies existing route redistribution rules for the specified TIER0 logical\nrouter.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/RedistributionConfig"
            },
            "required": true,
            "name": "RedistributionConfig",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Update the Redistribution Configuration on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateRedistributionConfig"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RedistributionConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about configured route redistribution for the specified\nlogical router.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Read the Redistribution Configuration on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadRedistributionConfig"
      }
    },
    "/upgrade/eula/accept": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Accept end user license agreement\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Licensing"
        ],
        "summary": "Accept end user license agreement\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "AcceptUpgradeEULA"
      }
    },
    "/csm/aws/regions/{region-id}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AwsRegion"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the particual Aws Region",
        "parameters": [
          {
            "description": "ID of the region",
            "required": true,
            "type": "string",
            "name": "region-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Returns information about the particual Aws Region",
        "consumes": [
          "application/json"
        ],
        "operationId": "AwsRegionInfo"
      }
    },
    "/compute-collection-transport-node-templates": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/ComputeCollectionTransportNodeTemplate"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "If automated transport node creation is configured on compute collection, this template will serve as the default setting for transport node creation.",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ComputeCollectionTransportNodeTemplate"
            },
            "required": true,
            "name": "ComputeCollectionTransportNodeTemplate",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Create transport node template for compute collection.",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateComputeCollectionTransportNodeTemplate"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TransportNodeTemplateListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns all eligible compute collection transportnode templates",
        "parameters": [
          {
            "description": "Compute collection id",
            "required": false,
            "type": "string",
            "name": "compute_collection_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "List compute collection transportnode templates",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListComputeCollectionTransportNodeTemplates"
      }
    },
    "/dhcp/servers/{server-id}/static-bindings": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/DhcpStaticBinding"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a static binding for a DHCP server",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "server-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/DhcpStaticBinding"
            },
            "required": true,
            "name": "DhcpStaticBinding",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Create a static binding for a DHCP server",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateDhcpStaticBinding"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DhcpStaticBindingListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get a paginated list of a DHCP server's static bindings",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "server-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get a paginated list of a DHCP server's static bindings",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListDhcpStaticBindings"
      }
    },
    "/cluster/restore/backuptimestamps": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ClusterBackupInfoListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns timestamps for all backup files that are available\non the SFTP server.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "List timestamps of all available Cluster Backups.",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListClusterBackupTimestamps"
      }
    },
    "/node/services/mgmt-plane-bus?action=stop": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the Rabbit MQ service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the Rabbit MQ service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateRabbitMQServiceActionStop"
      }
    },
    "/administration/support-bundles?action=collect": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/SupportBundleResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "502": {
            "description": "Bad Gateway"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Collect support bundles from registered cluster and fabric nodes.",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/SupportBundleRequest"
            },
            "required": true,
            "name": "SupportBundleRequest",
            "in": "body"
          },
          {
            "default": false,
            "description": "Override any existing support bundle async response",
            "type": "boolean",
            "name": "override_async_response",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Collect support bundles from registered cluster and fabric nodes",
        "consumes": [
          "application/json"
        ],
        "operationId": "CollectSupportBundlesCollect"
      }
    },
    "/network-encryption/sections/{section-id}/rules": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/DneRule"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Add a network encryption rule in a section",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/DneRule"
            },
            "required": true,
            "name": "DneRule",
            "in": "body"
          },
          {
            "in": "query",
            "description": "Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.",
            "required": false,
            "maxLength": 64,
            "type": "string",
            "name": "id"
          },
          {
            "enum": [
              "insert_top",
              "insert_bottom",
              "insert_after",
              "insert_before"
            ],
            "description": "Operation",
            "default": "insert_top",
            "required": true,
            "in": "query",
            "type": "string",
            "name": "operation"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Add a network encryption rule in a section",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddDneRuleInSection"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneRuleListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get the rules of a network encryption section",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "description": "AppliedTo's  referenced by this section or section's DNE Rules .",
            "required": false,
            "type": "string",
            "name": "applied_tos",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Destinations referenced by this section's DNE Rules .",
            "required": false,
            "type": "string",
            "name": "destinations",
            "in": "query"
          },
          {
            "enum": [
              "FILTER",
              "SEARCH"
            ],
            "description": "Filter type",
            "default": "FILTER",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "filter_type"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "key policy identifier",
            "required": false,
            "type": "string",
            "name": "key_policy_id",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "NSService referenced by this section's DNE Rules .",
            "required": false,
            "type": "string",
            "name": "services",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "Sources referenced by this section's DNE Rules .",
            "required": false,
            "type": "string",
            "name": "sources",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get the rules of a network encryption section",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetDneRules"
      }
    },
    "/switching-profiles/{switching-profile-id}/summary": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/SwitchingProfileStatus"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get Counts of Ports and Switches Using This Switching Profile",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "switching-profile-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Get Counts of Ports and Switches Using This Switching Profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetSwitchingProfileStatus"
      }
    },
    "/upgrade/plan?action=start": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "tags": [
          "Upgrade"
        ],
        "summary": "Start upgrade",
        "operationId": "StartUpgradeStart",
        "consumes": [
          "application/json"
        ],
        "description": "Start upgrade"
      }
    },
    "/fabric/nodes/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeStatusListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns connectivity, heartbeat, and version information about all fabric nodes\n(host or edge).\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ReadNodesStatusRequestParameters"
            },
            "required": true,
            "name": "ReadNodesStatusRequestParameters",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Return Runtime Status Information for given Nodes",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNodesStatus"
      }
    },
    "/traceflows": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/Traceflow"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Initiate a Traceflow Operation on the Specified Port",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/TraceflowRequest"
            },
            "required": true,
            "name": "TraceflowRequest",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Initiate a Traceflow Operation on the Specified Port",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateTraceflow"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TraceflowListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "List all Traceflow rounds; if a logical port id is given as a query parameter,\nonly those originated from the logical port are returned.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "id of the source logical port where the trace flows originated",
            "required": false,
            "type": "string",
            "name": "lport_id",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "List all Traceflow rounds",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListTraceflows"
      }
    },
    "/firewall/status/{context-type}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FirewallStatus"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "description": "Bad Request"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update global firewall status for dfw context",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "context-type",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/FirewallStatus"
            },
            "required": true,
            "name": "FirewallStatus",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update global firewall status for dfw context",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateFirewallStatus"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FirewallStatus"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get firewall global status for dfw context",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "context-type",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get firewall global status for dfw context",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetFirewallStatus"
      }
    },
    "/bridge-endpoints": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/BridgeEndpoint"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a Bridge Endpoint. It describes the physical attributes of the\nbridge like vlan. A logical port can be attached to a vif providing\nbridging functionality from the logical overlay network to the physical\nvlan network\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/BridgeEndpoint"
            },
            "required": true,
            "name": "BridgeEndpoint",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Create a Bridge Endpoint",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateBridgeEndpoint"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BridgeEndpointListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all configured bridge endoints\n",
        "parameters": [
          {
            "description": "Bridge Cluster Identifier",
            "required": false,
            "type": "string",
            "name": "bridge_cluster_id",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Logical Switch Identifier",
            "required": false,
            "type": "string",
            "name": "logical_switch_id",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "List All Bridge Endpoints",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListBridgeEndpoints"
      }
    },
    "/network-encryption/sections/{section-id}?action=revise_with_rules": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneSectionRuleList"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "This API can be called for a section with or without rules.\nWhen invoked on a large number of rules, this API is supported only at low\nrates of invocation (not more than 2 times per minute). The typical latency\nof this API with about 1024 rules is about 15 seconds in a cluster\nsetup. This API should not be invoked with large payloads at automation\nspeeds.\n\nInstead, to move a section above or below another section, use:\nPOST /api/v1/network-encryption/sections/&lt;section-id&gt;?action=revise\n\nTo modify rules, use:\nPUT /api/v1/network-encryption/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt;\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/DneSectionRuleList"
            },
            "required": true,
            "name": "DneSectionRuleList",
            "in": "body"
          },
          {
            "in": "query",
            "description": "Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.",
            "required": false,
            "maxLength": 64,
            "type": "string",
            "name": "id"
          },
          {
            "enum": [
              "insert_top",
              "insert_bottom",
              "insert_after",
              "insert_before"
            ],
            "description": "Operation",
            "default": "insert_top",
            "required": true,
            "in": "query",
            "type": "string",
            "name": "operation"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update a network encryption section, its rules or position",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReviseDneSectionWithRulesRevise_with_rules"
      }
    },
    "/transport-zones/{zone-id}/summary": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TransportZoneStatus"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about a specified transport zone, including the number\nof logical switches in the transport zone, number of logical spitch ports\nassigned to the transport zone, and number of transport nodes in the\ntransport zone.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "zone-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Get a Transport Zone's Current Runtime Status Information",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetTransportZoneStatus"
      }
    },
    "/node/services/snmp?action=stop": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the SNMP service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the SNMP service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateSNMPServiceActionStop"
      }
    },
    "/edge-clusters/{edge-cluster-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/EdgeCluster"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies the specified edge cluster. Modifiable parameters include the\ndescription, display_name, transport-node-id. If the optional\nfabric_profile_binding is included, resource_type and profile_id are required.\nUser should do a GET on the edge-cluster and obtain the payload and retain the\nmember_index of the existing members as returning in the GET output. For new member\nadditions, the member_index cannot be defined by the user, user can read the system\nallocated index to the new member in the output of this API call or by doing a GET call.\nUser cannot use this PUT api to replace the transport_node of an existing member because\nthis is a disruption action, we have exposed a explicit API for doing so, refer to\n\"ReplaceEdgeClusterMemberTransportNode\"\nEdgeCluster only supports homogeneous members. The TransportNodes backed by EdgeNode are\nonly allowed in cluster members. DeploymentType (VIRTUAL_MACHINE|PHYSICAL_MACHINE) of these\nEdgeNodes should be same.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "edge-cluster-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/EdgeCluster"
            },
            "required": true,
            "name": "EdgeCluster",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Update Edge Cluster",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateEdgeCluster"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes the specified edge cluster.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "edge-cluster-id",
            "in": "path"
          }
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Delete Edge Cluster",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteEdgeCluster"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/EdgeCluster"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the specified edge cluster.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "edge-cluster-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Read Edge Cluster",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadEdgeCluster"
      }
    },
    "/cluster/restore?action=retry": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ClusterRestoreStatus"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "409": {
            "description": "Conflict",
            "schema": {
              "$ref": "#/definitions/ClusterRestoreStatus"
            }
          }
        },
        "description": "Retry any currently in-progress, failed restore operation. Only the last\nstep of the multi-step restore operation would have failed,and only that\nstep is retried. This operation is only valid when a\nGET cluster/restore/status returns a status with value FAILED. Otherwise,\na 409 response is returned.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Retry any failed restore operation",
        "consumes": [
          "application/json"
        ],
        "operationId": "RetryClusterRestoreRetry"
      }
    },
    "/logical-switches": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/LogicalSwitch"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a new logical switch. The request must include the\ntransport_zone_id, display_name, and admin_state (UP or DOWN). The\nreplication_mode (MTEP or SOURCE) is required for overlay logical\nswitches, but not for VLAN-based logical switches. A vlan needs to be\nprovided for VLAN-based logical switches\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/LogicalSwitch"
            },
            "required": true,
            "name": "LogicalSwitch",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Create a Logical Switch",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateLogicalSwitch"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalSwitchListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all configured logical switches.",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Flag to enable showing of transit logical switch.",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "diagnostic"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "Switching Profile identifier",
            "required": false,
            "type": "string",
            "name": "switching_profile_id",
            "in": "query"
          },
          {
            "enum": [
              "OVERLAY",
              "VLAN"
            ],
            "description": "Mode of transport supported in the transport zone for this logical switch",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "transport_type"
          },
          {
            "description": "Transport zone identifier",
            "required": false,
            "type": "string",
            "name": "transport_zone_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "List all Logical Switches",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListLogicalSwitches"
      }
    },
    "/hpm/global-config": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/GlobalCollectionConfiguration"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Set the global configuration for aggregation service related data collection",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/GlobalCollectionConfiguration"
            },
            "required": true,
            "name": "GlobalCollectionConfiguration",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Aggregation Service"
        ],
        "summary": "Set the global configuration for aggregation service related data collection",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateAggregationServiceGlobalConfig"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/GlobalCollectionConfiguration"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read global health performance monitoring configuration",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Aggregation Service"
        ],
        "summary": "Read global health performance monitoring configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetAggregationServiceGlobalConfig"
      }
    },
    "/node/services/install-upgrade?action=start": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the NSX install-upgrade service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the NSX install-upgrade service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateRepositoryServiceActionStart"
      }
    },
    "/host-switch-profiles/{host-switch-profile-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BaseHostSwitchProfile"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies a specified hostswitch profile. The body of the PUT request must\ninclude the resource_type. For uplink profiles, the put request must also\ninclude teaming parameters. Modifiable attributes include display_name, mtu,\nand transport_vlan. For uplink teaming policies, uplink_name and policy are\nalso modifiable.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "host-switch-profile-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/BaseHostSwitchProfile"
            },
            "required": true,
            "name": "BaseHostSwitchProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Update a Hostswitch Profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateHostSwitchProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BaseHostSwitchProfile"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about a specified hostswitch profile.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "host-switch-profile-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Get a Hostswitch Profile by ID",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetHostSwitchProfile"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes a specified hostswitch profile.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "host-switch-profile-id",
            "in": "path"
          }
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Delete a Hostswitch Profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteHostSwitchProfile"
      }
    },
    "/fabric/compute-collections": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ComputeCollectionListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all compute collections.",
        "parameters": [
          {
            "description": "Local Id of the compute collection in the Compute Manager",
            "required": false,
            "type": "string",
            "name": "cm_local_id",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Id of the discovered node which belongs to this Compute Collection\n",
            "required": false,
            "type": "string",
            "name": "discovered_node_id",
            "in": "query"
          },
          {
            "description": "Name of the ComputeCollection in source compute manager",
            "required": false,
            "type": "string",
            "name": "display_name",
            "in": "query"
          },
          {
            "description": "External ID of the ComputeCollection in the source Compute manager,\ne.g. mo-ref in VC\n",
            "required": false,
            "type": "string",
            "name": "external_id",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Id of the fabric node created from a discovered node belonging to\nthis Compute Collection\n",
            "required": false,
            "type": "string",
            "name": "node_id",
            "in": "query"
          },
          {
            "description": "Id of the compute manager from where this Compute Collection was discovered",
            "required": false,
            "type": "string",
            "name": "origin_id",
            "in": "query"
          },
          {
            "description": "ComputeCollection type like VC_Cluster. Here the Compute Manager\ntype prefix would help in differentiating similar named Compute\nCollection types from different Compute Managers\n",
            "required": false,
            "type": "string",
            "name": "origin_type",
            "in": "query"
          },
          {
            "description": "Id of the owner of compute collection in the Compute Manager",
            "required": false,
            "type": "string",
            "name": "owner_id",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Return the List of Compute Collections",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListComputeCollections"
      }
    },
    "/app-discovery/sessions/{session-id}/report/app-info-and-vm?format=csv": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AppInfoHostVmListInCsvFormat"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns app discovery results in CSV format, each row contains discovered app information\nand the id of the vms this app is discovered from for a given set of vms\n(or for all vms belong to this session when no vm id is passed in)\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "session-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/ReportAppResultsForVmsRequestParameters"
            },
            "required": true,
            "name": "ReportAppResultsForVmsRequestParameters",
            "in": "body"
          }
        ],
        "produces": [
          "text/csv"
        ],
        "tags": [
          "App Discovery"
        ],
        "summary": "Export app discovery results in CSV format",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetAppdiscoveryResultAppInfoAndHostVmInCsvFormatCsv"
      }
    },
    "/dhcp/relays/{relay-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DhcpRelayService"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies the specified dhcp relay service.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "relay-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/DhcpRelayService"
            },
            "required": true,
            "name": "DhcpRelayService",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Update a DHCP Relay Service",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateDhcpRelay"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DhcpRelayService"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the dhcp relay service information.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "relay-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Read a DHCP Relay Service",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadDhcpRelay"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes the specified dhcp relay service.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "relay-id",
            "in": "path"
          }
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Delete a DHCP Relay Service",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteDhcpRelay"
      }
    },
    "/node/services/http?action=start": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Start the http service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Start the http service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateProxyServiceActionStart"
      }
    },
    "/node?action=restart": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart or shutdown node",
        "operationId": "RestartOrShutdownNodeRestart",
        "consumes": [
          "application/json"
        ],
        "description": "Restarts or shuts down the NSX Manager appliance."
      }
    },
    "/node/network/interfaces/{interface-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeNetworkInterfaceProperties"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Updates the specified interface properties. You cannot change\nthe properties <code>ip_configuration</code>,\n<code>ip_addresses</code>, or <code>plane</code>. NSX\nManager must have a static IP address.\nYou must use NSX CLI to configure a controller or an edge node.\n",
        "parameters": [
          {
            "description": "ID of interface to update",
            "required": true,
            "type": "string",
            "name": "interface-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/NodeNetworkInterfaceProperties"
            },
            "required": true,
            "name": "NodeNetworkInterfaceProperties",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Update the NSX Manager's Network Interface",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateNodeInterface"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeNetworkInterfaceProperties"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns detailed information about the specified interface. Interface\ninformation includes MTU, broadcast and host IP addresses, link and admin\nstatus, MAC address, network  mask, and the IP configuration method.\n",
        "parameters": [
          {
            "description": "ID of interface to read",
            "required": true,
            "type": "string",
            "name": "interface-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read the NSX Manager's Network Interface",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNodeInterface"
      }
    },
    "/node/services/ssh": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeSshServiceProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update ssh service properties",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/NodeSshServiceProperties"
            },
            "required": true,
            "name": "NodeSshServiceProperties",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Update ssh service properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateSSHService"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeSshServiceProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read ssh service properties",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read ssh service properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadSSHService"
      }
    },
    "/bridge-endpoints/{endpoint-id}/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BridgeEndpointStatus"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get the status for the Bridge Endpoint of the given Endpoint id",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "endpoint-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Returns status of a specified Bridge Endpoint",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetBridgeEndpointStatus"
      }
    },
    "/loadbalancer/pools/{pool-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbPool"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a load balancer pool.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "pool-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/LbPool"
            },
            "required": true,
            "name": "LbPool",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update a load balancer pool",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateLoadBalancerPool"
      },
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbPool"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "For ADD_MEMBERS, pool members will be created and added to load balancer\npool. This action is only valid for static pool members.\nFor REMOVE_MEMBERS, pool members will be removed from load balancer pool\nvia IP and port in pool member settings. This action is only valid for\nstatic pool members.\nFor UPDATE_MEMBERS, pool members admin state will be updated. This action\nis valid for both static pool members and dynamic pool members. For dynamic\npool members, this update will be stored in customized_members field in load\nbalancer pool member group.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "pool-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/PoolMemberSettingList"
            },
            "required": true,
            "name": "PoolMemberSettingList",
            "in": "body"
          },
          {
            "enum": [
              "ADD_MEMBERS",
              "REMOVE_MEMBERS",
              "UPDATE_MEMBERS"
            ],
            "description": "Specifies addition, removal and modification action",
            "required": true,
            "in": "query",
            "type": "string",
            "name": "action"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Add, remove, or modify load balancer pool members",
        "consumes": [
          "application/json"
        ],
        "operationId": "PerformPoolMemberAction"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a load balancer pool.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "pool-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Delete a load balancer pool",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteLoadBalancerPool"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbPool"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Retrieve a load balancer pool.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "pool-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Retrieve a load balancer pool",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadLoadBalancerPool"
      }
    },
    "/firewall/sections/{section-id}?action=update_with_rules": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FirewallSectionRuleList"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies existing firewall section along with its association with rules.\nWhen invoked on a large number of rules, this API is supported only at low\nrates of invocation (not more than 2 times per minute). The typical latency\nof this API with about 1024 rules is about 15 seconds in a cluster setup.\nThis API should not be invoked with large payloads at automation speeds.\n\nInstead, to update rule content, use:\nPUT /api/v1/firewall/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt;\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/FirewallSectionRuleList"
            },
            "required": true,
            "name": "FirewallSectionRuleList",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update an Existing Section, Including Its Rules",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateSectionWithRulesUpdate_with_rules"
      }
    },
    "/node/rabbitmq-management-port": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Set RabbitMQ management port",
        "operationId": "SetRabbitMQManagementPort",
        "consumes": [
          "application/json"
        ],
        "description": "Set RabbitMQ management port"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Delete RabbitMQ management port",
        "operationId": "DELETERabbitMQManagementPort",
        "consumes": [
          "application/json"
        ],
        "description": "Delete RabbitMQ management port"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/PortStatus"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns status as true if RabbitMQ management port is enabled else false",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Check if RabbitMQ management port is enabled or not",
        "consumes": [
          "application/json"
        ],
        "operationId": "CheckRabbitMQManagementPort"
      }
    },
    "/firewall/sections/{section-id}?action=list_with_rules": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FirewallSectionRuleList"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns firewall section information with rules for a section identifier.\nWhen invoked on a section with a large number of rules, this API is supported\nonly at low rates of invocation (not more than 4-5 times per minute). The\ntypical latency of this API with about 1024 rules is about 4-5 seconds. This\nAPI should not be invoked with large payloads at automation speeds. More than\n50 rules with a large number rule references is not supported.\n\nInstead, to read firewall rules, use:\nGET /api/v1/firewall/sections/&lt;section-id&gt;/rules with the appropriate\npage_size.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get an Existing Section, Including Rules",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetSectionWithRulesList_with_rules"
      }
    },
    "/node/tasks/{task-id}": {
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete task",
        "parameters": [
          {
            "description": "ID of task to delete",
            "required": true,
            "type": "string",
            "name": "task-id",
            "in": "path"
          }
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Delete task",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteApplianceManagementTask"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ApplianceManagementTaskProperties"
            }
          },
          "303": {
            "description": "See Other",
            "schema": {
              "$ref": "#/definitions/ApplianceManagementTaskProperties"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read task properties",
        "parameters": [
          {
            "description": "ID of task to read",
            "required": true,
            "type": "string",
            "name": "task-id",
            "in": "path"
          },
          {
            "default": false,
            "description": "Suppress redirect status if applicable",
            "type": "boolean",
            "name": "suppress_redirect",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read task properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadApplianceManagementTaskProperties"
      }
    },
    "/loadbalancer/services/{service-id}/pools/{pool-id}/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbPoolStatus"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the status of the given load balancer pool by given load balancer\nserives id and load balancer pool id.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "pool-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get the status of load balancer pool",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLoadBalancerPoolStatus"
      }
    },
    "/licenses/licenses-usage": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FeatureUsageList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns usage report of all registered modules\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Licensing"
        ],
        "summary": "Get usage report of all registered modules",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLicenseUsageReport"
      }
    },
    "/licenses/{license-key}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/License"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deprecated. Use GET /licenses API instead.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "license-key",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Licensing"
        ],
        "summary": "Deprecated. Get license properties for license identified by the license-key",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLicenseByKey"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deprecated. Use POST /licenses?action=delete API instead.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "license-key",
            "in": "path"
          }
        ],
        "tags": [
          "Licensing"
        ],
        "summary": "Deprecated. Remove a license identified by the license-key",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteLicense"
      }
    },
    "/aaa/vidm/groups": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/VidmInfoListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get all the User Groups where vIDM display name matches the search key case insensitively. The search key is checked to be a substring of display name.",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "Search string to search for.\n",
            "required": true,
            "type": "string",
            "name": "search_string",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Aaa"
        ],
        "summary": "Get all the User Groups where vIDM display name matches the search key case insensitively. The search key is checked to be a substring of display name.",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetGroupVidmSearchResult"
      }
    },
    "/logical-ports": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/LogicalPort"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a new logical switch port. The required parameters are the\nassociated logical_switch_id and admin_state (UP or DOWN). Optional\nparameters are the attachment and switching_profile_ids. If you don't\nspecify switching_profile_ids, default switching profiles are assigned to\nthe port. If you don't specify an attachment, the switch port remains\nempty. To configure an attachment, you must specify an id, and\noptionally you can specify an attachment_type (VIF or LOGICALROUTER).\nThe attachment_type is VIF by default.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/LogicalPort"
            },
            "required": true,
            "name": "LogicalPort",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Create a Logical Port",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateLogicalPort"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalPortListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all configured logical switch ports. Logical\nswitch ports connect to VM virtual network interface cards (NICs). Each\nlogical port is associated with one logical switch.\n",
        "parameters": [
          {
            "description": "Logical Port attachment Id",
            "required": false,
            "type": "string",
            "name": "attachment_id",
            "in": "query"
          },
          {
            "enum": [
              "VIF",
              "LOGICALROUTER",
              "BRIDGEENDPOINT",
              "DHCP_SERVICE",
              "METADATA_PROXY",
              "NONE"
            ],
            "description": "Type of attachment for logical port; for query only.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "attachment_type"
          },
          {
            "description": "Bridge Cluster identifier",
            "required": false,
            "type": "string",
            "name": "bridge_cluster_id",
            "in": "query"
          },
          {
            "description": "Only container VIF logical ports will be returned if true",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "container_ports_only"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Flag to enable showing of transit logical port.",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "diagnostic"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Logical Switch identifier",
            "required": false,
            "type": "string",
            "name": "logical_switch_id",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "ID of the VIF of type PARENT",
            "required": false,
            "type": "string",
            "name": "parent_vif_id",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "Network Profile identifier",
            "required": false,
            "type": "string",
            "name": "switching_profile_id",
            "in": "query"
          },
          {
            "description": "Transport node identifier",
            "required": false,
            "type": "string",
            "name": "transport_node_id",
            "in": "query"
          },
          {
            "description": "Transport zone identifier",
            "required": false,
            "type": "string",
            "name": "transport_zone_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "List All Logical Ports",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListLogicalPorts"
      }
    },
    "/cluster?action=summarize_inventory_to_remote": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Request one-time inventory summary.",
        "operationId": "RequestOnetimeInventorySummarySummarize_inventory_to_remote",
        "consumes": [
          "application/json"
        ],
        "description": "Request one-time inventory summary. The backup will be uploaded using the\nsame server configuration as for an automatic backup.\n"
      }
    },
    "/logical-routers/{logical-router-id}/routing/static-routes/{id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/StaticRoute"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a specific static route on the specified logical router.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/StaticRoute"
            },
            "required": true,
            "name": "StaticRoute",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Update a specific Static Route Rule on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateStaticRoute"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/StaticRoute"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read a specific static routes on the specified logical router.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Get a specific Static Route on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadStaticRoute"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes a specific static route on the specified logical router.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "id",
            "in": "path"
          }
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Delete a specific Static Route on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteStaticRoute"
      }
    },
    "/logical-ports/{lport-id}/state": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalPortState"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns transport node id for a specified logical port. Also returns\ninformation about all address bindings of the specified logical port. This\nincludes address bindings discovered via various snooping methods like ARP\nsnooping, DHCP snooping etc. and addressing bindings that are realized\nbased on user configuration.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "lport-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Get realized state & location of a logical port",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalPortState"
      }
    },
    "/fabric/nodes/{node-id}?action=restart_inventory_sync": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart the inventory sync for the node if it is currently internally paused.\nAfter this action the next inventory sync coming from the node is processed.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          }
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Restart the inventory sync for the node if it is paused currently.",
        "consumes": [
          "application/json"
        ],
        "operationId": "RestartInventorySyncRestart_inventory_sync"
      }
    },
    "/node/tasks/{task-id}/response": {
      "get": {
        "responses": {
          "201": {
            "description": "Created"
          },
          "200": {
            "description": "OK"
          },
          "202": {
            "description": "Accepted"
          },
          "204": {
            "description": "No Content"
          },
          "303": {
            "description": "See Other"
          },
          "404": {
            "description": "Not Found"
          },
          "410": {
            "description": "Gone"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "502": {
            "description": "Bad Gateway"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "409": {
            "description": "Conflict"
          }
        },
        "description": "Read asynchronous task response",
        "parameters": [
          {
            "description": "ID of task to read",
            "required": true,
            "type": "string",
            "name": "task-id",
            "in": "path"
          }
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read asynchronous task response",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadAsnycApplianceManagementTaskResponse"
      }
    },
    "/node/services/mgmt-plane-bus/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read Rabbit MQ service status",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read Rabbit MQ service status",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadRabbitMQServiceStatus"
      }
    },
    "/fabric/compute-collection-fabric-templates": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/ComputeCollectionFabricTemplate"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Fabric templates are fabric configurations applied at the compute collection level. This configurations is used to decide what automated operations should be a run when a host membership changes.",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ComputeCollectionFabricTemplate"
            },
            "required": true,
            "name": "ComputeCollectionFabricTemplate",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Create a compute collection fabric template",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateComputeCollectionFabricTemplate"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ComputeCollectionFabricTemplateListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns compute collection fabric templates",
        "parameters": [
          {
            "description": "Compute collection id",
            "required": false,
            "type": "string",
            "name": "compute_collection_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Get compute collection fabric templates",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListComputeCollectionFabricTemplates"
      }
    },
    "/bridge-endpoints/{bridgeendpoint-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BridgeEndpoint"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies a existing bridge endpoint.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "bridgeendpoint-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/BridgeEndpoint"
            },
            "required": true,
            "name": "BridgeEndpoint",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Update a Bridge Endpoint",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateBridgeEndpoint"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BridgeEndpoint"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about a specified bridge endpoint.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "bridgeendpoint-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Get Information about a bridge endpoint",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetBridgeEndpoint"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes the specified Bridge Endpoint.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "bridgeendpoint-id",
            "in": "path"
          }
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Delete a Bridge Endpoint",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteBridgeEndpoint"
      }
    },
    "/cluster?action=backup_to_remote": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Request one-time backup",
        "operationId": "RequestOnetimeBackupBackup_to_remote",
        "consumes": [
          "application/json"
        ],
        "description": "Request one-time backup. The backup will be uploaded using the\nsame server configuration as for automatic backup.\n"
      }
    },
    "/cluster/backups/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/CurrentBackupOperationStatus"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get status of active backup operations\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Get backup status",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetBackupStatus"
      }
    },
    "/upgrade/version-whitelist/{component_type}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update the version whitelist for the specified component type (HOST, EDGE, CCP, MP).",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "component_type",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/VersionList"
            },
            "required": true,
            "name": "VersionList",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Update the version whitelist for the specified component type",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateVersionWhitelist"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AcceptableComponentVersion"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get whitelist of versions for a component. Component can include HOST, EDGE, CCP, MP",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "component_type",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Get the version whitelist for the specified component",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetVersionWhitelistByComponent"
      }
    },
    "/csm/aws/gateways?action=deploy": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AwsGatewayDeployConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "All the required configuration to deploy Aws gateways will be absorbed as a\npart of request body in this api and gateway deployment will be triggered.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/AwsGatewayDeployConfig"
            },
            "required": true,
            "name": "AwsGatewayDeployConfig",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "All the required configuration to deploy Aws gateways will be absorbed as a\npart of request body in this api and gateway deployment will be triggered.\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeployAwsGatewayDeploy"
      }
    },
    "/csm/csmstatus": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/CsmStatus"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Return Csm status information",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Return Csm status information",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetCsmStatus"
      }
    },
    "/node/logs/{log-name}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeLogProperties"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "For a single specified log file, lists the filename, file size, and\nlast-modified time.\n",
        "parameters": [
          {
            "description": "Name of log file to read properties",
            "required": true,
            "type": "string",
            "name": "log-name",
            "in": "path"
          }
        ],
        "produces": [
          "application/json",
          "application/octet-stream"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Read node log properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNodeLog"
      }
    },
    "/network-encryption/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NetworkEncryptionStatus"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get the network encryption status for a given context",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get the network encryption status for a given context",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetNetworkEncryptionStatus"
      }
    },
    "/ipfix/configs/{config-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IpfixConfig"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update an existing IPFIX configuration",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "config-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/IpfixConfig"
            },
            "required": true,
            "name": "IpfixConfig",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Operations"
        ],
        "summary": "Update an existing IPFIX configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateIpfixConfig"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete an existing IPFIX configuration",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "config-id",
            "in": "path"
          }
        ],
        "tags": [
          "Operations"
        ],
        "summary": "Delete an existing IPFIX configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteIpfixConfig"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IpfixConfig"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get an existing IPFIX configuration",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "config-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Operations"
        ],
        "summary": "Get an existing IPFIX configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetIpfixConfig"
      }
    },
    "/infra/realized-state/enforcement-points/{enforcement-point-name}/groups/nsgroups": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RealizedNSGroupListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Paginated list of all NSGroups. Returns populated NSGroups.\n",
        "parameters": [
          {
            "description": "Enforcement Point Name",
            "required": true,
            "type": "string",
            "name": "enforcement-point-name",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "List NS Groups",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListNSGroupRealizedStates"
      }
    },
    "/dhcp/servers/{server-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalDhcpServer"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a DHCP server",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "server-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/LogicalDhcpServer"
            },
            "required": true,
            "name": "LogicalDhcpServer",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update a DHCP server",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateDhcpServer"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a DHCP server",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "server-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Delete a DHCP server",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteDhcpServer"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalDhcpServer"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get a DHCP server",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "server-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get a DHCP server",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadDhcpServer"
      }
    },
    "/upgrade/plan?action=pause": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "tags": [
          "Upgrade"
        ],
        "summary": "Pause upgrade",
        "operationId": "PauseUpgradePause",
        "consumes": [
          "application/json"
        ],
        "description": "Pause upgrade"
      }
    },
    "/csm/aws/vpcs": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AwsVpcListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns a list of Vpcs. Support optional query parameters like account_id,\nregion_id, cidr and/or op_status\n",
        "parameters": [
          {
            "description": "Identifier for account based on which vpcs are to be filtered",
            "required": false,
            "type": "string",
            "name": "account_id",
            "in": "query"
          },
          {
            "description": "IPV4 CIDR Block for the Vpc",
            "format": "ipv4_cidr_block",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "cidr"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "enum": [
              "NSX_MANAGED",
              "NSX_UNMANAGED"
            ],
            "description": "Identifier for state based on which vpcs are to be filtered",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "op_status"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "Identifier for region based on which vpcs are to be filtered",
            "required": false,
            "type": "string",
            "name": "region_id",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "Identifier for vpc based on which the list can be filtered or can be\nused to validate that hierarchy is correct\n",
            "required": false,
            "type": "string",
            "name": "vpc_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Returns a list of Vpcs. Support optional query parameters like account_id,\nregion_id, cidr and/or op_status\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListAwsVpcs"
      }
    },
    "/infra/services/{service-id}/service-entries/{service-entry-id}": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "If a service entry with the service-entry-id is not already present,\ncreate a new service entry. If it already exists, update the service\nentry.\n",
        "parameters": [
          {
            "description": "Service ID",
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          },
          {
            "description": "Service entry ID",
            "required": true,
            "type": "string",
            "name": "service-entry-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/ServiceEntry"
            },
            "required": true,
            "name": "ServiceEntry",
            "in": "body"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Create or update a ServiceEntry",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateServiceEntry"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete Service entry",
        "parameters": [
          {
            "description": "Service ID",
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          },
          {
            "description": "Service entry ID",
            "required": true,
            "type": "string",
            "name": "service-entry-id",
            "in": "path"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Delete Service entry",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteServiceEntry"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ServiceEntry"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Service entry",
        "parameters": [
          {
            "description": "Service ID",
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          },
          {
            "description": "Service entry ID",
            "required": true,
            "type": "string",
            "name": "service-entry-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Service entry",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadServiceEntry"
      }
    },
    "/edge-clusters": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/EdgeCluster"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a new edge cluster.\nIt only supports homogeneous members.\nThe TransportNodes backed by EdgeNode are only allowed in cluster members.\nDeploymentType (VIRTUAL_MACHINE|PHYSICAL_MACHINE) of these EdgeNodes should be same.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/EdgeCluster"
            },
            "required": true,
            "name": "EdgeCluster",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Create Edge Cluster",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateEdgeCluster"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/EdgeClusterListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the configured edge clusters, which enable you to\ngroup together transport nodes of the type EdgeNode and apply fabric\nprofiles to all members of the edge cluster. Each edge node can participate\nin only one edge cluster.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "List Edge Clusters",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListEdgeClusters"
      }
    },
    "/firewall/sections/{section-id}/rules?action=create_multiple": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FirewallRuleList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "description": "Bad Request"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create multiple firewall rules in existing firewall section bounded by\nlimit of 1000 firewall rules per section.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/FirewallRuleList"
            },
            "required": true,
            "name": "FirewallRuleList",
            "in": "body"
          },
          {
            "in": "query",
            "description": "Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.",
            "required": false,
            "maxLength": 64,
            "type": "string",
            "name": "id"
          },
          {
            "enum": [
              "insert_top",
              "insert_bottom",
              "insert_after",
              "insert_before"
            ],
            "description": "Operation",
            "default": "insert_top",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "operation"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Add Multiple Rules in a Section",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddRulesInSectionCreate_multiple"
      }
    },
    "/infra/realized-state/enforcement-points/{enforcement-point-name}/groups/securitygroups": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RealizedSecurityGroupListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Paginated list of all Security Groups. Returns populated Security Groups.\n",
        "parameters": [
          {
            "description": "Enforcement Point Name",
            "required": true,
            "type": "string",
            "name": "enforcement-point-name",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "List Security Groups",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListSecurityGroupRealizedStates"
      }
    },
    "/trust-management/csrs/{csr-id}?action=import": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/CertificateList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Imports a certificate authority (CA)-signed certificate for a CSR. This\naction links the certificate to the private key created by the CSR. The\npem_encoded string in the request body is the signed certificate provided by\nyour CA in response to the CSR that you provide to them. The import POST\naction automatically deletes the associated CSR.\n",
        "parameters": [
          {
            "description": "CSR this certificate is associated with",
            "required": true,
            "type": "string",
            "name": "csr-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/TrustObjectData"
            },
            "required": true,
            "name": "TrustObjectData",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Import a Certificate Associated with an Approved CSR",
        "consumes": [
          "application/json"
        ],
        "operationId": "ImportCertificateImport"
      }
    },
    "/templates": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/PolicyTemplateListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "List Policy Templates",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "List Policy Templates",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListTemplates"
      }
    },
    "/node/services/ntp?action=start": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the NTP service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the NTP service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateNTPServiceActionStart"
      }
    },
    "/infra/domains/{domain-id}/domain-deployment-maps/{domain-deployment-map-id}": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "If the passed Domain Deployment Map does not already exist, create a new Domain Deployment Map.\nIf it already exist, replace it.\n",
        "parameters": [
          {
            "description": "Domain ID",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          },
          {
            "description": "Domain Deployment Map ID",
            "required": true,
            "type": "string",
            "name": "domain-deployment-map-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/DomainDeploymentMap"
            },
            "required": true,
            "name": "DomainDeploymentMap",
            "in": "body"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Create a new Domain Deployment Map under infra",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateOrUpdateDomainDeploymentMapForInfra"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DomainDeploymentMap"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read a Domain Deployment Map\n",
        "parameters": [
          {
            "description": "Domain ID",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          },
          {
            "description": "Domain Deployment Map id",
            "required": true,
            "type": "string",
            "name": "domain-deployment-map-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Read a DomainDeploymentMap",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadDomainDeploymentMapForInfra"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete Domain Deployment Map",
        "parameters": [
          {
            "description": "Domain ID",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          },
          {
            "description": "domain-deployment-map-id",
            "required": true,
            "type": "string",
            "name": "domain-deployment-map-id",
            "in": "path"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Delete Domain Deployment Map",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteDomainDeploymentMap"
      }
    },
    "/cluster/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ClusterStatus"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns status information for the NSX cluster control role and management\nrole.\n",
        "parameters": [
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read Cluster Status",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadClusterStatus"
      }
    },
    "/fabric/vifs": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/VirtualNetworkInterfaceListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all VIFs. A virtual network interface aggregates\nnetwork interfaces into a logical interface unit that is indistinuishable\nfrom a physical network interface.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Id of the host where this vif is located.",
            "required": false,
            "type": "string",
            "name": "host_id",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "LPort Attachment Id of the virtual network interface.",
            "required": false,
            "type": "string",
            "name": "lport_attachment_id",
            "in": "query"
          },
          {
            "description": "External id of the virtual machine.",
            "required": false,
            "type": "string",
            "name": "owner_vm_id",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "External id of the virtual machine.",
            "required": false,
            "type": "string",
            "name": "vm_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Return the List of Virtual Network Interfaces (VIFs)",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListVifs"
      }
    },
    "/node/services/manager?action=start": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateProtonServiceActionStart"
      }
    },
    "/node/services/cm-inventory/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read manager service status",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read manager service status",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadCminventoryServiceStatus"
      }
    },
    "/network-encryption/key-policies/{key-policy-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneKeyPolicy"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a network encryption key policy",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "key-policy-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/DneKeyPolicy"
            },
            "required": true,
            "name": "DneKeyPolicy",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update a network encryption key policy",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateDneKeyPolicy"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a specific network encryption key policy",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "key-policy-id",
            "in": "path"
          }
        ],
        "tags": [
          "Services"
        ],
        "summary": "Delete a specific network encryption key policy",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteDneKeyPolicy"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneKeyPolicy"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get a specific network encryption key policy",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "key-policy-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get a specific network encryption key policy",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetDneKeyPolicy"
      }
    },
    "/infra/deployment-zones": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DeploymentZoneListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Paginated list of all Deployment zones for infra.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "List Deployment Zones for infra",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListDeploymentZonesForInfra"
      }
    },
    "/network-encryption/sections?action=create_with_rules": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/DneSectionRuleList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "The limit on the number of rules is defined by maxItems in collection types\nfor DneRule (DneRuleList types). When invoked on a section with a large\nnumber of rules, this API is supported only at low rates of invocation (not\nmore than 4-5 times per minute). The typical latency of this API with about\n1024 rules is about 4-5 seconds. This API should not be invoked with large\npayloads at automation speeds. More than 50 rules with a large number of rule\nreferences is not supported.\n\nInstead, to create sections, use:\nPOST /api/v1/network-encryption/sections\n\nTo create rules, use:\nPOST /api/v1/network-encryption/sections/&lt;section-id&gt;/rules\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/DneSectionRuleList"
            },
            "required": true,
            "name": "DneSectionRuleList",
            "in": "body"
          },
          {
            "in": "query",
            "description": "Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.",
            "required": false,
            "maxLength": 64,
            "type": "string",
            "name": "id"
          },
          {
            "enum": [
              "insert_top",
              "insert_bottom",
              "insert_after",
              "insert_before"
            ],
            "description": "Operation",
            "default": "insert_top",
            "required": true,
            "in": "query",
            "type": "string",
            "name": "operation"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Create a network encryption section with rules",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddDneSectionWithRulesCreate_with_rules"
      }
    },
    "/node/users/{userid}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeUserProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Updates attributes of an existing NSX Manager appliance user. This method\ncannot be used to add a new user. Modifiable attributes include the\nusername, full name of the user, and password. If you specify a password in\na PUT request, it is not returned in the response. Nor is it returned in a\nGET request.\n",
        "parameters": [
          {
            "description": "User id of the user",
            "required": true,
            "type": "string",
            "name": "userid",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/NodeUserProperties"
            },
            "required": true,
            "name": "NodeUserProperties",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Update node user",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateNodeUser"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeUserProperties"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about a specified user who is configued to log in to the\nNSX Manager appliance\n",
        "parameters": [
          {
            "description": "User id of the user",
            "required": true,
            "type": "string",
            "name": "userid",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read node user",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNodeUser"
      }
    },
    "/loadbalancer/rules": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbRule"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a load balancer rule.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/LbRule"
            },
            "required": true,
            "name": "LbRule",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Create a load balancer rule",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateLoadBalancerRule"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbRuleListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Retrieve a paginated list of load balancer rules.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Retrieve a paginated list of load balancer rules",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListLoadBalancerRules"
      }
    },
    "/upgrade/upgrade-unit-groups/{group-id}/upgrade-unit/{upgrade-unit-id}?action=reorder": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Reorder an upgrade unit within the upgrade unit group",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "group-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "upgrade-unit-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/ReorderRequest"
            },
            "required": true,
            "name": "ReorderRequest",
            "in": "body"
          }
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Reorder an upgrade unit within the upgrade unit group",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReorderUpgradeUnitReorder"
      }
    },
    "/node/services/cm-inventory?action=start": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the manager service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the manager service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateCminventoryServiceActionStart"
      }
    },
    "/network-encryption/sections/{section-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneSection"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update the section but not its rules.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/DneSection"
            },
            "required": true,
            "name": "DneSection",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update a network encryption section",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateDneSection"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneSection"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get a specific network encryption section",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get a specific network encryption section",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetDneSection"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a network encryption section and its rules",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "description": "Flag to cascade delete of this object to all it's child objects.",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "cascade"
          },
          {
            "in": "query",
            "description": "Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.",
            "required": false,
            "maxLength": 64,
            "type": "string",
            "name": "id"
          },
          {
            "enum": [
              "insert_top",
              "insert_bottom",
              "insert_after",
              "insert_before"
            ],
            "description": "Operation",
            "default": "insert_top",
            "required": true,
            "in": "query",
            "type": "string",
            "name": "operation"
          }
        ],
        "tags": [
          "Services"
        ],
        "summary": "Delete a network encryption section and its rules",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteDneSection"
      }
    },
    "/transport-nodes/{transportnode-id}?action=resync_host_config": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Resync the TransportNode configuration on a host.\nIt is similar to updating the TransportNode with existing configuration,\nbut force synce these configurations to the host (no backend optimizations).\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "transportnode-id",
            "in": "path"
          }
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Resync a Transport Node",
        "consumes": [
          "application/json"
        ],
        "operationId": "ResyncTransportNodeResync_host_config"
      }
    },
    "/logical-switches/{lswitch-id}/summary": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalSwitchStatus"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the number of ports assigned to a logical switch.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "lswitch-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Get Logical Switch runtime status info for a given logical switch",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalSwitchStatus"
      }
    },
    "/dhcp/servers/{server-id}/statistics": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DhcpStatistics"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the statistics of the given dhcp server.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "server-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get DHCP statistics with given dhcp server id",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetDhcpStatistics"
      }
    },
    "/dhcp/relay-profiles/{relay-profile-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DhcpRelayProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies the specified dhcp relay profile.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "relay-profile-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/DhcpRelayProfile"
            },
            "required": true,
            "name": "DhcpRelayProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Update a DHCP Relay Profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateDhcpRelayProfile"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes the specified dhcp relay profile.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "relay-profile-id",
            "in": "path"
          }
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Delete a DHCP Relay Profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteDhcpRelayProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DhcpRelayProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the specified dhcp relay profile.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "relay-profile-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Read a DHCP Relay Profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadDhcpRelayProfile"
      }
    },
    "/loadbalancer/pools": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbPool"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a load balancer pool.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/LbPool"
            },
            "required": true,
            "name": "LbPool",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Create a load balancer pool",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateLoadBalancerPool"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbPoolListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Retrieve a paginated list of load balancer pools.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Retrieve a paginated list of load balancer pools",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListLoadBalancerPools"
      }
    },
    "/logical-switches/{lswitch-id}/mac-table?format=csv": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/MacAddressCsvListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns MAC table of a specified logical switch in CSV format from the given transport\nnode if a transport node id is given in the query parameter from the\nCentral Controller Plane.\nThe query parameter \"source=cached\" is not supported.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "lswitch-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "TransportNode Id",
            "required": false,
            "type": "string",
            "name": "transport_node_id",
            "in": "query"
          }
        ],
        "produces": [
          "text/csv"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Get MAC Table for Logical Switch of the Given ID (lswitch-id)",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalSwitchMacTableInCsvFormatCsv"
      }
    },
    "/normalizations": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NormalizedResourceListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the list of normalized resources based on the query parameters.\nId and Type of the resource on which the normalizations is to be performed,\nare to be specified as query parameters in the URI. The target resource\ntypes to which normalization is to be done should also be specified as\nquery parameter.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "enum": [
              "NSGroup",
              "IPSet",
              "MACSet",
              "LogicalSwitch",
              "LogicalPort"
            ],
            "description": "Resource type valid for use as target in normalization API.",
            "required": true,
            "in": "query",
            "type": "string",
            "name": "preferred_normalization_type"
          },
          {
            "description": "Identifier of the resource on which normalization is to be performed",
            "required": true,
            "type": "string",
            "name": "resource_id",
            "in": "query"
          },
          {
            "enum": [
              "NSGroup"
            ],
            "description": "Resource type valid for use as source in normalization API.",
            "required": true,
            "in": "query",
            "type": "string",
            "name": "resource_type"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Normalization"
        ],
        "summary": "Get normalizations based on the query parameters",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetNormalizations"
      }
    },
    "/logical-routers/{logical-router-id}?action=reprocess": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Reprocess logical router configuration and configuration of related entities like logical router ports, static routing, etc.\nAny missing Updates are published to controller.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          }
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Reprocesses a logical router configuration and publish updates to controller",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReProcessLogicalRouterReprocess"
      }
    },
    "/bridge-clusters": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/BridgeCluster"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a bridge cluster. It is collection of transport nodes\nthat will do the bridging for overlay network to vlan networks.\nBridge cluster may have one or more transport nodes\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/BridgeCluster"
            },
            "required": true,
            "name": "BridgeCluster",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Create a Bridge Cluster",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateBridgeCluster"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BridgeClusterListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all configured bridge clusters\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "List All Bridge Clusters",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListBridgeClusters"
      }
    },
    "/app-discovery/sessions/{session-id}/ns-groups": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NSGroupMetaInfoListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the ns groups that was part of the application discovery session |\nwhile it was started\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "session-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "App Discovery"
        ],
        "summary": "ns-groups in this application discovery session",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetAppDiscoverySessionNsGroups"
      }
    },
    "/node/services/nsx-message-bus?action=start": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the NSX Message Bus service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the NSX Message Bus service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateNSXMessageBusServiceActionStart"
      }
    },
    "/realization-state-barrier/current": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/CurrentRealizationStateBarrier"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the current global realization barrier number for NSX",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Realization"
        ],
        "summary": "Gets the current barrier number",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetCurrentBarrier"
      }
    },
    "/cluster-profiles/{cluster-profile-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ClusterProfile"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifie a specified cluster profile. The body of the PUT request must\ninclude the resource_type.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "cluster-profile-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/ClusterProfile"
            },
            "required": true,
            "name": "ClusterProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Update a cluster profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateClusterProfile"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a specified cluster profile.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "cluster-profile-id",
            "in": "path"
          }
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Delete a cluster profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteClusterProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ClusterProfile"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about a specified cluster profile.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "cluster-profile-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Get cluster profile by Id",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetClusterProfile"
      }
    },
    "/fabric/nodes/{node-id}/network/interfaces/{interface-id}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeInterfaceProperties"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns detailed information about the specified interface. Interface\ninformation includes MTU, broadcast and host IP addresses, link and admin\nstatus, MAC address, network  mask, and the IP configuration method (static\nor DHCP).\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "interface-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Read the node's Network Interface",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadFabricNodeInterface"
      }
    },
    "/logical-routers/{logical-router-id}/debug-info?format=text": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "string"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "description": "Bad Request"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "API to download below information as text which will be used\nfor debugging and troubleshooting.\n1) Logical router sub-components and ports.\n2) Routing configuration as sent to central control plane.\n3) TIER1 advertised network information.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          }
        ],
        "produces": [
          "text/plain; charset=utf-8"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Read the debug information for the logical router",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadDebugInfoText"
      }
    },
    "/infra/domains/{domain-id}/communication-map/communication-entries": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/CommunicationEntryListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "List CommunicationEntries",
        "parameters": [
          {
            "description": "Domain ID",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "List CommunicationEntries",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListCommunicationEntry"
      }
    },
    "/logical-routers/{logical-router-id}/routing/bgp/neighbors/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BgpNeighborsStatusListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the status of all the BGP neighbors for the Logical Router of the given id. To get BGP neighbors status for the logical router from particular node, parameter \"transport_node_id=<transportnode_id>\" needs to be specified. The query parameter \"source=cached\" is not supported.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "Transport node id",
            "required": false,
            "type": "string",
            "name": "transport_node_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Get the status of all the BGP neighbors for the Logical Router of the given id",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetBgpNeighborsStatus"
      }
    },
    "/transport-nodes/{node-id}/tunnels": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TunnelList"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "List of tunnels",
        "parameters": [
          {
            "description": "ID of transport node",
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          },
          {
            "description": "BFD diagnostic code of Tunnel as defined in RFC 5880",
            "enum": [
              "0",
              "NO_DIAGNOSTIC",
              "1",
              "CONTROL_DETECTION_TIME_EXPIRED",
              "2",
              "ECHO_FUNCTION_FAILED",
              "3",
              "NEIGHBOR_SIGNALED_SESSION_DOWN",
              "4",
              "FORWARDING_PLANE_RESET",
              "5",
              "PATH_DOWN",
              "6",
              "CONCATENATED_PATH_DOWN",
              "7",
              "ADMINISTRATIVELY_DOWN",
              "8",
              "REVERSE_CONCATENATED_PATH_DOWN"
            ],
            "type": "string",
            "name": "bfd_diagnostic_code",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "string",
            "name": "remote_node_id",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "Tunnel status",
            "enum": [
              "UP",
              "DOWN"
            ],
            "type": "string",
            "name": "status",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Transport Entities"
        ],
        "summary": "List of tunnels",
        "consumes": [
          "application/json"
        ],
        "operationId": "QueryTunnels"
      }
    },
    "/network-encryption/sections": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/DneSection"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a network encryption section without rules",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/DneSection"
            },
            "required": true,
            "name": "DneSection",
            "in": "body"
          },
          {
            "in": "query",
            "description": "Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.",
            "required": false,
            "maxLength": 64,
            "type": "string",
            "name": "id"
          },
          {
            "enum": [
              "insert_top",
              "insert_bottom",
              "insert_after",
              "insert_before"
            ],
            "description": "Operation",
            "default": "insert_top",
            "required": true,
            "in": "query",
            "type": "string",
            "name": "operation"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Create a network encryption section without rules",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddDneSection"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneSectionListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get network encryption sections",
        "parameters": [
          {
            "description": "AppliedTo's  referenced by this section or section's DNE Rules .",
            "required": false,
            "type": "string",
            "name": "applied_tos",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Destinations referenced by this section's DNE Rules .",
            "required": false,
            "type": "string",
            "name": "destinations",
            "in": "query"
          },
          {
            "enum": [
              "FILTER",
              "SEARCH"
            ],
            "description": "Filter type",
            "default": "FILTER",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "filter_type"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "key policy identifier",
            "required": false,
            "type": "string",
            "name": "key_policy_id",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "NSService referenced by this section's DNE Rules .",
            "required": false,
            "type": "string",
            "name": "services",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "Sources referenced by this section's DNE Rules .",
            "required": false,
            "type": "string",
            "name": "sources",
            "in": "query"
          },
          {
            "enum": [
              "LAYER2",
              "LAYER3"
            ],
            "description": "Section Type",
            "default": "LAYER3",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "type"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get network encryption sections",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListDneSections"
      }
    },
    "/infra/domains/{domain-id}/communication-map?action=revise": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "This is used to set a precedence of a communication map w.r.t others.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/CommunicationMap"
            },
            "required": true,
            "name": "CommunicationMap",
            "in": "body"
          },
          {
            "description": "The communication map path if operation is 'insert_after'\nor insert_before\n",
            "required": false,
            "type": "string",
            "name": "anchor_path",
            "in": "query"
          },
          {
            "enum": [
              "insert_top",
              "insert_bottom",
              "insert_after",
              "insert_before"
            ],
            "description": "Operation",
            "default": "insert_top",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "operation"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Revise the positioninng of communication maps",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReviseCommunicationMapsRevise"
      }
    },
    "/upgrade/upgrade-unit-groups/aggregate-info": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/UpgradeUnitGroupAggregateInfoListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Return aggregate information of all upgrade unit groups",
        "parameters": [
          {
            "description": "Component type based on which upgrade unit groups to be filtered",
            "required": false,
            "type": "string",
            "name": "component_type",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "Flag indicating whether to return summary",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "summary"
          },
          {
            "description": "Synchronize before returning upgrade unit groups",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "sync"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Return aggregate information of all upgrade unit groups",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetUpgradeUnitGroupAggregateInfo"
      }
    },
    "/pools/ip-subnets": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/IpBlockSubnet"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Carves out a subnet of requested size from the specified IP block. The \"size\"\nparameter  and the \"block_id \" are the requireds field while invoking this API.\nIf the IP block has sufficient resources/space to allocate a subnet of specified size,\nthe response will contain all the details of the newly created subnet including the\ndisplay_name, description, cidr & allocation_ranges. Returns a conflict error\nif the IP block does not have enough resources/space to allocate a subnet of\nthe requested size.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/IpBlockSubnet"
            },
            "required": true,
            "name": "IpBlockSubnet",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "Create subnet of specified size within an IP block",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateIpBlockSubnet"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IpBlockSubnetListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all subnets present within an IP address\nblock. Information includes subnet's id, display_name, description, cidr and\nallocation ranges.\n",
        "parameters": [
          {
            "required": false,
            "type": "string",
            "name": "block_id",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "List subnets within an IP block",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListIpBlockSubnets"
      }
    },
    "/logical-routers/{logical-router-id}/routing/redistribution/rules": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RedistributionRuleList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies all route redistribution rules for the specified TIER0 logical\nrouter. Set the rules list to empty to delete/clear all rules.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/RedistributionRuleList"
            },
            "required": true,
            "name": "RedistributionRuleList",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Update All the Redistribution Rules on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateRedistributionRuleList"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RedistributionRuleList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns all the route redistribution rules for the specified\nlogical router.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Read All the Redistribution Rules on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadRedistributionRuleList"
      }
    },
    "/cluster/nodes/{node-id}/network/interfaces/{interface-id}/stats": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeInterfaceStatisticsProperties"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "On the specified interface, returns the number of received (rx), transmitted\n(tx), and dropped packets; the number of bytes and errors received and\ntransmitted on the interface; and the number of detected collisions.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "interface-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read the NSX Manager/Controller's Network Interface Statistics",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadClusterNodeInterfaceStatistics"
      }
    },
    "/firewall/excludelist?action=remove_member": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ResourceReference"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Remove an existing object from the exclude list",
        "parameters": [
          {
            "in": "query",
            "description": "identifier of the object",
            "required": true,
            "maxLength": 64,
            "type": "string",
            "name": "object_id"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Remove an existing object from the exclude list",
        "consumes": [
          "application/json"
        ],
        "operationId": "RemoveMemberRemove_member"
      }
    },
    "/cluster/nodes?action=revoke_missing_nodes": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Revoke Missing Nodes from the Cluster",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RevokeNodeRequest"
            },
            "required": true,
            "name": "RevokeNodeRequest",
            "in": "body"
          }
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Revoke Missing Nodes from the Cluster",
        "consumes": [
          "application/json"
        ],
        "operationId": "RevokeMissingClusterNodeConfigRevoke_missing_nodes"
      }
    },
    "/configs/management": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ManagementConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies the NSX Management nodes global configuration.",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ManagementConfig"
            },
            "required": true,
            "name": "ManagementConfig",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Update NSX Management nodes global configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateManagementConfig"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ManagementConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the NSX Management nodes global configuration.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read NSX Management nodes global configuration.",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadManagementConfig"
      }
    },
    "/node/services/ntp/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read NTP service status",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read NTP service status",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNTPServiceStatus"
      }
    },
    "/logical-switches/{lswitch-id}/state": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalSwitchState"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns current state of the logical switch configuration and details of only\nout-of-sync transport nodes.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "lswitch-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Get the realized state associated with provided logical switch id",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalSwitchState"
      }
    },
    "/node/logs/{log-name}/data": {
      "get": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "206": {
            "description": "Partial Content"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "For a single specified log file, returns the content of the log file.\nThis method supports byte-range requests. To request just a portion of a\nlog file, supply an HTTP Range header, e.g. \"Range: bytes=<start>-<end>\".\n<end> is optional, and, if omitted, the file contents from start to the\nend of the file are returned.'\n",
        "parameters": [
          {
            "description": "Name of log to read",
            "required": true,
            "type": "string",
            "name": "log-name",
            "in": "path"
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Read node log contents",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNodeLogData"
      }
    },
    "/ns-groups/{ns-group-id}/effective-ip-address-members": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/EffectiveIPAddressMemberListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns effective ip address members of the specified NSGroup.\n",
        "parameters": [
          {
            "description": "NSGroup Id",
            "required": true,
            "type": "string",
            "name": "ns-group-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Get Effective IPAddress translated from the NSGroup",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetEffectiveIPAddressMembers"
      }
    },
    "/fabric/discovered-nodes/{node-ext-id}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DiscoveredNode"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about a specific discovered node.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-ext-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Return Discovered Node Information",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadDiscoveredNode"
      }
    },
    "/services": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/LogicalService"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a service that can be applied to one or more logical router ports.\nFor some service types, you must create a service-profile before you can\ncreate a service.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/LogicalService"
            },
            "required": true,
            "name": "LogicalService",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Create a Logical Router Service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateService"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalServiceListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all configured logical router services that can be\napplied to one or more logical router ports. You must create a\nservice-profile before you can create a service. Currently, only\nDhcpRelayService is supported.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "required": false,
            "type": "string",
            "name": "resource_type",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "List all Logical Router Services",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListServices"
      }
    },
    "/dhcp/relay-profiles": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/DhcpRelayProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a dhcp relay profile.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/DhcpRelayProfile"
            },
            "required": true,
            "name": "DhcpRelayProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Create a DHCP Relay Profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateDhcpRelayProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DhcpRelayProfileListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all dhcp relay profiles.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "List All DHCP Relay Profiles",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListDhcpRelayProfiles"
      }
    },
    "/upgrade/upgrade-units/{upgrade-unit-id}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/UpgradeUnit"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get a specific upgrade unit",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "upgrade-unit-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Get a specific upgrade unit",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetUpgradeUnit"
      }
    },
    "/upgrade/upgrade-unit-groups/{group-id}?action=reorder": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Reorder upgrade unit group",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "group-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/ReorderRequest"
            },
            "required": true,
            "name": "ReorderRequest",
            "in": "body"
          }
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Reorder upgrade unit group",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReorderUpgradeUnitGroupReorder"
      }
    },
    "/lldp/transport-nodes/{node-id}/interfaces/{interface-name}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/InterfaceNeighborProperties"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read LLDP Neighbor Properties",
        "parameters": [
          {
            "description": "ID of transport node",
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          },
          {
            "description": "Interface name to read",
            "required": true,
            "type": "string",
            "name": "interface-name",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Read LLDP Neighbor Properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNeighborProperties"
      }
    },
    "/loadbalancer/persistence-profiles": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbPersistenceProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a load balancer persistence profile.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/LbPersistenceProfile"
            },
            "required": true,
            "name": "LbPersistenceProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Create a load balancer persistence profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateLoadBalancerPersistenceProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbPersistenceProfileListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Retrieve a paginated list of load balancer persistence profiles.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "enum": [
              "LbCookiePersistenceProfile",
              "LbSourceIpPersistenceProfile"
            ],
            "description": "persistence profile type",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "type"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Retrieve a paginated list of load balancer persistence profiles",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListLoadBalancerPersistenceProfiles"
      }
    },
    "/cluster/restore/instruction-resources": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ActionableResourceListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "For restore operations requiring user input e.g. performing an action,\naccepting/rejecting an action, etc. the information to be conveyed to users\nis provided in this call.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Id of the instruction set whose instructions are to be returned",
            "required": true,
            "type": "string",
            "name": "instruction_id",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "List resources for a given instruction, to be\nshown to/executed by users.\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListRestoreInstructionResources"
      }
    },
    "/transport-nodes/{node-id}/pnic-bond-status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/PnicBondStatusListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get high-level summary of a transport node",
        "parameters": [
          {
            "description": "ID of transport node",
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Get high-level summary of a transport node",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetPnicStatusesForTransportNode"
      }
    },
    "/loadbalancer/server-ssl-profiles/{server-ssl-profile-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbServerSslProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a load balancer server-ssl profile.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "server-ssl-profile-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/LbServerSslProfile"
            },
            "required": true,
            "name": "LbServerSslProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update a load balancer server-ssl profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateLoadBalancerServerSslProfile"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a load balancer server-ssl profile.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "server-ssl-profile-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Delete a load balancer server-ssl profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteLoadBalancerServerSslProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbServerSslProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Retrieve a load balancer server-ssl profile.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "server-ssl-profile-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Retrieve a load balancer server-ssl profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadLoadBalancerServerSslProfile"
      }
    },
    "/fabric/discovered-nodes": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DiscoveredNodeListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all discovered nodes.",
        "parameters": [
          {
            "description": "Local Id of the discovered node in the Compute Manager",
            "required": false,
            "type": "string",
            "name": "cm_local_id",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Display name of discovered node",
            "required": false,
            "type": "string",
            "name": "display_name",
            "in": "query"
          },
          {
            "description": "External id of the discovered node, ex. a mo-ref from VC",
            "required": false,
            "type": "string",
            "name": "external_id",
            "in": "query"
          },
          {
            "enum": [
              "true",
              "false"
            ],
            "description": "Discovered node has a parent compute collection or is a standalone host",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "has_parent"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "IP address of the discovered node",
            "required": false,
            "type": "string",
            "name": "ip_address",
            "in": "query"
          },
          {
            "description": "Id of the fabric node created from the discovered node",
            "required": false,
            "type": "string",
            "name": "node_id",
            "in": "query"
          },
          {
            "description": "Discovered Node type like HostNode",
            "required": false,
            "type": "string",
            "name": "node_type",
            "in": "query"
          },
          {
            "description": "Id of the compute manager from where this node was discovered",
            "required": false,
            "type": "string",
            "name": "origin_id",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "External id of the compute collection to which this node belongs",
            "required": false,
            "type": "string",
            "name": "parent_compute_collection",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Return the List of Discovered Nodes",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListDiscoveredNodes"
      }
    },
    "/logical-switches/{lswitch-id}/statistics": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalSwitchStatistics"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns statistics  of a specified logical switch.\nThe query parameter \"source=realtime\" is not supported.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "lswitch-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Get Statistics for Logical Switch of the Given ID (lswitch-id)",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalSwitchStatistics"
      }
    },
    "/edge-clusters/{edge-cluster-id}?action=replace_transport_node": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/EdgeCluster"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Replace the transport node in the specified member of the edge-cluster.\nThis is a disruptive action. This will move all the LogicalRouterPorts(uplink and routerLink)\nhost on the old transport_node to the new transport_node. The transportNode cannot be\npresent in another member of any edgeClusters.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "edge-cluster-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/EdgeClusterMemberTransportNode"
            },
            "required": true,
            "name": "EdgeClusterMemberTransportNode",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Replace the transport node in the specified member of the edge-cluster",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReplaceEdgeClusterMemberTransportNodeReplace_transport_node"
      }
    },
    "/trust-management/certificates": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/CertificateList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns all certificate information viewable by the user, including each\ncertificate's UUID; resource_type (for example, certificate_self_signed,\ncertificate_ca, or certificate_signed); pem_encoded data; and history of the\ncertificate (who created or modified it and when). For additional\ninformation, include the ?details=true modifier at the end of the request\nURI.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "whether to expand the pem data and show all its details",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "details"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Return All the User-Facing Components' Certificates",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetCertificates"
      }
    },
    "/infra/realized-state/enforcement-points/{enforcement-point-name}/mac-sets/mac-sets-nsxt/{mac-set-name}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RealizedMACSet"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read an MACSet\n",
        "parameters": [
          {
            "description": "Enforcement Point Name",
            "required": true,
            "type": "string",
            "name": "enforcement-point-name",
            "in": "path"
          },
          {
            "description": "MACSet name",
            "required": true,
            "type": "string",
            "name": "mac-set-name",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Read MACSet Realized state",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadMACSetRealizedState"
      }
    },
    "/associations": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AssociationListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about resources that are associated with the given\nresource. Id and type of the resource for which associated resources are\nto be fetched are to be specified as query parameter in the URI. Resource\ntype of the associated resources must be specified as query\nparameter.\n",
        "parameters": [
          {
            "enum": [
              "NSGroup"
            ],
            "description": "Resource type valid for use as target in association API",
            "required": true,
            "in": "query",
            "type": "string",
            "name": "associated_resource_type"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Fetch complete list of associated resources considering\ncontainment and nesting\n",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "fetch_ancestors"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "The resource for which associated resources are to be fetched",
            "required": true,
            "type": "string",
            "name": "resource_id",
            "in": "query"
          },
          {
            "enum": [
              "NSGroup",
              "IPSet",
              "MACSet",
              "LogicalSwitch",
              "LogicalPort",
              "VirtualMachine"
            ],
            "description": "Resource type valid for use as source in association API",
            "required": true,
            "in": "query",
            "type": "string",
            "name": "resource_type"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Associations"
        ],
        "summary": "Get ResourceReference objects to which the given resource belongs to\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetAssociations"
      }
    },
    "/bridge-clusters/{cluster-id}/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BridgeClusterStatus"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get the status for the Bridge Cluster of the given cluster id",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "cluster-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Returns status of a specified Bridge Cluster",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetBridgeClusterStatus"
      }
    },
    "/upgrade/plan?action=continue": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Continue upgrade",
        "parameters": [
          {
            "description": "Skip to upgrade of next component.",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "skip"
          }
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Continue upgrade",
        "consumes": [
          "application/json"
        ],
        "operationId": "ContinueUpgradeContinue"
      }
    },
    "/logical-switches/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalSwitchStatusSummary"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns Operational status of all logical switches.\nThe query parameter \"source=realtime\" is not supported.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Flag to enable showing of transit logical switch.",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "diagnostic"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "Switching Profile identifier",
            "required": false,
            "type": "string",
            "name": "switching_profile_id",
            "in": "query"
          },
          {
            "enum": [
              "OVERLAY",
              "VLAN"
            ],
            "description": "Mode of transport supported in the transport zone for this logical switch",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "transport_type"
          },
          {
            "description": "Transport zone identifier",
            "required": false,
            "type": "string",
            "name": "transport_zone_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Get Status Summary of All Logical Switches in the System",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalSwitchStatusSummary"
      }
    },
    "/firewall/excludelist": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ExcludeList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modify exclude list",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ExcludeList"
            },
            "required": true,
            "name": "ExcludeList",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Modify exclude list",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateExcludeList"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ExcludeList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get list of entities in exclude list",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get list of entities in exclude list",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetExcludeList"
      }
    },
    "/app-discovery/sessions/{session-id}/summary": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AppDiscoverySessionResultSummary"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the summary of the application discovery session\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "session-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "App Discovery"
        ],
        "summary": "Returns the summary of the application discovery session",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetAppDiscoverySessionSummary"
      }
    },
    "/upgrade/upgrade-units/aggregate-info": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/UpgradeUnitAggregateInfoListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get upgrade units aggregate-info",
        "parameters": [
          {
            "description": "Component type based on which upgrade units to be filtered",
            "required": false,
            "type": "string",
            "name": "component_type",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Identifier of group based on which upgrade units to be filtered",
            "required": false,
            "type": "string",
            "name": "group_id",
            "in": "query"
          },
          {
            "description": "Flag to indicate whether to return only upgrade units with errors",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "has_errors"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Metadata about upgrade unit to filter on",
            "required": false,
            "type": "string",
            "name": "metadata",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "enum": [
              "SELECTED",
              "DESELECTED",
              "ALL"
            ],
            "description": "Flag to indicate whether to return only selected, only deselected or both type of upgrade units",
            "default": "ALL",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "selection_status"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Get upgrade units aggregate-info",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetUpgradeUnitAggregateInfo"
      }
    },
    "/logical-routers/{logical-router-id}/routing/route-table": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalRouterRouteTable"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deprecated - Please use /logical-routers/<logical-router-id>/routing/routing-table for RIB and\n/logical-routers/<logical-router-id>/routing/forwarding-table for FIB.\nReturns the route table for the logical router on a node of the given transport-node-id.\nQuery parameter \"transport_node_id=<transport-node-id>\" is required.\nThe query parameter \"source=cached\" is not supported.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "TransportNode Id",
            "required": true,
            "type": "string",
            "name": "transport_node_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Get route table on a given node for a logical router",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalRouterRouteTable"
      }
    },
    "/fabric/compute-collections/{cc-ext-id}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ComputeCollection"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about a specific compute collection.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "cc-ext-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Return Compute Collection Information",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadComputeCollection"
      }
    },
    "/ui-views/dashboard/widgetconfigurations/{widgetconfiguration-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/WidgetConfiguration"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update Widget Configuration",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "widgetconfiguration-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/WidgetConfiguration"
            },
            "required": true,
            "name": "WidgetConfiguration",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Dashboard"
        ],
        "summary": "Update Widget Configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateWidgetConfiguration"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/WidgetConfiguration"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns Information about a specific Widget Configuration\n( 'LabelValueConfiguration' ).\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "widgetconfiguration-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Dashboard"
        ],
        "summary": "Returns Widget Configuration Information",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetWidgetConfiguration"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete Widget Configuration",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "widgetconfiguration-id",
            "in": "path"
          }
        ],
        "tags": [
          "Dashboard"
        ],
        "summary": "Delete Widget Configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteWidgetConfiguration"
      }
    },
    "/ip-sets": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/IPSet"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a new IPSet that can group either IPv4 or IPv6 individual ip addresses,\nranges or subnets.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/IPSet"
            },
            "required": true,
            "name": "IPSet",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Create IPSet",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateIPSet"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IPSetListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns paginated list of IPSets\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "List IPSets",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListIPSets"
      }
    },
    "/trust-management/certificates/{cert-id}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/Certificate"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information for the specified certificate ID, including the\ncertificate's UUID; resource_type (for example, certificate_self_signed,\ncertificate_ca, or certificate_signed); pem_encoded data; and history of the\ncertificate (who created or modified it and when). For additional\ninformation, include the ?details=true modifier at the end of the request\nURI.\n",
        "parameters": [
          {
            "description": "ID of certificate to read",
            "required": true,
            "type": "string",
            "name": "cert-id",
            "in": "path"
          },
          {
            "description": "whether to expand the pem data and show all its details",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "details"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Show Certificate Data for the Given Certificate ID",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetCertificate"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Removes the specified certificate. The private key associated with the\ncertificate is also deleted.\n",
        "parameters": [
          {
            "description": "ID of certificate to delete",
            "required": true,
            "type": "string",
            "name": "cert-id",
            "in": "path"
          }
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Delete Certificate for the Given Certificate ID",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteCertificate"
      }
    },
    "/app-discovery/app-profiles": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/AppProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Adds a new app profile\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/AppProfile"
            },
            "required": true,
            "name": "AppProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "App Discovery"
        ],
        "summary": "Adds a new app profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddAppProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AppProfileListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns list of app profile IDs created\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "App Discovery"
        ],
        "summary": "Returns list of app profile IDs created",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetAppProfiles"
      }
    },
    "/node/logs": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeLogPropertiesListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the number of log files and lists the log files that reside on the\nNSX virtual appliance. The list includes the filename, file size,\nand last-modified time in milliseconds since epoch (1 January 1970) for each\nlog file. Knowing the last-modified time with millisecond accuracy since\nepoch is helpful when you are comparing two times, such as the time of a\nPOST request and the end time on a server.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "List available node logs",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListNodeLogs"
      }
    },
    "/csm/nsx-manager-accounts": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NsxManagerAccount"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a NSX Manager account",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/NsxManagerAccount"
            },
            "required": true,
            "name": "NsxManagerAccount",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Create a NSX Manager account",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateNsxManagerAccount"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NsxManagerAccountsListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns a list of NSX Manager accounts",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Returns a list of NSX Manager accounts",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListNsxManagerAccounts"
      }
    },
    "/network-encryption/sections/{section-id}?action=revise": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneSection"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a network encryption section and/or its position",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/DneSection"
            },
            "required": true,
            "name": "DneSection",
            "in": "body"
          },
          {
            "in": "query",
            "description": "Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.",
            "required": false,
            "maxLength": 64,
            "type": "string",
            "name": "id"
          },
          {
            "enum": [
              "insert_top",
              "insert_bottom",
              "insert_after",
              "insert_before"
            ],
            "description": "Operation",
            "default": "insert_top",
            "required": true,
            "in": "query",
            "type": "string",
            "name": "operation"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update a network encryption section and/or its position",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReviseDneSectionRevise"
      }
    },
    "/eula/accept": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Accept end user license agreement\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Licensing"
        ],
        "summary": "Accept end user license agreement\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "AcceptEULA"
      }
    },
    "/transport-nodes/{node-id}/tunnels/{tunnel-name}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TunnelProperties"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Tunnel properties",
        "parameters": [
          {
            "description": "ID of transport node",
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          },
          {
            "description": "Tunnel name",
            "required": true,
            "type": "string",
            "name": "tunnel-name",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Transport Entities"
        ],
        "summary": "Tunnel properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetTunnel"
      }
    },
    "/infra/realized-state/enforcement-points/{enforcement-point-name}/groups/securitygroups/{securitygroup-name}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RealizedSecurityGroup"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read a Security Group and the complete tree underneath. Returns the\npopulated Security Group object.\n",
        "parameters": [
          {
            "description": "Enforcement Point Name",
            "required": true,
            "type": "string",
            "name": "enforcement-point-name",
            "in": "path"
          },
          {
            "description": "Group Name",
            "required": true,
            "type": "string",
            "name": "securitygroup-name",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Read Group",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadSecurityGroupRealizedState"
      }
    },
    "/pools/vtep-label-pools": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/VtepLabelPoolListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns a list of all virtual tunnel endpoint label pools\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "List virtual tunnel endpoint Label Pools",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListVtepLabelPools"
      }
    },
    "/firewall/sections?action=create_with_rules": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/FirewallSectionRuleList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a new firewall section with rules. The limit on the number of\nrules is defined by maxItems in collection types for FirewallRule\n(FirewallRuleXXXList types). When invoked on a section with a large number\nof rules, this API is supported only at low rates of invocation (not more\nthan 4-5 times per minute). The typical latency of this API with about 1024\nrules is about 4-5 seconds. This API should not be invoked with large\npayloads at automation speeds. More than 50 rules with a large number of\nrule references is not supported.\n\nInstead, to create sections, use:\nPOST /api/v1/firewall/sections\n\nTo create rules, use:\nPOST /api/v1/firewall/sections/&lt;section-id&gt;/rules\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/FirewallSectionRuleList"
            },
            "required": true,
            "name": "FirewallSectionRuleList",
            "in": "body"
          },
          {
            "in": "query",
            "description": "Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.",
            "required": false,
            "maxLength": 64,
            "type": "string",
            "name": "id"
          },
          {
            "enum": [
              "insert_top",
              "insert_bottom",
              "insert_after",
              "insert_before"
            ],
            "description": "Operation",
            "default": "insert_top",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "operation"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Create a Section with Rules",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddSectionWithRulesCreate_with_rules"
      }
    },
    "/node/network/search-domains": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeSearchDomainsProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies the list of domain names that the NSX Manager node uses to complete\nunqualified host names. If DHCP is configured, this method returns\na 409 CONFLICT error, because DHCP manages the list of name servers.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/NodeSearchDomainsProperties"
            },
            "required": true,
            "name": "NodeSearchDomainsProperties",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Update the NSX Manager's Search Domains",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateNodeSearchDomains"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeSearchDomainsProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the domain list that the NSX Manager node uses to complete\nunqualified host names. When a host name does not include a fully\nqualified domain name (FQDN), the NSX Management node appends the\nfirst-listed domain name to the host name before the host name is looked\nup. The NSX Management node continues this for each entry in the domain\nlist until it finds a match.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read the NSX Manager's Search Domains",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNodeSearchDomains"
      }
    },
    "/network-encryption/sections/{section-id}/rules/{rule-id}?action=revise": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneRule"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update or reorder a rule in a network encryption section",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "rule-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/DneRule"
            },
            "required": true,
            "name": "DneRule",
            "in": "body"
          },
          {
            "in": "query",
            "description": "Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.",
            "required": false,
            "maxLength": 64,
            "type": "string",
            "name": "id"
          },
          {
            "enum": [
              "insert_top",
              "insert_bottom",
              "insert_after",
              "insert_before"
            ],
            "description": "Operation",
            "default": "insert_top",
            "required": true,
            "in": "query",
            "type": "string",
            "name": "operation"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update or reorder a rule in a network encryption section",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReviseDneRuleRevise"
      }
    },
    "/realization-state-barrier/current?action=increment": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/CurrentRealizationStateBarrier"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Increments the barrier count by 1",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Realization"
        ],
        "summary": "Increments the barrier count by 1",
        "consumes": [
          "application/json"
        ],
        "operationId": "IncrementRealizationStateBarrierIncrement"
      }
    },
    "/transport-nodes/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/HeatMapTransportZoneStatus"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get high-level summary of all transport nodes. The service layer does not support source = realtime or cached.",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Get high-level summary of all transport nodes. The service layer does not support source = realtime or cached.",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetAllTransportNodesStatus"
      }
    },
    "/ns-groups/{ns-group-id}/effective-logical-switch-members": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/EffectiveMemberResourceListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns effective logical switch members of the specified NSGroup.\n",
        "parameters": [
          {
            "description": "NSGroup Id",
            "required": true,
            "type": "string",
            "name": "ns-group-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Get Effective switch members translated from the NSGroup",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetEffectiveLogicalSwitchMembers"
      }
    },
    "/logical-routers/{logical-router-id}/routing/bgp/neighbors": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BgpNeighbor"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Add a new BGP Neighbor on a Logical Router\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/BgpNeighbor"
            },
            "required": true,
            "name": "BgpNeighbor",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Add a new BGP Neighbor on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddBgpNeighbor"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BgpNeighborListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Paginated list of BGP Neighbors on a Logical Router\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Paginated list of BGP Neighbors on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListBgpNeighbors"
      }
    },
    "/transport-nodes/{node-id}/remote-transport-node-status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TransportNodeStatusListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read status of all transport nodes with tunnel connections to transport node\n",
        "parameters": [
          {
            "description": "ID of transport node",
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          },
          {
            "description": "BFD diagnostic code of Tunnel as defined in RFC 5880",
            "enum": [
              "0",
              "NO_DIAGNOSTIC",
              "1",
              "CONTROL_DETECTION_TIME_EXPIRED",
              "2",
              "ECHO_FUNCTION_FAILED",
              "3",
              "NEIGHBOR_SIGNALED_SESSION_DOWN",
              "4",
              "FORWARDING_PLANE_RESET",
              "5",
              "PATH_DOWN",
              "6",
              "CONCATENATED_PATH_DOWN",
              "7",
              "ADMINISTRATIVELY_DOWN",
              "8",
              "REVERSE_CONCATENATED_PATH_DOWN"
            ],
            "type": "string",
            "name": "bfd_diagnostic_code",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "Tunnel Status",
            "enum": [
              "UP",
              "DOWN"
            ],
            "type": "string",
            "name": "tunnel_status",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Read status of all transport nodes with tunnel connections to transport node\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListRemoteTransportNodeStatus"
      }
    },
    "/ipfix/configs": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/IpfixConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "description": "Bad Request"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a new IPFIX configuration",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/IpfixConfig"
            },
            "required": true,
            "name": "IpfixConfig",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Operations"
        ],
        "summary": "Create a new IPFIX configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateIpfixConfig"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IpfixConfigListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "List IPFIX configuration",
        "parameters": [
          {
            "description": "Applied To",
            "required": false,
            "type": "string",
            "name": "applied_to",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "enum": [
              "IpfixSwitchConfig",
              "IpfixDfwConfig"
            ],
            "description": "Supported IPFIX Config Types.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "ipfix_config_type"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Operations"
        ],
        "summary": "List IPFIX configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListIpfixConfig"
      }
    },
    "/node/services/node-mgmt?action=restart": {
      "post": {
        "responses": {
          "202": {
            "description": "Accepted"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart the node management service",
        "operationId": "CreateApplianceManagementServiceActionRestart",
        "consumes": [
          "application/json"
        ],
        "description": "Restart the node management service"
      }
    },
    "/error-resolver/{error_id}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ErrorResolverInfo"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns some metadata about the given error_id. This includes\ninformation of whether there is a resolver present for the\ngiven error_id and its associated user input data\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "error_id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Error Resolver"
        ],
        "summary": "Fetches metadata about the given error_id",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetErrorResolverInfo"
      }
    },
    "/node/services/ssh?action=restart": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the ssh service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the ssh service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateSSHServiceActionRestart"
      }
    },
    "/node/services/syslog/exporters/{exporter-name}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeSyslogExporterProperties"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about a specific syslog collection point.",
        "parameters": [
          {
            "description": "Name of syslog exporter",
            "required": true,
            "type": "string",
            "name": "exporter-name",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read node syslog exporter",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNodeSyslogExporter"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Removes a specified rule from the collection of syslog exporter rules.\n",
        "parameters": [
          {
            "description": "Name of syslog exporter to delete",
            "required": true,
            "type": "string",
            "name": "exporter-name",
            "in": "path"
          }
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Delete node syslog exporter",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteNodeSyslogExporter"
      }
    },
    "/cluster/nodes/{node-id}/network/interfaces/{interface-id}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeInterfaceProperties"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns detailed information about the specified interface. Interface\ninformation includes MTU, broadcast and host IP addresses, link and admin\nstatus, MAC address, network  mask, and the IP configuration method (static\nor DHCP).\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "interface-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read the node's Network Interface",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadClusterNodeInterface"
      }
    },
    "/fabric/virtual-machines": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/VirtualMachineListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all virtual machines.",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Display Name of the virtual machine",
            "required": false,
            "type": "string",
            "name": "display_name",
            "in": "query"
          },
          {
            "description": "External id of the virtual machine",
            "required": false,
            "type": "string",
            "name": "external_id",
            "in": "query"
          },
          {
            "description": "Id of the host where this vif is located",
            "required": false,
            "type": "string",
            "name": "host_id",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Return the List of Virtual Machines",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListVirtualMachines"
      }
    },
    "/infra/services/{service-id}": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a new service if a service with the given ID does not already\nexist. Creates new service entries if populated in the service.\nIf a service with the given ID already exists, update the service\nincluding the nested service entries. This is a full replace.\n",
        "parameters": [
          {
            "description": "Service ID",
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/Service"
            },
            "required": true,
            "name": "Service",
            "in": "body"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Create or update a Service",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateServiceForTenant"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/Service"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read a service",
        "parameters": [
          {
            "description": "Service ID",
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Read a service",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadServiceForTenant"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete Service",
        "parameters": [
          {
            "description": "Service ID",
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Delete Service",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteServiceForTenant"
      }
    },
    "/logical-routers/{logical-router-id}/routing/forwarding-table?format=csv": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalRouterRouteTableInCsvFormat"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the FIB table in CSV format for the logical router on a node of the given\ntransport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required.\nTo filter the result by network address, paramter \"network_prefix=<a.b.c.d/mask>\"\nneeds to be specified.\nThe query parameter \"source=cached\" is not supported.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "description": "IPv4 CIDR Block",
            "format": "ipv4-cidr-block",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "network_prefix"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "TransportNode Id",
            "required": true,
            "type": "string",
            "name": "transport_node_id",
            "in": "query"
          }
        ],
        "produces": [
          "text/csv"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Get FIB table on a specified node for a logical router",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalRouterForwardingTableInCsvFormatCsv"
      }
    },
    "/md-proxies/{proxy-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/MetadataProxy"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a metadata proxy",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "proxy-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/MetadataProxy"
            },
            "required": true,
            "name": "MetadataProxy",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update a metadata proxy",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateMetadataProxy"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/MetadataProxy"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get a metadata proxy",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "proxy-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get a metadata proxy",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadMetadataProxy"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a metadata proxy",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "proxy-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Delete a metadata proxy",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteMetadataProxy"
      }
    },
    "/fabric/nodes/{node-id}/network/interfaces": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeInterfacePropertiesListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the number of interfaces on the node and detailed\ninformation about each interface. Interface information includes MTU,\nbroadcast and host IP addresses, link and admin status, MAC address, network\nmask, and the IP configuration method (static or DHCP).\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "List the specified node's Network Interfaces",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListFabricNodeInterfaces"
      }
    },
    "/network-encryption/key-policies": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/DneKeyPolicy"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a network encryption key policy",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/DneKeyPolicy"
            },
            "required": true,
            "name": "DneKeyPolicy",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Create a network encryption key policy",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddDneKeyPolicy"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneKeyPolicyListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get all network encryption key policies",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "enum": [
              "ENC_NULL",
              "ENC_AES_GCM_128"
            ],
            "description": "DNE key encryption algorithm",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "encrypt_algorithm"
          },
          {
            "enum": [
              "INTEGRITY_ONLY",
              "ENCRYPTION_AND_INTEGRITY"
            ],
            "description": "Key policy encryption type",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "encrypt_type"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "enum": [
              "MAC_ALG_AES_GCM_128"
            ],
            "description": "MAC algorithm type",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "mac_algorithm"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get all network encryption key policies",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListDneKeyPolicies"
      }
    },
    "/fabric/nodes/{node-id}?action=upgrade_infra": {
      "post": {
        "responses": {
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/Node"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Perform a service deployment upgrade on a host node",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          },
          {
            "description": "Should VM migration be disabled during upgrade",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "disable_vm_migration"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Perform a service deployment upgrade on a host node",
        "consumes": [
          "application/json"
        ],
        "operationId": "PerformHostNodeUpgradeActionUpgrade_infra"
      }
    },
    "/dhcp/servers/{server-id}/static-bindings/{binding-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DhcpStaticBinding"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a DHCP server's static binding",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "server-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "binding-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/DhcpStaticBinding"
            },
            "required": true,
            "name": "DhcpStaticBinding",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update a DHCP server's static binding",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateDhcpStaticBinding"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a static binding",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "server-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "binding-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Delete a static binding",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteDhcpStaticBinding"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DhcpStaticBinding"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get a DHCP server's static binding with the specified binding ID",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "server-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "binding-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get a DHCP server's static binding with the specified binding ID",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadDhcpStaticBinding"
      }
    },
    "/logical-routers/{logical-router-id}/routing/routing-table": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalRouterRouteTable"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the route table(RIB) for the logical router on a node of the given transport-node-id.\nQuery parameter \"transport_node_id=<transport-node-id>\" is required.\nTo filter the result by network address, parameter \"network_prefix=<a.b.c.d/mask>\"\nneeds to be specified.\nTo filter the result by route source, parameter \"route_source=<source_type>\" needs to be specified\nwhere source_type can be BGP, STATIC, CONNECTED, NSX_STATIC, TIER1_NAT or TIER0_NAT.\nIt is also possible to filter the RIB table using both network address and\nroute source filter together.\nThe query parameter \"source=cached\" is not supported.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "IPv4 CIDR Block",
            "format": "ipv4-cidr-block",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "network_prefix"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "enum": [
              "BGP",
              "STATIC",
              "CONNECTED"
            ],
            "description": "To filter the RIB table based on the source from which route is learned.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "route_source"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "TransportNode Id",
            "required": true,
            "type": "string",
            "name": "transport_node_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Get RIB table on a specified node for a logical router",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalRouterRoutingTable"
      }
    },
    "/node/services/snmp?action=start": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the SNMP service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the SNMP service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateSNMPServiceActionStart"
      }
    },
    "/node/services/snmp?action=restart": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the SNMP service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the SNMP service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateSNMPServiceActionRestart"
      }
    },
    "/network-encryption/key-managers/{key-manager-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneKeyManager"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a specific network encryption key manager configuration",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "key-manager-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/DneKeyManager"
            },
            "required": true,
            "name": "DneKeyManager",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update a specific network encryption key manager configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateDneKeyManager"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneKeyManager"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get configuration for a specific network encryption key manager",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "key-manager-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get configuration for a specific network encryption key manager",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetDneKeyManager"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete an attached network encryption key manager",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "key-manager-id",
            "in": "path"
          }
        ],
        "tags": [
          "Services"
        ],
        "summary": "Delete an attached network encryption key manager",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteDneKeyManager"
      }
    },
    "/node/file-store/{file-name}/thumbprint": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FileThumbprint"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read file thumbprint",
        "parameters": [
          {
            "description": "Name of the file for which thumbprint should be computed",
            "required": true,
            "type": "string",
            "name": "file-name",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read file thumbprint",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadFileThumbprint"
      }
    },
    "/network-encryption/key-managers": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/DneKeyManager"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Add a network encryption key manager configuration",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/DneKeyManager"
            },
            "required": true,
            "name": "DneKeyManager",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Add a network encryption key manager configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddDneKeyManager"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneKeyManagerListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get all configured instances of network encryption key managers",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get all configured instances of network encryption key managers",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListDneKeyManagers"
      }
    },
    "/transport-nodes/{node-id}/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TransportNodeStatus"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read status of a transport node",
        "parameters": [
          {
            "description": "ID of transport node",
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Read status of a transport node",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetTransportNodeStatus"
      }
    },
    "/infra/deployment-zones/{deployment-zone-id}/enforcement-points/{enforcementpoint-id}": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "If the passed Enforcement Point does not already exist, create a new Enforcement Point.\nIf it already exists, replace it.\n",
        "parameters": [
          {
            "description": "Deployment zone id",
            "required": true,
            "type": "string",
            "name": "deployment-zone-id",
            "in": "path"
          },
          {
            "description": "EnforcementPoint id",
            "required": true,
            "type": "string",
            "name": "enforcementpoint-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/EnforcementPoint"
            },
            "required": true,
            "name": "EnforcementPoint",
            "in": "body"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Create/update a new Enforcement Point under infra",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateOrUpdateEnforcementPointForInfra"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/EnforcementPoint"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read an Enforcement Point\n",
        "parameters": [
          {
            "description": "Deployment zone id",
            "required": true,
            "type": "string",
            "name": "deployment-zone-id",
            "in": "path"
          },
          {
            "description": "EnforcementPoint id",
            "required": true,
            "type": "string",
            "name": "enforcementpoint-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Read an Enforcement Point",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadEnforcementPointForInfra"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete EnforcementPoint",
        "parameters": [
          {
            "description": "Deployment zone id",
            "required": true,
            "type": "string",
            "name": "deployment-zone-id",
            "in": "path"
          },
          {
            "description": "enforcementpoint-id",
            "required": true,
            "type": "string",
            "name": "enforcementpoint-id",
            "in": "path"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Delete EnforcementPoint",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteEnforcementPoint"
      }
    },
    "/loadbalancer/services/{service-id}/virtual-servers/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbVirtualServerStatusListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the status list of virtual servers in given load balancer service.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get the status list of virtual servers in given load balancer service",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListLoadBalancerVirtualServerStatuses"
      }
    },
    "/dhcp/server-profiles/{profile-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DhcpProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a DHCP server profile",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "profile-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/DhcpProfile"
            },
            "required": true,
            "name": "DhcpProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update a DHCP server profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateDhcpProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DhcpProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get a DHCP server profile",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "profile-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get a DHCP server profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadDhcpProfile"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a DHCP server profile",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "profile-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Delete a DHCP server profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteDhcpProfile"
      }
    },
    "/node/services/liagent/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read liagent service status",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read liagent service status",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadLiagentServiceStatus"
      }
    },
    "/network-encryption/sections/{section-id}?action=list_with_rules": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneSectionRuleList"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "When invoked on a section with a large number of rules, this API is\nsupported only at low rates of invocation (not more than 4-5 times per\nminute). The typical latency of this API with about 1024 rules is about 4-5\nseconds. This API should not be invoked with large payloads at automation\nspeeds. More than 50 rules with a large number rule references is not\nsupported.\n\nInstead, to get network encryption rules, use:\nGET /api/v1/network-encryption/sections/&lt;section-id&gt;/rules with\nthe appropriate page size.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get a specific network encryption section and its rules",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetDneSectionWithRulesList_with_rules"
      }
    },
    "/upgrade/upgrade-unit-groups/{group-id}?action=add_upgrade_units": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/UpgradeUnitList"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Add upgrade units to specified upgrade unit group",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "group-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/UpgradeUnitList"
            },
            "required": true,
            "name": "UpgradeUnitList",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Add upgrade units to specified upgrade unit group",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddUpgradeUnitsToGroupAdd_upgrade_units"
      }
    },
    "/cluster/restore?action=start": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ClusterRestoreStatus"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "409": {
            "description": "Conflict",
            "schema": {
              "$ref": "#/definitions/ClusterRestoreStatus"
            }
          }
        },
        "description": "Start the restore of an NSX cluster, from some previously\nbacked-up configuration. This operation is only valid\nwhen a GET cluster/restore/status returns a status with value NOT_STARTED.\nOtherwise, a 409 response is returned.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/InitiateClusterRestoreRequest"
            },
            "required": true,
            "name": "InitiateClusterRestoreRequest",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Initiate a restore operation",
        "consumes": [
          "application/json"
        ],
        "operationId": "InitiateClusterRestoreStart"
      }
    },
    "/fabric/compute-managers": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/ComputeManager"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "description": "Bad Request"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Registers compute manager with NSX. Inventory service will collect\ndata from the registered compute manager\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ComputeManager"
            },
            "required": true,
            "name": "ComputeManager",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Register compute manager with NSX",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddComputeManager"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ComputeManagerListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all compute managers.",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Compute manager type like vCenter",
            "required": false,
            "type": "string",
            "name": "origin_type",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "IP address or hostname of compute manager",
            "format": "hostname-or-ip",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "server"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Return the List of Compute managers",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListComputeManagers"
      }
    },
    "/loadbalancer/ssl/ciphers-and-protocols": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbSslCipherAndProtocolListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Retrieve a list of supported SSL ciphers and protocols.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Retrieve a list of supported SSL ciphers and protocols",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListLoadBalancerSslCiphersAndProtocols"
      }
    },
    "/ns-groups/{ns-group-id}/member-types": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/EffectiveMemberTypeListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns member types for a specified NSGroup including child NSGroups.\nThis considers static members and members added via membership criteria only\n",
        "parameters": [
          {
            "description": "NSGroup Id",
            "required": true,
            "type": "string",
            "name": "ns-group-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Get member types from NSGroup",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetMemberTypes"
      }
    },
    "/csm/aws/regions": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AwsRegionsListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns a list of Aws regions",
        "parameters": [
          {
            "description": "Identifier for account based on which regions are to be filtered",
            "required": false,
            "type": "string",
            "name": "account_id",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "Identifier for region based on which the list can be filtered or can be used\nto validate that hierarchy is correct\n",
            "required": false,
            "type": "string",
            "name": "region_id",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Returns a list of Aws regions",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListAwsRegions"
      }
    },
    "/compute-collection-transport-node-templates/{template-id}/state": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ComputeCollectionTransportNodeTemplateStateList"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns detailed transport node states for this compute collection",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "template-id",
            "in": "path"
          },
          {
            "description": "Compute collection id",
            "required": false,
            "type": "string",
            "name": "compute_collection_id",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Get compute collection transportnode template application states",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetComputeCollectionTransportNodeTemplateState"
      }
    },
    "/aaa/vidm/users": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/VidmInfoListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get all the users from vIDM whose userName, givenName or familyName matches the search key case insensitively. The search key is checked to be a substring of name or given name or family name.",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "Search string to search for.\n",
            "required": true,
            "type": "string",
            "name": "search_string",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Aaa"
        ],
        "summary": "Get all the users from vIDM whose userName, givenName or familyName matches the search key case insensitively. The search key is checked to be a substring of name or given name or family name.",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetUserVidmSearchResult"
      }
    },
    "/host-switch-profiles": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/BaseHostSwitchProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a hostswitch profile. The resource_type is required. For uplink\nprofiles, the teaming and policy parameters are required. By default, the\nmtu is 1600 and the transport_vlan is 0. The supported MTU range is 1280\nthrough 9000.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/BaseHostSwitchProfile"
            },
            "required": true,
            "name": "BaseHostSwitchProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Create a Hostswitch Profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateHostSwitchProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/HostSwitchProfilesListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the configured hostswitch profiles. Hostswitch\nprofiles define networking policies for hostswitches (sometimes referred to\nas bridges in OVS). Currently, only uplink teaming is supported. Uplink\nteaming allows NSX to load balance traffic across different physical NICs\n(PNICs) on the hypervisor hosts. Multiple teaming policies are supported,\nincluding LACP active, LACP passive, load balancing based on source ID, and\nfailover order.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "enum": [
              "UplinkHostSwitchProfile",
              "LldpHostSwitchProfile"
            ],
            "description": "Supported HostSwitch profiles.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "hostswitch_profile_type"
          },
          {
            "description": "Whether the list result contains system resources",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "include_system_owned"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "List Hostswitch Profiles",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListHostSwitchProfiles"
      }
    },
    "/logical-router-ports/{logical-router-port-id}/arp-table": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalRouterPortArpTable"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns ARP table for the Logical Router Port of the given id, on a node\nif a query parameter \"transport_node_id=<transport-node-id>\" is given. The\ntransport_node_id parameter is mandatory if the router port is not uplink type.\nThe query parameter \"source=cached\" is not supported.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-port-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "TransportNode Id",
            "required": false,
            "type": "string",
            "name": "transport_node_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Get the ARP table for the Logical Router Port of the given id",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalRouterPortArpTable"
      }
    },
    "/logical-router-ports/{logical-router-port-id}/statistics/summary": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalRouterPortStatisticsSummary"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the summation of statistics from all nodes for the Specified\nLogical Router Port.\nThe query parameter \"source=realtime\" is not supported.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-port-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Get the statistics summary of a specified logical router port",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalRouterPortStatisticsSummary"
      }
    },
    "/service-profiles": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/ServiceProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a service profile, which can then be used to create a service.\nServices are then applied to one or more logical router ports.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ServiceProfile"
            },
            "required": true,
            "name": "ServiceProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Create a Service Profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateServiceProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ServiceProfileListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all service profiles. A service profile is a\nconfiguration that you can use to create a service, which is then applied\nto one or more logical router ports. Currently, only the DhcpRelayProfile\nis supported.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "required": false,
            "type": "string",
            "name": "resource_type",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "List All Service Profiles",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListServiceProfiles"
      }
    },
    "/fabric/nodes/{node-id}/state": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ConfigurationState"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get the Realized State of a Fabric Node",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Get the Realized State of a Fabric Node",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetFabricNodeState"
      }
    },
    "/logical-router-ports": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/LogicalRouterPort"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a logical router port. The required parameters include resource_type\n(LogicalRouterUpLinkPort, LogicalRouterDownLinkPort, LogicalRouterLinkPort,\nLogicalRouterLoopbackPort); and logical_router_id (the router to which each\nlogical router port is assigned). The service_bindings parameter is optional.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/LogicalRouterPort"
            },
            "required": true,
            "name": "LogicalRouterPort",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Create a Logical Router Port",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateLogicalRouterPort"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalRouterPortListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all logical router ports. Information includes the\nresource_type (LogicalRouterUpLinkPort, LogicalRouterDownLinkPort,\nLogicalRouterLinkPort, LogicalRouterLoopbackPort); logical_router_id\n(the router to which each logical router port is assigned);\nand any service_bindings (such as DHCP relay service).\nThe GET request can include a query parameter (logical_router_id\nor logical_switch_id).\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Logical Router identifier",
            "required": false,
            "type": "string",
            "name": "logical_router_id",
            "in": "query"
          },
          {
            "description": "Logical Switch identifier",
            "required": false,
            "type": "string",
            "name": "logical_switch_id",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "enum": [
              "LogicalRouterUpLinkPort",
              "LogicalRouterDownLinkPort",
              "LogicalRouterLinkPortOnTIER0",
              "LogicalRouterLinkPortOnTIER1",
              "LogicalRouterLoopbackPort"
            ],
            "description": "Resource types of logical router port",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "resource_type"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "List Logical Router Ports",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListLogicalRouterPorts"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes the specified logical router port. You must delete logical router ports before you can delete the associated logical router. To Delete Tier0 router link port you must have to delete attached tier1 router link port, otherwise pass 'force=true' as query param to force delete the Tier0 router link port. \n",
        "parameters": [
          {
            "default": false,
            "description": "Force delete the resource even if it is being used somewhere\n",
            "type": "boolean",
            "name": "force",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Delete a Logical Router Port",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteLogicalRouterPorts"
      }
    },
    "/realization-state-barrier/config": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RealizationStateBarrierConfig"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Updates the barrier configuration having interval set in milliseconds\nThe new interval that automatically increments the global realization number\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RealizationStateBarrierConfig"
            },
            "required": true,
            "name": "RealizationStateBarrierConfig",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Realization"
        ],
        "summary": "Updates the barrier configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateRealizationStateBarrierConfig"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RealizationStateBarrierConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the current barrier configuration\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Realization"
        ],
        "summary": "Gets the realization state barrier configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetRealizationStateBarrierConfig"
      }
    },
    "/node/services/nsx-message-bus?action=stop": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the NSX Message Bus service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the NSX Message Bus service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateNSXMessageBusServiceActionStop"
      }
    },
    "/node/services/snmp/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read SNMP service status",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read SNMP service status",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadSNMPServiceStatus"
      }
    },
    "/mirror-sessions": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/PortMirroringSession"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a mirror session",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/PortMirroringSession"
            },
            "required": true,
            "name": "PortMirroringSession",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Create a mirror session",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreatePortMirroringSessions"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/PortMirroringSessionListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "List all mirror sessions",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "List all mirror sessions",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListPortMirroringSession"
      }
    },
    "/firewall/sections/{section-id}?action=revise": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FirewallSection"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies an existing firewall section along with its relative position\namong other firewall sections in the system.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/FirewallSection"
            },
            "required": true,
            "name": "FirewallSection",
            "in": "body"
          },
          {
            "in": "query",
            "description": "Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.",
            "required": false,
            "maxLength": 64,
            "type": "string",
            "name": "id"
          },
          {
            "enum": [
              "insert_top",
              "insert_bottom",
              "insert_after",
              "insert_before"
            ],
            "description": "Operation",
            "default": "insert_top",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "operation"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update an Existing Section, Including Its Position",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReviseSectionRevise"
      }
    },
    "/firewall/excludelist?action=add_member": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ResourceReference"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Add a new object in the exclude list",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ResourceReference"
            },
            "required": true,
            "name": "ResourceReference",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Add a new object in the exclude list",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddMemberAdd_member"
      }
    },
    "/node/support-bundle": {
      "get": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read node support bundle",
        "parameters": [
          {
            "default": false,
            "description": "Include all files",
            "type": "boolean",
            "name": "all",
            "in": "query"
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read node support bundle",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNodeSupportBundle"
      }
    },
    "/csm/virtual-machines/{virtual-machine-id}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/CloudVirtualMachine"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the particular virtual machine",
        "parameters": [
          {
            "description": "ID of the virtual machine",
            "required": true,
            "type": "string",
            "name": "virtual-machine-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Returns information about the particular virtual machine",
        "consumes": [
          "application/json"
        ],
        "operationId": "CloudVirtualMachineInfo"
      }
    },
    "/node/services/search": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read NSX Search service properties",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read NSX Search service properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadSearchService"
      }
    },
    "/transport-zones": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/TransportZone"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a new transport zone. The required parameters are host_switch_name\nand transport_type (OVERLAY or VLAN). The optional parameters are\ndescription and display_name.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/TransportZone"
            },
            "required": true,
            "name": "TransportZone",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Create a Transport Zone",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateTransportZone"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TransportZoneListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about configured transport zones. NSX requires at\nleast one transport zone. NSX uses transport zones to provide connectivity\nbased on the topology of the underlying network, trust zones, or\norganizational separations. For example, you might have hypervisors that\nuse one network for management traffic and a different network for VM\ntraffic. This architecture would require two transport zones. The\ncombination of transport zones plus transport connectors enables NSX to\nform tunnels between hypervisors. Transport zones define which interfaces\non the hypervisors can communicate with which other interfaces on other\nhypervisors to establish overlay tunnels or provide connectivity to a VLAN.\nA logical switch can be in one (and only one) transport zone. This means\nthat all of a switch's interfaces must be in the same transport zone.\nHowever, each hypervisor virtual switch (OVS or VDS) has multiple\ninterfaces (connectors), and each connector can be attached to a different\nlogical switch. For example, on a single hypervisor with two connectors,\nconnector A can be attached to logical switch 1 in transport zone A, while\nconnector B is attached to logical switch 2 in transport zone B. In this\nway, a single hypervisor can participate in multiple transport zones. The\nAPI for creating a transport zone requires that a single host switch be\nspecified for each transport zone, and multiple transport zones can share\nthe same host switch.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "List Transport Zones",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListTransportZones"
      }
    },
    "/licenses/licenses-usage?format=csv": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FeatureUsageListInCsvFormat"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns usage report of all registered modules in CSV format\n",
        "produces": [
          "text/csv"
        ],
        "tags": [
          "Licensing"
        ],
        "summary": "Get usage report of all registred modules in CSV format",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLicenseUsageReportInCsvFormatCsv"
      }
    },
    "/csm/aws/gateway-amis/{region-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AwsGatewayAmiInfo"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a AWS Gateway AMI",
        "parameters": [
          {
            "description": "ID of AWS region",
            "required": true,
            "type": "string",
            "name": "region-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/AwsGatewayAmiInfo"
            },
            "required": true,
            "name": "AwsGatewayAmiInfo",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Update a AWS Gateway AMI",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateAwsGatewayAmi"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a AWS Gateway AMI",
        "parameters": [
          {
            "description": "ID of AWS region",
            "required": true,
            "type": "string",
            "name": "region-id",
            "in": "path"
          }
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Delete a AWS Gateway AMI",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteAwsGatewayAmi"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AwsGatewayAmiInfo"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns AWS Gateway AMI for a particular region",
        "parameters": [
          {
            "description": "ID of AWS region",
            "required": true,
            "type": "string",
            "name": "region-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Returns AWS Gateway AMI for a particular region",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetAwsGatewayAmiInfo"
      }
    },
    "/pools/ip-blocks/{block-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IpBlock"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies the IP address block with specifed id. display_name, description\nand cidr are parameters that can be modified. If a new cidr is specified,\nit should contain all existing subnets in the IP block. Returns a conflict error\nif the IP address block cidr can not be modified due to the presence of\nsubnets that it contains. Eg: If the IP block contains a subnet 192.168.0.1/24\nand we try to change the IP block cidr to 10.1.0.1/16, it results in a conflict.\n",
        "parameters": [
          {
            "description": "IP address block id",
            "required": true,
            "type": "string",
            "name": "block-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/IpBlock"
            },
            "required": true,
            "name": "IpBlock",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "Update an IP Address Block",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateIpBlock"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IpBlock"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the IP address block with specified id.\nInformation includes id, display_name, description & cidr.\n",
        "parameters": [
          {
            "description": "IP address block id",
            "required": true,
            "type": "string",
            "name": "block-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "Get IP address block information.",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadIpBlock"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes the IP address block with specified id if it exists. IP\nblock cannot be deleted if there are allocated subnets from the block.\n",
        "parameters": [
          {
            "description": "IP address block id",
            "required": true,
            "type": "string",
            "name": "block-id",
            "in": "path"
          }
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "Delete an IP Address Block",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteIpBlock"
      }
    },
    "/ipfix/collectorconfigs": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/IpfixCollectorConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "description": "Bad Request"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a new IPFIX collector configuration",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/IpfixCollectorConfig"
            },
            "required": true,
            "name": "IpfixCollectorConfig",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Operations"
        ],
        "summary": "Create a new IPFIX collector configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateIpfixCollectorConfig"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IpfixCollectorConfigListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "List IPFIX collector configurations",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Operations"
        ],
        "summary": "List IPFIX collector configurations",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListIpfixCollectorConfig"
      }
    },
    "/cluster/restore?action=cancel": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ClusterRestoreStatus"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "409": {
            "description": "Conflict",
            "schema": {
              "$ref": "#/definitions/ClusterRestoreStatus"
            }
          }
        },
        "description": "Cancel any currently running restore operation. If there exists a currently\nrunning step, it is allowed to finish. The system is not rolled back to the\npre-restore state. This operation is only valid when a\nGET cluster/restore/status returns a status with value RUNNING or SUSPENDED.\nOtherwise, a 409 response is returned.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Cancel any running restore operation",
        "consumes": [
          "application/json"
        ],
        "operationId": "CancelClusterRestoreCancel"
      }
    },
    "/trust-management/csrs/{csr-id}/pem-file": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "string"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Downloads the CSR PEM file for a specified CSR. Clients must include an Accept: text/plain request header.",
        "parameters": [
          {
            "description": "ID of CSR to read",
            "required": true,
            "type": "string",
            "name": "csr-id",
            "in": "path"
          }
        ],
        "produces": [
          "text/plain;charset=UTF-8"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Get CSR PEM File for the Given CSR ID",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetCsrPem"
      }
    },
    "/firewall/sections/{section-id}/rules/stats": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FirewallStatsList"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get aggregated statistics for all rules for a given firewall section. The\nAPI only supports access to cached (source=cached) statistical data\ncollected offline in the system. Data includes total number of packets,\nbytes and sessions counters for a firewall rule and overall session count\nfor all firewall rules on transport nodes or edge nodes.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get Firewall section level statistics section",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetFirewallSectionStats"
      }
    },
    "/logical-routers/{logical-router-id}/nat/rules/statistics": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NatStatisticsPerLogicalRouter"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the summation of statistics for all rules from all nodes for the Specified\nLogical Router. Also gives the per transport node statistics for provided logical router.\nThe query parameter \"source=realtime\" is not supported.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Get the statistics of all rules of the logical router",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetNatStatisticsPerLogicalRouter"
      }
    },
    "/cluster/restore?action=advance": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ClusterRestoreStatus"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "409": {
            "description": "Conflict",
            "schema": {
              "$ref": "#/definitions/ClusterRestoreStatus"
            }
          }
        },
        "description": "Advance any currently suspended restore operation. The operation might\nhave been suspended because (1) the user had suspended it previously, or\n(2) the operation is waiting for user input, to be provided as a\npart of the POST request body. This operation is only valid\nwhen a GET cluster/restore/status returns a status with value SUSPENDED.\nOtherwise, a 409 response is returned.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/AdvanceClusterRestoreRequest"
            },
            "required": true,
            "name": "AdvanceClusterRestoreRequest",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Advance any suspended restore operation",
        "consumes": [
          "application/json"
        ],
        "operationId": "AdvanceClusterRestoreAdvance"
      }
    },
    "/csm/nsx-manager-accounts/{account-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NsxManagerAccount"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a NSX Manager account",
        "parameters": [
          {
            "description": "ID of NSX Manager account",
            "required": true,
            "type": "string",
            "name": "account-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/NsxManagerAccount"
            },
            "required": true,
            "name": "NsxManagerAccount",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Update a NSX Manager account",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateNsxManagerAccount"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a NSX Manager account",
        "parameters": [
          {
            "description": "ID of NSX Manager account",
            "required": true,
            "type": "string",
            "name": "account-id",
            "in": "path"
          }
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Delete a NSX Manager account",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteNsxManagerAccount"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NsxManagerAccount"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the particular NSX Manager account information",
        "parameters": [
          {
            "description": "ID of NSX Manager account",
            "required": true,
            "type": "string",
            "name": "account-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Returns the particular NSX Manager account information",
        "consumes": [
          "application/json"
        ],
        "operationId": "NsxManagerAccountInfo"
      }
    },
    "/infra/domains/{domain-id}/groups/{group-id}": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "If a group with the group-id is not already present, create a new group.\nIf it already exists, update the group.\n",
        "parameters": [
          {
            "description": "Domain ID",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          },
          {
            "description": "Group ID",
            "required": true,
            "type": "string",
            "name": "group-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/Group"
            },
            "required": true,
            "name": "Group",
            "in": "body"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Create or update a group",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateGroupForDomain"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete Group",
        "parameters": [
          {
            "description": "Domain ID",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          },
          {
            "description": "Group ID",
            "required": true,
            "type": "string",
            "name": "group-id",
            "in": "path"
          },
          {
            "default": false,
            "description": "Force delete the resource even if it is being used somewhere\n",
            "type": "boolean",
            "name": "force",
            "in": "query"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Delete Group",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteGroup"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/Group"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read group",
        "parameters": [
          {
            "description": "Domain ID",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          },
          {
            "description": "Group ID",
            "required": true,
            "type": "string",
            "name": "group-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Read group",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadGroupForDomain"
      }
    },
    "/loadbalancer/application-profiles": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbAppProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a load balancer application profile.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/LbAppProfile"
            },
            "required": true,
            "name": "LbAppProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Create a load balancer application profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateLoadBalancerApplicationProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbAppProfileListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Retrieve a paginated list of load balancer application profiles.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "enum": [
              "LbHttpProfile",
              "LbFastTcpProfile",
              "LbFastUdpProfile"
            ],
            "description": "application profile type",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "type"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Retrieve a paginated list of load balancer application profiles",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListLoadBalancerApplicationProfiles"
      }
    },
    "/node/services/ssh/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read ssh service status",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read ssh service status",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadSSHServiceStatus"
      }
    },
    "/pools/mac-pools/{pool-id}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/MacPool"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the specified MAC pool.\n",
        "parameters": [
          {
            "description": "MAC pool ID",
            "required": true,
            "type": "string",
            "name": "pool-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "Read MAC Pool",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadMacPool"
      }
    },
    "/infra/communication-profiles": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/CommunicationProfileListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Paginated list of CommunicationProfiles.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "List CommunicationProfiles",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListCommunicationProfiles"
      }
    },
    "/node/services/nsx-message-bus?action=restart": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the NSX Message Bus service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the NSX Message Bus service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateNSXMessageBusServiceActionRestart"
      }
    },
    "/fabric/discovered-nodes/{node-ext-id}?action=hostprep": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/Node"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Prepares(hostprep) discovered node for NSX. NSX LCP bundles are installed on this discovered node.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-ext-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Prepares discovered Node for NSX",
        "consumes": [
          "application/json"
        ],
        "operationId": "HostPrepDiscoveredNodeHostprep"
      }
    },
    "/switching-profiles/{switching-profile-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BaseSwitchingProfile"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Updates the user-configurable parameters of a switching profile. Only the qos,\nport-mirroring, spoof-guard and port-security switching profiles can be modified.\nYou cannot modify the ipfix or ip-discovery switching profiles.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "switching-profile-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/BaseSwitchingProfile"
            },
            "required": true,
            "name": "BaseSwitchingProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Update a Switching Profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateSwitchingProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BaseSwitchingProfile"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about a specified switching profile.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "switching-profile-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Get Switching Profile by ID",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetSwitchingProfile"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes the specified switching profile.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "switching-profile-id",
            "in": "path"
          },
          {
            "description": "force unbinding of logical switches and ports from a switching profile",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "unbind"
          }
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Delete a Switching Profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteSwitchingProfile"
      }
    },
    "/loadbalancer/monitors/{monitor-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbMonitor"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a load balancer monitor.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "monitor-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/LbMonitor"
            },
            "required": true,
            "name": "LbMonitor",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update a load balancer monitor",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateLoadBalancerMonitor"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbMonitor"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Retrieve a load balancer monitor.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "monitor-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Retrieve a load balancer monitor",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadLoadBalancerMonitor"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a load balancer monitor.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "monitor-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Delete a load balancer monitor",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteLoadBalancerMonitor"
      }
    },
    "/upgrade/upgrade-units": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/UpgradeUnitListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get upgrade units",
        "parameters": [
          {
            "description": "Component type based on which upgrade units to be filtered",
            "required": false,
            "type": "string",
            "name": "component_type",
            "in": "query"
          },
          {
            "description": "Current version of upgrade unit based on which upgrade units to be filtered",
            "required": false,
            "type": "string",
            "name": "current_version",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "UUID of group based on which upgrade units to be filtered",
            "required": false,
            "type": "string",
            "name": "group_id",
            "in": "query"
          },
          {
            "description": "Flag to indicate whether to return only upgrade units with warnings",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "has_warnings"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Metadata about upgrade unit to filter on",
            "required": false,
            "type": "string",
            "name": "metadata",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "Upgrade unit type based on which upgrade units to be filtered",
            "required": false,
            "type": "string",
            "name": "upgrade_unit_type",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Get upgrade units",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetUpgradeUnits"
      }
    },
    "/network-encryption/status?action=update_status": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NetworkEncryptionStatus"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update the firewall status for a given context",
        "parameters": [
          {
            "description": "Context for which network encryption status.",
            "required": true,
            "type": "string",
            "name": "context",
            "in": "query"
          },
          {
            "enum": [
              "DISABLE",
              "ENABLE"
            ],
            "description": "status of the given context. It could be one of the following values.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "status"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update the firewall status for a given context",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateNetworkEncryptionStatusUpdate_status"
      }
    },
    "/cluster/restore/config": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RestoreConfiguration"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Configure file server where the backed-up files used for the Restore\noperation are available.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RestoreConfiguration"
            },
            "required": true,
            "name": "RestoreConfiguration",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Configure Restore SFTP server credentials",
        "consumes": [
          "application/json"
        ],
        "operationId": "ConfigureRestoreConfig"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RestoreConfiguration"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get configuration information for the file server used to store backed-up files.\nFields that contain secrets (password, passphrase) are not returned.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Get Restore configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetRestoreConfig"
      }
    },
    "/node/services/cm-inventory": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read cm inventory service properties",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read cm inventory service properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadCminventoryService"
      }
    },
    "/switching-profiles": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/BaseSwitchingProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a new, custom qos, port-mirroring, spoof-guard or port-security\nswitching profile. You can override their default switching profile assignments\nby creating a new switching profile and assigning it to one or more logical\nswitches. You cannot override the default ipfix or ip_discovery switching profiles.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/BaseSwitchingProfile"
            },
            "required": true,
            "name": "BaseSwitchingProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Create a Switching Profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateSwitchingProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/SwitchingProfilesListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the system-default and user-configured switching\nprofiles. Each switching profile has a unique ID, a display name, and\nvarious other read-only and configurable properties. The default switching\nprofiles are assigned automatically to each switch.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Whether the list result contains system resources",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "include_system_owned"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "comma-separated list of switching profile types, e.g. ?switching_profile_type=QosSwitchingProfile,PortMirroringSwitchingProfile",
            "required": false,
            "type": "string",
            "name": "switching_profile_type",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "List Switching Profiles",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListSwitchingProfiles"
      }
    },
    "/cluster/restore?action=suspend": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ClusterRestoreStatus"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "409": {
            "description": "Conflict",
            "schema": {
              "$ref": "#/definitions/ClusterRestoreStatus"
            }
          }
        },
        "description": "Suspend any currently running restore operation. The restore operation is\nmade up of a number of steps. When this call is issued, any currently\nrunning step is allowed to finish (successfully or with errors), and the\nnext step (and therefore the entire restore operation) is suspended until\na subsequent resume or cancel call is issued. This operation is only valid\nwhen a GET cluster/restore/status returns a status with value RUNNING.\nOtherwise, a 409 response is returned.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Suspend any running restore operation",
        "consumes": [
          "application/json"
        ],
        "operationId": "SuspendClusterRestoreSuspend"
      }
    },
    "/loadbalancer/client-ssl-profiles/{client-ssl-profile-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbClientSslProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a load balancer client-ssl profile.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "client-ssl-profile-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/LbClientSslProfile"
            },
            "required": true,
            "name": "LbClientSslProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update a load balancer client-ssl profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateLoadBalancerClientSslProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbClientSslProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Retrieve a load balancer client-ssl profile.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "client-ssl-profile-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Retrieve a load balancer client-ssl profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadLoadBalancerClientSslProfile"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a load balancer client-ssl profile.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "client-ssl-profile-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Delete a load balancer client-ssl profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteLoadBalancerClientSslProfile"
      }
    },
    "/ns-groups/{ns-group-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NSGroup"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Updates the specified NSGroup. Modifiable parameters include the\ndescription, display_name and members.\n",
        "parameters": [
          {
            "description": "NSGroup Id",
            "required": true,
            "type": "string",
            "name": "ns-group-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/NSGroup"
            },
            "required": true,
            "name": "NSGroup",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Update NSGroup",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateNSGroup"
      },
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NSGroup"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Add/remove the expressions passed in the request body to/from the NSGroup\n",
        "parameters": [
          {
            "description": "NSGroup Id",
            "required": true,
            "type": "string",
            "name": "ns-group-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/NSGroupExpressionList"
            },
            "required": true,
            "name": "NSGroupExpressionList",
            "in": "body"
          },
          {
            "enum": [
              "ADD_MEMBERS",
              "REMOVE_MEMBERS"
            ],
            "description": "Specifies addition or removal action",
            "required": true,
            "in": "query",
            "type": "string",
            "name": "action"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Add NSGroup expression",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddOrRemoveNSGroupExpression"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NSGroup"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the specified NSGroup.\n",
        "parameters": [
          {
            "description": "NSGroup Id",
            "required": true,
            "type": "string",
            "name": "ns-group-id",
            "in": "path"
          },
          {
            "default": false,
            "description": "Populate metadata of resource referenced by NSGroupExpressions\n",
            "type": "boolean",
            "name": "populate_references",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Read NSGroup",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNSGroup"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes the specified NSGroup. By default, if the NSGroup is added to\nanother NSGroup, it won't be deleted. In such situations, pass\n\"force=true\" as query param to force delete the NSGroup.\n",
        "parameters": [
          {
            "description": "NSGroup Id",
            "required": true,
            "type": "string",
            "name": "ns-group-id",
            "in": "path"
          },
          {
            "default": false,
            "description": "Force delete the resource even if it is being used somewhere\n",
            "type": "boolean",
            "name": "force",
            "in": "query"
          }
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Delete NSGroup",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteNSGroup"
      }
    },
    "/transport-nodes/{node-id}/statistics/nat-rules": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NatStatisticsPerTransportNode"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the summation of statistics for all rules from all logical routers\nwhich are present on given transport node. Only cached statistics are supported.\nThe query parameter \"source=realtime\" is not supported.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Get statistics for all logical router NAT rules on a transport node",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetNatStatisticsPerTransportNode"
      }
    },
    "/upgrade/eula/content": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/EULAContent"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Return the content of end user license agreement in the specified format.\nBy default, it's pure string without line break\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "End User License Agreement content output format",
            "type": "string",
            "name": "format",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Licensing"
        ],
        "summary": "Return the content of end user license agreement\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetUpgradeEULAContent"
      }
    },
    "/network-encryption/sections/{section-id}/rules/{rule-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneRule"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a specific rule in a network encryption section",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "rule-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/DneRule"
            },
            "required": true,
            "name": "DneRule",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update a specific rule in a network encryption section",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateDneRule"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a specific network encryption rule",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "rule-id",
            "in": "path"
          }
        ],
        "tags": [
          "Services"
        ],
        "summary": "Delete a specific network encryption rule",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteDneRule"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneRule"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get a specific rule in a network encryption section",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "rule-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get a specific rule in a network encryption section",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetDneRule"
      }
    },
    "/loadbalancer/services/{service-id}/pools/statistics": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbPoolStatisticsListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the statistics list of load balancer pools in given load balancer service.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get the statistics list of load balancer pools",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListLoadBalancerPoolStatistics"
      }
    },
    "/loadbalancer/services/{service-id}/virtual-servers/{virtual-server-id}/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbVirtualServerStatus"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the status of the virtual server by given load balancer serives id\nand load balancer virtual server id.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "virtual-server-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get the status of the load balancer virtual server",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLoadBalancerVirtualServerStatus"
      }
    },
    "/loadbalancer/services/{service-id}/virtual-servers/{virtual-server-id}/statistics": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbVirtualServerStatistics"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the statistics of the load balancer virtual server by given load\n balancer serives id and load balancer virtual server id.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "virtual-server-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get the statistics of the given load balancer virtual server",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLoadBalancerVirtualServerStatistics"
      }
    },
    "/ns-groups/{ns-group-id}/effective-virtual-machine-members": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/VirtualMachineListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns effective virtual machine members of the specified NSGroup.\n",
        "parameters": [
          {
            "description": "NSGroup Id",
            "required": true,
            "type": "string",
            "name": "ns-group-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Get Effective Virtual Machine members of the specified NSGroup.",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetEffectiveVirtualMachineMembers"
      }
    },
    "/firewall/sections/{section-id}/rules/{rule-id}?action=revise": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FirewallRule"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies existing firewall rule along with relative position among\nother firewall rules inside a firewall section.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "rule-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/FirewallRule"
            },
            "required": true,
            "name": "FirewallRule",
            "in": "body"
          },
          {
            "in": "query",
            "description": "Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.",
            "required": false,
            "maxLength": 64,
            "type": "string",
            "name": "id"
          },
          {
            "enum": [
              "insert_top",
              "insert_bottom",
              "insert_after",
              "insert_before"
            ],
            "description": "Operation",
            "default": "insert_top",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "operation"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update an Existing Rule and Reorder the Rule",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReviseRuleRevise"
      }
    },
    "/app-discovery/sessions/{session-id}/report/app-profile-and-app-info?format=csv": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AppProfileMemberAppsListInCsvFormat"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns app profiles information for a given session in CSV format\nEach row will contain detailed info of an app profile, and the id of\napps which is member of this app profile in this session\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "session-id",
            "in": "path"
          }
        ],
        "produces": [
          "text/csv"
        ],
        "tags": [
          "App Discovery"
        ],
        "summary": "Export app profiles in CSV format for a given sessiom",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetAppdiscoverySessionAppProfileMemberAppsInCsvFormatCsv"
      }
    },
    "/node/tasks/{task-id}?action=cancel": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Cancel specified task",
        "parameters": [
          {
            "description": "ID of task to delete",
            "required": true,
            "type": "string",
            "name": "task-id",
            "in": "path"
          }
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Cancel specified task",
        "consumes": [
          "application/json"
        ],
        "operationId": "CancelApplianceManagementTaskCancel"
      }
    },
    "/trust-management/principal-identities/{principal-identity-id}": {
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a principal identity. It does not delete the certificate.\n",
        "parameters": [
          {
            "description": "Unique id of the principal identity to delete",
            "required": true,
            "type": "string",
            "name": "principal-identity-id",
            "in": "path"
          }
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Delete a principal identity",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeletePrincipalIdentity"
      }
    },
    "/node/file-store/{file-name}": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/FileProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "When you issue this API, the client must specify:\n- HTTP header Content-Type:application/octet-stream.\n- Request body with the contents of the file in the filestore.\nIn the CLI, you can view the filestore with the <em>get files</em> command.\n",
        "parameters": [
          {
            "description": "Destination filename",
            "required": true,
            "type": "string",
            "name": "file-name",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Upload a file to the file store",
        "consumes": [
          "application/octet-stream"
        ],
        "operationId": "CreateFile"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete file",
        "parameters": [
          {
            "description": "Name of the file to delete",
            "required": true,
            "type": "string",
            "name": "file-name",
            "in": "path"
          }
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Delete file",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteFile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FileProperties"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read file properties",
        "parameters": [
          {
            "description": "Name of the file to retrieve information about",
            "required": true,
            "type": "string",
            "name": "file-name",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read file properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadFileProperties"
      }
    },
    "/infra/realized-state/enforcement-points/{enforcement-point-name}/ip-sets/ip-sets-nsxt/{ip-set-name}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RealizedIPSet"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read an IPSet\n",
        "parameters": [
          {
            "description": "Enforcement Point Name",
            "required": true,
            "type": "string",
            "name": "enforcement-point-name",
            "in": "path"
          },
          {
            "description": "IPSet name",
            "required": true,
            "type": "string",
            "name": "ip-set-name",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Read IPSet Realized state",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadIPSetRealizedState"
      }
    },
    "/infra/communication-profiles/{communication-profile-id}/communication-profile-entries": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/CommunicationProfileEntryListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Paginated list of CommunicationProfileEntries for the given CommunicationProfile.\n",
        "parameters": [
          {
            "description": "CommunicationProfile ID",
            "required": true,
            "type": "string",
            "name": "communication-profile-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "List CommunicationProfileEntries for CommunicationProfile",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListCommunicationProfileEntries"
      }
    },
    "/network-encryption/sections/{section-id}/state": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneSectionState"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get the realized state of a network encryption section",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "name": "barrier_id",
            "format": "int64",
            "required": false,
            "minimum": 0,
            "in": "query",
            "type": "integer"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get the realized state of a network encryption section",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetDneSectionState"
      }
    },
    "/node/aaa/auth-policy": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AuthenticationPolicyProperties"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/AuthenticationPolicyProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update the currently configured authentication policy on the node.\nIf any of api_max_auth_failures, api_failed_auth_reset_period, or\napi_failed_auth_lockout_period are modified, the http service is\nautomatically restarted.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/AuthenticationPolicyProperties"
            },
            "required": true,
            "name": "AuthenticationPolicyProperties",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Api Services"
        ],
        "summary": "Update node authentication policy configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateAuthenticationPolicyProperties"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AuthenticationPolicyProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the currently configured authentication\npolicies on the node.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Api Services"
        ],
        "summary": "Read node authentication policy configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadAuthenticationPolicyProperties"
      }
    },
    "/transport-zones/{zone-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TransportZone"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Updates an existing transport zone. Modifiable parameters are\ntransport_type (VLAN or OVERLAY), description, and display_name. The\nrequest must include the existing host_switch_name.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "zone-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/TransportZone"
            },
            "required": true,
            "name": "TransportZone",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Update a Transport Zone",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateTransportZone"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TransportZone"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about a single transport zone.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "zone-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Get a Transport Zone",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetTransportZone"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes an existing transport zone.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "zone-id",
            "in": "path"
          }
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Delete a Transport Zone",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteTransportZone"
      }
    },
    "/tasks/{task-id}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TaskProperties"
            }
          },
          "303": {
            "description": "See Other",
            "schema": {
              "$ref": "#/definitions/TaskProperties"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get information about the specified task",
        "parameters": [
          {
            "description": "ID of task to read",
            "required": true,
            "type": "string",
            "name": "task-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Api Services"
        ],
        "summary": "Get information about the specified task",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadTaskProperties"
      }
    },
    "/mirror-sessions/{mirror-session-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/PortMirroringSession"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update the mirror session",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "mirror-session-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/PortMirroringSession"
            },
            "required": true,
            "name": "PortMirroringSession",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Update the mirror session",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdatePortMirroringSession"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/PortMirroringSession"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get the mirror session",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "mirror-session-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Get the mirror session",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetPortMirroringSession"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete the mirror session",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "mirror-session-id",
            "in": "path"
          }
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Delete the mirror session",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeletePortMirroringSession"
      }
    },
    "/node/services/cm-inventory?action=restart": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the manager service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the manager service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateCminventoryServiceActionRestart"
      }
    },
    "/ui-views/dashboard/widgetconfigurations": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/WidgetConfiguration"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a new Widget Configuration and adds it to the 'default_view'.\nSupported resource_types are LabelValueConfiguration, DonutConfiguration,\n  MultiWidgetConfiguration and ContainerConfiguration.\n\nNote: Expressions should be given in a single line. If an expression spans\n  multiple lines, then form the expression in a single line.\nFor label-value pairs, expressions are evaluated as follows:\n  a. First, render configurations are evaluated in their order of\n     appearance in the widget config. The 'field' is evaluated at the end.\n  b. Second, when render configuration is provided then the order of\n     evaluation is\n     1. If expressions provided in condition and display value are\n        well-formed and free of runtime-errors such as null pointers and\n        evaluates to true; Then remaining render configurations are not\n        evaluated, and the current render configurations 'display value'\n        is taken as the final value.\n     2. If expression provided in condition of render configuration is\n        false, then next render configuration is evaluated.\n     3. Finally, field is evaluated only when every render configuration\n        evaluates to false and no error occurs during steps 1 and 2 above.\n\nIf an error occurs during evaluation of render configuration, then an\n  error message: \"__ERROR__: See the Error_Messages field of this report\n  for details\" is shown. The display value corresponding to that label is\n  not shown and evaluation of the remaining render configurations continues\n  to collect and show all the error messages (marked with the Label for\n  identification) as Error_Messages: {}.\n\nIf during evaluation of expressions for any label-value pair an error\n  occurs, then it is marked with error. The errors are shown in the report,\n  along with the label value pairs that are error-free.\n\nImportant: For elements that take expressions, strings should be provided\n  by escaping them with a back-slash. These elements are - condition, field,\n  tooltip text and render_configuration's display_value.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/WidgetConfiguration"
            },
            "required": true,
            "name": "WidgetConfiguration",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Dashboard"
        ],
        "summary": "Creates a new Widget Configuration.",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateWidgetConfiguration"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/WidgetConfigurationList"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "If no query params are specified then all the Widget Configurations of\nthe view are returned.\n",
        "parameters": [
          {
            "description": "Id of the container",
            "type": "string",
            "name": "container",
            "in": "query"
          },
          {
            "description": "Ids of the WidgetConfigurations",
            "type": "string",
            "name": "widget_ids",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Dashboard"
        ],
        "summary": "Returns the Widget Configurations based on query criteria defined in WidgetQueryParameters.",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListWidgetConfigurations"
      }
    },
    "/logical-routers/{logical-router-id}/routing/static-routes/bfd-peers": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/StaticHopBfdPeer"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a BFD peer for static route. The required parameters includes peer IP address.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/StaticHopBfdPeer"
            },
            "required": true,
            "name": "StaticHopBfdPeer",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Create a static hop BFD peer",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateStaticHopBfdPeer"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/StaticHopBfdPeerListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all BFD peers created on specified logical router for static routes.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "List static routes BFD Peers",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListStaticHopBfdPeers"
      }
    },
    "/md-proxies": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/MetadataProxy"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a metadata proxy",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/MetadataProxy"
            },
            "required": true,
            "name": "MetadataProxy",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Create a metadata proxy",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateMetadataProxy"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/MetadataProxyListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get a paginated list of metadata proxies",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get a paginated list of metadata proxies",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListMetadataProxy"
      }
    },
    "/firewall/sections/{section-id}/rules": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FirewallRule"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "description": "Bad Request"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Adds a new firewall rule in existing firewall section.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/FirewallRule"
            },
            "required": true,
            "name": "FirewallRule",
            "in": "body"
          },
          {
            "in": "query",
            "description": "Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.",
            "required": false,
            "maxLength": 64,
            "type": "string",
            "name": "id"
          },
          {
            "enum": [
              "insert_top",
              "insert_bottom",
              "insert_after",
              "insert_before"
            ],
            "description": "Operation",
            "default": "insert_top",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "operation"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Add a Single Rule in a Section",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddRuleInSection"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FirewallRuleListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Return all firewall rule(s) information for a given firewall section.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "description": "AppliedTo's  referenced by this section or section's Firewall Rules .",
            "required": false,
            "type": "string",
            "name": "applied_tos",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Destinations referenced by this section's Firewall Rules .",
            "required": false,
            "type": "string",
            "name": "destinations",
            "in": "query"
          },
          {
            "enum": [
              "FILTER",
              "SEARCH"
            ],
            "description": "Filter type",
            "default": "FILTER",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "filter_type"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "NSService referenced by this section's Firewall Rules .",
            "required": false,
            "type": "string",
            "name": "services",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "Sources referenced by this section's Firewall Rules .",
            "required": false,
            "type": "string",
            "name": "sources",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get All the Rules for a Section",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetRules"
      }
    },
    "/ns-service-groups/{ns-service-group-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NSServiceGroup"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Updates the specified NSService. Modifiable parameters include the description,\ndisplay_name and members.\n",
        "parameters": [
          {
            "description": "NSServiceGroup Id",
            "required": true,
            "type": "string",
            "name": "ns-service-group-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/NSServiceGroup"
            },
            "required": true,
            "name": "NSServiceGroup",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Update NSServiceGroup",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateNSServiceGroup"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes the specified NSServiceGroup. By default, if the NSServiceGroup is\nconsumed in a Firewall rule, it won't get deleted. In such situations, pass\n\"force=true\" as query param to force delete the NSServiceGroup.\n",
        "parameters": [
          {
            "description": "NSServiceGroup Id",
            "required": true,
            "type": "string",
            "name": "ns-service-group-id",
            "in": "path"
          },
          {
            "default": false,
            "description": "Force delete the resource even if it is being used somewhere\n",
            "type": "boolean",
            "name": "force",
            "in": "query"
          }
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Delete NSServiceGroup",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteNSServiceGroup"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NSServiceGroup"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the specified NSServiceGroup\n",
        "parameters": [
          {
            "description": "NSServiceGroup Id",
            "required": true,
            "type": "string",
            "name": "ns-service-group-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Read NSServiceGroup",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNSServiceGroup"
      }
    },
    "/batch": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BatchResponse"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Enables you to make multiple API requests using a single request. The batch\nAPI takes in an array of logical HTTP requests represented as JSON arrays.\nEach request has a method (GET, PUT, POST, or DELETE), a relative_url (the\nportion of the URL after https://&lt;nsx-mgr&gt;/api/), optional headers\narray (corresponding to HTTP headers) and an optional body (for POST and PUT\nrequests). The batch API returns an array of logical HTTP responses\nrepresented as JSON arrays. Each response has a status code, an optional\nheaders array and an optional body (which is a JSON-encoded string).\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/BatchRequest"
            },
            "required": true,
            "name": "BatchRequest",
            "in": "body"
          },
          {
            "description": "transactional atomicity for the batch of requests embedded in the batch list",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "atomic"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Api Services"
        ],
        "summary": "Register a Collection of API Calls at a Single End Point",
        "consumes": [
          "application/json"
        ],
        "operationId": "RegisterBatchRequest"
      }
    },
    "/logical-ports/{lport-id}/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalPortOperationalStatus"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns operational status of a specified logical port.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "lport-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Get Operational Status for Logical Port of a Given Port ID (lport-id)",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalPortOperationalStatus"
      }
    },
    "/licenses?action=delete": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "This will delete the license key identified in the request body\nby \"license_key\" and its properties from the system.\nAttempting to delete the last license key will result in an error.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/License"
            },
            "required": true,
            "name": "License",
            "in": "body"
          }
        ],
        "tags": [
          "Licensing"
        ],
        "summary": "Remove a license",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteLicenseKeyDelete"
      }
    },
    "/upgrade/status-summary": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/UpgradeStatus"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get upgrade status summary",
        "parameters": [
          {
            "description": "Component type based on which upgrade units to be filtered",
            "required": false,
            "type": "string",
            "name": "component_type",
            "in": "query"
          },
          {
            "enum": [
              "SELECTED",
              "DESELECTED",
              "ALL"
            ],
            "description": "Flag to indicate whether to return status for only selected, only deselected or both type of upgrade units",
            "default": "ALL",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "selection_status"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Get upgrade status summary",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetUpgradeStatusSummary"
      }
    },
    "/logical-ports/{lport-id}/mac-table?format=csv": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalPortMacAddressCsvListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns MAC table in CSV format of a specified logical port. If the target transport node id is not provided,\nthe NSX manager will ask the controller for the transport node where the logical port is located.\nThe query parameter \"source=cached\" is not supported.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "lport-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "TransportNode Id",
            "required": false,
            "type": "string",
            "name": "transport_node_id",
            "in": "query"
          }
        ],
        "produces": [
          "text/csv"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Get MAC table of a logical port with a given port id (lport-id)",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalPortMacTableInCsvFormatCsv"
      }
    },
    "/loadbalancer/services/{service-id}/virtual-servers/statistics": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbVirtualServerStatisticsListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the statistics list of virtual servers in given load balancer service.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get the statistics list of virtual servers",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListLoadBalancerVirtualServersStatistics"
      }
    },
    "/network-encryption/key-policies/{key-policy-id}?action=rotate": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Manually rotate a network encryption key policy for graceful re-key",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "key-policy-id",
            "in": "path"
          }
        ],
        "tags": [
          "Services"
        ],
        "summary": "Manually rotate a network encryption key policy for graceful re-key",
        "consumes": [
          "application/json"
        ],
        "operationId": "RotateDneKeyPolicyRotate"
      }
    },
    "/node/users/{userid}/ssh-keys?action=add_ssh_key": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "description": "Internal Server Error"
          }
        },
        "description": "Add SSH public key to authorized_keys file for node user",
        "parameters": [
          {
            "description": "User id of the user",
            "required": true,
            "type": "string",
            "name": "userid",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/SshKeyProperties"
            },
            "required": true,
            "name": "SshKeyProperties",
            "in": "body"
          }
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Add SSH public key to authorized_keys file for node user",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddNodeUserSshKeyAdd_ssh_key"
      }
    },
    "/upgrade/upgrade-unit-groups/{group-id}/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/UpgradeUnitStatusListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get upgrade status for group",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "group-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Flag to indicate whether to return only upgrade units with errors",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "has_errors"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Get upgrade status for group",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetUpgradeUnitGroupStatus"
      }
    },
    "/node/services/ssh?action=remove_host_fingerprint": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Remove a host's fingerprint from known hosts file",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/KnownHostParameter"
            },
            "required": true,
            "name": "KnownHostParameter",
            "in": "body"
          }
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Remove a host's fingerprint from known hosts file",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateSSHServiceRemoveHostFingerprintActionRemove_host_fingerprint"
      }
    },
    "/csm/aws/accounts/{account-id}?action=sync_inventory": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Synchronizes Aws account related inventory like Regions, Vpcs, Instances\nStatus of inventory synchronization can be known from Aws account status api\n",
        "parameters": [
          {
            "description": "ID of AWS account",
            "required": true,
            "type": "string",
            "name": "account-id",
            "in": "path"
          }
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Synchronizes Aws account related inventory like Regions, Vpcs, Instances\nStatus of inventory synchronization can be known from Aws account status api\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "SyncAwsAccountInventorySync_inventory"
      }
    },
    "/node/tasks": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ApplianceManagementTaskListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "List appliance management tasks",
        "parameters": [
          {
            "description": "Fields to include in query results",
            "type": "string",
            "name": "fields",
            "in": "query"
          },
          {
            "pattern": "/^(=|!=|~|!~)?.+$/",
            "description": "Request method(s) to include in query result",
            "type": "string",
            "name": "request_method",
            "in": "query"
          },
          {
            "pattern": "/^(=|!=|~|!~)?.+$/",
            "description": "Request URI path(s) to include in query result",
            "type": "string",
            "name": "request_path",
            "in": "query"
          },
          {
            "pattern": "/^(=|!=|~|!~)?.+$/",
            "description": "Request URI(s) to include in query result",
            "type": "string",
            "name": "request_uri",
            "in": "query"
          },
          {
            "pattern": "/^(=|!=|~|!~)?.+$/",
            "description": "Status(es) to include in query result",
            "type": "string",
            "name": "status",
            "in": "query"
          },
          {
            "pattern": "/^(=|!=|~|!~)?.+$/",
            "description": "Names of users to include in query result",
            "type": "string",
            "name": "user",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "List appliance management tasks",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListApplianceManagementTasks"
      }
    },
    "/fabric/compute-managers/{compute-manager-id}/state": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ConfigurationState"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get the realized state of a compute manager",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "compute-manager-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Get the realized state of a compute manager",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetComputeManagerState"
      }
    },
    "/infra": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update the infra including all the nested entities",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/Infra"
            },
            "required": true,
            "name": "Infra",
            "in": "body"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Update the infra including all the nested entities",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateInfra"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/Infra"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read infra. Returns only the infra related properties. Inner object\nare not populated.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Read infra",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadInfra"
      }
    },
    "/aaa/role-bindings/{binding-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RoleBinding"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update User or Group's roles",
        "parameters": [
          {
            "description": "User/Group's id",
            "required": true,
            "type": "string",
            "name": "binding-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/RoleBinding"
            },
            "required": true,
            "name": "RoleBinding",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Aaa"
        ],
        "summary": "Update User or Group's roles",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateRoleBinding"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete user/group's roles assignment",
        "parameters": [
          {
            "description": "User/Group's id",
            "required": true,
            "type": "string",
            "name": "binding-id",
            "in": "path"
          }
        ],
        "tags": [
          "Aaa"
        ],
        "summary": "Delete user/group's roles assignment",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteRoleBinding"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RoleBinding"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get user/group's role information",
        "parameters": [
          {
            "description": "User/Group's id",
            "required": true,
            "type": "string",
            "name": "binding-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Aaa"
        ],
        "summary": "Get user/group's role information",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetRoleBinding"
      }
    },
    "/transport-nodes/{transportnode-id}/state": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TransportNodeState"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the current state of the transport node\nconfiguration and information about the associated hostswitch.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "transportnode-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Get a Transport Node's State",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetTransportNodeState"
      }
    },
    "/logical-routers/{logical-router-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalRouter"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies the specified logical router. Modifiable attributes include the\ninternal_transit_network, external_transit_networks, and edge_cluster_id\n(for TIER0 routers).\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/LogicalRouter"
            },
            "required": true,
            "name": "LogicalRouter",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Update a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateLogicalRouter"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalRouter"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the specified logical router.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Read Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadLogicalRouter"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes the specified logical router. You must delete associated logical\nrouter ports before you can delete a logical router. Otherwise use force\ndelete which will delete all related ports and other entities associated\nwith that LR. To force delete logical router pass force=true in query param.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "default": false,
            "description": "Force delete the resource even if it is being used somewhere\n",
            "type": "boolean",
            "name": "force",
            "in": "query"
          }
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Delete a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteLogicalRouter"
      }
    },
    "/node/services/mgmt-plane-bus?action=start": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the Rabbit MQ service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the Rabbit MQ service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateRabbitMQServiceActionStart"
      }
    },
    "/node/services/nsx-message-bus/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read NSX Message Bus service status",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read NSX Message Bus service status",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNSXMessageBusServiceStatus"
      }
    },
    "/ip-sets/{ip-set-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IPSet"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Updates the specified IPSet. Modifiable parameters include description,\ndisplay_name and ip_addresses.\n",
        "parameters": [
          {
            "description": "IPSet Id",
            "required": true,
            "type": "string",
            "name": "ip-set-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/IPSet"
            },
            "required": true,
            "name": "IPSet",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Update IPSet",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateIPSet"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes the specified IPSet.  By default, if the IPSet is added to an\nNSGroup, it won't be deleted. In such situations, pass \"force=true\" as\nquery param to force delete the IPSet.\n",
        "parameters": [
          {
            "description": "IPSet Id",
            "required": true,
            "type": "string",
            "name": "ip-set-id",
            "in": "path"
          },
          {
            "default": false,
            "description": "Force delete the resource even if it is being used somewhere\n",
            "type": "boolean",
            "name": "force",
            "in": "query"
          }
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Delete IPSet",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteIPSet"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IPSet"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the specified IPSet\n",
        "parameters": [
          {
            "description": "IPSet Id",
            "required": true,
            "type": "string",
            "name": "ip-set-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Read IPSet",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadIPSet"
      }
    },
    "/tasks": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TaskListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get information about all tasks",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "Request URI(s) to include in query result",
            "type": "string",
            "name": "request_uri",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "Status(es) to include in query result",
            "type": "string",
            "name": "status",
            "in": "query"
          },
          {
            "description": "Names of users to include in query result",
            "type": "string",
            "name": "user",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Api Services"
        ],
        "summary": "Get information about all tasks",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListTasks"
      }
    },
    "/logical-ports/{lport-id}/mac-table": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalPortMacAddressListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns MAC table of a specified logical port. If the target transport node id is not provided,\nthe NSX manager will ask the controller for the transport node where the logical port is located.\nThe query parameter \"source=cached\" is not supported.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "lport-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "TransportNode Id",
            "required": false,
            "type": "string",
            "name": "transport_node_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Get MAC table of a logical port with a given port id (lport-id)",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalPortMacTable"
      }
    },
    "/logical-routers/{logical-router-id}/routing/advertisement/rules": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AdvertiseRuleList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies the advertisement rules on the specified logical\nrouter. The PUT request must include all the rules with the networks parameter. Modifiable\nparameters are networks, display_name, and description. Set the rules list to empty to delete/clear all rules.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/AdvertiseRuleList"
            },
            "required": true,
            "name": "AdvertiseRuleList",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Update the Advertisement Rules on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateAdvertiseRuleList"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AdvertiseRuleList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the advertisement rule list for the specified\nTIER1 logical router.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Read the Advertisement Rules on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadAdvertiseRuleList"
      }
    },
    "/logical-routers/{logical-router-id}/routing/routing-table?format=csv": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalRouterRouteTableInCsvFormat"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the route table in CSV format for the logical router on a node of the given\ntransport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required.\nTo filter the result by network address, paramter \"network_prefix=<a.b.c.d/mask>\"\nneeds to be specified.\nTo filter the result by route source, parameter \"route_source=<source_type>\" needs to be specified\nwhere source_type can be BGP, STATIC, CONNECTED, NSX_STATIC, TIER1_NAT or TIER0_NAT.\nIt is also possible to filter the RIB table using both network address and\nroute source filter together.\nThe query parameter \"source=cached\" is not supported.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "description": "IPv4 CIDR Block",
            "format": "ipv4-cidr-block",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "network_prefix"
          },
          {
            "enum": [
              "BGP",
              "STATIC",
              "CONNECTED"
            ],
            "description": "To filter the RIB table based on the source from which route is learned.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "route_source"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "TransportNode Id",
            "required": true,
            "type": "string",
            "name": "transport_node_id",
            "in": "query"
          }
        ],
        "produces": [
          "text/csv"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Get RIB table on a specified node for a logical router",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalRouterRoutingTableInCsvFormatCsv"
      }
    },
    "/transport-nodes": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/TransportNode"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Enables a fabric node to act as a transport node.\n\nAdditional documentation on creating a transport node can be found\nin the NSX-T Installation Guide.\n\nTransport nodes are hypervisor hosts and NSX Edges that will participate\nin an NSX-T overlay. For a hypervisor host, this means that it hosts\nVMs that will communicate over NSX-T logical switches. For NSX Edges,\nthis means that it will have logical router uplinks and downlinks.\n\nWhen creating a transport node, you must provide the node id of\nan existing fabric node (hypervisor host or NSX Edge node) in the\nnode_id property of the payload. This property is required.\n\nAdditionally, in order for the transport node to forward packets,\nthe host_switch_spec property must be specified.\n\nHost switches (called bridges in OVS on KVM hypervisors) are the\nindividual switches within the host virtual switch. Virtual machines\nare connected to the host switches.\n\nWhen creating a transport node, you need to specify if the host switches\nare already manually preconfigured on the node, or if NSX should create\nand manage the host switches. You specify this choice by the type\nof host switches you pass in the host_switch_spec property of the\nTransportNode request payload.\n\nFor a KVM host, you can preconfigure the host switch, or you can have\nNSX Manager perform the configuration. For an ESXi host or NSX Edge\nnode, NSX Manager always configures the host switch.\n\nTo preconfigure the host switches on a KVM host, pass an array\nof PreconfiguredHostSwitchSpec objects that describes those host\nswitches. In the current NSX-T release, only one prefonfigured host\nswitch can be specified.  See the PreconfiguredHostSwitchSpec schema\ndefinition for documentation on the properties that must be provided.\nPreconfigured host switches are only supported on KVM hosts, not on\nESXi hosts or NSX Edge nodes.\n\nTo allow NSX to manage the host switch configuration on KVM hosts,\nESXi hosts, or NSX Edge nodes, pass an array of StandardHostSwitchSpec\nobjects in the host_switch_spec property, and NSX will automatically\ncreate host switches with the properties you provide. In the current\nNSX-T release, up to 5 host switches can be automatically managed.\nSee the StandardHostSwitchSpec schema definition for documentation on\nthe properties that must be provided.\n\nNote: previous versions of NSX-T used a property named host_switches\nto specify the host switch configuration on the transport node. That\nproperty is deprecated, but still functions. You should configure new\nhost switches using the host_switch_spec property.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/TransportNode"
            },
            "required": true,
            "name": "TransportNode",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Create a Transport Node",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateTransportNode"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TransportNodeListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all transport nodes. A transport node is a\nfabric node (host or edge) that contains hostswitches. A hostswitch can\nhave virtual machines connected to them.\n\nBecause each transport node has HostSwitches, transport nodes can also have\nvirtual tunnel endpoints, which means that they can be part of the overlay.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "maintenance mode flag",
            "required": false,
            "type": "boolean",
            "name": "in_maintenance_mode",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "node identifier",
            "required": false,
            "type": "string",
            "name": "node_id",
            "in": "query"
          },
          {
            "description": "Fabric node IP address",
            "required": false,
            "type": "string",
            "name": "node_ip",
            "in": "query"
          },
          {
            "description": "a list of fabric node types separated by comma or a single type",
            "required": false,
            "type": "string",
            "name": "node_types",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "Transport zone identifier",
            "required": false,
            "type": "string",
            "name": "transport_zone_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "List Transport Nodes",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListTransportNodes"
      }
    },
    "/csm/aws/accounts/{account-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AwsAccount"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a AWS account information",
        "parameters": [
          {
            "description": "ID of AWS account",
            "required": true,
            "type": "string",
            "name": "account-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/AwsAccount"
            },
            "required": true,
            "name": "AwsAccount",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Update a AWS account information",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateAwsAccount"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete AWS account information",
        "parameters": [
          {
            "description": "ID of AWS account to delete",
            "required": true,
            "type": "string",
            "name": "account-id",
            "in": "path"
          }
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Delete AWS account information",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteAwsAccount"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AwsAccount"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the details of the particular AWS account",
        "parameters": [
          {
            "description": "ID of AWS account",
            "required": true,
            "type": "string",
            "name": "account-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Returns the details of the particular AWS account",
        "consumes": [
          "application/json"
        ],
        "operationId": "AwsAccountInfo"
      }
    },
    "/upgrade/plan?action=upgrade_selected_units": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Upgrade selected units",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/UpgradeUnitList"
            },
            "required": true,
            "name": "UpgradeUnitList",
            "in": "body"
          }
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Upgrade selected units",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpgradeSelectedUnitsUpgrade_selected_units"
      }
    },
    "/dhcp/relays": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/DhcpRelayService"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a dhcp relay service.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/DhcpRelayService"
            },
            "required": true,
            "name": "DhcpRelayService",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Create a DHCP Relay Service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateDhcpRelay"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DhcpRelayServiceListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all configured dhcp relay services.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "List all DHCP Relay Services",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListDhcpRelays"
      }
    },
    "/node/services/node-mgmt/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read appliance management service status",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read appliance management service status",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadApplianceManagementServiceStatus"
      }
    },
    "/cluster/nodes/{node-id}": {
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Removes the specified manager or control node from the NSX cluster.\nBefore you can remove a node from the cluster, you must shut down the manager\nor controller service with the \"stop service manager\" or the \"stop service controller\"\ncommand.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          }
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Remove a Node from the Cluster",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteClusterNodeConfig"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ClusterNodeConfig"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the specified NSX cluster node.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read Cluster Node Configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadClusterNodeConfig"
      }
    },
    "/pools/ip-blocks": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/IpBlock"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a new IPv4 address block using the specified cidr. cidr is a required\nparameter. display_name & description are optional parameters\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/IpBlock"
            },
            "required": true,
            "name": "IpBlock",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "Create a new IP address block.",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateIpBlock"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IpBlockListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about configured IP address blocks. Information includes\nthe id, display name, description & CIDR of IP address blocks\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "Returns list of configured IP address blocks.",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListIpBlocks"
      }
    },
    "/node/services/ntp?action=stop": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the NTP service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the NTP service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateNTPServiceActionStop"
      }
    },
    "/node/services/syslog?action=restart": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the syslog service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the syslog service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateSyslogServiceActionRestart"
      }
    },
    "/upgrade/upgrade-unit-groups-status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/UpgradeUnitGroupStatusListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get upgrade status for upgrade unit groups",
        "parameters": [
          {
            "description": "Component type based on which upgrade unit groups to be filtered",
            "required": false,
            "type": "string",
            "name": "component_type",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Get upgrade status for upgrade unit groups",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetUpgradeUnitGroupsStatus"
      }
    },
    "/node/services/manager": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeProtonServiceProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update service properties",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/NodeProtonServiceProperties"
            },
            "required": true,
            "name": "NodeProtonServiceProperties",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Update service properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateProtonService"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeProtonServiceProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read service properties",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read service properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadProtonService"
      }
    },
    "/firewall/sections/{section-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FirewallSection"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies the specified section, but does not modify the section's associated rules.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/FirewallSection"
            },
            "required": true,
            "name": "FirewallSection",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update an Existing Section",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateSection"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FirewallSection"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about firewall section for the identifier.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get an Existing Section",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetSection"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Removes firewall section from the system. Firewall section with\nrules can only be deleted by passing \"cascade=true\" parameter.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "description": "Flag to cascade delete of this object to all it's child objects.",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "cascade"
          }
        ],
        "tags": [
          "Services"
        ],
        "summary": "Delete an Existing Section and Its Associated Rules",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteSection"
      }
    },
    "/node/services/http?action=restart": {
      "post": {
        "responses": {
          "202": {
            "description": "Accepted"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart the http service",
        "operationId": "CreateProxyServiceActionRestart",
        "consumes": [
          "application/json"
        ],
        "description": "Restart the http service"
      }
    },
    "/firewall/sections/{section-id}/rules/{rule-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FirewallRule"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies existing firewall rule in a firewall section.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "rule-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/FirewallRule"
            },
            "required": true,
            "name": "FirewallRule",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update an Existing Rule",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateRule"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete existing firewall rule in a firewall section.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "rule-id",
            "in": "path"
          }
        ],
        "tags": [
          "Services"
        ],
        "summary": "Delete an Existing Rule",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteRule"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FirewallRule"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Return existing firewall rule information in a firewall section.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "rule-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Read an Existing Rule",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetRule"
      }
    },
    "/node/aaa/providers/vidm/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeAuthProviderVidmStatus"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read AAA provider vIDM status",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read AAA provider vIDM status",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadAuthProviderVidmStatus"
      }
    },
    "/logical-switches/{lswitch-id}/vtep-table?format=csv": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/VtepCsvListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns virtual tunnel endpoint table of a specified logical switch in\nCSV format from the given transport node if a transport node id is\ngiven in the query parameter from the Central Controller Plane.\nThe query parameter \"source=cached\" is not supported.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "lswitch-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "TransportNode Id",
            "required": false,
            "type": "string",
            "name": "transport_node_id",
            "in": "query"
          }
        ],
        "produces": [
          "text/csv"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Get virtual tunnel endpoint table for logical switch of the given\nID (lswitch-id)\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalSwitchVtepTableInCsvFormatCsv"
      }
    },
    "/infra/communication-profiles/{communication-profile-id}": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a new CommunicationProfile if a CommunicationProfile with the given ID does not already\nexist. Creates new CommunicationProfileEntries if populated in the CommunicationProfile.\nIf a CommunicationProfile with the given ID already exists, update the CommunicationProfile\nincluding the nested CommunicationProfileEntries. This is a full replace.\nThis is the ONLY way to create CommunicationProfileEntries and to add them to a\nCommunicationProfile.\n",
        "parameters": [
          {
            "description": "CommunicationProfile ID",
            "required": true,
            "type": "string",
            "name": "communication-profile-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/CommunicationProfile"
            },
            "required": true,
            "name": "CommunicationProfile",
            "in": "body"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Create or update a CommunicationProfile",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateCommunicationProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/CommunicationProfile"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read a CommunicationProfile.\n",
        "parameters": [
          {
            "description": "CommunicationProfile ID",
            "required": true,
            "type": "string",
            "name": "communication-profile-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Read CommunicationProfile",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadCommunicationProfile"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete CommunicationProfile",
        "parameters": [
          {
            "description": "CommunicationProfile ID",
            "required": true,
            "type": "string",
            "name": "communication-profile-id",
            "in": "path"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Delete CommunicationProfile",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteCommunicationProfile"
      }
    },
    "/node/services/manager?action=reset-manager-logging-levels": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Reset the logging levels to default values",
        "operationId": "ResetProtonServiceLoggingLevelActionReset-manager-logging-levels",
        "consumes": [
          "application/json"
        ],
        "description": "Reset the logging levels to default values"
      }
    },
    "/fabric/nodes/{node-id}/capabilities": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeCapabilitiesResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about capabilities of a single fabric node (host or edge).",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Return the List of Capabilities of a Single Node",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListNodeCapabilities"
      }
    },
    "/infra/communication-profiles/{communication-profile-id}/communication-profile-entries/{communication-profile-entry-id}": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update the CommunicationProfileEntry. If a CommunicationProfileEntry with the communication-profile-entry-id\nis not already present, this API fails with a 404. Creation of CommunicationProfileEntries\nis not allowed using this API.\n",
        "parameters": [
          {
            "description": "CommunicationProfile ID",
            "required": true,
            "type": "string",
            "name": "communication-profile-id",
            "in": "path"
          },
          {
            "description": "CommunicationProfileEntry ID",
            "required": true,
            "type": "string",
            "name": "communication-profile-entry-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/CommunicationProfileEntry"
            },
            "required": true,
            "name": "CommunicationProfileEntry",
            "in": "body"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Create or update a CommunicationProfileEntry",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateCommunicationProfileEntry"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete CommunicationProfileEntry",
        "parameters": [
          {
            "description": "CommunicationProfile ID",
            "required": true,
            "type": "string",
            "name": "communication-profile-id",
            "in": "path"
          },
          {
            "description": "CommunicationProfileEntry ID",
            "required": true,
            "type": "string",
            "name": "communication-profile-entry-id",
            "in": "path"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Delete CommunicationProfileEntry",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteCommunicationProfileEntry"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/CommunicationProfileEntry"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read CommunicationProfileEntry",
        "parameters": [
          {
            "description": "CommunicationProfile ID",
            "required": true,
            "type": "string",
            "name": "communication-profile-id",
            "in": "path"
          },
          {
            "description": "CommunicationProfileEntry ID",
            "required": true,
            "type": "string",
            "name": "communication-profile-entry-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Read CommunicationProfileEntry",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadCommunicationProfileEntry"
      }
    },
    "/logical-switches/{lswitch-id}/mac-table": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/MacAddressListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns MAC table of a specified logical switch from the given transport\nnode if a transport node id is given in the query parameter from the\nCentral Controller Plane.\nThe query parameter \"source=cached\" is not supported.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "lswitch-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "TransportNode Id",
            "required": false,
            "type": "string",
            "name": "transport_node_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Get MAC Table for Logical Switch of the Given ID (lswitch-id)",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalSwitchMacTable"
      }
    },
    "/pools/vni-pools/{pool-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/VniPool"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Updates the specified VNI pool. Modifiable parameters include description, display_name and ranges.\nRanges can be added, modified or deleted. Overlapping ranges are not allowed.\nOnly range end can be modified for any existing range.\nRange shrinking or deletion is not allowed if there are any allocated VNIs.\n",
        "parameters": [
          {
            "description": "VNI pool ID",
            "required": true,
            "type": "string",
            "name": "pool-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/VniPool"
            },
            "required": true,
            "name": "VniPool",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "Update a VNI Pool",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateVNIPool"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/VniPool"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the specified virtual network identifier (VNI) pool.\n",
        "parameters": [
          {
            "description": "VNI pool ID",
            "required": true,
            "type": "string",
            "name": "pool-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "Read VNI Pool",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadVNIPool"
      }
    },
    "/infra/realized-state/enforcement-points/{enforcement-point-name}/services/nsservices": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RealizedNSServiceListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Paginated list of all Realized NSService.\n",
        "parameters": [
          {
            "description": "Enforcement Point Name",
            "required": true,
            "type": "string",
            "name": "enforcement-point-name",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "List Realized NSServices",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListNSServiceRealizedStates"
      }
    },
    "/licenses": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/License"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "This will add a license key to the system.\nThe API supports adding only one license key for each license edition\ntype - Standard, Advanced or Enterprise. If a new license key is tried\nto add for an edition for which the license key already exists,\nthen this API will return an error.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/License"
            },
            "required": true,
            "name": "License",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Licensing"
        ],
        "summary": "Add a new license key",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateLicense"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LicensesListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns all licenses.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Licensing"
        ],
        "summary": "Get all licenses",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLicenses"
      }
    },
    "/node/users": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeUserPropertiesListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the list of users configued to log in to the NSX Manager appliance.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "List node users",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListNodeUsers"
      }
    },
    "/templates/{template-id}": {
      "post": {
        "responses": {
          "201": {
            "description": "Created"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a new template if the specified template id does not correspond to an existing template. Update the template\nif otherwise.\n",
        "parameters": [
          {
            "description": "Template identifier",
            "required": true,
            "type": "string",
            "name": "template-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/PolicyTemplate"
            },
            "required": true,
            "name": "PolicyTemplate",
            "in": "body"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Create or update a template.",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateOrUpdateTemplate"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/PolicyTemplate"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read a template and returns the template properties for a given template identifier.\n",
        "parameters": [
          {
            "description": "Template identifier",
            "required": true,
            "type": "string",
            "name": "template-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Read template.",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadTemplate"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a template.",
        "parameters": [
          {
            "description": "Template identifier",
            "required": true,
            "type": "string",
            "name": "template-id",
            "in": "path"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Delete template.",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteTemplate"
      }
    },
    "/logical-routers/{logical-router-id}/routing/ip-prefix-lists/{id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IPPrefixList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a specific IPPrefixList on the specified logical router.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/IPPrefixList"
            },
            "required": true,
            "name": "IPPrefixList",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Update a specific IPPrefixList on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateIPPrefixList"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IPPrefixList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read a specific IPPrefixList on the specified logical router.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Get a specific IPPrefixList on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadIPPrefixList"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes a specific IPPrefixList on the specified logical router.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "id",
            "in": "path"
          }
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Delete a specific IPPrefixList on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteIPPrefixList"
      }
    },
    "/mac-sets/{mac-set-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/MACSet"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Updates the specified MACSet. Modifiable parameters include the\ndescription, display_name and mac_addresses.\n",
        "parameters": [
          {
            "description": "MACSet Id",
            "required": true,
            "type": "string",
            "name": "mac-set-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/MACSet"
            },
            "required": true,
            "name": "MACSet",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Update MACSet",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateMACSet"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes the specified MACSet. By default, if the MACSet is added to an\nNSGroup, it won't be deleted. In such situations, pass \"force=true\" as\nquery param to force delete the MACSet.\n",
        "parameters": [
          {
            "description": "MACSet Id",
            "required": true,
            "type": "string",
            "name": "mac-set-id",
            "in": "path"
          },
          {
            "default": false,
            "description": "Force delete the resource even if it is being used somewhere\n",
            "type": "boolean",
            "name": "force",
            "in": "query"
          }
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Delete MACSet",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteMACSet"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/MACSet"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the specified MACSet\n",
        "parameters": [
          {
            "description": "MACSet Id",
            "required": true,
            "type": "string",
            "name": "mac-set-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Read MACSet",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadMACSet"
      }
    },
    "/logical-ports/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalPortStatusSummary"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns operational status of all logical ports.\nThe query parameter \"source=realtime\" is not supported.\n",
        "parameters": [
          {
            "description": "Logical Port attachment Id",
            "required": false,
            "type": "string",
            "name": "attachment_id",
            "in": "query"
          },
          {
            "enum": [
              "VIF",
              "LOGICALROUTER",
              "BRIDGEENDPOINT",
              "DHCP_SERVICE",
              "METADATA_PROXY",
              "NONE"
            ],
            "description": "Type of attachment for logical port; for query only.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "attachment_type"
          },
          {
            "description": "Bridge Cluster identifier",
            "required": false,
            "type": "string",
            "name": "bridge_cluster_id",
            "in": "query"
          },
          {
            "description": "Only container VIF logical ports will be returned if true",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "container_ports_only"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Flag to enable showing of transit logical port.",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "diagnostic"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Logical Switch identifier",
            "required": false,
            "type": "string",
            "name": "logical_switch_id",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "ID of the VIF of type PARENT",
            "required": false,
            "type": "string",
            "name": "parent_vif_id",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "Network Profile identifier",
            "required": false,
            "type": "string",
            "name": "switching_profile_id",
            "in": "query"
          },
          {
            "description": "Transport node identifier",
            "required": false,
            "type": "string",
            "name": "transport_node_id",
            "in": "query"
          },
          {
            "description": "Transport zone identifier",
            "required": false,
            "type": "string",
            "name": "transport_zone_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Get Operational Status Summary of All Logical Ports in the System",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalPortStatusSummary"
      }
    },
    "/md-proxies/{proxy-id}/{logical-switch-id}/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/MetadataProxyStatus"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the status of the given metadata proxy and attached logical switch.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "proxy-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "logical-switch-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get Metadata Proxy status with given proxy id and attached logical switch.",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetMetadataProxyStatus"
      }
    },
    "/firewall/sections/{section-id}/state": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FirewallSectionState"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Return realized state information of a firewall section.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "name": "barrier_id",
            "format": "int64",
            "required": false,
            "minimum": 0,
            "in": "query",
            "type": "integer"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get the Realized State of a Firewall Section",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetSectionState"
      }
    },
    "/csm/aws/accounts": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AwsAccount"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Add a AWS account to cloud serivce manager",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/AwsAccount"
            },
            "required": true,
            "name": "AwsAccount",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Add a AWS account to cloud serivce manager",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateAwsAccount"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AwsAccountsListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Return a list of all AWS accounts",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "Identifier for region based on which accounts statistics will be\naggregated. Using this request parameter will return\nonly all_accounts_vpc_stats and all_accounts_instance_stats properties.\n",
            "required": false,
            "type": "string",
            "name": "region_id",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Return a list of all AWS accounts",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListAwsAccounts"
      }
    },
    "/ns-services": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/NSService"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a new NSService which allows users to specify characteristics to use\nfor matching network traffic.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/NSService"
            },
            "required": true,
            "name": "NSService",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Create NSService",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateNSService"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NSServiceListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns paginated list of NSServices\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Fetch all default NSServices",
            "type": "boolean",
            "name": "default_service",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "List all NSServices",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListNSServices"
      }
    },
    "/cluster/nodes/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ClustersAggregateInfo"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read Cluster Status",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read Cluster Status",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadClusterNodesAggregateStatus"
      }
    },
    "/cluster-profiles": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/ClusterProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a cluster profile. The resource_type is required.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ClusterProfile"
            },
            "required": true,
            "name": "ClusterProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Create a Cluster Profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateClusterProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ClusterProfileListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns paginated list of cluster profiles\nCluster profiles define policies for edge cluster and bridge cluster.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Whether the list result contains system resources",
            "default": true,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "include_system_owned"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "enum": [
              "EdgeHighAvailabilityProfile",
              "BridgeHighAvailabilityClusterProfile"
            ],
            "description": "Supported cluster profiles.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "resource_type"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "List Cluster Profiles",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListClusterProfiles"
      }
    },
    "/logical-router-ports/{logical-router-port-id}/statistics": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalRouterPortStatistics"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the statistics for the Logical Router Port. If query parameter\n\"transport_node_id=<transport-node-id>\" is given,  only the statistics\nfrom the given node for the logical router port will be returned.\nOtherwise the statistics from each node for the same logical router port\nwill be returned. The transport_node_id is mandatory if the router port\nis not uplink type.\nThe query parameter \"source=realtime\" is not supported.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-port-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "TransportNode Id",
            "required": false,
            "type": "string",
            "name": "transport_node_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Get the statistics of a specified logical router port on all or a specified node",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalRouterPortStatistics"
      }
    },
    "/pools/ip-subnets/{subnet-id}": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AllocationIpAddress"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Allocates or releases an IP address from the specified IP subnet. To allocate\nan address, include ?action=ALLOCATE in the request and a \"{}\"\nin the request body. When the request is successful, the response is\n\"allocation_id\": \"<ip-address>\", where <ip-address> is an IP address from\nthe specified pool. To release an IP address (return it back to the pool),\ninclude ?action=RELEASE in the request and \"allocation_id\":<ip-address> in\nthe request body, where <ip-address> is the address to be released. When the\nrequest is successful, the response is NULL.\n",
        "parameters": [
          {
            "description": "IP subnet id",
            "required": true,
            "type": "string",
            "name": "subnet-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/AllocationIpAddress"
            },
            "required": true,
            "name": "AllocationIpAddress",
            "in": "body"
          },
          {
            "enum": [
              "ALLOCATE",
              "RELEASE"
            ],
            "description": "Specifies allocate or release action",
            "required": true,
            "in": "query",
            "type": "string",
            "name": "action"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "Allocate or Release an IP Address from a Ip Subnet",
        "consumes": [
          "application/json"
        ],
        "operationId": "AllocateOrReleaseFromIpBlockSubnet"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes a subnet with specified id within a given IP address block.\nDeletion is allowed only when there are no allocated IP addresses\nfrom that subnet.\n",
        "parameters": [
          {
            "description": "Subnet id",
            "required": true,
            "type": "string",
            "name": "subnet-id",
            "in": "path"
          }
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "Delete subnet within an IP block",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteIpBlockSubnet"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IpBlockSubnet"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the subnet with specified id within a given\nIP address block. Information includes display_name, description, cidr and\nallocation_ranges.\n",
        "parameters": [
          {
            "description": "Subnet id",
            "required": true,
            "type": "string",
            "name": "subnet-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "Get the subnet within an IP block",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadIpBlockSubnet"
      }
    },
    "/node/services/nsx-upgrade-agent/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read Nsx upgrade agent service status",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read Nsx upgrade agent service status",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNsxUpgradeAgentServiceStatus"
      }
    },
    "/md-proxies/{proxy-id}/statistics": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/MetadataProxyStatistics"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the statistics of the given metatada proxy. If no logical switch\nis provided, all staticstics of all the logical switches the proxy was\nattached will be returned.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "proxy-id",
            "in": "path"
          },
          {
            "description": "The uuid of logical switch",
            "required": false,
            "type": "string",
            "name": "logical_switch_id",
            "in": "query"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get Metadata Proxy statistics with given proxy id",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetMetadataProxyStatistics"
      }
    },
    "/node/file-store/{file-name}?action=copy_from_remote_file": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/FileProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "504": {
            "description": "Gateway Timeout"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Copy a remote file to the file store. If you use scp or sftp,\nyou must provide the remote server's SSH fingerprint. See the\n<i>NSX-T Administration Guide</i> for information and instructions\nabout finding the SSH fingerprint.\n",
        "parameters": [
          {
            "description": "Destination filename",
            "required": true,
            "type": "string",
            "name": "file-name",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/CopyFromRemoteFileProperties"
            },
            "required": true,
            "name": "CopyFromRemoteFileProperties",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Copy a remote file to the file store",
        "consumes": [
          "application/json"
        ],
        "operationId": "CopyFromRemoteFileCopy_from_remote_file"
      }
    },
    "/node/services/node-mgmt": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read appliance management service properties",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read appliance management service properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadApplianceManagementService"
      }
    },
    "/node/services/install-upgrade": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeInstallUpgradeServiceProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update NSX install-upgrade service properties",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/NodeInstallUpgradeServiceProperties"
            },
            "required": true,
            "name": "NodeInstallUpgradeServiceProperties",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Update NSX install-upgrade service properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateRepositoryService"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeInstallUpgradeServiceProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read NSX install-upgrade service properties",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read NSX install-upgrade service properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadRepositoryService"
      }
    },
    "/pools/ip-pools": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/IpPool"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a new IPv4 or IPv6 address pool. Required parameters are\nallocation_ranges and cidr. Optional parameters are display_name,\ndescription, dns_nameservers, dns_suffix, and gateway_ip.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/IpPool"
            },
            "required": true,
            "name": "IpPool",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "Create an IP Pool",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateIpPool"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IpPoolListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the configured IP address pools. Information\nincludes the display name and description of the pool and the details of\neach of the subnets in the pool, including the DNS servers, allocation\nranges, gateway, and CIDR subnet address.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "List IP Pools",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListIpPools"
      }
    },
    "/node/processes": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeProcessPropertiesListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the number of processes and information about each\nprocess. Process information includes 1) mem_resident, which is roughly\nequivalent to the amount of RAM, in bytes, currently used by the process,\n2) parent process ID (ppid), 3) process name, 4) process up time in milliseconds,\n5) mem_used, wich is the amount of virtual memory used by the process, in\nbytes, 6) process start time, in milliseconds since epoch, 7) process ID\n(pid), 8) CPU time, both user and the system, consumed by the process in\nmilliseconds.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "List node processes",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListNodeProcesses"
      }
    },
    "/csm/virtual-machines": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/CloudVirtualMachinesListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the list of all virtual machines created or imported under a particular account id. Supports optional query parameters like region id, vpc id, public_ip, is_gateway.",
        "parameters": [
          {
            "description": "Identifier for account based on which virtual machines are to be filtered",
            "required": false,
            "type": "string",
            "name": "account_id",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Identifier for virtual machine based on which the list can be filtered",
            "required": false,
            "type": "string",
            "name": "instance_id",
            "in": "query"
          },
          {
            "description": "Is the VM a gateway node?",
            "required": false,
            "type": "boolean",
            "name": "is_gateway",
            "in": "query"
          },
          {
            "description": "Identifier for logical switch based on which Aws Virtual Machines are\nto be filtered\n",
            "required": false,
            "type": "string",
            "name": "logical_switch_id",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "Public IP address of the virtual machine",
            "required": false,
            "type": "string",
            "name": "public_ip",
            "in": "query"
          },
          {
            "enum": [
              "QUARANTINED",
              "NOT_QUARANTINED",
              "UNKNOWN",
              "OVERRIDDEN"
            ],
            "description": "Quarantine State",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "quarantine_state"
          },
          {
            "description": "Identifier for region based on whicha Virtual Machines are to be filtered",
            "required": false,
            "type": "string",
            "name": "region_id",
            "in": "query"
          },
          {
            "enum": [
              "AwsVirtualMachine",
              "AzureVirtualMachine"
            ],
            "description": "Identifier for virtual machines of a particular cloud provider",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "resource_type"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "Identifier for vpc based on which Aws Virtual Machines are to be filtered",
            "required": false,
            "type": "string",
            "name": "vpc_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Returns the list of all virtual machines created or imported under a particular account id. Supports optional query parameters like region id, vpc id, public_ip, is_gateway.",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListCloudVirtualMachines"
      }
    },
    "/infra/services/{service-id}/service-entries": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ServiceEntryListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Paginated list of Service entries for the given service\n",
        "parameters": [
          {
            "description": "Service ID",
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "List Service entries for the given service",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListServiceEntries"
      }
    },
    "/node/network/routes/{route-id}": {
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a route from the NSX Manager routing table. You can modify an\nexisting route by deleting it and then posting the modified version of the\nroute. To verify, remove the route ID from the URI, issue a GET request, and\nnote the absense of the deleted route.\n",
        "parameters": [
          {
            "description": "ID of route to delete",
            "required": true,
            "type": "string",
            "name": "route-id",
            "in": "path"
          }
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Delete node network route",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteNodeNetworkRoute"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeRouteProperties"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns detailed information about a specified route in the NSX Manager\nrouting table.\n",
        "parameters": [
          {
            "description": "ID of route to read",
            "required": true,
            "type": "string",
            "name": "route-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read node network route",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNodeNetworkRoute"
      }
    },
    "/loadbalancer/services/{service-id}/statistics": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbServiceStatistics"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the statistics of the given load balancer service.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get the statistics of load balancer service",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLoadBalancerServiceStatistics"
      }
    },
    "/lldp/transport-nodes/{node-id}/interfaces": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/InterfaceNeighborPropertyListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "List LLDP Neighbor Properties",
        "parameters": [
          {
            "description": "ID of transport node",
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "List LLDP Neighbor Properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListNeighborProperties"
      }
    },
    "/logical-ports/{lport-id}/forwarding-path": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/PortConnectionEntities"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "description": "Bad Request"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get networking entities between two logical ports with VIF attachment",
        "parameters": [
          {
            "description": "ID of source port",
            "required": true,
            "type": "string",
            "name": "lport-id",
            "in": "path"
          },
          {
            "description": "ID of peer port",
            "required": true,
            "type": "string",
            "name": "peer_port_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Get networking entities between two logical ports with VIF attachment",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetForwardingPath"
      }
    },
    "/error-resolver": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ErrorResolverInfoList"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns a list of metadata for all the error resolvers registered.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Error Resolver"
        ],
        "summary": "Fetches a list of metadata for all the registered error resolvers",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListErrorResolverInfo"
      }
    },
    "/node/file-store": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FilePropertiesListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "List node files",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "List node files",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListFiles"
      }
    },
    "/trust-management/csrs": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/Csr"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a new certificate signing request (CSR). A CSR is encrypted text that\ncontains information about your organization (organization name, country,\nand so on) and your Web server's public key, which is a public certificate\nthe is generated on the server that can be used to forward this request to a\ncertificate authority (CA). A private key is also usually created at the\nsame time as the CSR.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/Csr"
            },
            "required": true,
            "name": "Csr",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Generate a New Certificate Signing Request",
        "consumes": [
          "application/json"
        ],
        "operationId": "GenerateCsr"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/CsrList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all of the CSRs that have been created.",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Return All the Generated CSRs",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetCsrs"
      }
    },
    "/node/services/nsx-upgrade-agent": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read NSX upgrade Agent service properties",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read NSX upgrade Agent service properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNsxUpgradeAgentService"
      }
    },
    "/network-encryption/key-policies/reset/{encrypt-type}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Reset default network encryption key policy to system default for a specific encryption type",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "encrypt-type",
            "in": "path"
          }
        ],
        "tags": [
          "Services"
        ],
        "summary": "Reset default network encryption key policy to system default for a specific encryption type",
        "consumes": [
          "application/json"
        ],
        "operationId": "ResetDefaultDneKeyPolicyToSystemDefault"
      }
    },
    "/logical-routers/{logical-router-id}/routing/route-maps/{id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RouteMap"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a specific RouteMap on the specified logical router.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/RouteMap"
            },
            "required": true,
            "name": "RouteMap",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Update a specific RouteMap on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateRouteMap"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RouteMap"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read a specific RouteMap on the specified logical router.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Get a specific RouteMap on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadRouteMap"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes a specific RouteMap on the specified logical router.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "id",
            "in": "path"
          }
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Delete a specific RouteMap on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteRouteMap"
      }
    },
    "/node/hardening-policy/mandatory-access-control/report": {
      "get": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get the report for Mandatory Access Control",
        "produces": [
          "application/octet-stream"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Get the report for Mandatory Access Control",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetNodeMandatoryAccessControlReport"
      }
    },
    "/infra/realized-state/enforcement-points/{enforcement-point-name}/firewalls/firewall-sections": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RealizedFirewallSectionListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Paginated list of all Firewalls. Returns populated Firewalls.\n",
        "parameters": [
          {
            "description": "Enforcement Point Name",
            "required": true,
            "type": "string",
            "name": "enforcement-point-name",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "List Firewall Sections",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListFirewallSectionRealizedStates"
      }
    },
    "/loadbalancer/services/{service-id}/pools/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbPoolStatusListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the status list of load balancer pools in given load balancer service.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get the status list of load balancer pools",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListLoadBalancerPoolStatuses"
      }
    },
    "/logical-ports/{lport-id}/statistics": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalPortStatistics"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns statistics of a specified logical port. If the logical port is attached to\na logical router port, query parameter \"source=realtime\" is not supported.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "lport-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Get Statistics for Logical Port of a Given Port ID (lport-id)",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalPortStatistics"
      }
    },
    "/node/services/install-upgrade/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read NSX install-upgrade service status",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read NSX install-upgrade service status",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadRepositoryServiceStatus"
      }
    },
    "/firewall/sections/{section-id}/rules/{rule-id}/stats": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FirewallStats"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get aggregated statistics for a rule for given firewall section. The\nAPI only supports access to cached (source=cached) statistical data\ncollected offline in the system. Data includes total number of packets,\nbytes and sessions counters for a firewall rule and overall session count\nfor all firewall rules on transport nodes or edge nodes.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "rule-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get Firewall rule level statistics",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetFirewallStats"
      }
    },
    "/firewall/rules/{rule-id}/state": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RuleState"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Return realized state information of a firewall rule.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "rule-id",
            "in": "path"
          },
          {
            "name": "barrier_id",
            "format": "int64",
            "required": false,
            "minimum": 0,
            "in": "query",
            "type": "integer"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get the Realized State of a Firewall Rule",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetRuleState"
      }
    },
    "/ipfix/collectorconfigs/{collector-config-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IpfixCollectorConfig"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update an existing IPFIX collector configuration",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "collector-config-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/IpfixCollectorConfig"
            },
            "required": true,
            "name": "IpfixCollectorConfig",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Operations"
        ],
        "summary": "Update an existing IPFIX collector configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateIpfixCollectorConfig"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete an existing IPFIX collector configuration",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "collector-config-id",
            "in": "path"
          }
        ],
        "tags": [
          "Operations"
        ],
        "summary": "Delete an existing IPFIX collector configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteIpfixCollectorConfig"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IpfixCollectorConfig"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get an existing IPFIX collector configuration",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "collector-config-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Operations"
        ],
        "summary": "Get an existing IPFIX collector configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetIpfixCollectorConfig"
      }
    },
    "/cluster": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ClusterConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the NSX cluster configuration. An NSX cluster has\ntwo functions or purposes, commonly referred to as \"roles.\" These two roles\nare control and management. Each NSX installation has a single cluster.\nSeparate NSX clusters do not share data. In other words, a given data-plane\nnode is attached to only one cluster, not to multiple clusters.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read Cluster Configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadClusterConfig"
      }
    },
    "/logical-switches/{lswitch-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalSwitch"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies attributes of an existing logical switch. Modifiable\nattributes include admin_state, replication_mode, switching_profile_ids\nand vlan. You cannot modify the original transport_zone_id.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "lswitch-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/LogicalSwitch"
            },
            "required": true,
            "name": "LogicalSwitch",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Update a Logical Switch",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateLogicalSwitch"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Removes a logical switch from the associated overlay or VLAN transport\nzone. By default, a logical switch cannot be deleted if there are logical\nports on the switch, or it is added to a NSGroup.\nCascade option can be used to delete all ports and the logical switch.\nDetach option can be used to delete the logical switch forcibly.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "lswitch-id",
            "in": "path"
          },
          {
            "description": "Delete a Logical Switch and all the logical ports in it,\nif none of the logical ports have any attachment.\n",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "cascade"
          },
          {
            "description": "Force delete a logical switch",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "detach"
          }
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Delete a Logical Switch",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteLogicalSwitch"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalSwitch"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the specified logical switch Id.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "lswitch-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Get Logical Switch associated with the provided id (lswitch-id)",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalSwitch"
      }
    },
    "/node/file-store?action=create_remote_directory": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "504": {
            "description": "Gateway Timeout"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a directory on the remote remote server. Supports only SFTP.\nYou must provide the remote server's SSH fingerprint. See the\n<i>NSX Administration Guide</i> for information and instructions\nabout finding the SSH fingerprint.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/CreateRemoteDirectoryProperties"
            },
            "required": true,
            "name": "CreateRemoteDirectoryProperties",
            "in": "body"
          }
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Create directory in remote file server",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateRemoteDirectoryCreate_remote_directory"
      }
    },
    "/firewall/excludelist?action=check_if_exists": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ResourceReference"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Check if the object a member of the exclude list",
        "parameters": [
          {
            "in": "query",
            "description": "identifier of the object",
            "required": true,
            "maxLength": 64,
            "type": "string",
            "name": "object_id"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Check if the object a member of the exclude list",
        "consumes": [
          "application/json"
        ],
        "operationId": "CheckMemberIfExistsCheck_if_exists"
      }
    },
    "/upgrade/summary": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/UpgradeSummary"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get upgrade summary",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Get upgrade summary",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetUpgradeSummary"
      }
    },
    "/app-discovery/sessions/{session-id}": {
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Cancel and delete the application discovery session\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "session-id",
            "in": "path"
          }
        ],
        "tags": [
          "App Discovery"
        ],
        "summary": "Cancel and delete the application discovery session",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteAppDiscoverySession"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AppDiscoverySession"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the status of the application discovery session and other details\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "session-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "App Discovery"
        ],
        "summary": "Returns the status of the application discovery session and other details",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetAppDiscoverySession"
      }
    },
    "/node/services/syslog?action=start": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the syslog service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the syslog service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateSyslogServiceActionStart"
      }
    },
    "/network-encryption/key-policies/{key-policy-id}?action=revoke": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Manually revoke a network encryption key policy for ungraceful re-key",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "key-policy-id",
            "in": "path"
          }
        ],
        "tags": [
          "Services"
        ],
        "summary": "Manually revoke a network encryption key policy for ungraceful re-key",
        "consumes": [
          "application/json"
        ],
        "operationId": "RevokeDneKeyPolicyRevoke"
      }
    },
    "/node/services/syslog": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read syslog service properties",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read syslog service properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadSyslogService"
      }
    },
    "/pools/ip-pools/{pool-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IpPool"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies the specified IP address pool. Modifiable parameters include the\ndescription, display_name, and all subnet information.\n",
        "parameters": [
          {
            "description": "IP pool ID",
            "required": true,
            "type": "string",
            "name": "pool-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/IpPool"
            },
            "required": true,
            "name": "IpPool",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "Update an IP Pool",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateIpPool"
      },
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AllocationIpAddress"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Allocates or releases an IP address from the specified IP pool. To allocate\nan address, include ?action=ALLOCATE in the request and \"allocation_id\":null\nin the request body. When the request is successful, the response is\n\"allocation_id\": \"<ip-address>\", where <ip-address> is an IP address from\nthe specified pool. To release an IP address (return it back to the pool),\ninclude ?action=RELEASE in the request and \"allocation_id\":<ip-address> in\nthe request body, where <ip-address> is the address to be released. When the\nrequest is successful, the response is NULL. Tags, display_name and description\nattributes are not supported for AllocationIpAddress in this release.\n",
        "parameters": [
          {
            "description": "IP pool ID",
            "required": true,
            "type": "string",
            "name": "pool-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/AllocationIpAddress"
            },
            "required": true,
            "name": "AllocationIpAddress",
            "in": "body"
          },
          {
            "enum": [
              "ALLOCATE",
              "RELEASE"
            ],
            "description": "Specifies allocate or release action",
            "required": true,
            "in": "query",
            "type": "string",
            "name": "action"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "Allocate or Release an IP Address from a Pool",
        "consumes": [
          "application/json"
        ],
        "operationId": "AllocateOrReleaseFromIpPool"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IpPool"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the specified IP address pool.",
        "parameters": [
          {
            "description": "IP pool ID",
            "required": true,
            "type": "string",
            "name": "pool-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "Read IP Pool",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadIpPool"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes the specified IP address pool. By default, if the IpPool is used in other configurations (such as transport node template), it won't be deleted. In such situations, pass \"force=true\" as query param to force delete the IpPool",
        "parameters": [
          {
            "description": "IP pool ID",
            "required": true,
            "type": "string",
            "name": "pool-id",
            "in": "path"
          },
          {
            "default": false,
            "description": "Force delete the resource even if it is being used somewhere\n",
            "type": "boolean",
            "name": "force",
            "in": "query"
          }
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "Delete an IP Pool",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteIpPool"
      }
    },
    "/cluster/backups/config": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BackupConfiguration"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Configure file server and timers for automated backup.\nIf secret fields are omitted (password, passphrase)\nthen use the previously set value.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/BackupConfiguration"
            },
            "required": true,
            "name": "BackupConfiguration",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Configure backup",
        "consumes": [
          "application/json"
        ],
        "operationId": "ConfigureBackupConfig"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BackupConfiguration"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get a configuration of a file server and timers for automated backup.\nFields that contain secrets (password, passphrase) are not returned.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Get backup configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetBackupConfig"
      }
    },
    "/traceflows/{traceflow-id}/observations": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TraceflowObservationListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get observations for the Traceflow round",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "traceflow-id",
            "in": "path"
          },
          {
            "description": "Observations having the given component name will be listed.",
            "required": false,
            "type": "string",
            "name": "component_name",
            "in": "query"
          },
          {
            "enum": [
              "PHYSICAL",
              "LR",
              "LS",
              "DFW",
              "BRIDGE",
              "EDGE_TUNNEL",
              "EDGE_HOSTSWITCH",
              "UNKNOWN"
            ],
            "description": "Observations having the given component type will be listed.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "component_type"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "enum": [
              "TraceflowObservationForwarded",
              "TraceflowObservationDropped",
              "TraceflowObservationDelivered",
              "TraceflowObservationReceived",
              "TraceflowObservationForwardedLogical",
              "TraceflowObservationDroppedLogical",
              "TraceflowObservationReceivedLogical"
            ],
            "description": "The type of observations that will be listed.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "resource_type"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "Observations having the given transport node name will be listed.",
            "required": false,
            "type": "string",
            "name": "transport_node_name",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Get observations for the Traceflow round",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetTraceflowObservations"
      }
    },
    "/trust-management/crls/{crl-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/Crl"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Updates an existing CRL.",
        "parameters": [
          {
            "description": "ID of CRL to update",
            "required": true,
            "type": "string",
            "name": "crl-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/Crl"
            },
            "required": true,
            "name": "Crl",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Update CRL for the Given CRL ID",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateCrl"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/Crl"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the specified CRL. For additional information,\ninclude the ?details=true modifier at the end of the request URI.\n",
        "parameters": [
          {
            "description": "ID of CRL to read",
            "required": true,
            "type": "string",
            "name": "crl-id",
            "in": "path"
          },
          {
            "description": "whether to expand the pem data and show all its details",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "details"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Show CRL Data for the Given CRL ID",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetCrl"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes an existing CRL.",
        "parameters": [
          {
            "description": "ID of CRL to delete",
            "required": true,
            "type": "string",
            "name": "crl-id",
            "in": "path"
          }
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Delete a CRL",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteCrl"
      }
    },
    "/trust-management/csrs/{csr-id}?action=self_sign": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/Certificate"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Self-signs the previously generated CSR. This action is similar to the\nimport certificate action, but instead of using a public certificate signed\nby a CA, the self_sign POST action uses a certificate that is signed with\nNSX's own private key.\n",
        "parameters": [
          {
            "description": "CSR this certificate is associated with",
            "required": true,
            "type": "string",
            "name": "csr-id",
            "in": "path"
          },
          {
            "description": "Number of days the certificate will be valid, default 10 years",
            "format": "int64",
            "default": 3650,
            "required": true,
            "maximum": 10000,
            "minimum": 1,
            "in": "query",
            "type": "integer",
            "name": "days_valid"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Self-Sign the CSR",
        "consumes": [
          "application/json"
        ],
        "operationId": "SelfSignCertificateSelf_sign"
      }
    },
    "/aaa/registration-token": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RegistrationToken"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "By default, api role is network_engineer.\n",
        "parameters": [
          {
            "description": "API User Role for registration",
            "enum": [
              "enterprise_admin",
              "network_engineer"
            ],
            "type": "string",
            "name": "registration_api_user_role",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Aaa"
        ],
        "summary": "Create registration access token",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateRegistrationToken"
      }
    },
    "/node/users/{userid}/ssh-keys?action=remove_ssh_key": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "description": "Internal Server Error"
          }
        },
        "description": "Remove SSH public key from authorized_keys file for node user",
        "parameters": [
          {
            "description": "User id of the user",
            "required": true,
            "type": "string",
            "name": "userid",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/SshKeyBaseProperties"
            },
            "required": true,
            "name": "SshKeyBaseProperties",
            "in": "body"
          }
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Remove SSH public key from authorized_keys file for node user",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteNodeUserSshKeyRemove_ssh_key"
      }
    },
    "/fabric/nodes": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/Node"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a host node (hypervisor) or edge node (router) in the transport\nnetwork.\n\nWhen you run this command for a host, NSX Manager attempts to install the\nNSX kernel modules, which are packaged as VIB, RPM, or DEB files. For the\ninstallation to succeed, you must provide the host login credentials and the\nhost thumbprint.\n\nTo get the ESXi host thumbprint, SSH to the host and run the\n<b>openssl x509 -in /etc/vmware/ssl/rui.crt -fingerprint -sha256 -noout</b>\ncommand.\n\nTo generate host key thumbprint using SHA-256 algorithm please follow the\nsteps below.\n\nLog into the host, making sure that the connection is not vulnerable to a\nman in the middle attack. Check whether a public key already exists.\nHost public key is generally located at '/etc/ssh/ssh_host_rsa_key.pub'.\nIf the key is not present then generate a new key by running the following\ncommand and follow the instructions.\n\n<b>ssh-keygen -t rsa</b>\n\nNow generate a SHA256 hash of the key using the following command. Please\nmake sure to pass the appropriate file name if the public key is stored with\na different file name other than the default 'id_rsa.pub'.\n\n<b>awk '{print $2}' id_rsa.pub | base64 -d | sha256sum -b | sed 's/ .*$//' | xxd -r -p | base64</b>\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/Node"
            },
            "required": true,
            "name": "Node",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Register and Install NSX Components on a Node",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddNode"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all fabric nodes (hosts and edges).",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Id of the discovered node which was converted to create this node",
            "required": false,
            "type": "string",
            "name": "discovered_node_id",
            "in": "query"
          },
          {
            "description": "HostNode display name",
            "required": false,
            "type": "string",
            "name": "display_name",
            "in": "query"
          },
          {
            "description": "HostNode external id",
            "required": false,
            "type": "string",
            "name": "external_id",
            "in": "query"
          },
          {
            "enum": [
              "ESXI",
              "RHELKVM",
              "UBUNTUKVM",
              "HYPERV"
            ],
            "description": "HostNode's Hypervisor type, for example ESXi, RHEL KVM or UBUNTU KVM.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "hypervisor_os_type"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Management IP address of the node",
            "required": false,
            "type": "string",
            "name": "ip_address",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "enum": [
              "HostNode",
              "EdgeNode",
              "PublicCloudGatewayNode"
            ],
            "description": "Node type from 'HostNode', 'EdgeNode', 'PublicCloudGatewayNode'",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "resource_type"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Return the List of Nodes",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListNodes"
      }
    },
    "/node/network/interfaces/{interface-id}/stats": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeInterfaceStatisticsProperties"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "On the specified interface, returns the number of received (rx), transmitted\n(tx), and dropped packets; the number of bytes and errors received and\ntransmitted on the interface; and the number of detected collisions.\n",
        "parameters": [
          {
            "description": "ID of interface to read",
            "required": true,
            "type": "string",
            "name": "interface-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read the NSX Manager's Network Interface Statistics",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNetworkInterfaceStatistics"
      }
    },
    "/fabric/nodes/{node-id}/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeStatus"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns connectivity, heartbeat, and version information about a fabric node\n(host or edge). Note that the LCP connectivity status remains down until\nafter the fabric node has been added as a transpot node and the NSX host\nswitch has been successfully installed. See POST /api/v1/transport-nodes.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Return Runtime Status Information for a Node",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNodeStatus"
      }
    },
    "/loadbalancer/client-ssl-profiles": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbClientSslProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a load balancer client-ssl profile.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/LbClientSslProfile"
            },
            "required": true,
            "name": "LbClientSslProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Create a load balancer client-ssl profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateLoadBalancerClientSslProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbClientSslProfileListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Retrieve a paginated list of load balancer client-ssl profiles.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Retrieve a paginated list of load balancer client-ssl profiles",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListLoadBalancerClientSslProfiles"
      }
    },
    "/node/services/ssh?action=stop": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the ssh service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the ssh service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateSSHServiceActionStop"
      }
    },
    "/transport-zones/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/HeatMapTransportNodesAggregateStatus"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get high-level summary of a transport zone. The service layer does not support source = realtime or cached.",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Get high-level summary of a transport zone. The service layer does not support source = realtime or cached.",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetAllTransportZoneStatus"
      }
    },
    "/fabric/compute-collection-fabric-templates/{fabric-template-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ComputeCollectionFabricTemplate"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Updates compute collection fabric template for the given id",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "fabric-template-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/ComputeCollectionFabricTemplate"
            },
            "required": true,
            "name": "ComputeCollectionFabricTemplate",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Updates compute collection fabric template",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateComputeCollectionFabricTemplate"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ComputeCollectionFabricTemplate"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get compute collection fabric template for the given id",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "fabric-template-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Get compute collection fabric template by id",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetComputeCollectionFabricTemplate"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes compute collection fabric template for the given id",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "fabric-template-id",
            "in": "path"
          }
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Deletes compute collection fabric template",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteComputeCollectionFabricTemplate"
      }
    },
    "/node/services/syslog/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read syslog service status",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read syslog service status",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadSyslogServiceStatus"
      }
    },
    "/trust-management/certificates?action=import": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/CertificateList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Adds a new private-public certificate or a chain of certificates (CAs) and,\noptionally, a private key that can be applied to one of the user-facing\ncomponents (appliance management or edge). The certificate and the key\nshould be stored in PEM format. If no private key is provided, the\ncertificate is used as a client certificate in the trust store.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/TrustObjectData"
            },
            "required": true,
            "name": "TrustObjectData",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Add a New Certificate",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddCertificateImport"
      }
    },
    "/csm/aws/gateways?action=undeploy": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "All the required configuration to undeploy Aws gateways will be absorbed as a\npart of request body in this api and gateway undeployment will be triggered.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/AwsGatewayUndeployConfig"
            },
            "required": true,
            "name": "AwsGatewayUndeployConfig",
            "in": "body"
          }
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "All the required configuration to undeploy Aws gateways will be absorbed as a\npart of request body in this api and gateway undeployment will be triggered.\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "UndeployAwsGatewayUndeploy"
      }
    },
    "/firewall/stats?action=reset": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Sets firewall rule statistics counter to zero. This operation is supported\nfor given category, for example: L3DFW i.e. for all layer3 firewall\n(transport nodes only) rules or L3EDGE i.e. for all layer3 edge firewall\n(edge nodes only) rules.\n",
        "parameters": [
          {
            "enum": [
              "L3DFW",
              "L3EDGE"
            ],
            "description": "Aggregation Statistic Category",
            "required": true,
            "in": "query",
            "type": "string",
            "name": "category"
          }
        ],
        "tags": [
          "Services"
        ],
        "summary": "Reset firewall rule statistics",
        "consumes": [
          "application/json"
        ],
        "operationId": "ResetFirewallRuleStatsReset"
      }
    },
    "/error-resolver?action=resolve_error": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Invokes the corresponding error resolver for the\ngiven error(s) present in the payload\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ErrorResolverMetadataList"
            },
            "required": true,
            "name": "ErrorResolverMetadataList",
            "in": "body"
          }
        ],
        "tags": [
          "Error Resolver"
        ],
        "summary": "Resolves the error",
        "consumes": [
          "application/json"
        ],
        "operationId": "ResolveErrorResolve_error"
      }
    },
    "/node/services/syslog?action=stop": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the syslog service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the syslog service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateSyslogServiceActionStop"
      }
    },
    "/ipfix-obs-points": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IpfixObsPointsListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get the list of IPFIX observation points",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Get the list of IPFIX observation points",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetIpfixObsPoints"
      }
    },
    "/network-encryption/sections/{section-id}/rules?action=create_multiple": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/DneRuleList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Add multiple rules to a network encryption section",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/DneRuleList"
            },
            "required": true,
            "name": "DneRuleList",
            "in": "body"
          },
          {
            "in": "query",
            "description": "Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.",
            "required": false,
            "maxLength": 64,
            "type": "string",
            "name": "id"
          },
          {
            "enum": [
              "insert_top",
              "insert_bottom",
              "insert_after",
              "insert_before"
            ],
            "description": "Operation",
            "default": "insert_top",
            "required": true,
            "in": "query",
            "type": "string",
            "name": "operation"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Add multiple rules to a network encryption section",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddDneRulesInSectionCreate_multiple"
      }
    },
    "/trust-management/principal-identities": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/PrincipalIdentity"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Associates a principal's name with a certificate that is used to authenticate.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/PrincipalIdentity"
            },
            "required": true,
            "name": "PrincipalIdentity",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Register a name-certificate combination.",
        "consumes": [
          "application/json"
        ],
        "operationId": "RegisterPrincipalIdentity"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/PrincipalIdentityList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the list of principals registered with a certificate.",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Return the list of principal identities",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetPrincipalIdentities"
      }
    },
    "/bridge-clusters/{bridgecluster-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BridgeCluster"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies a existing bridge cluster. One of more transport nodes\ncan be added or removed from the bridge cluster using this API.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "bridgecluster-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/BridgeCluster"
            },
            "required": true,
            "name": "BridgeCluster",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Update a Bridge Cluster",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateBridgeCluster"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Removes the specified Bridge Cluster.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "bridgecluster-id",
            "in": "path"
          }
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Delete a Bridge Cluster",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteBridgeCluster"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BridgeCluster"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about a specified bridge cluster.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "bridgecluster-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Get Information about a bridge cluster",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetBridgeCluster"
      }
    },
    "/app-discovery/sessions/{session-id}/app-profiles": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AppProfileListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the application profiles that was part of the application discovery session |\nwhile it was started.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "session-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "App Discovery"
        ],
        "summary": "application profiles in this application discovery session",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetAppDiscoverySessionAppProfiles"
      }
    },
    "/compute-collection-transport-node-templates/{template-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ComputeCollectionTransportNodeTemplate"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update configuration of compute collection transportnode template.\nCompute_collection_id isn't allowed to be changed since it represents\nthe association between ComputeCollection and this template. This is\ndetermined when ComputeCollectionTransportNodeTemplate got created.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "template-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/ComputeCollectionTransportNodeTemplate"
            },
            "required": true,
            "name": "ComputeCollectionTransportNodeTemplate",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Update compute collection transportnode template",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateComputeCollectionTransportNodeTemplate"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ComputeCollectionTransportNodeTemplate"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns compute collection transportnode template by id",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "template-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Get compute collection transportnode template by id",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetComputeCollectionTransportNodeTemplate"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete the specified compute collection transport node template.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "template-id",
            "in": "path"
          }
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Delete a compute collection transport node template",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteComputeCollectionTransportNodeTemplate"
      }
    },
    "/logical-routers/{logical-router-id}/routing/bgp": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BgpConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies the BGP configuration on a specified TIER0 logical router.\nModifiable parameters include enabled, graceful_restart, as_number.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/BgpConfig"
            },
            "required": true,
            "name": "BgpConfig",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Update the BGP Configuration on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateBgpConfig"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BgpConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the BGP configuration on a specified logical\nrouter. Information includes whether or not the BGP configuration is\nenabled, the AS number, and whether or not graceful\nrestart is enabled.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Read the BGP Configuration on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadBgpConfig"
      }
    },
    "/node/services/manager?action=stop": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateProtonServiceActionStop"
      }
    },
    "/logical-switches/state": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalSwitchStateListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns a list of logical switches states that have realized state as provided\nas query parameter.\n",
        "parameters": [
          {
            "enum": [
              "PENDING",
              "IN_PROGRESS",
              "PARTIAL_SUCCESS",
              "SUCCESS"
            ],
            "description": "Realized state of logical switches",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "status"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "List logical switches by realized state",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListLogicalSwitchesByState"
      }
    },
    "/trust-management/crls": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/CrlList"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about all CRLs. For additional information, include the\n?details=true modifier at the end of the request URI.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "whether to expand the pem data and show all its details",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "details"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Return All Added CRLs",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetCrls"
      }
    },
    "/transport-zones/{zone-id}/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/HeatMapTransportZoneStatus"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get high-level summary of a transport zone",
        "parameters": [
          {
            "description": "ID of transport zone",
            "required": true,
            "type": "string",
            "name": "zone-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Get high-level summary of a transport zone",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetHeatmapTransportZoneStatus"
      }
    },
    "/dhcp/servers/{server-id}/leases": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DhcpLeases"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get lease info of a given dhcp server id. If a \"pool_id\" is specified,\nthe lease info of the pool are returned. If an \"address\" is specified,\nonly the lease info the this address is returned. The \"address\" can be\na single IP, an ip-range, or a mac address. \"pool_id\" and \"address\" are\nmutually excluded. Either a \"pool_id\" or an \"address\" can be provided,\nbut not both.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "server-id",
            "in": "path"
          },
          {
            "description": "can be an ip address, or an ip range, or a mac address",
            "required": false,
            "type": "string",
            "name": "address",
            "in": "query"
          },
          {
            "description": "The uuid of dhcp ip pool",
            "required": false,
            "type": "string",
            "name": "pool_id",
            "in": "query"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get lease info of a given dhcp server id",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetDhcpLeaseInfo"
      }
    },
    "/fabric/compute-managers/{compute-manager-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ComputeManager"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Updates a specified compute manager\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "compute-manager-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/ComputeManager"
            },
            "required": true,
            "name": "ComputeManager",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Update compute manager",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateComputeManager"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Unregisters a specified compute manager\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "compute-manager-id",
            "in": "path"
          }
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Unregister a compute manager",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteComputeManager"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ComputeManager"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about a specific compute manager",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "compute-manager-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Return compute manager Information",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadComputeManager"
      }
    },
    "/node/aaa/providers/vidm": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeAuthProviderVidmProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update AAA provider vIDM properties",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/NodeAuthProviderVidmProperties"
            },
            "required": true,
            "name": "NodeAuthProviderVidmProperties",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Update AAA provider vIDM properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateAuthProviderVidm"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeAuthProviderVidmProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read AAA provider vIDM properties",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read AAA provider vIDM properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadAuthProviderVidm"
      }
    },
    "/infra/services": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ServiceListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Paginated list of Services for infra.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "List Services for infra",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListServicesForTenant"
      }
    },
    "/ns-groups/unassociated-virtual-machines": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/UnassociatedVMListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get the list of all the virtual machines that are not a part of any existing NSGroup.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Display Name of the virtual machine",
            "required": false,
            "type": "string",
            "name": "display_name",
            "in": "query"
          },
          {
            "description": "External id of the virtual machine",
            "required": false,
            "type": "string",
            "name": "external_id",
            "in": "query"
          },
          {
            "description": "Id of the host where this vif is located",
            "required": false,
            "type": "string",
            "name": "host_id",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Get the list of all the virtual machines that are not a part of any existing NSGroup.",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetUnassociatedVirtualMachines"
      }
    },
    "/fabric/nodes/{node-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/Node"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies attributes of a fabric node (host or edge).\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/Node"
            },
            "required": true,
            "name": "Node",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Update a Node",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateNode"
      },
      "post": {
        "responses": {
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/Node"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "The supported fabric node actions are enter_maintenance_mode,\nexit_maintenance_mode for EdgeNode.\nThis API is deprecated, please call TransportNode maintenance mode API to\nupdate maintenance mode, refer to \"Update transport node maintenance mode\".\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          },
          {
            "description": "Supported fabric node actions",
            "enum": [
              "enter_maintenance_mode",
              "exit_maintenance_mode"
            ],
            "type": "string",
            "name": "action",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Perform an Action on Fabric Node",
        "consumes": [
          "application/json"
        ],
        "operationId": "PerformNodeAction"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/Node"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about a specific fabric node (host or edge).",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Return Node Information",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNode"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Removes a specified fabric node (host or edge).\nA fabric node may only be deleted when it is no longer referenced\nby a Transport Node. If unprepare_host option is specified, the\nhost will be deleted without uninstalling the NSX components from\nthe host.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          },
          {
            "description": "Delete a host without uninstalling NSX components",
            "default": true,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "unprepare_host"
          }
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Delete a Node",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteNode"
      }
    },
    "/logical-routers/{logical-router-id}/routing": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RoutingConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies the routing configuration for a specified logical router.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/RoutingConfig"
            },
            "required": true,
            "name": "RoutingConfig",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Update the Routing Configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateRoutingConfig"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RoutingConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the routing configuration for a specified logical router.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Read the Routing Configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadRoutingConfig"
      }
    },
    "/loadbalancer/monitors": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbMonitor"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a load balancer monitor.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/LbMonitor"
            },
            "required": true,
            "name": "LbMonitor",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Create a load balancer monitor",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateLoadBalancerMonitor"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbMonitorListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Retrieve a paginated list of load balancer monitors.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "enum": [
              "LbHttpMonitor",
              "LbHttpsMonitor",
              "LbIcmpMonitor",
              "LbTcpMonitor",
              "LbUdpMonitor",
              "LbPassiveMonitor",
              "LbActiveMonitor"
            ],
            "description": "monitor query type",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "type"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Retrieve a paginated list of load balancer monitors",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListLoadBalancerMonitors"
      }
    },
    "/fabric/nodes/{node-id}/network/interfaces/{interface-id}/stats": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeInterfaceStatisticsProperties"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "On the specified interface, returns the number of received (rx), transmitted\n(tx), and dropped packets; the number of bytes and errors received and\ntransmitted on the interface; and the number of detected collisions.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "node-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "interface-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Fabric"
        ],
        "summary": "Read the NSX Manager's Network Interface Statistics",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadFabricNodeInterfaceStatistics"
      }
    },
    "/mac-sets": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/MACSet"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a new MACSet that can group individual MAC addresses.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/MACSet"
            },
            "required": true,
            "name": "MACSet",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Create MACSet",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateMACSet"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/MACSetListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns paginated list of MACSets\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "List MACSets",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListMACSets"
      }
    },
    "/node/services": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServicePropertiesListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns a list of all services available on the NSX Manager applicance.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "List node services",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListNodeServices"
      }
    },
    "/trust-management/csrs/{csr-id}": {
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Removes a specified CSR. If a CSR is not used for verification, you can\ndelete it. Note that the CSR import and upload POST actions automatically\ndelete the associated CSR.\n",
        "parameters": [
          {
            "description": "ID of CSR to delete",
            "required": true,
            "type": "string",
            "name": "csr-id",
            "in": "path"
          }
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Delete a CSR",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteCsr"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/Csr"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the specified CSR.",
        "parameters": [
          {
            "description": "ID of CSR to read",
            "required": true,
            "type": "string",
            "name": "csr-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Show CSR Data for the Given CSR ID",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetCsr"
      }
    },
    "/pools/vtep-label-pools/{pool-id}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/VtepLabelPool"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the specified virtual tunnel endpoint label pool.\n",
        "parameters": [
          {
            "description": "Virtual tunnel endpoint label pool ID",
            "required": true,
            "type": "string",
            "name": "pool-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "Read a virtual tunnel endpoint label pool",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadVtepLabelPool"
      }
    },
    "/node?action=shutdown": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart or shutdown node",
        "operationId": "RestartOrShutdownNodeShutdown",
        "consumes": [
          "application/json"
        ],
        "description": "Restarts or shuts down the NSX Manager appliance."
      }
    },
    "/infra/domains/{domain-id}": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "If a domain with the domain-id is not already present, create a new\ndomain. If it already exists, update the domain including the nested\ngroups. This is a full replace\n",
        "parameters": [
          {
            "description": "Domain ID",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/Domain"
            },
            "required": true,
            "name": "Domain",
            "in": "body"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Create or update a domain",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateDomainForInfra"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/Domain"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read a domain.\n",
        "parameters": [
          {
            "description": "Domain ID",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Read domain",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadDomainForInfra"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete the domain along with all the entities contained by this domain.\nThe groups that are a part of this domain are also deleted along with\nthe domain.\n",
        "parameters": [
          {
            "description": "Domain ID",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Delete Domain and all the entities contained by this domain",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteDomain"
      }
    },
    "/logical-routers/{logical-router-id}/routing/advertisement": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AdvertisementConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies the route advertisement configuration on the specified logical router.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/AdvertisementConfig"
            },
            "required": true,
            "name": "AdvertisementConfig",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Update the Advertisement Configuration on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateAdvertisementConfig"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AdvertisementConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the routes to be advertised by the specified\nTIER1 logical router.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Read the Advertisement Configuration on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadAdvertisementConfig"
      }
    },
    "/services/{service-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalService"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies the specified logical router service. The resource_type parameter\nis required. The modifiable parameters depend on the service type.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/LogicalService"
            },
            "required": true,
            "name": "LogicalService",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Update a Logical Router Service",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateService"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalService"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the specified service.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Read a Logical Router Service",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadService"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes the specified logical router service.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          }
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Delete a Logical Router Service",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteService"
      }
    },
    "/upgrade/nodes": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeInfoListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get list of nodes across all types",
        "parameters": [
          {
            "description": "Component type based on which nodes will be filtered",
            "required": false,
            "type": "string",
            "name": "component_type",
            "in": "query"
          },
          {
            "description": "Component version based on which nodes will be filtered",
            "required": false,
            "type": "string",
            "name": "component_version",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Get list of nodes across all types",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetNodes"
      }
    },
    "/node/services/http/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read http service status",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read http service status",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadProxyServiceStatus"
      }
    },
    "/node/network/interfaces": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeNetworkInterfacePropertiesListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the number of interfaces on the NSX Manager appliance and detailed\ninformation about each interface. Interface information includes MTU,\nbroadcast and host IP addresses, link and admin status, MAC address, network\nmask, and the IP configuration method (static or DHCP).\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "List the NSX Manager's Network Interfaces",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListNodeInterfaces"
      }
    },
    "/infra/realized-state/enforcement-points": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RealizedEnforcementPointListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Paginated list of all enforcement points. Returns the populated enforcement points.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "List Enforcement Points",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListEnforcementPointRealizedStates"
      }
    },
    "/node/services/http?action=apply_certificate": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Applies a security certificate to the http service. In the POST request,\nthe CERTIFICATE_ID references a certificate created with the\n/api/v1/trust-management APIs. Issuing this request causes the http service\nto restart so that the service can begin using the new certificate. When the\nPOST request succeeds, it doesn't return a valid response. The request times\nout because of the restart.\n",
        "parameters": [
          {
            "description": "Certificate ID",
            "required": true,
            "type": "string",
            "name": "certificate_id",
            "in": "query"
          }
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Update http service certificate",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateProxyServiceApplyCertificateActionApply_certificate"
      }
    },
    "/node/services/search?action=stop": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the NSX Search service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the NSX Search service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateSearchServiceActionStop"
      }
    },
    "/logical-routers/{logical-router-id}/routing/bgp/neighbors/{id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BgpNeighbor"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a specific BGP Neighbor on a Logical Router\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/BgpNeighbor"
            },
            "required": true,
            "name": "BgpNeighbor",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Update a specific BGP Neighbor on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateBgpNeighbor"
      },
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BgpNeighbor"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Unset/Delete the password property on the specific BGP Neighbor.\nNo other property of the BgpNeighbor can be updated using this API\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "id",
            "in": "path"
          },
          {
            "enum": [
              "clear_password"
            ],
            "type": "string",
            "name": "action",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Unset/Delete password property on specific BGP Neighbor on Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "UnSetPasswordOnBgpNeighbor"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BgpNeighbor"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read a specific BGP Neighbor on a Logical Router\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Read a specific BGP Neighbor on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadBgpNeighbor"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a specific BGP Neighbor on a Logical Router\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "id",
            "in": "path"
          }
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Delete a specific BGP Neighbor on a Logical Router",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteBgpNeighbor"
      }
    },
    "/loadbalancer/services": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbService"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a load balancer service.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/LbService"
            },
            "required": true,
            "name": "LbService",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Create a load balancer service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateLoadBalancerService"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbServiceListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Retrieve a paginated list of load balancer services.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Retrieve a paginated list of load balancer services",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListLoadBalancerServices"
      }
    },
    "/node/users/{userid}/ssh-keys": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/SshKeyPropertiesListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "description": "Internal Server Error"
          }
        },
        "description": "Returns a list of all SSH keys from authorized_keys file for node user\n",
        "parameters": [
          {
            "description": "User id of the user",
            "required": true,
            "type": "string",
            "name": "userid",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "List SSH keys from authorized_keys file for node user",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListNodeUserSshKeys"
      }
    },
    "/infra/deployment-zones/{deployment-zone-id}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DeploymentZone"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read a Deployment Zone\n",
        "parameters": [
          {
            "description": "Deployment Zone id",
            "required": true,
            "type": "string",
            "name": "deployment-zone-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Read a DeploymentZone",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadDeploymentZoneInfra"
      }
    },
    "/app-discovery/sessions/{session-id}/ns-groups/{ns-group-id}/members": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AppDiscoveryVmInfoListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the vms in the ns-group of the application discovery session\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "session-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "ns-group-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "App Discovery"
        ],
        "summary": "vms in the ns-group of the application discovery session",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetAppDiscoverySessionNsGroupMembers"
      }
    },
    "/node/services/search?action=start": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the NSX Search service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the NSX Search service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateSearchServiceActionStart"
      }
    },
    "/ns-groups/{ns-group-id}/effective-logical-port-members": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/EffectiveMemberResourceListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns effective logical port members of the specified NSGroup.\n",
        "parameters": [
          {
            "description": "NSGroup Id",
            "required": true,
            "type": "string",
            "name": "ns-group-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Get Effective Logical Ports translated from the NSgroup",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetEffectiveLogicalPortMembers"
      }
    },
    "/node/services/search?action=restart": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the NSX Search service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the NSX Search service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateSearchServiceActionRestart"
      }
    },
    "/infra/realized-state/enforcement-points/{enforcement-point-name}/groups/nsgroups/{nsgroup-name}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RealizedNSGroup"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read a NSGroup and the complete tree underneath. Returns the\npopulated NSgroup object.\n",
        "parameters": [
          {
            "description": "Enforcement Point Name",
            "required": true,
            "type": "string",
            "name": "enforcement-point-name",
            "in": "path"
          },
          {
            "description": "Group Name",
            "required": true,
            "type": "string",
            "name": "nsgroup-name",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Read Group",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNSGroupRealizedState"
      }
    },
    "/network-encryption/config": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneGlobalConfig"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update the global configuration of network encryption service",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/DneGlobalConfig"
            },
            "required": true,
            "name": "DneGlobalConfig",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update the global configuration of network encryption service",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateDneGlobalConfig"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneGlobalConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get the global configuration of network encryption service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get the global configuration of network encryption service",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetDneGlobalConfig"
      }
    },
    "/infra/realized-state/enforcement-points/{enforcement-point-name}/mac-sets/mac-sets-nsxt": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RealizedMACSetListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Paginated list of all Realized MACSets\n",
        "parameters": [
          {
            "description": "Enforcement Point Name",
            "required": true,
            "type": "string",
            "name": "enforcement-point-name",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "List MACSets",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListMACSetRealizedStates"
      }
    },
    "/aaa/roles": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RoleListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get information about all roles",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Aaa"
        ],
        "summary": "Get information about all roles",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetAllRolesInfo"
      }
    },
    "/transport-zones/{zone-id}/transport-node-status-report": {
      "get": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a status report of transport nodes in a transport zone",
        "parameters": [
          {
            "description": "ID of transport zone",
            "required": true,
            "type": "string",
            "name": "zone-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "Transport node",
            "enum": [
              "UP",
              "DOWN",
              "DEGRADED"
            ],
            "type": "string",
            "name": "status",
            "in": "query"
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Creates a status report of transport nodes in a transport zone",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetTransportNodeReportForATransportZone"
      }
    },
    "/upgrade?action=upgrade_uc": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "description": "Internal Server Error"
          }
        },
        "tags": [
          "Upgrade"
        ],
        "summary": "Upgrade the upgrade coordinator.",
        "operationId": "TriggerUcUpgradeUpgrade_uc",
        "consumes": [
          "application/json"
        ],
        "description": "Upgrade the upgrade coordinator."
      }
    },
    "/app-discovery/app-profiles/{app-profile-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AppProfile"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update AppProfile\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "app-profile-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/AppProfile"
            },
            "required": true,
            "name": "AppProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "App Discovery"
        ],
        "summary": "Update AppProfile",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateAppProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AppProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns detail of the app profile\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "app-profile-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "App Discovery"
        ],
        "summary": "Returns detail of the app profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetAppProfileDetails"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes the specified AppProfile.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "app-profile-id",
            "in": "path"
          },
          {
            "default": false,
            "description": "Force delete the resource even if it is being used somewhere\n",
            "type": "boolean",
            "name": "force",
            "in": "query"
          }
        ],
        "tags": [
          "App Discovery"
        ],
        "summary": "Delete App Profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteAppProfile"
      }
    },
    "/logical-routers/{logical-router-id}/routing/bfd-config": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BfdConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies the BFD configuration for routing BFD peers. Note - the configuration |\n  changes apply only to those routing BFD peers for which the BFD configuration has |\n  not been overridden at Peer level.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/BfdConfig"
            },
            "required": true,
            "name": "BfdConfig",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Update the BFD Configuration for BFD peers for routing",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateRoutingBfdConfig"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BfdConfig"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the BFD configuration for all routing BFD peers. This will be inherited |\n  by all BFD peers for LogicalRouter unless overriden while configuring the Peer.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Read the Routing BFD Configuration",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadRoutingBfdConfig"
      }
    },
    "/logical-ports/{lport-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalPort"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies an existing logical switch port. Parameters that can be modified\ninclude attachment_type (LOGICALROUTER, VIF), admin_state (UP or DOWN),\nattachment id and switching_profile_ids. You cannot modify the logical_switch_id.\nIn other words, you cannot move an existing port from one switch to another switch.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "lport-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/LogicalPort"
            },
            "required": true,
            "name": "LogicalPort",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Update a Logical Port",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateLogicalPort"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalPort"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about a specified logical port.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "lport-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Get Information About a Logical Port",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalPort"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes the specified logical switch port. By default, if logical port has\nattachments, or it is added to any NSGroup, the deletion will be failed.\nOption detach could be used for deleting logical port forcibly.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "lport-id",
            "in": "path"
          },
          {
            "description": "force delete even if attached or referenced by a group",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "detach"
          }
        ],
        "tags": [
          "Logical Switching"
        ],
        "summary": "Delete a Logical Port",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteLogicalPort"
      }
    },
    "/csm/aws/vpcs/{vpc-id}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AwsVpc"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns Vpc information",
        "parameters": [
          {
            "description": "ID of the Vpc",
            "required": true,
            "type": "string",
            "name": "vpc-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Returns Vpc information",
        "consumes": [
          "application/json"
        ],
        "operationId": "AwsVpcInfo"
      }
    },
    "/network-encryption/sections/{section-id}/rules/{rule-id}/state": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneRuleState"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get the realized State of a network encryption rule",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "rule-id",
            "in": "path"
          },
          {
            "name": "barrier_id",
            "format": "int64",
            "required": false,
            "minimum": 0,
            "in": "query",
            "type": "integer"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get the realized State of a network encryption rule",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetDneRuleState"
      }
    },
    "/loadbalancer/services/{service-id}/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbServiceStatus"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the status of the given load balancer service.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get the status of the given load balancer service",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLoadBalancerServiceStatus"
      }
    },
    "/firewall/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FirewallStatusListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "List all firewall status for supported contexts",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "List all firewall status for supported contexts",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListFirewallStatus"
      }
    },
    "/node/services/install-upgrade?action=restart": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the NSX install-upgrade service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the NSX install-upgrade service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateRepositoryServiceActionRestart"
      }
    },
    "/service-profiles/{service-profile-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ServiceProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies the specified service profile. The PUT request must include the\nresource_type parameters. Modifiable parameters include description and\ndisplay_name. Other parameters might be modifiable, depending on the\nspecified service type.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "service-profile-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/ServiceProfile"
            },
            "required": true,
            "name": "ServiceProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Update a Service Profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateServiceProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ServiceProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the specified service profile.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "service-profile-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Read a Service Profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadServiceProfile"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes the specified service profile.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "service-profile-id",
            "in": "path"
          }
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Delete a Service Profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteServiceProfile"
      }
    },
    "/node/services/manager/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read service status",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read service status",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadProtonServiceStatus"
      }
    },
    "/ns-service-groups": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/NSServiceGroup"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a new NSServiceGroup which can contain NSServices.\nA given NSServiceGroup can contain either only ether type of NSServices\nor only non-ether type of NSServices, i.e. an NSServiceGroup cannot\ncontain a mix of both ether and non-ether types of NSServices.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/NSServiceGroup"
            },
            "required": true,
            "name": "NSServiceGroup",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Create NSServiceGroup",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateNSServiceGroup"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NSServiceGroupListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns paginated list of NSServiceGroups\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Fetch all default NSServiceGroups",
            "type": "boolean",
            "name": "default_service",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "List all NSServiceGroups",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListNSServiceGroups"
      }
    },
    "/loadbalancer/virtual-servers/{virtual-server-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbVirtualServer"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a load balancer virtual server.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "virtual-server-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/LbVirtualServer"
            },
            "required": true,
            "name": "LbVirtualServer",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update a load balancer virtual server",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateLoadBalancerVirtualServer"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a load balancer virtual server.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "virtual-server-id",
            "in": "path"
          },
          {
            "description": "Delete associated rules",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "delete_associated_rules"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Delete a load balancer virtual server",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteLoadBalancerVirtualServer"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbVirtualServer"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Retrieve a load balancer virtual server.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "virtual-server-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Retrieve a load balancer virtual server",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadLoadBalancerVirtualServer"
      }
    },
    "/node/services/liagent?action=restart": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the liagent service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the liagent service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateLiagentServiceActionRestart"
      }
    },
    "/transport-zones/transport-node-status-report": {
      "get": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a status report of transport nodes of all the transport zones",
        "parameters": [
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "Transport node",
            "enum": [
              "UP",
              "DOWN",
              "DEGRADED"
            ],
            "type": "string",
            "name": "status",
            "in": "query"
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Creates a status report of transport nodes of all the transport zones",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetTransportNodeReport"
      }
    },
    "/network-encryption/sections/{section-id}?action=update_with_rules": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneSectionRuleList"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "This API returns an error if the section does not have rules.\nWhen invoked on a large number of rules, this API is supported only at low\nrates of invocation (not more than 2 times per minute). The typical latency of\nthis API with about 1024 rules is about 15 seconds in a cluster setup. This\nAPI should not be invoked with large payloads at automation speeds.\n\nInstead, to update rule content, use:\nPUT /api/v1/network-enryption/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt;\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/DneSectionRuleList"
            },
            "required": true,
            "name": "DneSectionRuleList",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update a network encryption section and its rules",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateDneSectionWithRulesUpdate_with_rules"
      }
    },
    "/network-encryption/sections/{section-id}/rules/{rule-id}/stats": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneRuleStats"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get the statistics for a network encryption rule",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "section-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "rule-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get the statistics for a network encryption rule",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetDneRuleStats"
      }
    },
    "/node/services/nsx-message-bus": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read NSX Message Bus service properties",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read NSX Message Bus service properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNSXMessageBusService"
      }
    },
    "/csm/aws/subnets": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AwsSubnetListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns a list of subnets",
        "parameters": [
          {
            "description": "Identifier for account based on which subnets are to be filtered",
            "required": true,
            "type": "string",
            "name": "account_id",
            "in": "query"
          },
          {
            "description": "Identifier for availability zone based on which subnets are to be filtered",
            "required": true,
            "type": "string",
            "name": "availability_zone_name",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "Identifier for region based on which subnets are to be filtered",
            "required": true,
            "type": "string",
            "name": "region_name",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "Identifier for vpc based on which subnets are to be filtered",
            "required": true,
            "type": "string",
            "name": "vpc_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Returns a list of subnets",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListAwsSubnets"
      }
    },
    "/ns-groups": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/NSGroup"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a new NSGroup that can group NSX resources - VIFs, Lports\nand LSwitches as well as the grouping objects - IPSet, MACSet and other\nNSGroups\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/NSGroup"
            },
            "required": true,
            "name": "NSGroup",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "Create NSGroup",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateNSGroup"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NSGroupListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "List the NSGroups in a paginated format. The page size is restricted\nto 50 NSGroups so that the size of the response remains small even\nin the worst case.\nOptionally, specify valid member types as request parameter to filter NSGroups.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Specify member types to filter corresponding NSGroups\n",
            "required": false,
            "type": "string",
            "name": "member_types",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "default": false,
            "description": "Populate metadata of resource referenced by NSGroupExpressions\n",
            "type": "boolean",
            "name": "populate_references",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Grouping Objects"
        ],
        "summary": "List NSGroups",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListNSGroups"
      }
    },
    "/infra/domains/{domain-id}/domain-deployment-maps": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DomainDeploymentMapListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Paginated list of all Domain Deployment Entries for infra.\n",
        "parameters": [
          {
            "description": "Domain ID",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "List Domain Deployment maps for infra",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListDomainDeploymentMapsForInfra"
      }
    },
    "/csm/aws/gateways": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AwsGatewaysListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns configuration information for all gateways",
        "parameters": [
          {
            "description": "Identifier for account based on which Aws gateways list can to be filtered",
            "required": false,
            "type": "string",
            "name": "account_id",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "Identifier for region based on which Aws Gateways list can to be filtered",
            "required": false,
            "type": "string",
            "name": "region_id",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "Identifier for vpc based on which Aws Gateways list can to be filtered",
            "required": false,
            "type": "string",
            "name": "vpc_id",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Returns configuration information for all gateways",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListAwsGateways"
      }
    },
    "/pools/ip-pools/{pool-id}/allocations": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AllocationIpAddressListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about which addresses have been allocated from a\nspecified IP address pool.\n",
        "parameters": [
          {
            "description": "IP pool ID",
            "required": true,
            "type": "string",
            "name": "pool-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Pool Management"
        ],
        "summary": "List IP Pool Allocations",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListIpPoolAllocations"
      }
    },
    "/bridge-endpoints/{endpoint-id}/statistics": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/BridgeEndpointStatistics"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get the statistics for the Bridge Endpoint of the given Endpoint id (endpoint-id)",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "endpoint-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Returns statistics of a specified Bridge Endpoint",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetBridgeEndpointStatistics"
      }
    },
    "/loadbalancer/persistence-profiles/{persistence-profile-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbPersistenceProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a load balancer persistence profile.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "persistence-profile-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/LbPersistenceProfile"
            },
            "required": true,
            "name": "LbPersistenceProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Update a load balancer persistence profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateLoadBalancerPersistenceProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbPersistenceProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Retrieve a load balancer persistence profile.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "persistence-profile-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Retrieve a load balancer persistence profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadLoadBalancerPersistenceProfile"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a load balancer persistence profile.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "persistence-profile-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Delete a load balancer persistence profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteLoadBalancerPersistenceProfile"
      }
    },
    "/infra/realized-state/enforcement-points/{enforcement-point-name}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RealizedEnforcementPoint"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read a Enforcement Point and the complete tree underneath. Returns the populated enforcement point object.\n",
        "parameters": [
          {
            "description": "Enforcement Point Name",
            "required": true,
            "type": "string",
            "name": "enforcement-point-name",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Read Enforcement Point",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadEnforcementPointRealizedState"
      }
    },
    "/node/services/install-upgrade?action=stop": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the NSX install-upgrade service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the NSX install-upgrade service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateRepositoryServiceActionStop"
      }
    },
    "/aaa/vidm/search": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/VidmInfoListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get all the users and groups from vIDM matching the search key case insensitively. The search key is checked to be a substring of name or given name or family name of user and display name of group.",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "Search string to search for.\n",
            "required": true,
            "type": "string",
            "name": "search_string",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Aaa"
        ],
        "summary": "Get all the users and groups from vIDM matching the search key case insensitively. The search key is checked to be a substring of name or given name or family name of user and display name of group.",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetVidmSearchResult"
      }
    },
    "/logical-router-ports/{logical-router-port-id}/arp-table?format=csv": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalRouterPortArpTableInCsvFormat"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns ARP table in CSV format for the Logical Router Port of the given id, on a\nnode if a query parameter \"transport_node_id=<transport-node-id>\" is given. The\ntransport_node_id parameter is mandatory if the router port is not uplink type.\nThe query parameter \"source=cached\" is not supported.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-port-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "TransportNode Id",
            "required": false,
            "type": "string",
            "name": "transport_node_id",
            "in": "query"
          }
        ],
        "produces": [
          "text/csv"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Get the ARP table for the Logical Router Port of the given id",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLogicalRouterPortArpTableInCsvFormatCsv"
      }
    },
    "/infra/domains/{domain-id}/communication-map/communication-entries/{communication-entry-id}": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update the CommunicationEntry. If a CommunicationEntry with the communication-entry-id\nis not already present, this API fails with a 404. Creation of CommunicationEntries\nis not allowed using this API.\n",
        "parameters": [
          {
            "description": "Domain ID",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          },
          {
            "description": "CommunicationEntry ID",
            "required": true,
            "type": "string",
            "name": "communication-entry-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/CommunicationEntry"
            },
            "required": true,
            "name": "CommunicationEntry",
            "in": "body"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Create or update a CommunicationEntry",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateCommunicationEntry"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete CommunicationEntry",
        "parameters": [
          {
            "description": "Domain ID",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          },
          {
            "description": "CommunicationEntry ID",
            "required": true,
            "type": "string",
            "name": "communication-entry-id",
            "in": "path"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Delete CommunicationEntry",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteCommunicationEntry"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/CommunicationEntry"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read CommunicationEntry",
        "parameters": [
          {
            "description": "Domain ID",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          },
          {
            "description": "CommunicationEntry ID",
            "required": true,
            "type": "string",
            "name": "communication-entry-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Read CommunicationEntry",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadCommunicationEntry"
      }
    },
    "/mirror-sessions/{mirror-session-id}?action=verify": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Verify whether all participants are on the same transport node",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "mirror-session-id",
            "in": "path"
          }
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Verify whether the mirror session is still valid",
        "consumes": [
          "application/json"
        ],
        "operationId": "VerifyPortMirroringSessionVerify"
      }
    },
    "/node/services/nsx-upgrade-agent?action=stop": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the NSX upgrade agent service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the NSX upgrade agent service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateNsxUpgradeAgentServiceActionStop"
      }
    },
    "/upgrade/history": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/UpgradeHistoryList"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get upgrade history",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Get upgrade history",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetUpgradeHistory"
      }
    },
    "/hpm/features": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FeatureStackCollectionConfigurationList"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "List all health performance monitoring feature stacks",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Aggregation Service"
        ],
        "summary": "List all health performance monitoring feature stacks",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListFeatureStackConfigurations"
      }
    },
    "/transportzone-profiles/{transportzone-profile-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TransportZoneProfile"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies a specified transport zone profile. The body of the PUT request must include the resource_type.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "transportzone-profile-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/TransportZoneProfile"
            },
            "required": true,
            "name": "TransportZoneProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Update a transport zone profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateTransportZoneProfile"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes a specified transport zone profile.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "transportzone-profile-id",
            "in": "path"
          }
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Delete a transport zone Profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteTransportZoneProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TransportZoneProfile"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about a specified transport zone profile.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "transportzone-profile-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Get transport zone profile by identifier",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetTransportZoneProfile"
      }
    },
    "/app-discovery/sessions": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/AppDiscoverySession"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Starts the discovery of application discovery session\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/StartAppDiscoverySessionParameters"
            },
            "required": true,
            "name": "StartAppDiscoverySessionParameters",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "App Discovery"
        ],
        "summary": "Starts the discovery of application discovery session",
        "consumes": [
          "application/json"
        ],
        "operationId": "StartAppDiscoverySession"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AppDiscoverySessionsListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the list of the application discovery sessions available\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "NSGroup id, helps user query sessions related to one nsgroup",
            "required": false,
            "type": "string",
            "name": "group_id",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "enum": [
              "STARTING",
              "FAILED",
              "RUNNING",
              "FINISHED"
            ],
            "description": "Session Status, e.g. get all running sessions",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "status"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "App Discovery"
        ],
        "summary": "Returns the list of the application discovery sessions available",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetAppDiscoverySessions"
      }
    },
    "/logical-router-ports/{logical-router-port-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalRouterPort"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies the specified logical router port. Required parameters include the\nresource_type and logical_router_id. Modifiable parameters include the\nresource_type (LogicalRouterUpLinkPort, LogicalRouterDownLinkPort,\nLogicalRouterLinkPort, LogicalRouterLoopbackPort), logical_router_id\n(to reassign the port to a different router), and service_bindings.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-port-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/LogicalRouterPort"
            },
            "required": true,
            "name": "LogicalRouterPort",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Update a Logical Router Port",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateLogicalRouterPort"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LogicalRouterPort"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the specified logical router port.",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-port-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Read Logical Router Port",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadLogicalRouterPort"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Deletes the specified logical router port. You must delete logical router\nports before you can delete the associated logical router. To Delete Tier0\nrouter link port you must have to delete attached tier1 router link port,\notherwise pass \"force=true\" as query param to force delete the Tier0\nrouter link port.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-port-id",
            "in": "path"
          },
          {
            "default": false,
            "description": "Force delete the resource even if it is being used somewhere\n",
            "type": "boolean",
            "name": "force",
            "in": "query"
          }
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Delete a Logical Router Port",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteLogicalRouterPort"
      }
    },
    "/logical-routers/{logical-router-id}/nat/rules/{rule-id}": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NatRule"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update a specific NAT rule from a given logical router.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "rule-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/NatRule"
            },
            "required": true,
            "name": "NatRule",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Update a specific NAT rule from a given logical router",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateNatRule"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NatRule"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get a specific NAT rule from a given logical router\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "rule-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Get a specific NAT rule from a given logical router",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetNatRule"
      },
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete a specific NAT rule from a logical router\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "rule-id",
            "in": "path"
          }
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Delete a specific NAT rule from a logical router",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteNatRule"
      }
    },
    "/network-encryption/key-policies/{keypolicy-id}/rules": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DneRuleListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get all network encryption rules attached to a specific key policy",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "keypolicy-id",
            "in": "path"
          },
          {
            "description": "AppliedTo's  referenced by this section or section's DNE Rules .",
            "required": false,
            "type": "string",
            "name": "applied_tos",
            "in": "query"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Destinations referenced by this section's DNE Rules .",
            "required": false,
            "type": "string",
            "name": "destinations",
            "in": "query"
          },
          {
            "enum": [
              "FILTER",
              "SEARCH"
            ],
            "description": "Filter type",
            "default": "FILTER",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "filter_type"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "key policy identifier",
            "required": false,
            "type": "string",
            "name": "key_policy_id",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "NSService referenced by this section's DNE Rules .",
            "required": false,
            "type": "string",
            "name": "services",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "Sources referenced by this section's DNE Rules .",
            "required": false,
            "type": "string",
            "name": "sources",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get all network encryption rules attached to a specific key policy",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetDneRulesByKeyPolicy"
      }
    },
    "/logical-routers/{logical-router-id}/nat/rules": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/NatRule"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Add a NAT rule in a specific logical router.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/NatRule"
            },
            "required": true,
            "name": "NatRule",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "Add a NAT rule in a specific logical router",
        "consumes": [
          "application/json"
        ],
        "operationId": "AddNatRule"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NatRuleListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns paginated list of all user defined NAT rules of the specific logical router\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "logical-router-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Logical Routing And Services"
        ],
        "summary": "List NAT rules of the logical router",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListNatRules"
      }
    },
    "/node/hardening-policy/mandatory-access-control": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/MandatoryAccessControlProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Enable or disable  Mandatory Access Control",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/MandatoryAccessControlProperties"
            },
            "required": true,
            "name": "MandatoryAccessControlProperties",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Enable or disable  Mandatory Access Control",
        "consumes": [
          "application/json"
        ],
        "operationId": "SetNodeMandatoryAccessControl"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/MandatoryAccessControlProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Gets the enable status for Mandatory Access Control",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Gets the enable status for Mandatory Access Control",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetNodeMandatoryAccessControl"
      }
    },
    "/infra/domains": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DomainListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Paginated list of all domains for infra.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "List domains for infra",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListDomainForInfra"
      }
    },
    "/node": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Modifies NSX Manager appliance properties. Modifiable properties include the\ntimezone, message of the day (motd), and hostname. The NSX Manager\nnode_version, system_time, and kernel_version are read only and cannot be\nmodified with this method.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/NodeProperties"
            },
            "required": true,
            "name": "NodeProperties",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Update node properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateNodeProperties"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the NSX Manager appliance. Information includes\nrelease number, time zone, system time, kernel version, message of the day\n(motd), and host name.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read node properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNodeProperties"
      }
    },
    "/upgrade/plan/{component_type}/settings": {
      "put": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/UpgradePlanSettings"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "description": "Bad Request"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update the upgrade plan settings for the component.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "component_type",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/UpgradePlanSettings"
            },
            "required": true,
            "name": "UpgradePlanSettings",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Update upgrade plan settings for the component",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateUpgradePlanSettings"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/UpgradePlanSettings"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get the upgrade plan settings for the component.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "component_type",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Get upgrade plan settings for the component",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetUpgradePlanSettings"
      }
    },
    "/loadbalancer/services/{service-id}/pools/{pool-id}/statistics": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbPoolStatistics"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns the statistics of the given load balancer pool by given load balancer\nserives id and load balancer pool id.\n",
        "parameters": [
          {
            "required": true,
            "type": "string",
            "name": "service-id",
            "in": "path"
          },
          {
            "required": true,
            "type": "string",
            "name": "pool-id",
            "in": "path"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Get the statistics of load balancer pool",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetLoadBalancerPoolStatistics"
      }
    },
    "/node/services/http": {
      "put": {
        "responses": {
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/NodeHttpServiceProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update http service properties",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/NodeHttpServiceProperties"
            },
            "required": true,
            "name": "NodeHttpServiceProperties",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Update http service properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateProxyService"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeHttpServiceProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read http service properties",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read http service properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadProxyService"
      }
    },
    "/upgrade/eula/acceptance": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/EULAAcceptance"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Return the acceptance status of end user license agreement\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Licensing"
        ],
        "summary": "Return the acceptance status of end user license agreement\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetUpgradeEULAAcceptance"
      }
    },
    "/infra/domains/{domain-id}/communication-map": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Update the communication map for a domain. This is a full replace.\nAll the CommunicationEntries are replaced.\n",
        "parameters": [
          {
            "description": "Domain ID",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/CommunicationMap"
            },
            "required": true,
            "name": "CommunicationMap",
            "in": "body"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Update communication map",
        "consumes": [
          "application/json"
        ],
        "operationId": "UpdateCommunicationMapForDomain"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/CommunicationMap"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read communication-map for a domain.\n",
        "parameters": [
          {
            "description": "Domain ID",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Read communication-map",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadCommunicationMapForDomain"
      }
    },
    "/transport-nodes/state": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TransportNodeStateListResult"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns a list of transport node states that have realized state as provided\nas query parameter\n",
        "parameters": [
          {
            "enum": [
              "ENTERING",
              "ENABLED",
              "EXITING",
              "DISABLED"
            ],
            "description": "maintenance mode state",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "mm_state"
          },
          {
            "enum": [
              "PENDING",
              "IN_PROGRESS",
              "SUCCESS",
              "PARTIAL_SUCCESS",
              "FAILED",
              "ORPHANED"
            ],
            "description": "Realized state of transport nodes",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "status"
          },
          {
            "description": "Virtual tunnel endpoint ip address of transport node",
            "required": false,
            "type": "string",
            "name": "vtep_ip",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "List transport nodes by realized state",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListTransportNodesByState"
      }
    },
    "/node/processes/{process-id}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeProcessProperties"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information for a specified process ID (pid).",
        "parameters": [
          {
            "description": "ID of process to read",
            "required": true,
            "type": "string",
            "name": "process-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read node process",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadNodeProcess"
      }
    },
    "/node/services/liagent?action=start": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceStatusProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Restart, start or stop the liagent service",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Restart, start or stop the liagent service",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateLiagentServiceActionStart"
      }
    },
    "/upgrade/plan?action=reset": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Reset the upgrade plan to default plan. User has an option to change\nthe default plan. But if after making changes, user wants to go\nback to the default plan, this is the way to do so.\n",
        "parameters": [
          {
            "description": "Component type",
            "required": true,
            "type": "string",
            "name": "component_type",
            "in": "query"
          }
        ],
        "tags": [
          "Upgrade"
        ],
        "summary": "Reset upgrade plan to default plan",
        "consumes": [
          "application/json"
        ],
        "operationId": "ResetUpgradePlanReset"
      }
    },
    "/tasks/{task-id}/response": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object"
            }
          },
          "303": {
            "description": "See Other",
            "schema": {
              "type": "object"
            }
          },
          "404": {
            "description": "Not Found"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get the response of a task",
        "parameters": [
          {
            "description": "ID of task to read",
            "required": true,
            "type": "string",
            "name": "task-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Api Services"
        ],
        "summary": "Get the response of a task",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadTaskResult"
      }
    },
    "/aaa/registration-token/{token}": {
      "delete": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Delete registration access token",
        "parameters": [
          {
            "description": "Registration token",
            "required": true,
            "type": "string",
            "name": "token",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Aaa"
        ],
        "summary": "Delete registration access token",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeleteRegistrationToken"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RegistrationToken"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get registration access token",
        "parameters": [
          {
            "description": "Registration token",
            "required": true,
            "type": "string",
            "name": "token",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Aaa"
        ],
        "summary": "Get registration access token",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetRegistrationToken"
      }
    },
    "/node/services/mgmt-plane-bus": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeServiceProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read Rabbit MQ service properties",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Read Rabbit MQ service properties",
        "consumes": [
          "application/json"
        ],
        "operationId": "ReadRabbitMQService"
      }
    },
    "/templates/{template-id}?action=deploy": {
      "post": {
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read a template, populate the placeholders' fields with the parameters' values, and deploy the template\nbody by creating or updating all the nested policy objects inside the AbstractSpace object.\n",
        "parameters": [
          {
            "description": "Template identifier",
            "required": true,
            "type": "string",
            "name": "template-id",
            "in": "path"
          },
          {
            "schema": {
              "$ref": "#/definitions/PolicyTemplateParameters"
            },
            "required": true,
            "name": "PolicyTemplateParameters",
            "in": "body"
          }
        ],
        "tags": [
          "Policy"
        ],
        "summary": "Deploy template.",
        "consumes": [
          "application/json"
        ],
        "operationId": "DeployTemplateDeploy"
      }
    },
    "/loadbalancer/virtual-servers": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbVirtualServer"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Create a load balancer virtual server.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/LbVirtualServer"
            },
            "required": true,
            "name": "LbVirtualServer",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Create a load balancer virtual server",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateLoadBalancerVirtualServer"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LbVirtualServerListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Retrieve a paginated list of load balancer virtual servers.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Services"
        ],
        "summary": "Retrieve a paginated list of load balancer virtual servers",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListLoadBalancerVirtualServers"
      }
    },
    "/transport-zones/transport-node-status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TransportNodeStatusListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Read status of all the transport nodes",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "enum": [
              "realtime",
              "cached"
            ],
            "description": "Data source type.",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "source"
          },
          {
            "description": "Transport node",
            "enum": [
              "UP",
              "DOWN",
              "DEGRADED",
              "UNKNOWN"
            ],
            "type": "string",
            "name": "status",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Troubleshooting And Monitoring"
        ],
        "summary": "Read status of all the transport nodes",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListTransportNodeStatus"
      }
    },
    "/node/network/routes": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/NodeRouteProperties"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "409": {
            "description": "Conflict"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Add a route to the NSX Manager routing table. For static routes, the\nroute_type, interface_id, netmask, and destination are required parameters.\nFor default routes, the route_type, gateway address, and interface_id\nare required. For blackhole routes, the route_type and destination are\nrequired. All other parameters are optional. When you add a static route,\nthe scope and route_id are created automatically. When you add a default or\nblackhole route, the route_id is created automatically. The route_id is\nread-only, meaning that it cannot be modified. All other properties can be\nmodified by deleting and readding the route.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/NodeRouteProperties"
            },
            "required": true,
            "name": "NodeRouteProperties",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "Create node network route",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateNodeNetworkRoute"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NodeRoutePropertiesListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns detailed information about each route in the NSX Manager routing\ntable. Route information includes the route type (default, static, and so\non), a unique route identifier, the route metric, the protocol from which\nthe route was learned, the route source (which is the preferred egress\ninterface), the route destination, and the route scope. The route scope\nrefers to the distance to the destination network: The \"host\" scope leads to\na destination address on the NSX Manager, such as a loopback address;\nthe \"link\" scope leads to a destination on the local network; and the\n\"global\" scope leads to addresses that are more than one hop away.\n",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Nsx Component Administration"
        ],
        "summary": "List node network routes",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListNodeNetworkRoutes"
      }
    },
    "/csm/aws/accounts/{account-id}/status": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AwsAccountStatus"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Return status of the account like credentails validity, inventory\nsynchronization status and inventory synchronization state\n",
        "parameters": [
          {
            "description": "ID of AWS account",
            "required": true,
            "type": "string",
            "name": "account-id",
            "in": "path"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Cloud Service Manager"
        ],
        "summary": "Return status of the account like credentails validity, inventory\nsynchronization status and inventory synchronization state\n",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetAwsAccountStatus"
      }
    },
    "/transportzone-profiles": {
      "post": {
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/TransportZoneProfile"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Creates a transport zone profile. The resource_type is required.\n",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/TransportZoneProfile"
            },
            "required": true,
            "name": "TransportZoneProfile",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "Create a transport zone Profile",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateTransportZoneProfile"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TransportZoneProfileListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Returns information about the configured transport zone profiles. Transport zone\nprofiles define networking policies for transport zones and transport zone endpoints.\n",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Whether the list result contains system resources",
            "default": false,
            "required": false,
            "in": "query",
            "type": "boolean",
            "name": "include_system_owned"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "description": "comma-separated list of transport zone profile types, e.g. ?resource_type=BfdHealthMonitoringProfile",
            "required": false,
            "type": "string",
            "name": "resource_type",
            "in": "query"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Network Transport"
        ],
        "summary": "List transport zone profiles",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListTransportZoneProfiles"
      }
    },
    "/infra/domains/{domain-id}/groups": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/GroupListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "List Groups for a domain",
        "parameters": [
          {
            "description": "Domain ID",
            "required": true,
            "type": "string",
            "name": "domain-id",
            "in": "path"
          },
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Policy"
        ],
        "summary": "List Groups for a domain",
        "consumes": [
          "application/json"
        ],
        "operationId": "ListGroupForDomain"
      }
    },
    "/aaa/role-bindings": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RoleBinding"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Assign roles to User or Group",
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RoleBinding"
            },
            "required": true,
            "name": "RoleBinding",
            "in": "body"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Aaa"
        ],
        "summary": "Assign roles to User or Group",
        "consumes": [
          "application/json"
        ],
        "operationId": "CreateRoleBinding"
      },
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/RoleBindingListResult"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "403": {
            "$ref": "#/responses/Forbidden"
          },
          "412": {
            "$ref": "#/responses/PreconditionFailed"
          },
          "400": {
            "$ref": "#/responses/BadRequest"
          },
          "503": {
            "$ref": "#/responses/ServiceUnavailable"
          },
          "500": {
            "$ref": "#/responses/InternalServerError"
          }
        },
        "description": "Get all users and groups with their roles",
        "parameters": [
          {
            "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
            "type": "string",
            "name": "cursor",
            "in": "query"
          },
          {
            "description": "Comma separated list of fields that should be included to result of query",
            "type": "string",
            "name": "included_fields",
            "in": "query"
          },
          {
            "description": "User/Group name",
            "required": false,
            "type": "string",
            "name": "name",
            "in": "query"
          },
          {
            "description": "Maximum number of results to return in this page (server may return fewer)",
            "format": "int64",
            "default": 1000,
            "maximum": 1000,
            "minimum": 0,
            "in": "query",
            "type": "integer",
            "name": "page_size"
          },
          {
            "type": "boolean",
            "name": "sort_ascending",
            "in": "query"
          },
          {
            "description": "Field by which records are sorted",
            "type": "string",
            "name": "sort_by",
            "in": "query"
          },
          {
            "enum": [
              "remote_user",
              "remote_group"
            ],
            "description": "Type",
            "required": false,
            "in": "query",
            "type": "string",
            "name": "type"
          }
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Aaa"
        ],
        "summary": "Get all users and groups with their roles",
        "consumes": [
          "application/json"
        ],
        "operationId": "GetAllRoleBindings"
      }
    }
  },
  "definitions": {
    "LogicalRouterPortArpEntry": {
      "required": [
        "ip",
        "mac_address"
      ],
      "type": "object",
      "properties": {
        "ip": {
          "format": "ip",
          "type": "string",
          "description": "The IP address"
        },
        "mac_address": {
          "type": "string",
          "description": "The MAC address",
          "title": "The MAC address"
        }
      }
    },
    "ComputeCollectionFabricTemplate": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "compute_collection_id": {
              "type": "string",
              "description": "Associated compute collection id",
              "title": "Associated compute collection id"
            },
            "auto_install_nsx": {
              "type": "boolean",
              "description": "Indicates whether NSX components should be automcatically installed. When 'true' NSX components will be automatically installed on the new host added to compute collection.",
              "title": "Flag to enable/disable automatic install of NSX components"
            }
          },
          "required": [
            "compute_collection_id",
            "auto_install_nsx"
          ],
          "type": "object"
        }
      ],
      "description": "Compute collection fabric template",
      "title": "Compute collection fabric template"
    },
    "BackupSchedule": {
      "description": "Abstract base type for Weekly or Interval Backup Schedule",
      "title": "Abstract base type for Weekly or Interval Backup Schedule",
      "required": [
        "resource_type"
      ],
      "discriminator": "resource_type",
      "type": "object",
      "properties": {
        "resource_type": {
          "enum": [
            "WeeklyBackupSchedule",
            "IntervalBackupSchedule"
          ],
          "type": "string"
        }
      }
    },
    "EtherTypeNSService": {
      "allOf": [
        {
          "$ref": "#/definitions/NSServiceElement"
        },
        {
          "properties": {
            "ether_type": {
              "format": "int64",
              "type": "integer",
              "description": "Type of the encapsulated protocol",
              "title": "Type of the encapsulated protocol"
            }
          },
          "required": [
            "ether_type"
          ],
          "type": "object"
        }
      ],
      "description": "An NSService element that represents an ethertype protocol",
      "title": "An NSService element that represents an ethertype protocol"
    },
    "ManagedResource": {
      "allOf": [
        {
          "$ref": "#/definitions/RevisionedResource"
        },
        {
          "type": "object",
          "properties": {
            "_system_owned": {
              "readOnly": true,
              "type": "boolean",
              "description": "Indicates system owned resource"
            },
            "display_name": {
              "maxLength": 255,
              "type": "string",
              "description": "Defaults to ID if not set",
              "title": "Identifier to use when displaying entity in logs or GUI"
            },
            "description": {
              "maxLength": 1024,
              "type": "string",
              "description": "Description of this resource",
              "title": "Description of this resource"
            },
            "tags": {
              "items": {
                "$ref": "#/definitions/Tag"
              },
              "type": "array",
              "description": "Opaque identifiers meaningful to the API user",
              "maxItems": 15,
              "title": "Opaque identifiers meaningful to the API user"
            },
            "_create_user": {
              "readOnly": true,
              "type": "string",
              "description": "ID of the user who created this resource"
            },
            "_protection": {
              "readOnly": true,
              "type": "string",
              "description": "Protection status is one of the following:\nPROTECTED - the client who retrieved the entity is not allowed\n            to modify it.\nNOT_PROTECTED - the client who retrieved the entity is allowed\n                to modify it\nREQUIRE_OVERRIDE - the client who retrieved the entity is a super\n                   user and can modify it, but only when providing\n                   the request header X-Allow-Overwrite=true.\nUNKNOWN - the _protection field could not be determined for this\n          entity.\n",
              "title": "Indicates protection status of this resource"
            },
            "_create_time": {
              "readOnly": true,
              "type": "integer",
              "description": "Timestamp of resource creation",
              "format": "int64"
            },
            "_last_modified_time": {
              "readOnly": true,
              "type": "integer",
              "description": "Timestamp of last modification",
              "format": "int64"
            },
            "_last_modified_user": {
              "readOnly": true,
              "type": "string",
              "description": "ID of the user who last modified this resource"
            },
            "id": {
              "readOnly": true,
              "type": "string",
              "description": "Unique identifier of this resource",
              "title": "Unique identifier of this resource"
            },
            "resource_type": {
              "readOnly": false,
              "type": "string",
              "description": "The type of this resource."
            }
          }
        }
      ]
    },
    "DNEServiceAssociationListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ServiceAssociationListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/DneRule"
              },
              "readOnly": true,
              "type": "array",
              "description": "DNE rule list result with pagination support.",
              "title": "DNE rule list result"
            }
          }
        }
      ]
    },
    "RealizedNSGroupMemberEvaluation": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyRealizedResource"
        },
        {
          "properties": {
            "logical_ports": {
              "items": {
                "$ref": "#/definitions/RealizedLogicalPort"
              },
              "readOnly": true,
              "type": "array",
              "description": "list of logical ports",
              "title": "list of logical ports"
            },
            "virtual_machines": {
              "items": {
                "$ref": "#/definitions/RealizedVirtualMachine"
              },
              "readOnly": true,
              "type": "array",
              "description": "list of virtual machines",
              "title": "list of virtual machines"
            },
            "logical_switches": {
              "items": {
                "$ref": "#/definitions/RealizedLogicalSwitch"
              },
              "readOnly": true,
              "type": "array",
              "description": "list of logical switches",
              "title": "list of logical switches"
            },
            "member_count": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Count of the members added to this NSGroup",
              "title": "Count of the members added to this NSGroup"
            }
          },
          "type": "object"
        }
      ],
      "description": "Realized NSGroup member evaluation",
      "title": "Realized NSGroup member evaluation"
    },
    "AppDiscoveryVmInfo": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "vm_name": {
              "type": "string",
              "description": "Name of the VM",
              "title": "Name of the VM"
            },
            "vm_external_id": {
              "type": "string",
              "description": "External Id of the VM",
              "title": "External Id of the VM"
            }
          },
          "type": "object"
        }
      ],
      "description": "AppDiscoveryVmInfo details",
      "title": "AppDiscoveryVmInfo details"
    },
    "TrustManagementData": {
      "type": "object",
      "properties": {
        "supported_algorithms": {
          "items": {
            "$ref": "#/definitions/CryptoAlgorithm"
          },
          "readOnly": true,
          "type": "array",
          "description": "list of supported algorithms"
        }
      }
    },
    "IpfixObsPointConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "idle_timeout": {
              "description": "The time in seconds after a Flow is expired if no more packets matching\nthis Flow are received by the cache.\n",
              "title": "Idle timeout",
              "default": 300,
              "format": "int32",
              "maximum": 3600,
              "minimum": 60,
              "type": "integer"
            },
            "observation_domain_id": {
              "description": "An identifier that is unique to the exporting process and used to\nmeter the Flows.\n",
              "title": "Observation domain ID",
              "default": 0,
              "format": "int64",
              "maximum": 4294967295,
              "minimum": 0,
              "type": "integer"
            },
            "collectors": {
              "items": {
                "$ref": "#/definitions/IpfixCollector"
              },
              "type": "array",
              "description": "List of IPFIX collectors",
              "title": "List of IPFIX collectors"
            },
            "active_timeout": {
              "description": "The time in seconds after a Flow is expired even if more packets\nmatching this Flow are received by the cache.\n",
              "title": "Active timeout",
              "default": 300,
              "format": "int32",
              "maximum": 3600,
              "minimum": 60,
              "type": "integer"
            },
            "packet_sample_probability": {
              "description": "The probability in percentage that a packet is sampled, in range\n0-100. The probability is equal for every packet.\n",
              "title": "Packet sample probability",
              "default": 0.1,
              "exclusiveMinimum": true,
              "maximum": 100,
              "minimum": 0,
              "type": "number"
            },
            "enabled": {
              "type": "boolean",
              "description": "Enabled status of IPFIX export",
              "title": "Enabled status of IPFIX export"
            },
            "max_flows": {
              "description": "The maximum number of flow entries in each exporter flow cache.\n",
              "title": "Max flows",
              "default": 16384,
              "format": "int64",
              "maximum": 4294967295,
              "minimum": 0,
              "type": "integer"
            }
          },
          "required": [
            "enabled"
          ],
          "type": "object"
        }
      ],
      "description": "Logical IPFIX observation point",
      "title": "Logical IPFIX observation point"
    },
    "CopyRemoteFileProperties": {
      "required": [
        "uri",
        "server"
      ],
      "type": "object",
      "properties": {
        "port": {
          "description": "Server port",
          "format": "int64",
          "title": "Server port",
          "maximum": 65535,
          "minimum": 1,
          "type": "integer"
        },
        "uri": {
          "type": "string",
          "description": "URI of file to copy",
          "title": "URI of file to copy"
        },
        "server": {
          "type": "string",
          "description": "Remote server hostname or IP address",
          "title": "Remote server hostname or IP address"
        }
      }
    },
    "Uplink": {
      "properties": {
        "uplink_name": {
          "type": "string",
          "description": "Name of this uplink",
          "title": "Name of this uplink"
        },
        "uplink_type": {
          "enum": [
            "PNIC",
            "LAG"
          ],
          "type": "string",
          "description": "Type of the uplink",
          "title": "Type of the uplink"
        }
      },
      "required": [
        "uplink_name",
        "uplink_type"
      ],
      "type": "object",
      "description": "Object to identify an uplink based on its type and name",
      "title": "Object to identify an uplink based on its type and name"
    },
    "StateSyncNode": {
      "type": "object",
      "properties": {
        "cluster_node_id": {
          "readOnly": true,
          "type": "string",
          "description": "Internal identifier provided by the node",
          "title": "Internal identifier provided by the node"
        },
        "api_listen_ip": {
          "readOnly": true,
          "type": "string",
          "description": "The IP and port for the public API service on this node",
          "title": "The IP and port for the public API service on this node"
        }
      }
    },
    "PolicyRoot": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "type": "object"
        }
      ],
      "description": "Represents the root of the policy tree",
      "title": "Represents the root of the policy tree"
    },
    "AggregateRequest": {
      "allOf": [
        {
          "$ref": "#/definitions/IncludedFieldsParameters"
        },
        {
          "properties": {
            "alias": {
              "type": "string",
              "description": "Alias for the response",
              "title": "Alias"
            },
            "filters": {
              "items": {
                "$ref": "#/definitions/FilterRequest"
              },
              "type": "array",
              "description": "An array of filter conditions",
              "title": "Filter conditions"
            },
            "resource_type": {
              "type": "string",
              "description": "Resource type name",
              "title": "Resource Type"
            }
          },
          "required": [
            "resource_type"
          ],
          "type": "object"
        }
      ],
      "description": "Common request parameters for the primary/related types",
      "title": "Aggregate request"
    },
    "PreconfiguredHostSwitch": {
      "properties": {
        "host_switch_id": {
          "readOnly": false,
          "type": "string",
          "description": "External Id of the preconfigured host switch.",
          "title": "External Id of the preconfigured host switch."
        },
        "endpoints": {
          "items": {
            "$ref": "#/definitions/PreconfiguredEndpoint"
          },
          "type": "array",
          "description": "List of virtual tunnel endpoints which are preconfigured on this host switch",
          "maxItems": 1,
          "title": "List of virtual tunnel endpoints which are preconfigured on this host switch"
        }
      },
      "required": [
        "host_switch_id"
      ],
      "type": "object",
      "description": "Preconfigured host switch is used for manually configured transport node.",
      "title": "Preconfigured host switch"
    },
    "RealizedServices": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyRealizedResource"
        },
        {
          "properties": {
            "realized_services": {
              "items": {
                "$ref": "#/definitions/RealizedService"
              },
              "readOnly": true,
              "type": "array",
              "description": "List of realized services",
              "title": "List of realized services"
            }
          },
          "type": "object"
        }
      ],
      "description": "Realized services",
      "title": "Realized services"
    },
    "RealizedNSService": {
      "allOf": [
        {
          "$ref": "#/definitions/RealizedService"
        },
        {
          "properties": {
            "service_type": {
              "readOnly": true,
              "enum": [
                "SERVICE",
                "SERVICE_GROUP"
              ],
              "type": "string",
              "description": "Realized nsservice type",
              "title": "Realized nsservice type"
            }
          },
          "type": "object"
        }
      ],
      "description": "Realized NSService",
      "title": "Realized NSService"
    },
    "AppDiscoveryAppProfileResultSummary": {
      "properties": {
        "app_profile_id": {
          "type": "string",
          "description": "ID of the App Profile",
          "title": "ID of the App Profile"
        },
        "display_name": {
          "type": "string",
          "description": "Name of the App Profile",
          "title": "Name of the App Profile"
        },
        "installed_apps_count": {
          "format": "int64",
          "type": "integer",
          "description": "Number of apps installed that belongs to this App Profile",
          "title": "Number of apps installed that belongs to this App Profile"
        }
      },
      "type": "object",
      "description": "Contains the application discovery result summary of the App Profile\n",
      "title": "Application discovery result summary of an App Profile"
    },
    "StandardHostSwitch": {
      "properties": {
        "pnics": {
          "items": {
            "$ref": "#/definitions/Pnic"
          },
          "type": "array",
          "description": "Physical NICs connected to the host switch",
          "title": "Physical NICs connected to the host switch"
        },
        "host_switch_name": {
          "default": "nsxDefaultHostSwitch",
          "type": "string",
          "description": "If this name is unset or empty then the default host switch name will be used. The name must be unique among all host switches specified in a given transport node; unset name, empty name and the default host switch name are considered the same in terms of uniqueness.",
          "title": "host switch name. This name will be used to reference this host switch."
        },
        "ip_assignment_spec": {
          "readOnly": false,
          "title": "Specification for IPs to be used with host switch virtual tunnel endpoints",
          "description": "IPs can come from either a static IP pool or an explicitly specified IP list or DHCP. In case a list of IP is specified, the number of IPs provided should be sufficient as per teaming policy associated with host switch uplink profile.",
          "$ref": "#/definitions/IpAssignmentSpec"
        },
        "cpu_config": {
          "items": {
            "$ref": "#/definitions/CpuCoreConfigForEnhancedNetworkingStackSwitch"
          },
          "readOnly": false,
          "type": "array",
          "description": "CPU configuration specifies number of Logical cpu cores (Lcores) per Non Uniform Memory Access (NUMA) node dedicated to Enhnaced Networking Stack enabled HostSwitch to get the best performance.",
          "title": "Enhanced Networking Stack enabled HostSwitch CPU configuration"
        },
        "host_switch_profile_ids": {
          "items": {
            "$ref": "#/definitions/HostSwitchProfileTypeIdEntry"
          },
          "type": "array",
          "description": "host switch profiles bound to this host switch. If a profile ID is not provided for any HostSwitchProfileType that is supported by the transport node, the corresponding default profile will be bound to the host switch.",
          "title": "Identifiers of host switch profiles to be associated with this host switch."
        }
      },
      "type": "object",
      "description": "Standard host switch specification",
      "title": "Standard host switch specification"
    },
    "OwnerResourceLink": {
      "allOf": [
        {
          "$ref": "#/definitions/ResourceLink"
        },
        {
          "type": "object"
        }
      ],
      "description": "The server will populate this field when returing the resource. Ignored on PUT and POST.",
      "title": "Link to this resource"
    },
    "PortConnectionRouter": {
      "allOf": [
        {
          "$ref": "#/definitions/PortConnectionEntity"
        },
        {
          "properties": {
            "uplink_ports": {
              "items": {
                "$ref": "#/definitions/LogicalRouterPort"
              },
              "readOnly": true,
              "type": "array",
              "description": "Uplink ports of the Logical Router.",
              "title": "Uplink ports of the Logical Router."
            },
            "downlink_ports": {
              "items": {
                "$ref": "#/definitions/LogicalRouterPort"
              },
              "readOnly": true,
              "type": "array",
              "description": "Downlink ports of the Logical Router.",
              "title": "Downlink ports of the Logical Router."
            }
          },
          "type": "object"
        }
      ],
      "description": "Port Connection Logical Router Entity",
      "title": "Port Connection Logical Router Entity"
    },
    "BatchRequest": {
      "type": "object",
      "properties": {
        "requests": {
          "items": {
            "$ref": "#/definitions/BatchRequestItem"
          },
          "type": "array"
        },
        "continue_on_error": {
          "default": true,
          "type": "boolean",
          "description": "Flag to decide if we will continue processing subsequent requests in case of current error for atomic = false."
        }
      }
    },
    "DhcpRelayServiceListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/DhcpRelayService"
              },
              "type": "array",
              "description": "Dhcp relay service list results",
              "title": "Dhcp relay service list results"
            }
          }
        }
      ]
    },
    "LbHttpRequestBodyCondition": {
      "allOf": [
        {
          "$ref": "#/definitions/LbRuleCondition"
        },
        {
          "properties": {
            "body_value": {
              "type": "string",
              "description": "HTTP request body",
              "title": "HTTP request body"
            },
            "match_type": {
              "description": "Match type of HTTP body",
              "default": "REGEX",
              "enum": [
                "STARTS_WITH",
                "ENDS_WITH",
                "EQUALS",
                "CONTAINS",
                "REGEX"
              ],
              "type": "string"
            }
          },
          "required": [
            "body_value"
          ],
          "type": "object"
        }
      ],
      "description": "This condition is used to match the message body of an HTTP request.\nTypically, only HTTP POST, PATCH, or PUT requests have request body.\nThe match_type field defines how body_value field is used to match the body\nof HTTP requests.\n",
      "title": "Condition to match content of HTTP request message body"
    },
    "KeyValue": {
      "required": [
        "value",
        "key"
      ],
      "type": "object",
      "properties": {
        "value": {
          "readOnly": false,
          "type": "string",
          "description": "key value"
        },
        "key": {
          "readOnly": false,
          "type": "string",
          "description": "key name"
        }
      }
    },
    "AllocationTokenParameter": {
      "type": "object",
      "properties": {
        "allocation_token": {
          "type": "string",
          "description": "Unique pool allocation token to ensure idempotent allocation release.",
          "maxLength": 64
        }
      }
    },
    "ExcludeList": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "members"
          ],
          "type": "object",
          "properties": {
            "members": {
              "description": "List of the members in the exclude list",
              "title": "ExcludeList member list",
              "items": {
                "$ref": "#/definitions/ResourceReference"
              },
              "readOnly": false,
              "maxItems": 100,
              "type": "array"
            }
          }
        }
      ]
    },
    "UcMessage": {
      "required": [
        "application_name",
        "client_type",
        "payload",
        "type_id"
      ],
      "type": "object",
      "properties": {
        "application_name": {
          "readOnly": false,
          "type": "string",
          "description": "Application name (e.g. UPGRADE)",
          "title": "Application name (e.g. UPGRADE)"
        },
        "correlation_id": {
          "readOnly": false,
          "type": "string",
          "description": "UUID used to associate response with request. Ignored on send path.",
          "title": "UUID used to associate response with request. Ignored on send path."
        },
        "client_type": {
          "readOnly": false,
          "enum": [
            "HOST",
            "EDGE",
            "CCP",
            "CCP_MPA",
            "PCG",
            "NSX_AGENT"
          ],
          "type": "string",
          "description": "Type of messaging client",
          "title": "Type of messaging client"
        },
        "payload": {
          "readOnly": false,
          "type": "string",
          "description": "Message payload",
          "title": "Message payload"
        },
        "type_id": {
          "readOnly": false,
          "type": "string",
          "description": "A fully qualified protobuf message name.",
          "title": "Type of payload Message"
        }
      }
    },
    "Traceflow": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "type": "object",
          "properties": {
            "operation_state": {
              "readOnly": true,
              "enum": [
                "IN_PROGRESS",
                "FINISHED",
                "FAILED"
              ],
              "type": "string",
              "description": "Represents the traceflow operation state",
              "title": "Represents the traceflow operation state"
            },
            "logical_counters": {
              "readOnly": true,
              "title": "counters of observations from logical components",
              "description": "counters of observations from logical components",
              "$ref": "#/definitions/TraceflowObservationCounters"
            },
            "timeout": {
              "description": "Maximum time (in ms) the management plane will be waiting for this traceflow round.",
              "title": "Timeout (in ms) for traceflow observations result list",
              "format": "int64",
              "maximum": 15000,
              "readOnly": true,
              "minimum": 5000,
              "type": "integer"
            },
            "lport_id": {
              "readOnly": true,
              "type": "string",
              "description": "id of the source logical port used for injecting the traceflow packet",
              "title": "id of the source logical port used for injecting the traceflow packet"
            },
            "counters": {
              "readOnly": true,
              "title": "observation counters",
              "description": "observation counters",
              "$ref": "#/definitions/TraceflowObservationCounters"
            },
            "result_overflowed": {
              "readOnly": true,
              "type": "boolean",
              "description": "A flag, when set true, indicates some observations were deleted from the result set.",
              "title": "A flag, when set true, indicates some observations were deleted from the result set."
            },
            "analysis": {
              "items": {
                "type": "string"
              },
              "readOnly": true,
              "type": "array",
              "description": "Traceflow result analysis notes",
              "title": "Traceflow result analysis notes"
            },
            "id": {
              "readOnly": true,
              "type": "string",
              "description": "The id of the traceflow round",
              "title": "The id of the traceflow round"
            }
          }
        }
      ]
    },
    "VidmInfoListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/VidmInfo"
              },
              "type": "array",
              "description": "List results",
              "title": "List results"
            }
          }
        }
      ]
    },
    "BgpNeighbor": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "neighbor_address"
          ],
          "type": "object",
          "properties": {
            "filter_in_ipprefixlist_id": {
              "type": "string",
              "description": "This is a deprecated property, Please  use 'address_family' instead.",
              "x-deprecated": true,
              "title": "IPPrefix List to be used for IN direction filter for IPV4_UNICAST address family"
            },
            "neighbor_address": {
              "format": "ipv4",
              "type": "string",
              "description": "Neighbor IP Address"
            },
            "remote_as": {
              "description": "This is a deprecated property, Please use 'remote_as_num' instead.",
              "title": "Autonomous System Number of the neighbor",
              "format": "int64",
              "maximum": 4294967296,
              "x-deprecated": true,
              "minimum": 1,
              "type": "integer"
            },
            "filter_out_ipprefixlist_id": {
              "type": "string",
              "description": "This is a deprecated property, Please use 'address_family' instead.",
              "x-deprecated": true,
              "title": "IPPrefixList to be used for OUT direction filter for IPV4_UNICAST address family"
            },
            "hold_down_timer": {
              "description": "Wait period (seconds) before declaring peer dead",
              "title": "Wait period (seconds) before declaring peer dead",
              "default": 180,
              "format": "int64",
              "maximum": 65535,
              "minimum": 1,
              "type": "integer"
            },
            "maximum_hop_limit": {
              "description": "This value is set on TTL(time to live) of BGP header.\nWhen router receives the BGP packet, it decrements the TTL. The default\nvalue of TTL is one when BPG request is initiated.So in the case of a\nBGP peer multiple hops away and and value of TTL is one, then  next\nrouter in the path will decrement the TTL to 0, realize it cant forward\nthe packet and will drop it. If the hop count value to reach neighbor\nis equal to or less than the maximum_hop_limit value then intermediate\nrouter decrements the TTL count by one and forwards the request to\nBGP neighour. If the hop count value is greater than the maximum_hop_limit\nvalue then intermediate router discards the request when TTL becomes 0.\n",
              "title": "Maximum Number of hops allowed to reach BGP neighbor",
              "default": 1,
              "format": "int32",
              "maximum": 255,
              "minimum": 1,
              "type": "integer"
            },
            "enabled": {
              "default": true,
              "type": "boolean",
              "description": "Flag to enable this BGP Neighbor",
              "title": "Flag to enable this BGP Neighbor"
            },
            "bfd_config": {
              "title": "BFD Configuration Parameters for the given peer.",
              "description": "By specifying these paramaters BFD config for this given peer can be overriden | (the globally configured values will not apply for this peer)",
              "$ref": "#/definitions/BfdConfigParameters"
            },
            "logical_router_id": {
              "readOnly": true,
              "type": "string",
              "description": "Logical router id",
              "title": "Logical router id"
            },
            "remote_as_num": {
              "type": "string",
              "description": "4 Byte ASN of the neighbor in ASPLAIN/ASDOT Format",
              "title": "4 Byte ASN of the neighbor in ASPLAIN/ASDOT Format"
            },
            "filter_out_routemap_id": {
              "type": "string",
              "description": "This is a deprecated property, Please use 'address_family' instead.",
              "x-deprecated": true,
              "title": "RouteMap to be used for OUT direction filter for IPV4_UNICAST address family"
            },
            "filter_in_routemap_id": {
              "type": "string",
              "description": "This is a deprecated property, Please use 'address_family' instead.",
              "x-deprecated": true,
              "title": "RouteMap to be used for IN direction filter for IPV4_UNICAST address family"
            },
            "keep_alive_timer": {
              "description": "Frequency (seconds) with which keep alive messages are sent to peers",
              "title": "Frequency (seconds) with which keep alive messages are sent to peers",
              "default": 60,
              "format": "int64",
              "maximum": 65535,
              "minimum": 1,
              "type": "integer"
            },
            "password": {
              "minLength": 1,
              "maxLength": 20,
              "type": "string",
              "description": "User can create (POST) the neighbor with or without the password.\nThe view (GET) on the neighbor, would never reveal if the password is set or not.\nThe password can be set later using edit neighbor workFlow (PUT)\nOn the edit neighbor (PUT), if the user does not specify the password property, the older value is retained.\n",
              "title": "Password"
            },
            "source_address": {
              "description": "Deprecated - do not provide a value for this field. Use source_addresses instead.",
              "format": "ipv4",
              "x-deprecated": true,
              "type": "string"
            },
            "source_addresses": {
              "items": {
                "format": "ipv4",
                "type": "string",
                "description": "IPv4 address"
              },
              "type": "array",
              "description": "BGP neighborship will be formed from all these source addresses to this neighbour.",
              "maxItems": 8,
              "title": "Array of Logical Router Uplink IP Addresses"
            },
            "enable_bfd": {
              "default": false,
              "type": "boolean",
              "description": "Flag to enable BFD for this BGP Neighbor. Enable this if the neighbor supports BFD as this will lead to faster convergence.",
              "title": "Enable BFD for this BGP Neighbor"
            },
            "address_families": {
              "items": {
                "$ref": "#/definitions/BgpNeighborAddressFamily"
              },
              "type": "array",
              "description": "User can enable the neighbor for the specific address families and also define filters per address family.\nWhen the neighbor is created, it is default enabled for IPV4_UNICAST address family for backward compatibility reasons.\nUser can change that if required, by defining the address family configuration.\n",
              "title": "AddressFamily settings for the neighbor"
            }
          }
        }
      ]
    },
    "TransportNodeStatusListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/TransportNodeStatus"
              },
              "type": "array",
              "description": "List of transport node statuses",
              "title": "List of transport node statuses"
            }
          }
        }
      ]
    },
    "DhcpServerStatus": {
      "required": [
        "service_status",
        "active_node"
      ],
      "type": "object",
      "properties": {
        "error_message": {
          "type": "string",
          "description": "Error message, if available",
          "title": "Error message, if available"
        },
        "service_status": {
          "enum": [
            "UP",
            "DOWN",
            "ERROR",
            "NO_STANDBY"
          ],
          "type": "string",
          "description": "UP means the dhcp service is working fine on both active transport-node\nand stand-by transport-node (if have), hence fail-over can work at this\ntime if there is failure happens on one of the transport-node;\nDOWN means the dhcp service is down on both active transport-node and\nstand-by node (if have), hence the dhcp-service will not repsonse any\ndhcp request;\nError means error happens on transport-node(s) or no status is reported from\ntransport-node(s). The dhcp service may be working (or not working);\nNO_STANDBY means dhcp service is working in one of the transport node while\nnot in the other transport-node (if have). Hence if the dhcp service in\nthe working transport-node is down, fail-over will not happen and the\ndhcp service will go down.\n"
        },
        "stand_by_node": {
          "type": "string",
          "description": "uuid of stand_by transport node. null if non-HA mode",
          "title": "uuid of stand_by transport node. null if non-HA mode"
        },
        "active_node": {
          "type": "string",
          "description": "uuid of active transport node",
          "title": "uuid of active transport node"
        }
      }
    },
    "RealizedSecurityGroup": {
      "allOf": [
        {
          "$ref": "#/definitions/RealizedGroup"
        },
        {
          "properties": {
            "evaluations": {
              "description": "Reference to the evaluted members of the Security Group.\n",
              "title": "Evaluated members of Security Group",
              "items": {
                "$ref": "#/definitions/RealizedSecurityGroupMemberEvaluation"
              },
              "readOnly": true,
              "maxItems": 500,
              "type": "array"
            }
          },
          "type": "object"
        }
      ],
      "description": "Realized Network and Security Group",
      "title": "Realized Network and Security Group"
    },
    "CloudTag": {
      "type": "object",
      "properties": {
        "value": {
          "readOnly": true,
          "type": "string",
          "description": "Tag value",
          "title": "Tag value"
        },
        "key": {
          "readOnly": true,
          "type": "string",
          "description": "Tag key",
          "title": "Tag key"
        }
      }
    },
    "EdgeNodeBinding": {
      "properties": {
        "logical_router_port_ids": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "List of LR port ids backed by this node.",
          "title": "List of LR port ids backed by this node."
        },
        "edge_cluster_id": {
          "readOnly": true,
          "type": "string",
          "description": "Edge cluster UUID where this edge node is a member.",
          "title": "Edge cluster UUID where this edge node is a member."
        }
      },
      "required": [
        "logical_router_port_ids"
      ],
      "type": "object",
      "description": "Information about the object which is using the Edge node.",
      "title": "Information about the object which is using the Edge node."
    },
    "FeaturePermission": {
      "properties": {
        "feature": {
          "readOnly": true,
          "type": "string",
          "description": "Feature Name",
          "title": "Feature Name"
        },
        "permission": {
          "readOnly": true,
          "enum": [
            "crud",
            "read",
            "execute",
            "none"
          ],
          "type": "string",
          "description": "Permission",
          "title": "Permission"
        }
      },
      "type": "object",
      "description": "Feature Permission",
      "title": "Feature Permission"
    },
    "VtepCsvListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/CsvListResult"
        },
        {
          "type": "object",
          "properties": {
            "last_update_timestamp": {
              "readOnly": true,
              "type": "integer",
              "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
              "format": "int64"
            },
            "results": {
              "items": {
                "$ref": "#/definitions/VtepTableCsvRecord"
              },
              "type": "array"
            }
          }
        }
      ]
    },
    "TransportZoneListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/TransportZone"
              },
              "type": "array",
              "description": "Transport Zone Results",
              "title": "Transport Zone Results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Transport zone queries result",
      "title": "Transport zone queries result"
    },
    "TransportZoneProfileTypeIdEntry": {
      "required": [
        "profile_id"
      ],
      "type": "object",
      "properties": {
        "profile_id": {
          "readOnly": false,
          "type": "string",
          "description": "profile id of the resource type"
        },
        "resource_type": {
          "enum": [
            "BfdHealthMonitoringProfile"
          ],
          "type": "string",
          "description": "Selects the type of the transport zone profile"
        }
      }
    },
    "RedistributionRule": {
      "required": [
        "sources",
        "destination"
      ],
      "type": "object",
      "properties": {
        "sources": {
          "items": {
            "enum": [
              "STATIC",
              "NSX_CONNECTED",
              "NSX_STATIC",
              "TIER0_NAT",
              "TIER1_NAT",
              "TIER1_LB_VIP",
              "TIER1_LB_SNAT",
              "BGP"
            ],
            "type": "string",
            "description": "Redistribution Protocols"
          },
          "type": "array",
          "description": "Array of redistribution protocols",
          "title": "Array of redistribution protocols"
        },
        "destination": {
          "type": "string",
          "description": "Destination redistribution protocol",
          "enum": [
            "STATIC",
            "NSX_CONNECTED",
            "NSX_STATIC",
            "TIER0_NAT",
            "TIER1_NAT",
            "TIER1_LB_VIP",
            "TIER1_LB_SNAT",
            "BGP"
          ]
        },
        "route_map_id": {
          "type": "string",
          "description": "RouteMap Id for the filter",
          "title": "RouteMap Id for the filter"
        },
        "description": {
          "maxLength": 1024,
          "type": "string",
          "description": "Description",
          "title": "Description"
        },
        "display_name": {
          "maxLength": 255,
          "type": "string",
          "description": "Display name",
          "title": "Display name"
        }
      }
    },
    "RouteMapSequenceMatch": {
      "required": [
        "ip_prefix_lists"
      ],
      "type": "object",
      "properties": {
        "ip_prefix_lists": {
          "description": "IPPrefixList Identifiers for RouteMap Sequence Match Criteria",
          "title": "IPPrefixList Identifiers for RouteMap Sequence Match Criteria",
          "minItems": 1,
          "items": {
            "type": "string"
          },
          "maxItems": 500,
          "type": "array"
        }
      }
    },
    "AwsGatewayHaConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "gateway_ha_index": {
              "format": "int64",
              "type": "integer",
              "description": "Index of HA that indicates whether gateway is primary or secondary.\nIf index is 0, then it is primary gateway. Else secondary gateway.\n",
              "title": "Index of HA that indicates whether gateway is primary or secondary.\nIf index is 0, then it is primary gateway. Else secondary gateway.\n"
            },
            "management_subnet": {
              "type": "string",
              "description": "Management subnet",
              "title": "Management subnet"
            },
            "downlink_subnet": {
              "type": "string",
              "description": "Downlink subnet",
              "title": "Downlink subnet"
            },
            "uplink_subnet": {
              "type": "string",
              "description": "Uplink subnet",
              "title": "Uplink subnet"
            },
            "availability_zone": {
              "type": "string",
              "description": "Availability Zone",
              "title": "Availability Zone"
            }
          },
          "required": [
            "gateway_ha_index",
            "management_subnet",
            "downlink_subnet",
            "uplink_subnet",
            "availability_zone"
          ],
          "type": "object"
        }
      ],
      "description": "Aws subnet configuration to deploy gateways",
      "title": "Aws subnet configuration to deploy gateways"
    },
    "LbHttpProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/LbAppProfile"
        },
        {
          "type": "object",
          "properties": {
            "idle_timeout": {
              "description": "It is used to specify the HTTP application idle time out, instead of\nTCP socket setting which should be configured in TCP profile.\n",
              "format": "int64",
              "default": 15,
              "title": "HTTP application idle timeout in seconds",
              "minimum": 1,
              "type": "integer"
            },
            "ntlm": {
              "default": false,
              "type": "boolean",
              "description": "NTLM is an authentication protocol that can be used over HTTP. If the\nflag is set to true, LB will use NTLM challenge/response methodology.\n",
              "title": "NTLM support flag"
            },
            "request_header_size": {
              "description": "A request with header larger than request_header_size will be processed\nas best effort whereas a request with header below this specified size\nis guaranteed to be processed.\n",
              "title": "Maximum size of the buffer used to store HTTP request headers",
              "default": 1024,
              "format": "int64",
              "maximum": 65536,
              "minimum": 1,
              "type": "integer"
            },
            "http_redirect_to_https": {
              "default": false,
              "type": "boolean",
              "description": "Certain secure applications may want to force communication over SSL,\nbut instead of rejecting non-SSL connections, they may choose to\nredirect the client automatically to use SSL.\n",
              "title": "flag to indicate whether enable HTTP-HTTPS redirect"
            },
            "x_forwarded_for": {
              "type": "string",
              "description": "insert or replace x_forwarded_for",
              "enum": [
                "INSERT",
                "REPLACE"
              ]
            },
            "http_redirect_to": {
              "type": "string",
              "description": "If a website is temporarily down or has moved, incoming requests\nfor that virtual server can be temporarily redirected to a URL\n",
              "title": "http redirect static URL"
            }
          }
        }
      ]
    },
    "EnforcementPoint": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "properties": {
            "connection_info": {
              "title": "Enforcement point connection info",
              "description": "Enforcement point connection info",
              "$ref": "#/definitions/EnforcementPointConnectionInfo"
            },
            "version": {
              "readOnly": true,
              "type": "string",
              "description": "Version of the Enforcement point",
              "title": "Version of the Enforcement point"
            }
          },
          "required": [
            "connection_info"
          ],
          "type": "object"
        }
      ],
      "description": "Represents endpoint where policy will be applied",
      "title": "Represents endpoint where policy will be applied"
    },
    "LbSslProfileListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LbSslProfile"
              },
              "type": "array",
              "description": "paginated list of load balancer SSL profiles",
              "title": "paginated list of load balancer SSL profiles"
            }
          }
        }
      ]
    },
    "AwsVpcListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/AwsVpc"
              },
              "type": "array",
              "description": "Vpc list",
              "title": "Vpc list"
            }
          },
          "type": "object"
        }
      ],
      "description": "Vpc list",
      "title": "Vpc list"
    },
    "Protocol": {
      "required": [
        "name"
      ],
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Protocol name",
          "title": "Protocol name"
        }
      }
    },
    "LbMonitor": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "discriminator": "resource_type",
          "required": [
            "resource_type"
          ],
          "type": "object",
          "properties": {
            "resource_type": {
              "enum": [
                "LbHttpMonitor",
                "LbHttpsMonitor",
                "LbIcmpMonitor",
                "LbTcpMonitor",
                "LbUdpMonitor",
                "LbPassiveMonitor"
              ],
              "type": "string",
              "description": "Load balancers monitor the health of backend servers to ensure traffic\nis not black holed.\nThere are two types of healthchecks: active and passive.\nPassive healthchecks depend on failures in actual client traffic (e.g. RST\nfrom server in response to a client connection) to detect that the server\nor the application is down.\nIn case of active healthchecks, load balancer itself initiates new\nconnections (or sends ICMP ping) to the servers periodically to check their\nhealth, completely independent of any data traffic.\nCurrently, active health monitors are supported for HTTP, HTTPS, TCP, UDP\nand ICMP protocols.\n"
            }
          }
        }
      ]
    },
    "DneRuleList": {
      "required": [
        "rules"
      ],
      "type": "object",
      "properties": {
        "rules": {
          "description": "List of DNE rules in the section. Only homogenous rules are supported.",
          "title": "List of the DNE rules",
          "items": {
            "$ref": "#/definitions/DneRule"
          },
          "readOnly": false,
          "maxItems": 1000,
          "type": "array"
        }
      }
    },
    "PolicyTemplateListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/PolicyTemplate"
              },
              "type": "array",
              "description": "Policy Template list results",
              "title": "Policy Template list results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Paged Collection of Policy Templates",
      "title": "Paged Collection of Policy Templates"
    },
    "NodeLogProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "last_modified_time": {
              "readOnly": true,
              "type": "integer",
              "description": "Last modified time expressed in milliseconds since epoch",
              "format": "int64"
            },
            "log_size": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Size of log file in bytes",
              "title": "Size of log file in bytes"
            },
            "log_name": {
              "readOnly": true,
              "type": "string",
              "description": "Name of log file",
              "title": "Name of log file"
            }
          },
          "type": "object"
        }
      ],
      "description": "Node log properties",
      "title": "Node log properties"
    },
    "LogicalRouterDownLinkPort": {
      "allOf": [
        {
          "$ref": "#/definitions/LogicalRouterPort"
        },
        {
          "required": [
            "subnets"
          ],
          "type": "object",
          "properties": {
            "subnets": {
              "description": "Logical router port subnets",
              "title": "Logical router port subnets",
              "minItems": 1,
              "items": {
                "$ref": "#/definitions/IPSubnet"
              },
              "maxItems": 1,
              "type": "array"
            },
            "urpf_mode": {
              "description": "Unicast Reverse Path Forwarding mode",
              "default": "STRICT",
              "enum": [
                "NONE",
                "STRICT"
              ],
              "type": "string"
            },
            "linked_logical_switch_port_id": {
              "title": "Reference to the logical switch port to connect to",
              "description": "Reference to the logical switch port to connect to",
              "$ref": "#/definitions/ResourceReference"
            }
          }
        }
      ]
    },
    "TransportZoneEndPoint": {
      "properties": {
        "transport_zone_id": {
          "type": "string",
          "description": "Unique ID identifying the transport zone for this endpoint",
          "title": "Unique ID identifying the transport zone for this endpoint"
        },
        "transport_zone_profile_ids": {
          "items": {
            "$ref": "#/definitions/TransportZoneProfileTypeIdEntry"
          },
          "type": "array",
          "description": "Identifiers of the transport zone profiles associated with this transport zone endpoint on this transport node.",
          "title": "Identifiers of the transport zone profiles associated with this transport zone endpoint on this transport node."
        }
      },
      "required": [
        "transport_zone_id"
      ],
      "type": "object",
      "description": "Specify which HostSwitch from this TransportNode is used handle traffic for given TransportZone",
      "title": "This object associates TransportNode to a certain TransportZone"
    },
    "PoolMemberSetting": {
      "properties": {
        "admin_state": {
          "description": "Member admin state",
          "default": "ENABLED",
          "enum": [
            "ENABLED",
            "DISABLED",
            "GRACEFUL_DISABLED"
          ],
          "type": "string"
        },
        "ip_address": {
          "format": "ip",
          "type": "string",
          "description": "Pool member IP address"
        },
        "port": {
          "format": "port-or-range",
          "type": "string",
          "description": "Pool member port number"
        }
      },
      "required": [
        "ip_address"
      ],
      "type": "object",
      "description": "The setting is used to add, update or remove pool members from pool.\nOnly admin_state can be updated in pool member.\n",
      "title": "Pool member setting"
    },
    "LbIpHeaderCondition": {
      "allOf": [
        {
          "$ref": "#/definitions/LbRuleCondition"
        },
        {
          "properties": {
            "source_address": {
              "format": "address-or-block-or-range",
              "type": "string",
              "description": "Source IP address of HTTP message"
            }
          },
          "required": [
            "source_address"
          ],
          "type": "object"
        }
      ],
      "description": "This condition is used to match IP header fields of HTTP messages.\nCurrently, only the source IP address is supported. IP addresses can be\nexpressed as a single IP address like 10.1.1.1, or a range of IP addresses\nlike 10.1.1.101-10.1.1.160. Both IPv4 and IPv6 addresses are supported.\n",
      "title": "Condition to match IP header fields"
    },
    "NodeSyslogExporterProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "port": {
              "description": "Port to export to",
              "title": "Port to export to",
              "default": 514,
              "format": "int64",
              "maximum": 65535,
              "minimum": 1,
              "type": "integer"
            },
            "facilities": {
              "items": {
                "enum": [
                  "KERN",
                  "USER",
                  "MAIL",
                  "DAEMON",
                  "AUTH",
                  "SYSLOG",
                  "LPR",
                  "NEWS",
                  "UUCP",
                  "AUTHPRIV",
                  "FTP",
                  "LOGALERT",
                  "CRON",
                  "LOCAL0",
                  "LOCAL1",
                  "LOCAL2",
                  "LOCAL3",
                  "LOCAL4",
                  "LOCAL5",
                  "LOCAL6",
                  "LOCAL7"
                ],
                "type": "string",
                "description": "Syslog facility"
              },
              "type": "array",
              "description": "Facilities to export",
              "title": "Facilities to export"
            },
            "msgids": {
              "items": {
                "pattern": "/^.+$/",
                "type": "string"
              },
              "type": "array",
              "description": "MSGIDs to export",
              "title": "MSGIDs to export"
            },
            "protocol": {
              "enum": [
                "TCP",
                "TLS",
                "UDP",
                "LI",
                "LI-TLS"
              ],
              "type": "string",
              "description": "Export protocol",
              "title": "Export protocol"
            },
            "exporter_name": {
              "type": "string",
              "description": "Syslog exporter name",
              "title": "Syslog exporter name"
            },
            "level": {
              "enum": [
                "EMERG",
                "ALERT",
                "CRIT",
                "ERR",
                "WARNING",
                "NOTICE",
                "INFO",
                "DEBUG"
              ],
              "type": "string",
              "description": "Logging level to export",
              "title": "Logging level to export"
            },
            "structured_data": {
              "items": {
                "pattern": "/^(comp|subcomp|security|audit|reqId|ereqId|entId|errorCode)=.+$/",
                "type": "string"
              },
              "type": "array",
              "description": "Structured data to export",
              "title": "Structured data to export"
            },
            "tls_ca_pem": {
              "type": "string",
              "description": "CA certificate PEM of TLS server to export to",
              "title": "CA certificate PEM of TLS server to export to"
            },
            "server": {
              "pattern": "/^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/",
              "type": "string",
              "description": "IP address or hostname of server to export to"
            }
          },
          "required": [
            "server",
            "protocol",
            "exporter_name",
            "level"
          ],
          "type": "object"
        }
      ],
      "description": "Node syslog exporter properties",
      "title": "Node syslog exporter properties"
    },
    "Tag": {
      "type": "object",
      "properties": {
        "scope": {
          "description": "Tag searches may optionally be restricted by scope",
          "title": "Tag scope",
          "default": "",
          "readOnly": false,
          "maxLength": 30,
          "type": "string"
        },
        "tag": {
          "description": "Identifier meaningful to user",
          "title": "Tag value",
          "default": "",
          "readOnly": false,
          "maxLength": 40,
          "type": "string"
        }
      }
    },
    "RealizedVirtualMachine": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyRealizedResource"
        },
        {
          "properties": {
            "host_id": {
              "readOnly": true,
              "type": "string",
              "description": "Id of the host on which the vm exists.",
              "title": "Id of the host on which the vm exists."
            },
            "local_id_on_host": {
              "readOnly": true,
              "type": "string",
              "description": "Id of the vm unique within the host.",
              "title": "Id of the vm unique within the host."
            },
            "power_state": {
              "readOnly": true,
              "enum": [
                "VM_RUNNING",
                "VM_STOPPED",
                "VM_SUSPENDED",
                "UNKNOWN"
              ],
              "type": "string",
              "description": "Current power state of this virtual machine in the system.",
              "title": "Current power state of this virtual machine in the system."
            },
            "compute_ids": {
              "items": {
                "type": "string"
              },
              "readOnly": true,
              "type": "array",
              "description": "List of external compute ids of the virtual machine in the format 'id-type-key:value' , list of external compute ids ['uuid:xxxx-xxxx-xxxx-xxxx', 'moIdOnHost:moref-11', 'instanceUuid:xxxx-xxxx-xxxx-xxxx']",
              "title": "List of external compute ids of the virtual machine in the format 'id-type-key:value' , list of external compute ids ['uuid:xxxx-xxxx-xxxx-xxxx', 'moIdOnHost:moref-11', 'instanceUuid:xxxx-xxxx-xxxx-xxxx']"
            }
          },
          "type": "object"
        }
      ],
      "description": "Realized Virtual Machine",
      "title": "Realized Virtual Machine"
    },
    "TeamingPolicy": {
      "properties": {
        "policy": {
          "enum": [
            "FAILOVER_ORDER",
            "LOADBALANCE_SRCID"
          ],
          "type": "string",
          "description": "Teaming policy",
          "title": "Teaming policy"
        },
        "standby_list": {
          "items": {
            "$ref": "#/definitions/Uplink"
          },
          "type": "array",
          "description": "List of Uplinks used in standby list",
          "title": "List of Uplinks used in standby list"
        },
        "active_list": {
          "items": {
            "$ref": "#/definitions/Uplink"
          },
          "type": "array",
          "description": "List of Uplinks used in active list",
          "title": "List of Uplinks used in active list"
        }
      },
      "required": [
        "policy",
        "active_list"
      ],
      "type": "object",
      "description": "Uplink Teaming Policy",
      "title": "Uplink Teaming Policy"
    },
    "RealizedLogicalSwitch": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyRealizedResource"
        },
        {
          "properties": {
            "transport_zone_id": {
              "readOnly": true,
              "type": "string",
              "description": "Transport zone identifier",
              "title": "Transport zone identifier"
            },
            "logical_switch_id": {
              "readOnly": true,
              "type": "string",
              "description": "Id of the logical switch",
              "title": "Id of the logical switch"
            }
          },
          "type": "object"
        }
      ],
      "description": "Realized Logical Switch",
      "title": "Realized Logical Switch"
    },
    "FileUsageInfo": {
      "type": "object",
      "properties": {
        "applianceusage": {
          "items": {
            "$ref": "#/definitions/ApplianceFileUsage"
          },
          "type": "array",
          "description": "File usage of all appliances",
          "title": "File Usage Info"
        }
      }
    },
    "StaticRouteListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/StaticRoute"
              },
              "type": "array",
              "description": "Paginated list of static routes",
              "title": "Paginated list of static routes"
            }
          }
        }
      ]
    },
    "LogicalPortMirrorDestination": {
      "allOf": [
        {
          "$ref": "#/definitions/MirrorDestination"
        },
        {
          "required": [
            "port_ids"
          ],
          "type": "object",
          "properties": {
            "port_ids": {
              "description": "Destination logical port identifier list.",
              "title": "Destination logical port identifier list.",
              "minItems": 1,
              "items": {
                "type": "string"
              },
              "maxItems": 3,
              "type": "array"
            }
          }
        }
      ]
    },
    "RevokeNodeRequest": {
      "required": [
        "hosts"
      ],
      "type": "object",
      "properties": {
        "hosts": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "IP addresses of node(s) to revoke",
          "title": "IP addresses of node(s) to revoke"
        }
      }
    },
    "IpBlock": {
      "description": "A block of IPv4 addresses defined by a start address and a mask/prefix (network CIDR). An IP block is typically large & allocated to a tenant for automated consumption. An IP block is always a contiguous address space, for example 192.0.0.1/8. An IP block can be further subdivided into subnets called IP block subnets. These IP block subnets can later be added to IP pools and used for IP allocation. An IP pool is typically a collection of subnets that are often not a contiguous address space. Clients are allocated IP addresses only from IP pools. Sample Structure Diagram IpBlock_VMware 192.0.0.1/8 ======================================================================= /                          ___________________________________________/________ /  IpBlockSubnet_Finance  ( IpBlockSubnet_Eng1   IpBlockSubnet_Eng2   /        ) /  192.168.0.1/16         (   192.170.1.1/16      192.180.1.1/24      /        ) IpPool_Eng /                         (___________________________________________/________) /                                                                     / =======================================================================",
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "cidr"
          ],
          "type": "object",
          "properties": {
            "cidr": {
              "format": "ipv4-cidr-block",
              "type": "string",
              "description": "Represents network address and the prefix length which will be associated with a layer-2 broadcast domain",
              "title": "Represents network address and the prefix length which will be associated with a layer-2 broadcast domain"
            }
          }
        }
      ]
    },
    "NodeInfo": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "type": "object",
          "properties": {
            "type": {
              "readOnly": true,
              "type": "string",
              "description": "Node type",
              "title": "Node type"
            },
            "display_name": {
              "readOnly": true,
              "type": "string",
              "description": "Name of the node",
              "title": "Name of the node"
            },
            "id": {
              "readOnly": true,
              "type": "string",
              "description": "Identifier of the node",
              "title": "UUID of node"
            },
            "component_version": {
              "readOnly": true,
              "type": "string",
              "description": "Component version of the node",
              "title": "Component version of the node"
            }
          }
        }
      ]
    },
    "RealizedGroups": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyRealizedResource"
        },
        {
          "properties": {
            "realized_groups": {
              "items": {
                "$ref": "#/definitions/RealizedGroup"
              },
              "readOnly": true,
              "type": "array",
              "description": "list of realized groups",
              "title": "list of realized groups"
            }
          },
          "type": "object"
        }
      ],
      "description": "Realized groups",
      "title": "Realized groups"
    },
    "StaticRoute": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "next_hops",
            "network"
          ],
          "type": "object",
          "properties": {
            "next_hops": {
              "items": {
                "$ref": "#/definitions/StaticRouteNextHop"
              },
              "type": "array",
              "description": "Next Hops",
              "title": "Next Hops"
            },
            "logical_router_id": {
              "readOnly": true,
              "type": "string",
              "description": "Logical router id",
              "title": "Logical router id"
            },
            "network": {
              "format": "ipv4-cidr-block",
              "type": "string",
              "description": "CIDR"
            }
          }
        }
      ]
    },
    "Label": {
      "properties": {
        "text": {
          "maxLength": 255,
          "type": "string",
          "description": "Text to be displayed at the label.",
          "title": "Label text"
        }
      },
      "required": [
        "text"
      ],
      "type": "object",
      "description": "Label that will be displayed for a UI element.",
      "title": "Label"
    },
    "NodeListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/Node"
              },
              "type": "array",
              "description": "Node list results",
              "title": "Node list results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Node list result",
      "title": "Node list result"
    },
    "LogicalRouterPort": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "discriminator": "resource_type",
          "required": [
            "logical_router_id",
            "resource_type"
          ],
          "type": "object",
          "properties": {
            "logical_router_id": {
              "type": "string",
              "description": "Identifier for logical router on which this port is created",
              "title": "Identifier for logical router on which this port is created"
            },
            "service_bindings": {
              "items": {
                "$ref": "#/definitions/ServiceBinding"
              },
              "type": "array",
              "description": "Service Bindings",
              "title": "Service Bindings"
            },
            "resource_type": {
              "enum": [
                "LogicalRouterUpLinkPort",
                "LogicalRouterDownLinkPort",
                "LogicalRouterLinkPortOnTIER0",
                "LogicalRouterLinkPortOnTIER1",
                "LogicalRouterLoopbackPort"
              ],
              "type": "string",
              "description": "LogicalRouterUpLinkPort is allowed only on TIER0 logical router.\n  It is the north facing port of the logical router.\nLogicalRouterLinkPortOnTIER0 is allowed only on TIER0 logical router.\n  This is the port where the LogicalRouterLinkPortOnTIER1 of TIER1 logical router connects to.\nLogicalRouterLinkPortOnTIER1 is allowed only on TIER1 logical router.\n  This is the port using which the user connected to TIER1 logical router for upwards connectivity via TIER0 logical router.\n  Connect this port to the LogicalRouterLinkPortOnTIER0 of the TIER0 logical router.\nLogicalRouterDownLinkPort is for the connected subnets on the logical router.\nLogicalRouterLoopbackPort is a loopback port for logical router component\n  which is placed on chosen edge cluster member.\n"
            },
            "mac_address": {
              "readOnly": true,
              "type": "string",
              "description": "MAC address",
              "title": "MAC address"
            }
          }
        }
      ]
    },
    "CurrentRealizationStateBarrier": {
      "type": "object",
      "description": "The current global barrier number of the realized state",
      "properties": {
        "current_barrier_number": {
          "readOnly": true,
          "type": "integer",
          "description": "Gives the current global barrier number for NSX",
          "format": "int64"
        }
      }
    },
    "UpgradeUnitStatus": {
      "type": "object",
      "properties": {
        "status": {
          "readOnly": true,
          "enum": [
            "SUCCESS",
            "FAILED",
            "IN_PROGRESS",
            "NOT_STARTED",
            "PAUSED"
          ],
          "type": "string",
          "description": "Status of upgrade unit",
          "title": "Status of upgrade unit"
        },
        "errors": {
          "items": {
            "type": "string"
          },
          "readOnly": true,
          "type": "array",
          "description": "List of errors occurred during upgrade of this upgrade unit",
          "title": "List of errors occurred during upgrade of this upgrade unit"
        },
        "display_name": {
          "readOnly": true,
          "type": "string",
          "description": "Name of upgrade unit",
          "title": "Name of upgrade unit"
        },
        "id": {
          "readOnly": true,
          "type": "string",
          "description": "Identifier of upgrade unit",
          "title": "UUID of upgrade unit"
        },
        "percent_complete": {
          "readOnly": true,
          "type": "number",
          "description": "Indicator of upgrade progress in percentage",
          "title": "Indicator of upgrade progress in percentage"
        }
      }
    },
    "EmbeddedResource": {
      "allOf": [
        {
          "$ref": "#/definitions/RevisionedResource"
        },
        {
          "type": "object",
          "properties": {
            "_owner": {
              "readOnly": true,
              "$ref": "#/definitions/OwnerResourceLink"
            },
            "display_name": {
              "maxLength": 255,
              "type": "string",
              "description": "Defaults to ID if not set",
              "title": "Identifier to use when displaying entity in logs or GUI"
            },
            "id": {
              "readOnly": true,
              "type": "string",
              "description": "Identifier of the resource"
            },
            "resource_type": {
              "readOnly": false,
              "type": "string",
              "description": "The type of this resource."
            },
            "description": {
              "maxLength": 1024,
              "type": "string",
              "description": "Description of this resource",
              "title": "Description of this resource"
            }
          }
        }
      ]
    },
    "MetadataProxyListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/MetadataProxy"
              },
              "type": "array",
              "description": "paginated list of metadata proxies",
              "title": "paginated list of metadata proxies"
            }
          }
        }
      ]
    },
    "RealizedEnforcementPoint": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyRealizedResource"
        },
        {
          "properties": {
            "realized_firewalls": {
              "readOnly": true,
              "title": "Root of Realized Firewalls",
              "description": "Root of Realized Firewalls",
              "$ref": "#/definitions/RealizedFirewalls"
            },
            "realized_services": {
              "readOnly": true,
              "title": "Root of Realized Services",
              "description": "Root of Realized Services",
              "$ref": "#/definitions/RealizedServices"
            },
            "realized_groups": {
              "readOnly": true,
              "title": "Root of Realized Groups",
              "description": "Root of Realized Groups",
              "$ref": "#/definitions/RealizedGroups"
            }
          },
          "type": "object"
        }
      ],
      "description": "Realized Enforcement Point",
      "title": "Realized Enforcement Point"
    },
    "StaticHopBfdPeerListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/StaticHopBfdPeer"
              },
              "readOnly": true,
              "type": "array",
              "description": "static hop BFD peer list results",
              "title": "static hop BFD peer list results"
            }
          }
        }
      ]
    },
    "PrefixConfig": {
      "required": [
        "action"
      ],
      "type": "object",
      "properties": {
        "action": {
          "type": "string",
          "description": "Action for the IPPrefix",
          "enum": [
            "PERMIT",
            "DENY"
          ]
        },
        "ge": {
          "description": "Greater than or equal to",
          "format": "int64",
          "title": "Greater than or equal to",
          "maximum": 32,
          "minimum": 1,
          "type": "integer"
        },
        "le": {
          "description": "Less than or equal to",
          "format": "int64",
          "title": "Less than or equal to",
          "maximum": 32,
          "minimum": 1,
          "type": "integer"
        },
        "network": {
          "format": "ipv4-cidr-block",
          "type": "string",
          "description": "If absent, the action applies to all addresses."
        }
      }
    },
    "MACSetListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/MACSet"
              },
              "type": "array",
              "description": "Paged collection of MACSets",
              "title": "Paged collection of MACSets"
            }
          }
        }
      ]
    },
    "EdgeClusterMemberTransportNode": {
      "required": [
        "member_index",
        "transport_node_id"
      ],
      "type": "object",
      "properties": {
        "member_index": {
          "format": "int32",
          "type": "integer",
          "description": "System generated index for cluster member",
          "title": "System generated index for cluster member"
        },
        "transport_node_id": {
          "type": "string",
          "description": "Identifier of the transport node backed by an Edge node",
          "title": "UUID of edge transport node"
        }
      }
    },
    "ClusterProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "discriminator": "resource_type",
          "required": [
            "resource_type"
          ],
          "type": "object",
          "properties": {
            "resource_type": {
              "enum": [
                "EdgeHighAvailabilityProfile",
                "BridgeHighAvailabilityClusterProfile"
              ],
              "type": "string",
              "description": "Supported cluster profiles."
            }
          }
        }
      ]
    },
    "IPv4AddressProperties": {
      "properties": {
        "netmask": {
          "type": "string",
          "description": "Interface netmask",
          "title": "Interface netmask"
        },
        "ip_address": {
          "type": "string",
          "description": "Interface IPv4 address",
          "title": "Interface IPv4 address"
        }
      },
      "type": "object",
      "description": "IPv4 address properties",
      "title": "IPv4 address properties"
    },
    "VpcStats": {
      "properties": {
        "unmanaged": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "VPCs with status unmanaged",
          "title": "VPCs with status unmanaged"
        },
        "managed": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "VPCs with status managed",
          "title": "VPCs with status managed"
        }
      },
      "type": "object",
      "description": "VPC statistics",
      "title": "VPC statistics"
    },
    "PoolMemberSettingList": {
      "properties": {
        "members": {
          "items": {
            "$ref": "#/definitions/PoolMemberSetting"
          },
          "type": "array",
          "description": "List of pool member settings to be passed to add, update and remove APIs\n",
          "title": "List of pool member settings to be passed to add, update and remove APIs\n"
        }
      },
      "required": [
        "members"
      ],
      "type": "object",
      "description": "List of PoolMemberSetting",
      "title": "List of PoolMemberSetting"
    },
    "LogicalSwitchInfo": {
      "type": "object",
      "properties": {
        "logical_switch_id": {
          "readOnly": true,
          "type": "string",
          "description": "ID of the logical switch",
          "title": "ID of the logical switch"
        },
        "instances_count": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Number of instances on this logical switch",
          "title": "Number of instances on this logical switch"
        },
        "logical_switch_display_name": {
          "readOnly": true,
          "type": "string",
          "description": "Name of the logical switch",
          "title": "Name of the logical switch"
        },
        "is_default_logical_switch": {
          "readOnly": true,
          "type": "boolean",
          "description": "Flag to identify if this is the default logical switch",
          "title": "Flag to identify if this is the default logical switch"
        },
        "nsx_switch_tag": {
          "readOnly": true,
          "type": "string",
          "description": "This tag is applied on cloud compute resource to be attached to this\nlogical switch\n",
          "title": "This tag is applied on cloud compute resource to be attached to this\nlogical switch\n"
        }
      }
    },
    "GroupListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/Group"
              },
              "type": "array",
              "description": "Group list results",
              "title": "Group list results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Paged Collection of Groups",
      "title": "Paged Collection of Groups"
    },
    "NatCounters": {
      "type": "object",
      "properties": {
        "total_packets": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "The number of packets",
          "title": "The number of packets"
        },
        "total_bytes": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "The number of bytes",
          "title": "The number of bytes"
        },
        "active_sessions": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "The number of active sessions",
          "title": "The number of active sessions"
        }
      }
    },
    "HostSwitchState": {
      "properties": {
        "host_switch_id": {
          "readOnly": true,
          "type": "string",
          "description": "External ID of the HostSwitch",
          "title": "External ID of the HostSwitch"
        },
        "endpoints": {
          "items": {
            "$ref": "#/definitions/Endpoint"
          },
          "readOnly": true,
          "type": "array",
          "description": "List of virtual tunnel endpoints which are configured on this switch",
          "title": "List of virtual tunnel endpoints which are configured on this switch"
        },
        "transport_zone_ids": {
          "items": {
            "type": "string"
          },
          "readOnly": true,
          "type": "array",
          "description": "List of Ids of TransportZones this HostSwitch belongs to",
          "title": "List of Ids of TransportZones this HostSwitch belongs to"
        },
        "host_switch_name": {
          "readOnly": true,
          "type": "string",
          "description": "The name must be unique among all host switches specified in a given Transport Node.",
          "title": "HostSwitch name. This name will be used to reference this HostSwitch."
        }
      },
      "type": "object",
      "description": "Host Switch State",
      "title": "Host Switch State"
    },
    "AttachmentContext": {
      "discriminator": "resource_type",
      "required": [
        "resource_type"
      ],
      "type": "object",
      "properties": {
        "allocate_addresses": {
          "enum": [
            "IpPool",
            "MacPool",
            "Both",
            "None"
          ],
          "type": "string",
          "description": "A flag to indicate whether to allocate addresses from allocation\n    pools bound to the parent logical switch.\n",
          "title": "A flag to indicate whether to allocate addresses from allocation\n    pools bound to the parent logical switch.\n"
        },
        "resource_type": {
          "type": "string",
          "description": "Used to identify which concrete class it is",
          "title": "Used to identify which concrete class it is"
        }
      }
    },
    "NodeProtonServiceProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/NodeServiceProperties"
        },
        {
          "properties": {
            "service_properties": {
              "title": "Service properties",
              "description": "Service properties",
              "$ref": "#/definitions/ProtonServiceProperties"
            }
          },
          "type": "object"
        }
      ],
      "description": "Node service properties",
      "title": "Node service properties"
    },
    "HostNode": {
      "allOf": [
        {
          "$ref": "#/definitions/Node"
        },
        {
          "required": [
            "os_type"
          ],
          "type": "object",
          "properties": {
            "os_version": {
              "type": "string",
              "description": "The version of the hypervisor operating system.",
              "title": "The version of the hypervisor operating system."
            },
            "os_type": {
              "enum": [
                "ESXI",
                "RHELKVM",
                "UBUNTUKVM",
                "HYPERV"
              ],
              "type": "string",
              "description": "Hypervisor type, for example ESXi or RHEL KVM.",
              "title": "Hypervisor type, for example ESXi or RHEL KVM."
            },
            "managed_by_server": {
              "readOnly": true,
              "type": "string",
              "description": "The id of the virtual center server managing the ESXi type HostNode.",
              "title": "The id of the virtual center server managing the ESXi type HostNode."
            },
            "host_credential": {
              "title": "Login credentials for the host",
              "description": "Login credentials for the host",
              "$ref": "#/definitions/HostNodeLoginCredential"
            },
            "discovered_node_id": {
              "readOnly": true,
              "type": "string",
              "description": "Id of the discovered node which was converted to create this node",
              "title": "Id of the discovered node which was converted to create this node"
            }
          }
        }
      ]
    },
    "NodeFileSystemProperties": {
      "properties": {
        "mount": {
          "readOnly": true,
          "type": "string",
          "description": "File system mount",
          "title": "File system mount"
        },
        "total": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "File system size in kilobytes",
          "title": "File system size in kilobytes"
        },
        "type": {
          "readOnly": true,
          "type": "string",
          "description": "File system type",
          "title": "File system type"
        },
        "file_system": {
          "readOnly": true,
          "type": "string",
          "description": "File system id",
          "title": "File system id"
        },
        "used": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Amount of file system used in kilobytes",
          "title": "Amount of file system used in kilobytes"
        }
      },
      "type": "object",
      "description": "File system properties",
      "title": "File system properties"
    },
    "LbHttpsMonitor": {
      "allOf": [
        {
          "$ref": "#/definitions/LbActiveMonitor"
        },
        {
          "type": "object",
          "properties": {
            "response_status_codes": {
              "items": {
                "type": "integer",
                "format": "int32"
              },
              "type": "array",
              "description": "The HTTP response status code should be a valid HTTP status code.\n",
              "maxItems": 64,
              "title": "Array of single HTTP response status codes"
            },
            "server_auth_crl_ids": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "A Certificate Revocation List (CRL) can be specified in the server-side\nSSL profile binding to disallow compromised server certificates.\n",
              "title": "CRL identifier list to verify server certificate"
            },
            "server_auth": {
              "description": "server authentication mode",
              "default": "IGNORE",
              "enum": [
                "REQUIRED",
                "IGNORE"
              ],
              "type": "string"
            },
            "request_body": {
              "type": "string",
              "description": "String to send as part of HTTP health check request body. Valid only\nfor certain HTTP methods like POST.\n",
              "title": "String to send as part of HTTP health check request body. Valid only\nfor certain HTTP methods like POST.\n"
            },
            "response_body": {
              "type": "string",
              "description": "If HTTP response body match string (regular expressions not supported)\nis specified (using LbHttpMonitor.response_body) then the\nhealthcheck HTTP response body is matched against the specified string\nand server is considered healthy only if there is a match.\nIf the response body string is not specified, HTTP healthcheck is\nconsidered successful if the HTTP response status code is 2xx, but it\ncan be configured to accept other status codes as successful.\n",
              "title": "response body to match"
            },
            "ciphers": {
              "items": {
                "enum": [
                  "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
                  "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
                  "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
                  "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
                  "TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA",
                  "TLS_ECDH_RSA_WITH_AES_256_CBC_SHA",
                  "TLS_RSA_WITH_AES_256_CBC_SHA",
                  "TLS_RSA_WITH_AES_128_CBC_SHA",
                  "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
                  "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
                  "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
                  "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384",
                  "TLS_RSA_WITH_AES_128_CBC_SHA256",
                  "TLS_RSA_WITH_AES_128_GCM_SHA256",
                  "TLS_RSA_WITH_AES_256_CBC_SHA256",
                  "TLS_RSA_WITH_AES_256_GCM_SHA384",
                  "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
                  "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
                  "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
                  "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384",
                  "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
                  "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA",
                  "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256",
                  "TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256",
                  "TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384",
                  "TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384",
                  "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA",
                  "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256",
                  "TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256",
                  "TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384",
                  "TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384"
                ],
                "type": "string",
                "description": "SSL cipher"
              },
              "type": "array",
              "description": "supported SSL cipher list to servers",
              "title": "supported SSL cipher list to servers"
            },
            "client_certificate_id": {
              "type": "string",
              "description": "client certificate can be specified to support client authentication.\n",
              "title": "client certificate identifier"
            },
            "request_method": {
              "description": "the health check method for HTTP monitor type",
              "default": "GET",
              "enum": [
                "GET",
                "OPTIONS",
                "POST",
                "HEAD",
                "PUT"
              ],
              "type": "string"
            },
            "certificate_chain_depth": {
              "description": "authentication depth is used to set the verification depth in the server\ncertificates chain.\n",
              "format": "int64",
              "default": 3,
              "title": "the maximum traversal depth of server certificate chain",
              "minimum": 1,
              "type": "integer"
            },
            "is_secure": {
              "readOnly": true,
              "type": "boolean",
              "description": "This flag is set to true when all the ciphers and protocols are secure.\nIt is set to false when one of the ciphers or protocols is insecure.\n",
              "title": "Secure/Insecure monitor flag"
            },
            "request_url": {
              "type": "string",
              "description": "URL used for HTTP monitor",
              "title": "URL used for HTTP monitor"
            },
            "server_auth_ca_ids": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "If server auth type is REQUIRED, server certificate must be signed by\none of the trusted Certificate Authorities (CAs), also referred to as\nroot CAs, whose self signed certificates are specified.\n",
              "title": "CA identifier list to verify server certificate"
            },
            "request_version": {
              "description": "HTTP request version",
              "default": "HTTP_VERSION_1_1",
              "enum": [
                "HTTP_VERSION_1_0",
                "HTTP_VERSION_1_1",
                "HTTP_VERSION_2_0"
              ],
              "type": "string"
            },
            "protocols": {
              "items": {
                "enum": [
                  "SSL_V2",
                  "SSL_V3",
                  "TLS_V1",
                  "TLS_V1_1",
                  "TLS_V1_2"
                ],
                "type": "string",
                "description": "SSL protocol"
              },
              "type": "array",
              "description": "SSL versions TLS1.1 and TLS1.2 are supported and enabled by default.\nSSLv2, SSLv3, and TLS1.0 are supported, but disabled by default.\n",
              "title": "supported SSL protocol list to servers"
            }
          }
        }
      ]
    },
    "AssociationListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/ResourceReference"
              },
              "type": "array",
              "description": "Paged Collection of ResourceReference",
              "title": "Paged Collection of ResourceReference"
            }
          }
        }
      ]
    },
    "MacRange": {
      "required": [
        "start",
        "end"
      ],
      "type": "object",
      "description": "A range of MAC addresses with a start and end value",
      "properties": {
        "start": {
          "description": "Start value for MAC address range",
          "pattern": "/^(([0-9A-Fa-f]{2}[:]){5}([0-9A-Fa-f]{2}))|(([0-9A-Fa-f]{2}[-]){5}([0-9A-Fa-f]{2}))$/",
          "readOnly": false,
          "type": "string"
        },
        "end": {
          "description": "End value for MAC address range",
          "pattern": "/^(([0-9A-Fa-f]{2}[:]){5}([0-9A-Fa-f]{2}))|(([0-9A-Fa-f]{2}[-]){5}([0-9A-Fa-f]{2}))$/",
          "readOnly": false,
          "type": "string"
        }
      }
    },
    "L4PortSetNSService": {
      "allOf": [
        {
          "$ref": "#/definitions/NSServiceElement"
        },
        {
          "properties": {
            "destination_ports": {
              "items": {
                "format": "port-or-range",
                "type": "string",
                "description": "Examples- Single port \"8080\", Range of ports \"8090-8095\"\n"
              },
              "type": "array",
              "maxItems": 15
            },
            "l4_protocol": {
              "enum": [
                "TCP",
                "UDP"
              ],
              "type": "string"
            },
            "source_ports": {
              "items": {
                "format": "port-or-range",
                "type": "string",
                "description": "Examples- Single port \"8080\", Range of ports \"8090-8095\"\n"
              },
              "type": "array",
              "maxItems": 15
            }
          },
          "required": [
            "l4_protocol"
          ],
          "type": "object"
        }
      ],
      "description": "L4PortSet can be specified in comma separated notation of parts. Parts of a\nL4PortSet includes single integer or range of port in hyphen notation.\nExample of a PortSet: \"22, 33-70, 44\".\n",
      "title": "An NSService element that represents TCP or UDP protocol"
    },
    "ClusterRoleConfig": {
      "type": "object",
      "properties": {
        "type": {
          "readOnly": true,
          "enum": [
            "ManagementClusterRoleConfig",
            "ControllerClusterRoleConfig"
          ],
          "type": "string",
          "description": "Type of this role configuration",
          "title": "Type of this role configuration"
        }
      }
    },
    "RemoteFilestoreBackupFile": {
      "allOf": [
        {
          "$ref": "#/definitions/BackupFile"
        },
        {
          "properties": {
            "port": {
              "description": "Server port",
              "format": "int64",
              "title": "Server port",
              "maximum": 65535,
              "minimum": 1,
              "type": "integer"
            },
            "protocol": {
              "description": "Protocol to use to copy file",
              "title": "Protocol to use to copy file"
            },
            "uri": {
              "type": "string",
              "description": "URI of file to copy",
              "title": "URI of file to copy"
            },
            "file_store": {
              "enum": [
                "remote"
              ],
              "type": "string",
              "description": "File location",
              "title": "File location"
            },
            "server": {
              "type": "string",
              "description": "Remote server hostname or IP address",
              "title": "Remote server hostname or IP address"
            }
          },
          "required": [
            "protocol",
            "uri",
            "file_store",
            "server"
          ],
          "type": "object"
        }
      ],
      "description": "Remote file store backup file properties",
      "title": "Remote file store backup file properties"
    },
    "IpPool": {
      "description": "A collection of one or more IPv4 or IPv6 subnets or ranges that are often not a contiguous address space. Clients are allocated IPs from an IP pool. Often used when a client that consumes addresses exhausts an initial subnet or range and needs to be expanded but the adjoining address space is not available as it has been allocated to a different client.",
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "type": "object",
          "properties": {
            "subnets": {
              "items": {
                "$ref": "#/definitions/IpPoolSubnet"
              },
              "type": "array",
              "description": "Subnets can be IPv4 or IPv6 and they should not overlap. The maximum number will not exceed 5 subnets.",
              "maxItems": 5,
              "title": "The collection of one or more subnet objects in a pool"
            },
            "pool_usage": {
              "readOnly": true,
              "title": "Pool usage statistics",
              "description": "Pool usage statistics",
              "$ref": "#/definitions/PoolUsage"
            }
          }
        }
      ]
    },
    "MACSet": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "mac_addresses": {
              "items": {
                "pattern": "/^(([0-9A-Fa-f]{2}[:]){5}([0-9A-Fa-f]{2}))|(([0-9A-Fa-f]{2}[-]){5}([0-9A-Fa-f]{2}))$/",
                "type": "string",
                "description": "A MAC address. Must be 6 pairs of hexadecimal digits, upper or lower case,\nseparated by colons or dashes. Examples: 01:23:45:67:89:ab, 01-23-45-67-89-AB.\n"
              },
              "type": "array",
              "description": "MAC addresses",
              "maxItems": 4000,
              "title": "MAC addresses"
            }
          },
          "type": "object"
        }
      ],
      "description": "MACSet is used to group individual MAC addresses. MACSets can be used as\nsources and destinations in layer2 firewall rules. These can also be used as\nmembers of NSGroups.\n",
      "title": "Set of one or more MAC addresses"
    },
    "RealizedNSGroupListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "title": "NSGroup list results",
                "$ref": "#/definitions/RealizedNSGroup"
              },
              "readOnly": true,
              "type": "array",
              "description": "Paged Collection of realized NSGroups",
              "title": "Paged Collection of realized NSGroups"
            }
          }
        }
      ]
    },
    "LogicalPortState": {
      "properties": {
        "transport_node_ids": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Identifiers of the transport node where the port is located",
          "title": "Identifiers of the transport node where the port is located"
        },
        "discovered_bindings": {
          "items": {
            "$ref": "#/definitions/AddressBindingEntry"
          },
          "type": "array",
          "description": "Logical port bindings discovered automatically",
          "title": "Logical port bindings discovered automatically"
        },
        "id": {
          "type": "string",
          "description": "Id of the logical port",
          "title": "Id of the logical port"
        },
        "realized_bindings": {
          "items": {
            "$ref": "#/definitions/AddressBindingEntry"
          },
          "type": "array",
          "description": "Realized logical port bindings",
          "title": "Realized logical port bindings"
        }
      },
      "required": [
        "id"
      ],
      "type": "object",
      "description": "Contians realized state of the logical port. For example, transport node\non which the port is located, discovered and realized address bindings of\nthe logical port.\n",
      "title": "Realized state of the logical port."
    },
    "IcmpEchoRequestHeader": {
      "type": "object",
      "properties": {
        "id": {
          "description": "ICMP id",
          "title": "ICMP id",
          "default": 0,
          "format": "int64",
          "maximum": 65535,
          "minimum": 0,
          "type": "integer"
        },
        "sequence": {
          "description": "ICMP sequence number",
          "title": "ICMP sequence number",
          "default": 0,
          "format": "int64",
          "maximum": 65535,
          "minimum": 0,
          "type": "integer"
        }
      }
    },
    "FirewallRule": {
      "allOf": [
        {
          "$ref": "#/definitions/EmbeddedResource"
        },
        {
          "required": [
            "action"
          ],
          "type": "object",
          "properties": {
            "is_default": {
              "readOnly": true,
              "type": "boolean",
              "description": "Flag to indicate whether rule is default.",
              "title": "Default rule"
            },
            "direction": {
              "description": "Rule direction in case of stateless firewall rules. This will only considered if section level parameter is set to stateless. Default to IN_OUT if not specified.",
              "title": "Rule direction",
              "default": "IN_OUT",
              "enum": [
                "IN",
                "OUT",
                "IN_OUT"
              ],
              "readOnly": false,
              "type": "string"
            },
            "rule_tag": {
              "readOnly": false,
              "maxLength": 32,
              "type": "string",
              "description": "User level field which will be printed in CLI and packet logs.",
              "title": "Tag"
            },
            "ip_protocol": {
              "description": "Type of IP packet that should be matched while enforcing the rule.",
              "title": "IPv4 vs IPv6 packet type",
              "default": "IPV4_IPV6",
              "enum": [
                "IPV4",
                "IPV6",
                "IPV4_IPV6"
              ],
              "readOnly": false,
              "type": "string"
            },
            "notes": {
              "readOnly": false,
              "maxLength": 2048,
              "type": "string",
              "description": "User notes specific to the rule.",
              "title": "Notes"
            },
            "applied_tos": {
              "description": "List of object where rule will be enforced. The section level field overrides this one. Null will be treated as any.",
              "title": "AppliedTo List",
              "items": {
                "$ref": "#/definitions/ResourceReference"
              },
              "readOnly": false,
              "maxItems": 128,
              "type": "array"
            },
            "logged": {
              "default": false,
              "readOnly": false,
              "type": "boolean",
              "description": "Flag to enable packet logging. Default is disabled.",
              "title": "Enable logging flag"
            },
            "disabled": {
              "default": false,
              "readOnly": false,
              "type": "boolean",
              "description": "Flag to disable rule. Disabled will only be persisted but never provisioned/realized.",
              "title": "Rule enable/disable flag"
            },
            "sources": {
              "description": "List of sources. Null will be treated as any.",
              "title": "Source List",
              "items": {
                "$ref": "#/definitions/ResourceReference"
              },
              "readOnly": false,
              "maxItems": 128,
              "type": "array"
            },
            "services": {
              "description": "List of the services. Null will be treated as any.",
              "title": "Service List",
              "items": {
                "$ref": "#/definitions/FirewallService"
              },
              "readOnly": false,
              "maxItems": 128,
              "type": "array"
            },
            "action": {
              "readOnly": false,
              "enum": [
                "ALLOW",
                "DROP",
                "REJECT"
              ],
              "type": "string",
              "description": "Action enforced on the packets which matches the firewall rule.",
              "title": "Action"
            },
            "sources_excluded": {
              "default": false,
              "readOnly": false,
              "type": "boolean",
              "description": "Negation of the source.",
              "title": "Negation of source"
            },
            "destinations_excluded": {
              "default": false,
              "readOnly": false,
              "type": "boolean",
              "description": "Negation of the destination.",
              "title": "Negation of destination"
            },
            "destinations": {
              "description": "List of the destinations. Null will be treated as any.",
              "title": "Destination List",
              "items": {
                "$ref": "#/definitions/ResourceReference"
              },
              "readOnly": false,
              "maxItems": 128,
              "type": "array"
            }
          }
        }
      ]
    },
    "TransportZoneProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "discriminator": "resource_type",
          "required": [
            "resource_type"
          ],
          "type": "object",
          "properties": {
            "resource_type": {
              "enum": [
                "BfdHealthMonitoringProfile"
              ],
              "type": "string"
            }
          }
        }
      ]
    },
    "LbPassiveMonitor": {
      "allOf": [
        {
          "$ref": "#/definitions/LbMonitor"
        },
        {
          "type": "object",
          "properties": {
            "max_fails": {
              "description": "When the consecutive failures reach this value, then the member is\nconsidered temporarily unavailable for a configurable period\n",
              "format": "int64",
              "default": 5,
              "title": "number of consecutive connection failures",
              "minimum": 1,
              "type": "integer"
            },
            "timeout": {
              "description": "After this timeout period, the member is tried again for a new\nconnection to see if it is available.\n",
              "format": "int64",
              "default": 5,
              "title": "timeout in seconds before it is selected again for a new connection",
              "minimum": 1,
              "type": "integer"
            }
          }
        }
      ]
    },
    "LabelValueConfiguration": {
      "allOf": [
        {
          "$ref": "#/definitions/WidgetConfiguration"
        },
        {
          "properties": {
            "navigation": {
              "type": "string",
              "description": "Hyperlink of the specified UI page that provides details.",
              "title": "Navigation to a specified UI page"
            },
            "properties": {
              "items": {
                "$ref": "#/definitions/PropertyItem"
              },
              "type": "array",
              "description": "An array of label-value properties.",
              "title": "Rows"
            }
          },
          "required": [
            "properties"
          ],
          "type": "object"
        }
      ],
      "description": "Represents a Label-Value widget configuration",
      "title": "Label Value Dashboard Widget Configuration"
    },
    "SnmpServiceProperties": {
      "properties": {
        "communities": {
          "items": {
            "$ref": "#/definitions/SnmpCommunity"
          },
          "type": "array",
          "description": "SNMP v1, v2c community",
          "maxItems": 1,
          "title": "SNMP v1, v2c community"
        },
        "start_on_boot": {
          "type": "boolean",
          "description": "Start when system boots",
          "title": "Start when system boots"
        }
      },
      "required": [
        "start_on_boot"
      ],
      "type": "object",
      "description": "SNMP Service properties",
      "title": "SNMP Service properties"
    },
    "PolicyTemplateParameter": {
      "properties": {
        "parameter_id": {
          "type": "string",
          "description": "Parameter id",
          "title": "Parameter id"
        },
        "parameter_value": {
          "type": "string",
          "description": "Parameter value",
          "title": "Parameter value"
        }
      },
      "required": [
        "parameter_id",
        "parameter_value"
      ],
      "type": "object",
      "description": "Policy template parameter",
      "title": "Policy template parameter"
    },
    "FirewallRuleListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/FirewallRule"
              },
              "readOnly": true,
              "type": "array",
              "description": "Firewall rule list result with pagination support.",
              "title": "Firewall rule list result"
            }
          }
        }
      ]
    },
    "RemoteFileServer": {
      "properties": {
        "directory_path": {
          "type": "string",
          "description": "Remote server directory to copy bundle files to",
          "title": "Remote server directory to copy bundle files to"
        },
        "protocol": {
          "title": "Protocol to use to copy file",
          "description": "Protocol to use to copy file",
          "$ref": "#/definitions/FileTransferProtocol"
        },
        "port": {
          "description": "Server port",
          "title": "Server port",
          "default": 22,
          "format": "int64",
          "maximum": 65535,
          "minimum": 1,
          "type": "integer"
        },
        "server": {
          "format": "hostname-or-ip",
          "type": "string",
          "description": "Remote server hostname or IP address",
          "title": "Remote server hostname or IP address"
        }
      },
      "required": [
        "directory_path",
        "protocol",
        "port",
        "server"
      ],
      "type": "object",
      "description": "Remote file server",
      "title": "Remote file server"
    },
    "ServiceEndpoint": {
      "required": [
        "ip_address",
        "port"
      ],
      "type": "object",
      "properties": {
        "certificate_sha256_thumbprint": {
          "readOnly": true,
          "type": "string"
        },
        "ip_address": {
          "format": "ip",
          "type": "string",
          "description": "IPv4 or IPv6 address"
        },
        "fqdn": {
          "readOnly": true,
          "type": "string"
        },
        "certificate": {
          "type": "string"
        },
        "port": {
          "minimum": 0,
          "type": "integer",
          "maximum": 65535,
          "format": "int64"
        }
      }
    },
    "NestedExpression": {
      "allOf": [
        {
          "$ref": "#/definitions/Expression"
        },
        {
          "properties": {
            "expressions": {
              "items": {
                "$ref": "#/definitions/Expression"
              },
              "type": "array",
              "description": "Expression",
              "title": "Expression"
            }
          },
          "type": "object"
        }
      ],
      "description": "NestedExpression",
      "title": "NestedExpression"
    },
    "HostSwitchSpec": {
      "description": "The HostSwitchSpec is the base class for standard and preconfigured\nhost switch specifications.\n",
      "title": "Abstract base type for transport node host switch specification",
      "required": [
        "resource_type"
      ],
      "discriminator": "resource_type",
      "type": "object",
      "properties": {
        "resource_type": {
          "enum": [
            "StandardHostSwitchSpec",
            "PreconfiguredHostSwitchSpec"
          ],
          "type": "string"
        }
      }
    },
    "BgpNeighborAddressFamily": {
      "required": [
        "type"
      ],
      "type": "object",
      "properties": {
        "in_filter_ipprefixlist_id": {
          "type": "string",
          "description": "Id of the IPPrefix List to be used for IN direction filter",
          "title": "Id of the IPPrefix List to be used for IN direction filter"
        },
        "out_filter_routemap_id": {
          "type": "string",
          "description": "Id of the RouteMap to be used for OUT direction filter",
          "title": "Id of the RouteMap to be used for OUT direction filter"
        },
        "type": {
          "type": "string",
          "description": "Address family type",
          "enum": [
            "IPV4_UNICAST",
            "VPNV4_UNICAST"
          ]
        },
        "in_filter_routemap_id": {
          "type": "string",
          "description": "Id of the RouteMap to be used for IN direction filter",
          "title": "Id of the RouteMap to be used for IN direction filter"
        },
        "enabled": {
          "default": true,
          "type": "boolean",
          "description": "Enable this address family",
          "title": "Enable this address family"
        },
        "out_filter_ipprefixlist_id": {
          "type": "string",
          "description": "Id of the IPPrefixList to be used for OUT direction filter",
          "title": "Id of the IPPrefixList to be used for OUT direction filter"
        }
      }
    },
    "Group": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "properties": {
            "state": {
              "enum": [
                "IN_PROGRESS",
                "SUCCESS",
                "FAILURE"
              ],
              "type": "string",
              "description": "Realization state of this group",
              "title": "Realization state of this group"
            },
            "expression": {
              "items": {
                "$ref": "#/definitions/Expression"
              },
              "type": "array",
              "description": "Expression",
              "title": "Expression"
            }
          },
          "type": "object"
        }
      ],
      "description": "Group",
      "title": "Group"
    },
    "Certificate": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "pem_encoded"
          ],
          "type": "object",
          "properties": {
            "used_by": {
              "items": {
                "$ref": "#/definitions/NodeIdServicesMap"
              },
              "readOnly": true,
              "type": "array",
              "description": "list of node IDs with services, that are using this certificate"
            },
            "details": {
              "items": {
                "$ref": "#/definitions/X509Certificate"
              },
              "readOnly": true,
              "type": "array",
              "description": "list of X509Certificates"
            },
            "pem_encoded": {
              "readOnly": false,
              "type": "string",
              "description": "pem encoded certificate data"
            }
          }
        }
      ]
    },
    "UpgradeUnitListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/UpgradeUnit"
              },
              "type": "array",
              "description": "Paged Collection of Upgrade units",
              "title": "Paged Collection of Upgrade units"
            }
          }
        }
      ]
    },
    "NatStatisticsPerRule": {
      "allOf": [
        {
          "$ref": "#/definitions/NatCounters"
        },
        {
          "type": "object",
          "properties": {
            "last_update_timestamp": {
              "readOnly": true,
              "type": "integer",
              "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
              "format": "int64"
            },
            "logical_router_id": {
              "readOnly": true,
              "type": "string",
              "description": "The id of the logical router which owns the NAT rule.",
              "title": "The id of the logical router which owns the NAT rule."
            },
            "id": {
              "readOnly": true,
              "type": "string",
              "description": "The id of the NAT rule.",
              "title": "The id of the NAT rule."
            }
          }
        }
      ]
    },
    "AppDiscoverySession": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "status": {
              "readOnly": true,
              "enum": [
                "FAILED",
                "RUNNING",
                "FINISHED"
              ],
              "type": "string",
              "description": "The status of the session",
              "title": "The status of the session"
            },
            "start_timestamp": {
              "type": "integer",
              "description": "Start time of the session expressed in milliseconds since epoch",
              "format": "int64"
            },
            "end_timestamp": {
              "type": "integer",
              "description": "End time of the session expressed in milliseconds since epoch",
              "format": "int64"
            },
            "reclassification": {
              "readOnly": true,
              "enum": [
                "NOT_REQUIRED",
                "REQUIRED"
              ],
              "type": "string",
              "description": "Some App Profiles that were part of the discovery session could be modified or deleted |\nafter the session has been completed. NOT_REQUIRED status denotes that there were no such modifications. |\nREQUIRED status denotes some App Profiles that were part of the session has been modified/deleted and some |\nand some applications might not have been classfifed correctly. Use /session/<session-id>/reclassify API to|\nre-classfy the applications discovered based on app profiles.\n",
              "title": "The reclassification status of the discovery session"
            }
          },
          "type": "object"
        }
      ],
      "description": "Contains the details of an application discovery session\n",
      "title": "Contains the details of an application discovery session"
    },
    "TunnelList": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "tunnels": {
              "items": {
                "$ref": "#/definitions/TunnelProperties"
              },
              "readOnly": true,
              "type": "array",
              "description": "List of transport node tunnels",
              "title": "List of transport node tunnels"
            }
          }
        }
      ]
    },
    "PoolMember": {
      "required": [
        "ip_address"
      ],
      "type": "object",
      "properties": {
        "max_concurrent_connections": {
          "format": "int64",
          "minimum": 1,
          "type": "integer",
          "description": "To ensure members are not overloaded, connections to a member can be\ncapped by the load balancer. When a member reaches this limit, it is\nskipped during server selection.\nIf it is not specified, it means that connections are unlimited.\n",
          "title": "maximum concurrent connection number"
        },
        "admin_state": {
          "description": "member admin state",
          "default": "ENABLED",
          "enum": [
            "ENABLED",
            "DISABLED",
            "GRACEFUL_DISABLED"
          ],
          "type": "string"
        },
        "backup_member": {
          "default": false,
          "type": "boolean",
          "description": "Backup servers are typically configured with a sorry page indicating to\nthe user that the application is currently unavailable. While the pool\nis active (a specified minimum number of pool members are active)\nBACKUP members are skipped during server selection. When the pool is\ninactive, incoming connections are sent to only the BACKUP member(s).\n",
          "title": "determine whether the pool member is for backup usage"
        },
        "weight": {
          "description": "Pool member weight is used for WEIGHTED_ROUND_ROBIN balancing\nalgorithm. The weight value would be ignored in other algorithms.\n",
          "title": "pool member weight",
          "default": 1,
          "format": "int64",
          "maximum": 255,
          "minimum": 1,
          "type": "integer"
        },
        "display_name": {
          "type": "string",
          "description": "pool member name",
          "title": "pool member name"
        },
        "ip_address": {
          "format": "ip",
          "type": "string",
          "description": "pool member IP address"
        },
        "port": {
          "format": "port-or-range",
          "type": "string",
          "description": "If port is specified, all connections will be sent to this port. Only\nsingle port is supported.\nIf unset, the same port the client connected to will be used, it could\nbe overrode by default_pool_member_port setting in virtual server.\nThe port should not specified for port range case.\n"
        }
      }
    },
    "FailedNodeSupportBundleResult": {
      "type": "object",
      "properties": {
        "node_display_name": {
          "readOnly": true,
          "type": "string",
          "description": "Display name of node",
          "title": "Display name of node"
        },
        "node_id": {
          "readOnly": true,
          "type": "string",
          "description": "UUID of node",
          "title": "UUID of node"
        },
        "error_code": {
          "readOnly": true,
          "type": "string",
          "description": "Error code",
          "title": "Error code"
        },
        "error_message": {
          "readOnly": true,
          "type": "string",
          "description": "Error message",
          "title": "Error message"
        }
      }
    },
    "LbRuleListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LbRule"
              },
              "type": "array",
              "description": "paginated list of LB rules",
              "title": "paginated list of LB rules"
            }
          }
        }
      ]
    },
    "ServiceBinding": {
      "required": [
        "service_id"
      ],
      "type": "object",
      "properties": {
        "service_id": {
          "title": "UUID of Service",
          "description": "Identifier of Logical Service",
          "$ref": "#/definitions/ResourceReference"
        }
      }
    },
    "NSGroupExpressionList": {
      "properties": {
        "members": {
          "items": {
            "$ref": "#/definitions/NSGroupExpression"
          },
          "type": "array",
          "description": "List of NSGroupExpressions to be passed to add and remove APIs\n",
          "maxItems": 500,
          "title": "List of NSGroupExpressions to be passed to add and remove APIs\n"
        }
      },
      "required": [
        "members"
      ],
      "type": "object",
      "description": "List of NSGroupExpressions",
      "title": "List of NSGroupExpressions"
    },
    "SelfResourceLink": {
      "allOf": [
        {
          "$ref": "#/definitions/ResourceLink"
        },
        {
          "type": "object"
        }
      ],
      "description": "The server will populate this field when returing the resource. Ignored on PUT and POST.",
      "title": "Link to this resource"
    },
    "DeleteRequestParameters": {
      "type": "object",
      "properties": {
        "force": {
          "default": false,
          "type": "boolean",
          "description": "If true, deleting the resource succeeds even if it is being\nreferred as a resource reference.\n",
          "title": "Force delete the resource even if it is being used somewhere\n"
        }
      }
    },
    "Node": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "discriminator": "resource_type",
          "required": [
            "resource_type"
          ],
          "type": "object",
          "properties": {
            "discovered_ip_addresses": {
              "items": {
                "format": "ip",
                "type": "string",
                "description": "IPv4 or IPv6 address"
              },
              "readOnly": true,
              "type": "array",
              "description": "Discovered IP Addresses of the fabric node, version 4 or 6",
              "title": "Discovered IP Addresses of the fabric node, version 4 or 6"
            },
            "ip_addresses": {
              "items": {
                "format": "ip",
                "type": "string",
                "description": "IPv4 or IPv6 address"
              },
              "type": "array",
              "description": "IP Addresses of the Node, version 4 or 6. This property is mandatory for all nodes except for\nautomatic deployment of edge virtual machine node. For automatic deployment, the ip address from\nmanagement_port_subnets property will be considered.\n",
              "title": "IP Addresses of the Node, version 4 or 6"
            },
            "external_id": {
              "type": "string",
              "description": "ID of the Node maintained on the Node and used to recognize the Node",
              "title": "ID of the Node maintained on the Node and used to recognize the Node"
            },
            "fqdn": {
              "readOnly": true,
              "type": "string",
              "description": "Fully qualified domain name of the fabric node",
              "title": "Fully qualified domain name of the fabric node"
            },
            "resource_type": {
              "type": "string",
              "description": "Fabric node type, for example 'HostNode', 'EdgeNode' or 'PublicCloudGatewayNode'",
              "title": "Fabric node type, for example 'HostNode', 'EdgeNode' or 'PublicCloudGatewayNode'"
            }
          }
        }
      ]
    },
    "ClusterNodeStatus": {
      "type": "object",
      "properties": {
        "system_status": {
          "readOnly": true,
          "title": "Node status properties",
          "description": "Node status properties",
          "$ref": "#/definitions/NodeStatusProperties"
        },
        "mgmt_cluster_status": {
          "readOnly": true,
          "title": "Clustering status for management plane functions on this node",
          "description": "Clustering status for management plane functions on this node",
          "$ref": "#/definitions/ManagementClusterNodeStatus"
        },
        "version": {
          "readOnly": true,
          "type": "string",
          "description": "Software version running on node",
          "title": "Software version running on node"
        },
        "control_cluster_status": {
          "readOnly": true,
          "title": "Clustering status for control plane functions on this node",
          "description": "Clustering status for control plane functions on this node",
          "$ref": "#/definitions/ControlClusterNodeStatus"
        }
      }
    },
    "DneCertificate": {
      "type": "object",
      "properties": {
        "uuid": {
          "type": "string",
          "description": "this is the uuid of this mp node",
          "title": "the uuid of this mp node"
        },
        "certificate": {
          "type": "string",
          "description": "the dne specified certificate of this mp node",
          "title": "the dne specified certificate of this mp node"
        }
      }
    },
    "SshKeyBaseProperties": {
      "required": [
        "label"
      ],
      "type": "object",
      "properties": {
        "password": {
          "type": "string",
          "description": "Current password for user (required for users root and admin)",
          "title": "Current password for user (required for users root and admin)"
        },
        "label": {
          "type": "string",
          "description": "SSH key label (used to identify the key)",
          "title": "SSH key label (used to identify the key)"
        }
      }
    },
    "AddManagementNodeSpec": {
      "required": [
        "type",
        "password",
        "user_name",
        "remote_address"
      ],
      "type": "object",
      "properties": {
        "mpa_msg_client_info": {
          "$ref": "#/definitions/MsgClientInfo"
        },
        "type": {
          "readOnly": false,
          "enum": [
            "AddManagementNodeSpec"
          ],
          "type": "string",
          "description": "must be set to AddManagementNodeSpec",
          "title": "must be set to AddManagementNodeSpec"
        },
        "password": {
          "readOnly": false,
          "type": "string",
          "description": "The password to be used to authenticate with the remote node.",
          "title": "The password to be used to authenticate with the remote node."
        },
        "user_name": {
          "readOnly": false,
          "type": "string",
          "description": "The username to be used to authenticate with the remote node.",
          "title": "The username to be used to authenticate with the remote node."
        },
        "remote_address": {
          "description": "The host address of the remote node to which to send this join request.",
          "format": "ip",
          "readOnly": false,
          "type": "string"
        },
        "cert_thumbprint": {
          "readOnly": false,
          "type": "string",
          "description": "The certificate thumbprint of the remote node.",
          "title": "The certificate thumbprint of the remote node."
        }
      }
    },
    "AwsVirtualMachine": {
      "allOf": [
        {
          "$ref": "#/definitions/CloudVirtualMachine"
        },
        {
          "type": "object",
          "properties": {
            "vpc_name": {
              "readOnly": true,
              "type": "string",
              "description": "VPC name of the virtual machine",
              "title": "VPC name of the virtual machine"
            },
            "region": {
              "readOnly": true,
              "type": "string",
              "description": "Region of the virtual machine",
              "title": "Region of the virtual machine"
            },
            "power_state": {
              "readOnly": true,
              "enum": [
                "PENDING",
                "RUNNING",
                "SHUTTING_DOWN",
                "TERMINATED",
                "STOPPING",
                "STOPPED"
              ],
              "type": "string",
              "description": "Indicates the power state of the virutal machine as returned by AWS.\n",
              "title": "Power State"
            },
            "vpc": {
              "readOnly": true,
              "type": "string",
              "description": "VPC id of the virtual machine",
              "title": "VPC id of the virtual machine"
            },
            "availability_zone": {
              "readOnly": true,
              "type": "string",
              "description": "Availability Zone of the virtual machine",
              "title": "Availability Zone of the virtual machine"
            }
          }
        }
      ]
    },
    "EnforcementPointListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/EnforcementPoint"
              },
              "type": "array",
              "description": "EnforcementPoint list results",
              "title": "EnforcementPoint list results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Paged collection of enforcement points",
      "title": "Paged Collection of EnforcementPoints"
    },
    "TraceflowListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/Traceflow"
              },
              "readOnly": true,
              "type": "array",
              "description": "Traceflow Results",
              "title": "Traceflow Results"
            }
          },
          "type": "object"
        }
      ],
      "description": "Traceflow queries result",
      "title": "Traceflow queries result"
    },
    "StaticIpPoolSpec": {
      "allOf": [
        {
          "$ref": "#/definitions/IpAssignmentSpec"
        },
        {
          "properties": {
            "ip_pool_id": {
              "readOnly": false,
              "type": "string"
            }
          },
          "required": [
            "ip_pool_id"
          ],
          "type": "object"
        }
      ],
      "description": "IP assignment specification for Static IP Pool.",
      "title": "IP assignment specification for Static IP Pool."
    },
    "TunnelProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "type": "object",
          "properties": {
            "status": {
              "readOnly": true,
              "enum": [
                "UP",
                "DOWN",
                "UNKNOWN"
              ],
              "type": "string",
              "description": "Status of tunnel",
              "title": "Status of tunnel"
            },
            "egress_interface": {
              "readOnly": true,
              "type": "string",
              "description": "Corresponds to the interface where local_ip_address is routed.",
              "title": "Name of local transport interface carrying tunnel traffic"
            },
            "remote_node_display_name": {
              "readOnly": true,
              "type": "string",
              "description": "Represents the display name of the remote transport node at the other end of the tunnel.",
              "title": "Display name of the remote transport node"
            },
            "remote_node_id": {
              "readOnly": true,
              "type": "string",
              "description": "UUID of the remote transport node",
              "title": "UUID of the remote transport node"
            },
            "encap": {
              "readOnly": true,
              "enum": [
                "STT",
                "VXLAN",
                "GENEVE",
                "UNKNOWN_ENCAP"
              ],
              "type": "string",
              "description": "Tunnel encap",
              "title": "Tunnel encap"
            },
            "bfd": {
              "readOnly": true,
              "title": "Detailed information about BFD configured on interface",
              "description": "Detailed information about BFD configured on interface",
              "$ref": "#/definitions/BFDProperties"
            },
            "name": {
              "readOnly": true,
              "type": "string",
              "description": "Name of tunnel",
              "title": "Name of tunnel"
            },
            "local_ip": {
              "readOnly": true,
              "format": "ip",
              "type": "string",
              "description": "Local IP address of tunnel",
              "title": "Local IP address of tunnel"
            },
            "last_updated_time": {
              "readOnly": true,
              "type": "integer",
              "description": "Time at which the Tunnel status has been fetched last time.",
              "format": "int64"
            },
            "remote_ip": {
              "readOnly": true,
              "format": "ip",
              "type": "string",
              "description": "Remote IP address of tunnel",
              "title": "Remote IP address of tunnel"
            }
          }
        }
      ]
    },
    "IpDiscoverySwitchingProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/BaseSwitchingProfile"
        },
        {
          "type": "object",
          "properties": {
            "arp_snooping_enabled": {
              "default": true,
              "readOnly": false,
              "type": "boolean",
              "description": "Indicates whether ARP snooping is enabled",
              "title": "Indicates whether ARP snooping is enabled"
            },
            "arp_bindings_limit": {
              "description": "Indicates the number of arp snooped IP addresses to be remembered per LogicalPort. Decreasing this value, will retain the latest bindings from the existing list of address bindings. Increasing this value will retain existing bindings and also learn any new address bindings discovered on the port until the new limit is reached.",
              "title": "Number of arp snooped IP addresses",
              "default": 1,
              "format": "int32",
              "maximum": 128,
              "minimum": 1,
              "type": "integer"
            },
            "vm_tools_enabled": {
              "default": false,
              "readOnly": false,
              "type": "boolean",
              "description": "This option is only supported on ESX where vm-tools is installed.",
              "title": "Indicates whether fetching IP using vm-tools is enabled"
            },
            "dhcp_snooping_enabled": {
              "default": true,
              "readOnly": false,
              "type": "boolean",
              "description": "Indicates whether DHCP snooping is enabled",
              "title": "Indicates whether DHCP snooping is enabled"
            }
          }
        }
      ]
    },
    "FirewallStatsList": {
      "type": "object",
      "properties": {
        "result_count": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Total count for firewall rule statistics in results set",
          "title": "Firewall Rules stats count"
        },
        "section_id": {
          "readOnly": true,
          "type": "string",
          "description": "Corresponding firewall section identifier for list of rule statistics",
          "title": "Firewall Section ID"
        },
        "results": {
          "description": "List of rule statistics",
          "title": "Firewall Rules stats",
          "items": {
            "$ref": "#/definitions/FirewallStats"
          },
          "readOnly": true,
          "maxItems": 1000,
          "type": "array"
        }
      }
    },
    "EdgeHighAvailabilityProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/ClusterProfile"
        },
        {
          "properties": {
            "bfd_declare_dead_multiple": {
              "description": "Number of times a packet is missed before BFD declares the neighbor down.",
              "title": "Number of times a packet is missed before BFD declares the neighbor down.",
              "default": 3,
              "format": "int64",
              "maximum": 16,
              "minimum": 2,
              "type": "integer"
            },
            "bfd_probe_interval": {
              "description": "the time interval (in millisec) between probe packets for heartbeat purpose",
              "title": "the time interval (in millisec) between probe packets for heartbeat purpose",
              "default": 1000,
              "format": "int64",
              "maximum": 60000,
              "minimum": 300,
              "type": "integer"
            },
            "bfd_allowed_hops": {
              "description": "BFD allowed hops",
              "title": "BFD allowed hops",
              "default": 255,
              "format": "int64",
              "maximum": 255,
              "minimum": 1,
              "type": "integer"
            }
          },
          "type": "object"
        }
      ],
      "description": "Profile for BFD HA cluster setting",
      "title": "Profile for BFD HA cluster setting"
    },
    "NodeRouteProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "src": {
              "type": "string",
              "description": "Source address to prefer when sending to destinations of route",
              "title": "Source address to prefer when sending to destinations of route"
            },
            "from_address": {
              "type": "string",
              "description": "From address",
              "title": "From address"
            },
            "proto": {
              "default": "boot",
              "enum": [
                "unspec",
                "redirect",
                "kernel",
                "boot",
                "static",
                "gated",
                "ra",
                "mrt",
                "zebra",
                "bird",
                "dnrouted",
                "xorp",
                "ntk",
                "dhcp"
              ],
              "type": "string",
              "description": "Routing protocol identifier of route",
              "title": "Routing protocol identifier of route"
            },
            "route_type": {
              "enum": [
                "default",
                "static",
                "blackhole",
                "prohibit",
                "throw",
                "unreachable"
              ],
              "type": "string",
              "description": "Route type",
              "title": "Route type"
            },
            "metric": {
              "type": "string",
              "description": "Metric value of route",
              "title": "Metric value of route"
            },
            "destination": {
              "type": "string",
              "description": "Destination covered by route",
              "title": "Destination covered by route"
            },
            "interface_id": {
              "type": "string",
              "description": "Network interface id of route",
              "title": "Network interface id of route"
            },
            "route_id": {
              "readOnly": true,
              "type": "string",
              "description": "Unique identifier for the route",
              "title": "Unique identifier for the route"
            },
            "netmask": {
              "type": "string",
              "description": "Netmask of destination covered by route",
              "title": "Netmask of destination covered by route"
            },
            "scope": {
              "type": "string",
              "description": "Scope of destinations covered by route",
              "title": "Scope of destinations covered by route"
            },
            "gateway": {
              "type": "string",
              "description": "Address of next hop",
              "title": "Address of next hop"
            }
          },
          "required": [
            "route_type"
          ],
          "type": "object"
        }
      ],
      "description": "Node network route properties",
      "title": "Node network route properties"
    },
    "MacTableEntry": {
      "required": [
        "mac_address"
      ],
      "type": "object",
      "properties": {
        "vtep_mac_address": {
          "type": "string",
          "description": "The virtual tunnel endpoint MAC address",
          "title": "The virtual tunnel endpoint MAC address"
        },
        "vtep_ip": {
          "format": "ip",
          "type": "string",
          "description": "The virtual tunnel endpoint IP address"
        },
        "mac_address": {
          "type": "string",
          "description": "The MAC address",
          "title": "The MAC address"
        }
      }
    },
    "AdvanceClusterRestoreRequest": {
      "required": [
        "data"
      ],
      "type": "object",
      "properties": {
        "data": {
          "items": {
            "$ref": "#/definitions/AdvanceClusterRestoreInput"
          },
          "type": "array",
          "description": "List of instructions and their associated data",
          "title": "List of instructions and their associated data"
        }
      }
    },
    "LogicalPortAttachment": {
      "properties": {
        "attachment_type": {
          "description": "Indicates the type of logical port attachment. By default it is Virtual Machine interface (VIF)",
          "default": "VIF",
          "enum": [
            "VIF",
            "LOGICALROUTER",
            "BRIDGEENDPOINT",
            "DHCP_SERVICE",
            "METADATA_PROXY"
          ],
          "type": "string"
        },
        "context": {
          "title": "Attachment context",
          "description": "Extra context data for the attachment",
          "$ref": "#/definitions/AttachmentContext"
        },
        "id": {
          "type": "string",
          "description": "Identifier of the interface attached to the logical port",
          "title": "Identifier of the interface attached to the logical port"
        }
      },
      "required": [
        "id"
      ],
      "type": "object",
      "description": "Logical port attachment",
      "title": "Logical port attachment"
    },
    "UdpHeader": {
      "type": "object",
      "properties": {
        "src_port": {
          "description": "Source port of udp header",
          "title": "Source port of udp header",
          "default": 0,
          "format": "int64",
          "maximum": 65535,
          "minimum": 0,
          "type": "integer"
        },
        "dst_port": {
          "description": "Destination port of udp header",
          "title": "Destination port of udp header",
          "default": 0,
          "format": "int64",
          "maximum": 65535,
          "minimum": 0,
          "type": "integer"
        }
      }
    },
    "NodeUserProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "username": {
              "minLength": 1,
              "maxLength": 32,
              "type": "string",
              "description": "User login name (must be \"root\" if userid is 0)",
              "title": "User login name (must be \"root\" if userid is 0)"
            },
            "password": {
              "type": "string",
              "description": "Password for the user (optionally specified on PUT, unspecified on GET)",
              "title": "Password for the user (optionally specified on PUT, unspecified on GET)"
            },
            "userid": {
              "description": "Numeric id for the user",
              "title": "Numeric id for the user",
              "format": "int64",
              "maximum": 2147483647,
              "readOnly": true,
              "minimum": 0,
              "type": "integer"
            },
            "old_password": {
              "type": "string",
              "description": "Old password for the user (required on PUT if password specified)",
              "title": "Old password for the user (required on PUT if password specified)"
            },
            "full_name": {
              "type": "string",
              "description": "Full name for the user",
              "title": "Full name for the user"
            }
          },
          "type": "object"
        }
      ],
      "description": "Node user properties",
      "title": "Node user properties"
    },
    "MirrorDestination": {
      "discriminator": "resource_type",
      "required": [
        "resource_type"
      ],
      "type": "object",
      "properties": {
        "resource_type": {
          "enum": [
            "LogicalPortMirrorDestination",
            "PnicMirrorDestination"
          ],
          "type": "string",
          "description": "Resource types of mirror destination"
        }
      }
    },
    "BFDDiagnosticCount": {
      "type": "object",
      "properties": {
        "concatenated_path_down_count": {
          "format": "int64",
          "type": "integer",
          "description": "Number of tunnels with concatenated path down diagnostic message",
          "title": "Number of tunnels with concatenated path down diagnostic message"
        },
        "administratively_down_count": {
          "format": "int64",
          "type": "integer",
          "description": "Number of tunnels with administratively down diagnostic message",
          "title": "Number of tunnels with administratively down diagnostic message"
        },
        "no_diagnostic_count": {
          "format": "int64",
          "type": "integer",
          "description": "Number of tunnels with no diagnostic",
          "title": "Number of tunnels with no diagnostic"
        },
        "path_down_count": {
          "format": "int64",
          "type": "integer",
          "description": "Number of tunnels with path down diagnostic message",
          "title": "Number of tunnels with path down diagnostic message"
        },
        "reverse_concatenated_path_down_count": {
          "format": "int64",
          "type": "integer",
          "description": "Number of tunnels with reverse concatenated path down diagnostic message",
          "title": "Number of tunnels with reverse concatenated path down diagnostic message"
        },
        "neighbor_signaled_session_down_count": {
          "format": "int64",
          "type": "integer",
          "description": "Number of tunnels neighbor signaled session down",
          "title": "Number of tunnels neighbor signaled session down"
        },
        "control_detection_time_expired_count": {
          "format": "int64",
          "type": "integer",
          "description": "Number of tunnels with control detection time expired diagnostic message",
          "title": "Number of tunnels with control detection time expired diagnostic message"
        },
        "echo_function_failed_count": {
          "format": "int64",
          "type": "integer",
          "description": "Number of tunnels with echo function failed diagnostic message",
          "title": "Number of tunnels with echo function failed diagnostic message"
        },
        "forwarding_plane_reset_count": {
          "format": "int64",
          "type": "integer",
          "description": "Number of tunnels with forwarding plane reset diagnostic message",
          "title": "Number of tunnels with forwarding plane reset diagnostic message"
        }
      }
    },
    "RenderConfiguration": {
      "properties": {
        "color": {
          "enum": [
            "GREY",
            "SKY_BLUE",
            "BLUE",
            "GREEN",
            "YELLOW",
            "RED"
          ],
          "type": "string",
          "description": "The color to use when rendering an entity. For example, set color as 'RED' to render a portion of donut in red.",
          "title": "Color of the entity"
        },
        "condition": {
          "type": "string",
          "description": "If the condition is met then the rendering specified for the condition will be applied. Examples of expression syntax are provided under 'example_request' section of 'CreateWidgetConfiguration' API.",
          "title": "Expression for evaluating condition"
        },
        "display_value": {
          "type": "string",
          "description": "If specified, overrides the field value. This can be used to display a meaningful value in situations where field value is not available or not configured.",
          "title": "Overridden value to display, if any"
        },
        "tooltip": {
          "minItems": 0,
          "items": {
            "$ref": "#/definitions/Tooltip"
          },
          "type": "array",
          "description": "Text to be shown on tooltip while hovering over the UI element if the condition is met.",
          "title": "Tooltip"
        },
        "icons": {
          "minItems": 0,
          "items": {
            "$ref": "#/definitions/Icon"
          },
          "type": "array",
          "description": "Icons to be applied at dashboard for widgets and UI elements.",
          "title": "Icons"
        }
      },
      "type": "object",
      "description": "Render configuration to be applied to the widget.",
      "title": "Render Configuration"
    },
    "PortConnectionEntity": {
      "properties": {
        "resource": {
          "readOnly": true,
          "title": "Resource reference with details of the entity",
          "description": "Resource reference with details of the entity",
          "$ref": "#/definitions/ManagedResource"
        },
        "id": {
          "readOnly": true,
          "type": "string",
          "description": "Resource ID is mapped to this. (ID is Generated for Edge node groups, since resource will be null)",
          "title": "Resource ID is mapped to this. (ID is Generated for Edge node groups, since resource will be null)"
        }
      },
      "type": "object",
      "description": "Port Connection Entity",
      "title": "Port Connection Entity"
    },
    "LbSelectServerAction": {
      "allOf": [
        {
          "$ref": "#/definitions/LbRuleAction"
        },
        {
          "properties": {
            "ip": {
              "format": "ip",
              "type": "string",
              "description": "IP address of selected backend server"
            },
            "pool_id": {
              "type": "string",
              "description": "UUID of load balancer pool",
              "title": "UUID of load balancer pool"
            },
            "port": {
              "format": "port-or-range",
              "type": "string",
              "description": "This field is not required when the pool_id and ip fields can uniquely\nidentify a pool member and the port of backend service is same as the\nport of virtual server. Otherwise, this port field must be specified.\n"
            }
          },
          "required": [
            "ip",
            "pool_id"
          ],
          "type": "object"
        }
      ],
      "description": "This action is used to select a backend server for matched HTTP request\nmessages. Matched HTTP request messages are forwarded to the specified\nbackend server. The ip and port fields must be specified as single values,\nIP range and port range are not supported.\n",
      "title": "Action to select a backend server for HTTP request messages"
    },
    "Ipv4Header": {
      "type": "object",
      "properties": {
        "src_ip": {
          "format": "ip",
          "type": "string",
          "description": "The source ip address."
        },
        "flags": {
          "description": "IP flags",
          "title": "IP flags",
          "default": 0,
          "format": "int64",
          "maximum": 8,
          "minimum": 0,
          "type": "integer"
        },
        "dst_ip": {
          "format": "ip",
          "type": "string",
          "description": "The destination ip address."
        },
        "src_subnet_prefix_len": {
          "description": "This is used together with src_ip to calculate dst_ip for broadcast when dst_ip is not given; not used in all other cases.",
          "format": "int64",
          "title": "source subnet prefix length.",
          "maximum": 32,
          "minimum": 1,
          "type": "integer"
        },
        "ttl": {
          "description": "Time to live (ttl)",
          "title": "Time to live (ttl)",
          "default": 64,
          "format": "int64",
          "maximum": 255,
          "minimum": 0,
          "type": "integer"
        },
        "protocol": {
          "description": "IP protocol - defaults to ICMP",
          "title": "IP protocol - defaults to ICMP",
          "default": 1,
          "format": "int64",
          "maximum": 255,
          "minimum": 0,
          "type": "integer"
        }
      }
    },
    "LbVirtualServerStatisticsListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LbVirtualServerStatistics"
              },
              "type": "array",
              "description": "paginated statistics list of virtual servers",
              "title": "paginated statistics list of virtual servers"
            }
          }
        }
      ]
    },
    "LbHttpRequestUriArgumentsCondition": {
      "allOf": [
        {
          "$ref": "#/definitions/LbRuleCondition"
        },
        {
          "properties": {
            "uri_arguments": {
              "type": "string",
              "description": "URI arguments, aka query string of URI.\n",
              "title": "URI arguments"
            },
            "match_type": {
              "description": "Match type of URI arguments",
              "default": "REGEX",
              "enum": [
                "STARTS_WITH",
                "ENDS_WITH",
                "EQUALS",
                "CONTAINS",
                "REGEX"
              ],
              "type": "string"
            }
          },
          "required": [
            "uri_arguments"
          ],
          "type": "object"
        }
      ],
      "description": "This condition is used to match URI arguments aka query string of Http\nrequest messages, for example, in URI http://exaple.com?foo=1&bar=2, the\n\"foo=1&bar=2\" is the query string containing URI arguments. In an URI\nscheme, query string is indicated by the first question mark (\"?\")\ncharacter and terminated by a number sign (\"#\") character or by the end of\nthe URI.\nThe uri_arguments field can be specified as a regular expression(Set\nmatch_type to REGEX). For example, \"foo=(?&lt;x&gt;\\d+)\". It matches HTTP\nrequests whose URI arguments containing \"foo\", the value of foo contains\nonly digits. And the value of foo is captured as $x which can be used in\nLbRuleAction fields which support variables.\n",
      "title": "Condition to match URI arguments of HTTP requests"
    },
    "NSGroupExpression": {
      "description": "Policy expression for NSGroup membership",
      "title": "Policy expression for NSGroup membership",
      "required": [
        "resource_type"
      ],
      "discriminator": "resource_type",
      "type": "object",
      "properties": {
        "resource_type": {
          "enum": [
            "NSGroupSimpleExpression",
            "NSGroupComplexExpression",
            "NSGroupTagExpression"
          ],
          "type": "string"
        }
      }
    },
    "Tooltip": {
      "properties": {
        "text": {
          "maxLength": 1024,
          "type": "string",
          "description": "Text to be shown on tooltip while hovering over UI element. The text would be wrapped if it exceeds 80 chars.",
          "title": "Textbox shown at tooltip"
        },
        "condition": {
          "type": "string",
          "description": "If the condition is met then the tooltip will be applied. If no condition is provided, then the tooltip will be applied unconditionally. Examples of expression syntax are provided under 'example_request' section of 'CreateWidgetConfiguration' API.",
          "title": "Expression for evaluating condition"
        }
      },
      "required": [
        "text"
      ],
      "type": "object",
      "description": "Tooltip to be shown while hovering over the dashboard UI element.",
      "title": "Tooltip"
    },
    "RelatedDataRequest": {
      "allOf": [
        {
          "$ref": "#/definitions/AggregateRequest"
        },
        {
          "properties": {
            "join_condition": {
              "type": "string",
              "description": "Join condition between the parent and the related object.\nThis is to be specified in \"relatedObjectFieldName:ParentObjectFieldName\" format.\n",
              "title": "Join condition"
            },
            "size": {
              "format": "int64",
              "type": "integer",
              "description": "Number of related objects to return.\nIf not specified all the related objects will be returned.\nShould be set to 0 if only the count of related objects is desired.\n",
              "title": "Size"
            }
          },
          "required": [
            "join_condition"
          ],
          "type": "object"
        }
      ],
      "description": "Request parameters for the related types",
      "title": "Related object request"
    },
    "PackageStore": {
      "properties": {
        "package_url": {
          "type": "string",
          "description": "url of the package",
          "title": "url of the package"
        },
        "bulletin_ids": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "List of bulletin ids",
          "title": "List of bulletin ids"
        }
      },
      "required": [
        "package_url",
        "bulletin_ids"
      ],
      "type": "object",
      "description": "Contains package information",
      "title": "Contains package information"
    },
    "AdvertiseRule": {
      "required": [
        "networks"
      ],
      "type": "object",
      "properties": {
        "action": {
          "default": "ALLOW",
          "enum": [
            "DENY",
            "ALLOW"
          ],
          "type": "string",
          "description": "ALLOW action enables the advertisment and DENY action disables the advertisement of a filtered routes to the connected TIER0 router.",
          "title": "Action to ALLOW or DENY advertisement of routes"
        },
        "rule_filter": {
          "title": "Rule filter for the advertise rule",
          "description": "Rule filter for the advertise rule",
          "$ref": "#/definitions/AdvertisementRuleFilter"
        },
        "display_name": {
          "maxLength": 255,
          "type": "string",
          "description": "Display name",
          "title": "Display name"
        },
        "networks": {
          "items": {
            "format": "ipv4-cidr-block",
            "type": "string",
            "description": "IPv4 CIDR Block"
          },
          "type": "array",
          "description": "network(CIDR) to be routed",
          "title": "network(CIDR) to be routed"
        },
        "description": {
          "maxLength": 1024,
          "type": "string",
          "description": "Description",
          "title": "Description"
        }
      }
    },
    "ClusterRestoreStatus": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/definitions/GlobalRestoreStatus"
        },
        "step": {
          "$ref": "#/definitions/RestoreStep"
        },
        "endpoints": {
          "items": {
            "$ref": "#/definitions/ResourceLink"
          },
          "readOnly": true,
          "type": "array",
          "description": "The list of allowed endpoints, based on the current state of\nthe restore process\n",
          "title": "The list of allowed endpoints, based on the current state of\nthe restore process\n"
        },
        "total_steps": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Total number of steps in the entire restore process",
          "title": "Total number of steps in the entire restore process"
        },
        "restore_start_time": {
          "readOnly": true,
          "type": "integer",
          "description": "Timestamp when restore was started in epoch millisecond",
          "format": "int64"
        },
        "restore_end_time": {
          "readOnly": true,
          "type": "integer",
          "description": "Timestamp when restore was completed in epoch millisecond",
          "format": "int64"
        },
        "backup_timestamp": {
          "readOnly": true,
          "type": "integer",
          "description": "Timestamp when backup was initiated in epoch millisecond",
          "format": "int64"
        },
        "id": {
          "readOnly": true,
          "type": "string",
          "description": "Unique id for backup request",
          "title": "Unique id for backup request"
        },
        "instructions": {
          "items": {
            "$ref": "#/definitions/InstructionInfo"
          },
          "readOnly": true,
          "type": "array",
          "description": "Instructions for users to reconcile Restore operations",
          "title": "Instructions for users to reconcile Restore operations"
        }
      }
    },
    "Expression": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "required": [
            "resource_type"
          ],
          "discriminator": "resource_type",
          "type": "object",
          "properties": {
            "resource_type": {
              "enum": [
                "Condition",
                "ConjunctionOperator",
                "NestedExpression",
                "IPAddressExpression",
                "MACAddressExpression"
              ],
              "type": "string"
            }
          }
        }
      ],
      "description": "All the nodes of the expression extend from this abstract class. This\nis present for extensibility.\n",
      "title": "Base class for each node of the expression"
    },
    "EULAContent": {
      "required": [
        "content"
      ],
      "type": "object",
      "description": "End User License Agreement content",
      "properties": {
        "content": {
          "type": "string",
          "description": "End User License Agreement content",
          "title": "End User License Agreement content"
        }
      }
    },
    "ICMPTypeNSService": {
      "allOf": [
        {
          "$ref": "#/definitions/NSServiceElement"
        },
        {
          "properties": {
            "icmp_code": {
              "format": "int64",
              "type": "integer",
              "description": "ICMP message code",
              "title": "ICMP message code"
            },
            "icmp_type": {
              "format": "int64",
              "type": "integer",
              "description": "ICMP message type",
              "title": "ICMP message type"
            },
            "protocol": {
              "enum": [
                "ICMPv4",
                "ICMPv6"
              ],
              "type": "string"
            }
          },
          "required": [
            "protocol"
          ],
          "type": "object"
        }
      ],
      "description": "A NSService that represents IPv4 or IPv6 ICMP protocol",
      "title": "A NSService that represents IPv4 or IPv6 ICMP protocol"
    },
    "RealizedFirewallUIResourceListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/RealizedFirewallUIResource"
              },
              "type": "array",
              "description": "communication map and realized firewall sections list results",
              "title": "communication map and realized firewall sections list results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Paged Collection of communication map and Realized Firewall Sections Pairs",
      "title": "Paged Collection of communication map and Realized Firewall Sections Pairs"
    },
    "NodeInterfaceAlias": {
      "properties": {
        "ip_configuration": {
          "enum": [
            "dhcp",
            "static",
            "not configured"
          ],
          "type": "string",
          "description": "Interface configuration",
          "title": "Interface configuration"
        },
        "netmask": {
          "type": "string",
          "description": "Interface netmask",
          "title": "Interface netmask"
        },
        "ip_address": {
          "format": "ip",
          "type": "string",
          "description": "Interface IP address"
        },
        "physical_address": {
          "pattern": "/^(([0-9A-Fa-f]{2}[:]){5}([0-9A-Fa-f]{2}))|(([0-9A-Fa-f]{2}[-]){5}([0-9A-Fa-f]{2}))$/",
          "type": "string",
          "description": "Interface MAC address"
        },
        "broadcast_address": {
          "format": "ip",
          "type": "string",
          "description": "Interface broadcast address"
        }
      },
      "type": "object",
      "description": "Node network interface alias",
      "title": "Node network interface alias"
    },
    "LogicalService": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "dhcp_relay_profile_id",
            "resource_type"
          ],
          "type": "object",
          "properties": {
            "dhcp_relay_profile_id": {
              "type": "string",
              "description": "dhcp relay profile referenced by the dhcp relay service",
              "title": "dhcp relay profile referenced by the dhcp relay service"
            },
            "resource_type": {
              "type": "string",
              "description": "Resource type of the logical service",
              "enum": [
                "DhcpRelayService"
              ]
            }
          }
        }
      ]
    },
    "NSGroupMetaInfoListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/NSGroupMetaInfo"
              },
              "type": "array",
              "description": "list of NSGroupMetaInfos",
              "title": "list of NSGroupMetaInfos"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "NSGroupMetaInfo list",
      "title": "NSGroupMetaInfo list"
    },
    "LbHttpMonitor": {
      "allOf": [
        {
          "$ref": "#/definitions/LbActiveMonitor"
        },
        {
          "type": "object",
          "properties": {
            "response_status_codes": {
              "items": {
                "type": "integer",
                "format": "int32"
              },
              "type": "array",
              "description": "The HTTP response status code should be a valid HTTP status code.\n",
              "maxItems": 64,
              "title": "Array of single HTTP response status codes"
            },
            "request_method": {
              "description": "the health check method for HTTP monitor type",
              "default": "GET",
              "enum": [
                "GET",
                "OPTIONS",
                "POST",
                "HEAD",
                "PUT"
              ],
              "type": "string"
            },
            "request_body": {
              "type": "string",
              "description": "String to send as part of HTTP health check request body. Valid only\nfor certain HTTP methods like POST.\n",
              "title": "String to send as part of HTTP health check request body. Valid only\nfor certain HTTP methods like POST.\n"
            },
            "response_body": {
              "type": "string",
              "description": "If HTTP response body match string (regular expressions not supported)\nis specified (using LbHttpMonitor.response_body) then the\nhealthcheck HTTP response body is matched against the specified string\nand server is considered healthy only if there is a match.\nIf the response body string is not specified, HTTP healthcheck is\nconsidered successful if the HTTP response status code is 2xx, but it\ncan be configured to accept other status codes as successful.\n",
              "title": "response body to match"
            },
            "request_url": {
              "type": "string",
              "description": "URL used for HTTP monitor",
              "title": "URL used for HTTP monitor"
            },
            "request_version": {
              "description": "HTTP request version",
              "default": "HTTP_VERSION_1_1",
              "enum": [
                "HTTP_VERSION_1_0",
                "HTTP_VERSION_1_1",
                "HTTP_VERSION_2_0"
              ],
              "type": "string"
            }
          }
        }
      ]
    },
    "ComputeCollectionTransportNodeTemplateStateList": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/ComputeCollectionTransportNodeTemplateState"
              },
              "readOnly": true,
              "type": "array",
              "description": "State list per compute collection",
              "title": "State list per compute collection"
            }
          },
          "type": "object"
        }
      ],
      "description": "Transport node creation state list",
      "title": "Transport node creation state list"
    },
    "UpgradeStatus": {
      "type": "object",
      "properties": {
        "host_status": {
          "readOnly": true,
          "title": "Host upgrade status",
          "description": "Host upgrade status",
          "$ref": "#/definitions/HostUpgradeStatus"
        },
        "ccp_status": {
          "readOnly": true,
          "title": "CCP upgrade status",
          "description": "CCP upgrade status",
          "$ref": "#/definitions/CCPUpgradeStatus"
        },
        "edge_status": {
          "readOnly": true,
          "title": "Edge upgrade status",
          "description": "Edge upgrade status",
          "$ref": "#/definitions/EdgeUpgradeStatus"
        },
        "overall_upgrade_status": {
          "readOnly": true,
          "enum": [
            "SUCCESS",
            "FAILED",
            "IN_PROGRESS",
            "NOT_STARTED",
            "PAUSED"
          ],
          "type": "string",
          "description": "Status of upgrade",
          "title": "Status of upgrade"
        },
        "component_status": {
          "items": {
            "$ref": "#/definitions/ComponentUpgradeStatus"
          },
          "readOnly": true,
          "type": "array",
          "description": "List of component statuses",
          "title": "List of component statuses"
        }
      }
    },
    "RealizedFirewalls": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyRealizedResource"
        },
        {
          "properties": {
            "realized_firewalls": {
              "items": {
                "$ref": "#/definitions/RealizedFirewall"
              },
              "readOnly": true,
              "type": "array",
              "description": "list of realized firewalls",
              "title": "list of realized firewalls"
            }
          },
          "type": "object"
        }
      ],
      "description": "Realized firewalls",
      "title": "Realized firewalls"
    },
    "DhcpProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "edge_cluster_id"
          ],
          "type": "object",
          "properties": {
            "edge_cluster_member_indexes": {
              "description": "If none is provided, the NSX will auto-select two edge-nodes from the given edge cluster.\nIf user provides only one edge node, there will be no HA support.\n",
              "title": "edge node indexes",
              "minItems": 0,
              "items": {
                "type": "integer",
                "format": "int64"
              },
              "maxItems": 2,
              "uniqueItems": true,
              "type": "array"
            },
            "edge_cluster_id": {
              "type": "string",
              "description": "edge cluster uuid",
              "title": "edge cluster uuid"
            }
          }
        }
      ]
    },
    "NodeLogPropertiesListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/NodeLogProperties"
              },
              "type": "array",
              "description": "Node log property results",
              "title": "Node log property results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Node log property query results",
      "title": "Node log property query results"
    },
    "DefaultRequestParameters": {
      "type": "object",
      "description": "Default request parameters.",
      "properties": {
        "include_system_owned": {
          "readOnly": true,
          "type": "boolean",
          "description": "Flag indicating that operation should be performed on system resources too",
          "title": "Perform on system resources"
        }
      }
    },
    "InterfaceNeighborProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "ifindex": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Interface index",
              "title": "Interface index"
            },
            "neighbors": {
              "description": "Neighbor properties",
              "title": "Neighbor properties",
              "items": {
                "$ref": "#/definitions/NeighborProperties"
              },
              "readOnly": true,
              "uniqueItems": true,
              "type": "array"
            },
            "mac": {
              "readOnly": true,
              "type": "string",
              "description": "Interface MAC address",
              "title": "Interface MAC address"
            },
            "name": {
              "readOnly": true,
              "type": "string",
              "description": "Interface Name",
              "title": "Interface Name"
            }
          },
          "type": "object"
        }
      ],
      "description": "Interface neighbor properties",
      "title": "Interface neighbor properties"
    },
    "StaticIpListSpec": {
      "allOf": [
        {
          "$ref": "#/definitions/IpAssignmentSpec"
        },
        {
          "properties": {
            "subnet_mask": {
              "description": "Subnet mask",
              "format": "ip",
              "readOnly": false,
              "type": "string"
            },
            "ip_list": {
              "description": "List of IPs for transport node host switch virtual tunnel endpoints",
              "title": "List of IPs for transport node host switch virtual tunnel endpoints",
              "items": {
                "format": "ip",
                "type": "string",
                "description": "IPv4 or IPv6 address"
              },
              "readOnly": false,
              "maxItems": 32,
              "type": "array"
            },
            "default_gateway": {
              "description": "Gateway IP",
              "format": "ip",
              "readOnly": false,
              "type": "string"
            }
          },
          "required": [
            "subnet_mask",
            "ip_list",
            "default_gateway"
          ],
          "type": "object"
        }
      ],
      "description": "IP assignment specification for Static IP List.",
      "title": "IP assignment specification for Static IP List."
    },
    "SshServiceProperties": {
      "properties": {
        "start_on_boot": {
          "type": "boolean",
          "description": "Start service when system boots",
          "title": "Start service when system boots"
        }
      },
      "required": [
        "start_on_boot"
      ],
      "type": "object",
      "description": "SSH Service properties",
      "title": "SSH Service properties"
    },
    "AwsGatewayDeployConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "vpc_id": {
              "type": "string",
              "description": "ID of the vpc",
              "title": "ID of the vpc"
            },
            "configuration": {
              "readOnly": true,
              "title": "Configuration of this gateway",
              "description": "Configuration of this gateway",
              "$ref": "#/definitions/AwsGatewayConfig"
            },
            "account_id": {
              "type": "string",
              "description": "ID of the Aws account",
              "title": "ID of the Aws account"
            }
          },
          "required": [
            "vpc_id",
            "account_id"
          ],
          "type": "object"
        }
      ],
      "description": "Aws gateway deployment configuration",
      "title": "Aws gateway deployment configuration"
    },
    "NeighborProperties": {
      "properties": {
        "system_name": {
          "readOnly": true,
          "type": "string",
          "description": "System name",
          "title": "System name"
        },
        "system_desc": {
          "readOnly": true,
          "type": "string",
          "description": "System description",
          "title": "System description"
        },
        "system_port_number": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "System port number",
          "title": "System port number"
        },
        "name": {
          "readOnly": true,
          "type": "string",
          "description": "Interface name",
          "title": "Interface name"
        },
        "oid": {
          "readOnly": true,
          "type": "string",
          "description": "Object identifier",
          "title": "Object identifier"
        },
        "mgmt_addr": {
          "readOnly": true,
          "type": "string",
          "description": "Management address",
          "title": "Management address"
        },
        "capabilities": {
          "readOnly": true,
          "type": "string",
          "description": "Capabilities",
          "title": "Capabilities"
        },
        "link_aggregation_status": {
          "readOnly": true,
          "type": "boolean",
          "description": "True if currently in aggregation",
          "title": "Aggregation Status"
        },
        "ifindex": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Interface index",
          "title": "Interface index"
        },
        "mac": {
          "readOnly": true,
          "type": "string",
          "description": "Interface MAC address",
          "title": "Interface MAC address"
        },
        "link_aggregation_capable": {
          "readOnly": true,
          "type": "boolean",
          "description": "Aggregation Capability",
          "title": "Aggregation Capability"
        },
        "port_desc": {
          "readOnly": true,
          "type": "string",
          "description": "Port description",
          "title": "Port description"
        },
        "enabled_capabilities": {
          "readOnly": true,
          "type": "string",
          "description": "Enabled capabilities",
          "title": "Enabled capabilities"
        },
        "link_aggregation_port_id": {
          "readOnly": true,
          "type": "string",
          "description": "Aggregation port id",
          "title": "Aggregation port id"
        }
      },
      "type": "object",
      "description": "Neighbor properties",
      "title": "Neighbor properties"
    },
    "LbHttpRequestUriRewriteAction": {
      "allOf": [
        {
          "$ref": "#/definitions/LbRuleAction"
        },
        {
          "properties": {
            "uri_arguments": {
              "type": "string",
              "description": "Query string of URI, typically contains key value pairs, for example:\nfoo1=bar1&foo2=bar2\n",
              "title": "URI arguments"
            },
            "uri": {
              "type": "string",
              "description": "URI of HTTP request",
              "title": "URI of HTTP request"
            }
          },
          "required": [
            "uri"
          ],
          "type": "object"
        }
      ],
      "description": "This action is used to rewrite URIs in matched HTTP request messages.\nSpecify the uri and uri_arguments fields in this condition to rewrite the\nmatched HTTP request message's URI and URI arguments to the new values.\nFull URI scheme of HTTP messages have following syntax:\nscheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]\nThe uri field of this action is used to rewrite the /path part in above\nscheme. And the uri_arguments field is used to rewrite the query part.\nCaptured variables and built-in variables can be used in the uri and\nuri_arguments fields.\nCheck the example in LbRuleAction to see how to use variables in this\naction.\n",
      "title": "Action to rewrite HTTP request URIs."
    },
    "ControlClusterNodeStatus": {
      "type": "object",
      "properties": {
        "mgmt_connection_status": {
          "readOnly": true,
          "title": "Status of this node's management plane connection",
          "description": "Status of this node's management plane connection",
          "$ref": "#/definitions/MgmtConnStatus"
        },
        "control_cluster_status": {
          "description": "Status of this node's connection to the control cluster",
          "enum": [
            "CONNECTED",
            "DISCONNECTED",
            "UNKNOWN"
          ],
          "readOnly": true,
          "type": "string"
        }
      }
    },
    "CsrList": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/Csr"
              },
              "readOnly": false,
              "type": "array",
              "description": "CSR list"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Csr queries result",
      "title": "Csr queries result"
    },
    "EgressRateShaper": {
      "allOf": [
        {
          "$ref": "#/definitions/QosBaseRateShaper"
        },
        {
          "properties": {
            "average_bandwidth_mbps": {
              "description": "Average bandwidth in Mb/s",
              "format": "int32",
              "default": 0,
              "title": "Average bandwidth in Mb/s",
              "minimum": 0,
              "type": "integer"
            },
            "peak_bandwidth_mbps": {
              "description": "Peak bandwidth in Mb/s",
              "format": "int32",
              "default": 0,
              "title": "Peak bandwidth in Mb/s",
              "minimum": 0,
              "type": "integer"
            },
            "burst_size_bytes": {
              "description": "Burst size in bytes",
              "format": "int32",
              "default": 0,
              "title": "Burst size in bytes",
              "minimum": 0,
              "type": "integer"
            }
          },
          "type": "object"
        }
      ],
      "description": "A shaper that specifies egress rate properties in Mb/s",
      "title": "A shaper that specifies egress rate properties in Mb/s"
    },
    "TraceflowObservationCounters": {
      "type": "object",
      "properties": {
        "forwarded_count": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Total number of forwarded observations for this traceflow round.",
          "title": "Forwarded observation count"
        },
        "dropped_count": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Total number of dropped observations for this round.",
          "title": "Dropped observation count"
        },
        "delivered_count": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Total number of delivered observations for this traceflow round.",
          "title": "Delivered observation count"
        },
        "received_count": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Total number of received observations for this traceflow round.",
          "title": "Received observation count"
        }
      }
    },
    "BulkUpdateUpgradeUnitGroupsRequest": {
      "required": [
        "requests"
      ],
      "type": "object",
      "properties": {
        "requests": {
          "items": {
            "$ref": "#/definitions/UpgradeUnitGroup"
          },
          "type": "array"
        }
      }
    },
    "InstructionInfo": {
      "type": "object",
      "properties": {
        "fields": {
          "items": {
            "type": "string"
          },
          "readOnly": true,
          "type": "array",
          "description": "A list of fields that are displayable to users in a table",
          "title": "Displayable fields"
        },
        "id": {
          "readOnly": true,
          "type": "string",
          "description": "UUID of the instruction",
          "title": "UUID of the instruction"
        },
        "actions": {
          "items": {
            "type": "string"
          },
          "readOnly": true,
          "type": "array",
          "description": "A list of actions that are to be applied to resources",
          "title": "Actions list"
        },
        "name": {
          "readOnly": true,
          "type": "string",
          "description": "Instruction name",
          "title": "Instruction name"
        }
      }
    },
    "LogicalSwitchStatus": {
      "type": "object",
      "properties": {
        "num_logical_ports": {
          "readOnly": true,
          "format": "int32",
          "type": "integer",
          "description": "Count of Logical Ports belonging to this switch",
          "title": "Count of Logical Ports belonging to this switch"
        },
        "logical_switch_id": {
          "readOnly": true,
          "type": "string",
          "description": "Unique ID identifying the the Logical Switch",
          "title": "Unique ID identifying the the Logical Switch"
        }
      }
    },
    "HeatMapTransportZoneStatus": {
      "type": "object",
      "properties": {
        "degraded_count": {
          "format": "int32",
          "type": "integer",
          "description": "Number of transport nodes that are degraded",
          "title": "Number of transport nodes that are degraded"
        },
        "down_count": {
          "format": "int32",
          "type": "integer",
          "description": "Number of transport nodes that are down",
          "title": "Number of transport nodes that are down"
        },
        "unknown_count": {
          "format": "int32",
          "type": "integer",
          "description": "Number of transport nodes with unknown status",
          "title": "Number of transport nodes with unknown status"
        },
        "up_count": {
          "format": "int32",
          "type": "integer",
          "description": "Number of transport nodes that are up",
          "title": "Number of transport nodes that are up"
        }
      }
    },
    "BackupFile": {
      "properties": {
        "passphrase": {
          "type": "string",
          "description": "Passphrase used to encrypt backup file",
          "title": "Passphrase used to encrypt backup file"
        },
        "file_store": {
          "enum": [
            "local",
            "remote"
          ],
          "type": "string",
          "description": "File location",
          "title": "File location"
        }
      },
      "required": [
        "passphrase",
        "file_store"
      ],
      "type": "object",
      "description": "Backup file properties",
      "title": "Backup file properties"
    },
    "MetadataProxy": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "metadata_server_url",
            "edge_cluster_id"
          ],
          "type": "object",
          "properties": {
            "secret": {
              "type": "string",
              "description": "secret to access metadata server",
              "title": "secret to access metadata server"
            },
            "metadata_server_ca_ids": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "The CAs referenced here must be uploaded to the truststore using the API\nPOST /api/v1/trust-management/certificates?action=import.\nUser needs to ensure a correct CA for this metedata server is used. The REST API can\nnot detect a wrong CA which was used to verify a different server. If the Metadata\nProxy reports an ERROR or NO_BACKUP status, user can check the metadata proxy log\nat transport node for a possible CA issue.\n",
              "title": "uuids of CAs to verify metadata server certificate"
            },
            "edge_cluster_member_indexes": {
              "description": "If none is provided, the NSX will auto-select two edge-nodes from the given edge cluster.\nIf user provides only one edge node, there will be no HA support.\n",
              "title": "edge cluster member indexes",
              "minItems": 0,
              "items": {
                "type": "integer",
                "format": "int64"
              },
              "maxItems": 2,
              "uniqueItems": true,
              "type": "array"
            },
            "metadata_server_url": {
              "type": "string",
              "description": "The URL in format scheme://host:port/path. Please note, the scheme supports only http\nand https as of now, port supports range 3000 - 9000, inclusive.\n",
              "title": "metadata server url"
            },
            "attached_logical_port_id": {
              "readOnly": true,
              "type": "string",
              "description": "id of attached logical port",
              "title": "id of attached logical port"
            },
            "edge_cluster_id": {
              "type": "string",
              "description": "edge cluster uuid",
              "title": "edge cluster uuid"
            }
          }
        }
      ]
    },
    "LbVirtualServerStatus": {
      "required": [
        "virtual_server_id"
      ],
      "type": "object",
      "properties": {
        "status": {
          "enum": [
            "UP",
            "PARTIALLY_UP",
            "PRIMARY_DOWN",
            "DOWN",
            "DETACHED",
            "DISABLED"
          ],
          "type": "string",
          "description": "UP means that all primary members in default pool are in UP status.\nFor L7 virtual server, if there is no default pool, the virtual server\nwould be treated as UP.\nPARTIALLY_UP means that some(not all) primary members in default pool\nare in UP status. The size of these active primary members should be\nlarger than or equal to the certain number(min_active_members) which is\ndefined in LbPool.\nPRIMARY_DOWN means that less than certain(min_active_members) primary\nmembers in default pool are in UP status but backup members are in UP\nstatus, the connections would be dispatched to backup members.\nDOWN means that all primary and backup members are in DOWN status.\nDETACHED means that the virtual server is not bound to any service.\nDISABLED means that the admin state of the virtual server is disabled.\n",
          "title": "Virtual server status"
        },
        "last_update_timestamp": {
          "type": "integer",
          "description": "Timestamp when the data was last updated.",
          "format": "int64"
        },
        "virtual_server_id": {
          "type": "string",
          "description": "load balancer virtual server identifier",
          "title": "load balancer virtual server identifier"
        }
      }
    },
    "LbTcpHeaderCondition": {
      "allOf": [
        {
          "$ref": "#/definitions/LbRuleCondition"
        },
        {
          "properties": {
            "source_port": {
              "format": "port-or-range",
              "type": "string",
              "description": "TCP source port of HTTP message"
            }
          },
          "required": [
            "source_port"
          ],
          "type": "object"
        }
      ],
      "description": "This condition is used to match TCP header fields of HTTP messages.\nCurrently, only the TCP source port is supported. Ports can be expressed as\na single port number like 80, or a port range like 1024-1030.\n",
      "title": "Condition to match TCP header fields"
    },
    "BackupProperties": {
      "properties": {
        "backup_file": {
          "description": "Backup file",
          "title": "Backup file"
        }
      },
      "required": [
        "backup_file"
      ],
      "type": "object",
      "description": "Backup properties",
      "title": "Backup properties"
    },
    "EffectiveMemberTypeListResult": {
      "required": [
        "results"
      ],
      "type": "object",
      "properties": {
        "results": {
          "items": {
            "enum": [
              "NSGroup",
              "IPSet",
              "MACSet",
              "LogicalSwitch",
              "LogicalPort",
              "VirtualMachine"
            ],
            "type": "string",
            "description": "Resource type valid for use in an NSGroupExpression"
          },
          "type": "array",
          "description": "Collection of member types for the given NSGroup",
          "title": "Collection of member types for the given NSGroup"
        },
        "result_count": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Count of the member types in the results array",
          "title": "Count of the member types in the results array"
        }
      }
    },
    "LogicalRouterRouteEntry": {
      "required": [
        "route_type",
        "network"
      ],
      "type": "object",
      "properties": {
        "lr_component_id": {
          "type": "string",
          "description": "Logical router component(Service Router/Distributed Router) id",
          "title": "Logical router component(Service Router/Distributed Router) id"
        },
        "next_hop": {
          "format": "ip",
          "type": "string",
          "description": "The IP address of the next hop"
        },
        "lr_component_type": {
          "type": "string",
          "description": "Logical router component(Service Router/Distributed Router) type",
          "title": "Logical router component(Service Router/Distributed Router) type"
        },
        "network": {
          "format": "ipv4-cidr-block",
          "type": "string",
          "description": "CIDR network address"
        },
        "route_type": {
          "type": "string",
          "description": "Route type (USER, CONNECTED, NSX_INTERNAL,..)",
          "title": "Route type (USER, CONNECTED, NSX_INTERNAL,..)"
        },
        "logical_router_port_id": {
          "type": "string",
          "description": "The id of the logical router port which is used as the next hop",
          "title": "The id of the logical router port which is used as the next hop"
        },
        "admin_distance": {
          "format": "int64",
          "type": "integer",
          "description": "The admin distance of the next hop",
          "title": "The admin distance of the next hop"
        }
      }
    },
    "X509Crl": {
      "properties": {
        "next_update": {
          "readOnly": true,
          "type": "string",
          "description": "Next update time for the CRL"
        },
        "version": {
          "readOnly": true,
          "type": "string",
          "description": "CRL's version number either 1 or 2"
        },
        "crl_entries": {
          "items": {
            "$ref": "#/definitions/X509CrlEntry"
          },
          "readOnly": true,
          "type": "array",
          "description": "list of X509CrlEntry"
        },
        "issuer": {
          "readOnly": true,
          "type": "string",
          "description": "Issuer's distinguished name(DN)"
        }
      },
      "type": "object",
      "description": "A CRL is a time-stamped list identifying revoked certificates.",
      "title": "A CRL is a time-stamped list identifying revoked certificates."
    },
    "MacPoolListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/MacPool"
              },
              "type": "array",
              "description": "MAC pool list results",
              "title": "MAC pool list results"
            }
          }
        }
      ]
    },
    "BackupOperationStatus": {
      "required": [
        "backup_id",
        "success"
      ],
      "type": "object",
      "properties": {
        "backup_id": {
          "type": "string",
          "description": "Unique identifier of a backup",
          "title": "Unique identifier of a backup"
        },
        "end_time": {
          "type": "integer",
          "description": "Time when operation was ended",
          "format": "int64"
        },
        "success": {
          "type": "boolean",
          "description": "True if backup is successfully completed, else false",
          "title": "True if backup is successfully completed, else false"
        },
        "start_time": {
          "type": "integer",
          "description": "Time when operation was started",
          "format": "int64"
        },
        "error_message": {
          "type": "string",
          "description": "Error code details",
          "title": "Error code details"
        },
        "error_code": {
          "enum": [
            "BACKUP_NOT_RUN_ON_MASTER",
            "BACKUP_SERVER_UNREACHABLE",
            "BACKUP_AUTHENTICATION_FAILURE",
            "BACKUP_PERMISSION_ERROR",
            "BACKUP_TIMEOUT",
            "BACKUP_BAD_FINGERPRINT",
            "BACKUP_GENERIC_ERROR"
          ],
          "type": "string",
          "description": "Error code",
          "title": "Error code"
        }
      }
    },
    "LbServiceStatus": {
      "required": [
        "service_id"
      ],
      "type": "object",
      "properties": {
        "pools": {
          "items": {
            "$ref": "#/definitions/LbPoolStatus"
          },
          "type": "array",
          "description": "status of load balancer pools",
          "title": "status of load balancer pools"
        },
        "cpu_usage": {
          "format": "int64",
          "type": "integer",
          "description": "Cpu usage in percentage",
          "title": "Cpu usage in percentage"
        },
        "active_transport_nodes": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Ids of load balancer service related active transport nodes",
          "title": "Ids of load balancer service related active transport nodes"
        },
        "memory_usage": {
          "format": "int64",
          "type": "integer",
          "description": "Memory usage in percentage",
          "title": "Memory usage in percentage"
        },
        "service_id": {
          "type": "string",
          "description": "Load balancer service identifier",
          "title": "Load balancer service identifier"
        },
        "last_update_timestamp": {
          "type": "integer",
          "description": "Timestamp when the data was last updated",
          "format": "int64"
        },
        "standby_transport_nodes": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Ids of load balancer service related standby transport nodes",
          "title": "Ids of load balancer service related standby transport nodes"
        },
        "error_message": {
          "type": "string",
          "description": "Error message, if available",
          "title": "Error message, if available"
        },
        "virtual_servers": {
          "items": {
            "$ref": "#/definitions/LbVirtualServerStatus"
          },
          "type": "array",
          "description": "status of load balancer virtual servers",
          "title": "status of load balancer virtual servers"
        },
        "service_status": {
          "enum": [
            "UP",
            "DOWN",
            "ERROR",
            "NO_STANDBY",
            "DETACHED",
            "DISABLED",
            "UNKNOWN"
          ],
          "type": "string",
          "description": "UP means the load balancer service is working fine on both\ntransport-nodes(if have);\nDOWN means the load balancer service is down on both transport-nodes\n(if have), hence the load balancer will not respond to any requests;\nERROR means error happens on transport-node(s) or no status is\nreported from transport-node(s). The load balancer service may be\nworking (or not working);\nNO_STANDBY means load balancer service is working in one of the\ntransport node while not in the other transport-node (if have). Hence\nif the load balancer service in the working transport-node goes down,\nthe load balancer service will go down;\nDETACHED means that the load balancer service has no attachment setting\nand is not instantiated in any transport nodes;\nDISABLED means that admin state of load balancer service is DISABLED;\nUNKNOWN means that no status reported from transport-nodes.The load\nbalancer service may be working(or not working).\n",
          "title": "Status of load balancer service"
        }
      }
    },
    "IPSet": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "ip_addresses": {
              "items": {
                "format": "address-or-block-or-range",
                "type": "string",
                "description": "IPElement can be a single IP address, IP address range or a Subnet. Its\ntype can be of IPv4 or IPv6. Supported list of formats are 192.168.1.1,\n192.168.1.1-192.168.1.100, 192.168.0.0/24,\nfe80::250:56ff:fe83:318c,\nfe80::250:56ff:fe83:3181-fe80::250:56ff:fe83:318c,\nfe80::250:56ff:fe83:318c/64\n"
              },
              "type": "array",
              "description": "IP addresses",
              "maxItems": 100,
              "title": "IP addresses"
            }
          },
          "type": "object"
        }
      ],
      "description": "IPSet is used to group individual IP addresses, range of IP addresses or subnets.\nAn IPSet is a homogeneous group of IP addresses, either of type IPv4 or of type\nIPv6. IPSets can be used as source or destination in firewall rules. These can\nalso be used as members of NSGroups.\n",
      "title": "Set of one or more IP addresses"
    },
    "IpfixCollectorConfigListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/IpfixCollectorConfig"
              },
              "readOnly": true,
              "type": "array",
              "description": "IPFIX Collector Config",
              "title": "IPFIX Collector Config"
            }
          },
          "type": "object"
        }
      ],
      "description": "List of IPFIX Collector Configs",
      "title": "List of IPFIX Collector Configs"
    },
    "FirewallSectionRuleList": {
      "allOf": [
        {
          "$ref": "#/definitions/FirewallSection"
        },
        {
          "required": [
            "rules"
          ],
          "type": "object",
          "properties": {
            "rules": {
              "description": "List of firewall rules in the section. Only homogenous rules are supported.",
              "title": "List of the firewall rules",
              "items": {
                "$ref": "#/definitions/FirewallRule"
              },
              "readOnly": false,
              "maxItems": 1000,
              "type": "array"
            }
          }
        }
      ]
    },
    "IpfixDfwConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/IpfixConfig"
        },
        {
          "properties": {
            "priority": {
              "description": "This priority field is used to resolve conflicts in Logical Ports\nwhich are covered by more than one IPFIX profiles. The IPFIX\nexporter will send records to Collectors in highest priority\nprofile (lowest number) only.\n",
              "title": "Config Priority",
              "default": 0,
              "format": "int64",
              "maximum": 65536,
              "minimum": 0,
              "type": "integer"
            },
            "collector": {
              "type": "string",
              "description": "Each IPFIX DFW config can have its own collector config.\n",
              "title": "UUID of IPFIX DFW Collector Config"
            },
            "active_flow_export_timeout": {
              "description": "For long standing active flows, IPFIX records will be sent per timeout period\n",
              "title": "Active flow export timeout (minutes)",
              "default": 1,
              "format": "int64",
              "maximum": 60,
              "minimum": 1,
              "type": "integer"
            },
            "template_parameters": {
              "title": "Template Parameters",
              "description": "An object that indicates whether each corresponding template parameter\nis required or not.\n",
              "$ref": "#/definitions/IpfixDfwTemplateParameters"
            },
            "observation_domain_id": {
              "description": "An identifier that is unique to the exporting process and used to\nmeter the Flows.\n",
              "format": "int64",
              "title": "Observation domain ID",
              "maximum": 4294967295,
              "minimum": 0,
              "type": "integer"
            }
          },
          "required": [
            "priority",
            "collector",
            "observation_domain_id"
          ],
          "type": "object"
        }
      ],
      "description": "It defines IPFIX DFW Configuration.",
      "title": "IPFIX Config for the DFW Module"
    },
    "UcMessageList": {
      "required": [
        "messages"
      ],
      "type": "object",
      "properties": {
        "messages": {
          "items": {
            "$ref": "#/definitions/UcMessage"
          },
          "readOnly": false,
          "type": "array",
          "description": "List of UC messages",
          "title": "List of UC messages"
        }
      }
    },
    "TransportNodeStatus": {
      "type": "object",
      "properties": {
        "status": {
          "enum": [
            "UP",
            "DOWN",
            "DEGRADED",
            "UNKNOWN"
          ],
          "type": "string",
          "description": "Roll-up status of pNIC, management connection, control connection, tunnel status",
          "title": "Roll-up status of pNIC, management connection, control connection, tunnel status"
        },
        "node_uuid": {
          "type": "string",
          "description": "Transport node uuid",
          "title": "Transport node uuid"
        },
        "mgmt_connection_status": {
          "enum": [
            "UP",
            "DOWN"
          ],
          "type": "string",
          "description": "Management connection status",
          "title": "Management connection status"
        },
        "control_connection_status": {
          "title": "Control connection status",
          "description": "Control connection status",
          "$ref": "#/definitions/StatusCount"
        },
        "pnic_status": {
          "title": "pNIC status",
          "description": "pNIC status",
          "$ref": "#/definitions/StatusCount"
        },
        "node_display_name": {
          "type": "string",
          "description": "Transport node display name",
          "title": "Display name"
        },
        "tunnel_status": {
          "title": "Tunnel Status",
          "description": "Tunnel Status",
          "$ref": "#/definitions/TunnelStatusCount"
        }
      }
    },
    "LogicalRouterPortArpTableInCsvFormat": {
      "allOf": [
        {
          "$ref": "#/definitions/CsvListResult"
        },
        {
          "type": "object",
          "properties": {
            "last_update_timestamp": {
              "readOnly": true,
              "type": "integer",
              "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
              "format": "int64"
            },
            "results": {
              "items": {
                "$ref": "#/definitions/LogicalRouterPortArpCsvRecord"
              },
              "type": "array"
            }
          }
        }
      ]
    },
    "NodeInfoListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/NodeInfo"
              },
              "type": "array",
              "description": "Paged Collection of Nodes",
              "title": "Paged Collection of Nodes"
            }
          }
        }
      ]
    },
    "IpfixConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "resource_type"
          ],
          "discriminator": "resource_type",
          "type": "object",
          "properties": {
            "applied_tos": {
              "description": "List of objects where the IPFIX Config will be enabled.",
              "title": "AppliedTo List",
              "items": {
                "$ref": "#/definitions/ResourceReference"
              },
              "readOnly": false,
              "maxItems": 128,
              "type": "array"
            },
            "resource_type": {
              "description": "Supported IPFIX Config Types.",
              "enum": [
                "IpfixSwitchConfig",
                "IpfixDfwConfig"
              ],
              "readOnly": false,
              "type": "string"
            }
          }
        }
      ],
      "description": "IPFIX Config base representation",
      "title": "IPFIX Config base representation"
    },
    "RedistributionRuleList": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "type": "object",
          "properties": {
            "rules": {
              "description": "List of redistribution rules.\nUser needs to re-order rules to change the priority.\n",
              "title": "List of redistribution rules.\nUser needs to re-order rules to change the priority.\n",
              "default": [],
              "items": {
                "$ref": "#/definitions/RedistributionRule"
              },
              "minItems": 0,
              "maxItems": 5,
              "type": "array"
            },
            "logical_router_id": {
              "readOnly": true,
              "type": "string",
              "description": "Logical router id",
              "title": "Logical router id"
            }
          }
        }
      ]
    },
    "LbServiceListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LbService"
              },
              "type": "array",
              "description": "paginated list of load balancer services",
              "title": "paginated list of load balancer services"
            }
          }
        }
      ]
    },
    "ManagementClusterStatus": {
      "type": "object",
      "properties": {
        "status": {
          "readOnly": true,
          "enum": [
            "INITIALIZING",
            "UNSTABLE",
            "STABLE",
            "UNKNOWN"
          ],
          "type": "string",
          "description": "The current status of the management cluster",
          "title": "The current status of the management cluster"
        },
        "offline_nodes": {
          "items": {
            "$ref": "#/definitions/ManagementPlaneBaseNodeInfo"
          },
          "readOnly": true,
          "type": "array",
          "description": "Current missing management plane nodes"
        },
        "required_members_for_initialization": {
          "items": {
            "$ref": "#/definitions/ClusterInitializationNodeInfo"
          },
          "readOnly": true,
          "type": "array",
          "description": "The details of the cluster nodes required for cluster initialization"
        },
        "online_nodes": {
          "items": {
            "$ref": "#/definitions/ManagementPlaneBaseNodeInfo"
          },
          "readOnly": true,
          "type": "array",
          "description": "Current alive management plane nodes"
        }
      }
    },
    "LbHttpRequestUriCondition": {
      "allOf": [
        {
          "$ref": "#/definitions/LbRuleCondition"
        },
        {
          "properties": {
            "match_type": {
              "description": "Match type of URI",
              "default": "REGEX",
              "enum": [
                "STARTS_WITH",
                "ENDS_WITH",
                "EQUALS",
                "CONTAINS",
                "REGEX"
              ],
              "type": "string"
            },
            "uri": {
              "type": "string",
              "description": "A string used to identify resource",
              "title": "A string used to identify resource"
            }
          },
          "required": [
            "uri"
          ],
          "type": "object"
        }
      ],
      "description": "This condition is used to match URIs(Uniform Resource Identifier) of HTTP\nrequest messages. The URI field can be specified as a regular expression.\nIf an HTTP request message is requesting an URI which matches specified\nregular expression, it matches the condition.\nThe syntax of whole URI looks like this:\nscheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]\nThis condition matches only the path part of entire URI.\nWhen match_type field is specified as REGEX, the uri field is used as a\nregular expression to match URI path of HTTP requests. For example, to\nmatch any URI that has \"/image/\" or \"/images/\", uri field can be specified\nas: \"/image[s]?/\".\nNamed capturing groups can be used in the uri field to capture substrings\nof matched URIs and store them in variables for use in LbRuleAction. For\nexample, specify uri field as:\n\"/news/(?&lt;year&gt;\\d+)/(?&lt;month&gt;\\d+)/(?&lt;article&gt;.*)\"\nIf the URI path is /articles/news/2017/06/xyz.html, then substring \"2017\"\nis captured in variable year, \"06\" is captured in variable month, and\n\"xyz.html\" is captured in variable article. These variables can then\nbe used in an LbRuleAction field which supports variables, such as uri\nfield of LbHttpRequestUriRewriteAction. For example, set the uri field\nof LbHttpRequestUriRewriteAction as:\n\"/articles/news/$year-$month-$article\"\nThen the URI path /articles/news/2017/06/xyz.html is rewritten to:\n\"/articles/news/2017-06-xyz.html\"\n",
      "title": "Condition to match URIs of HTTP request messages"
    },
    "AdvertisementConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "type": "object",
          "properties": {
            "advertise_nsx_connected_routes": {
              "default": false,
              "type": "boolean",
              "description": "Flag to advertise all connected routes",
              "title": "Flag to advertise all connected routes"
            },
            "advertise_lb_vip": {
              "default": false,
              "type": "boolean",
              "description": "Flag to advertise lb vip",
              "title": "Flag to advertise lb vip"
            },
            "advertise_static_routes": {
              "default": false,
              "type": "boolean",
              "description": "Flag to advertise all static routes",
              "title": "Flag to advertise all static routes"
            },
            "logical_router_id": {
              "readOnly": true,
              "type": "string",
              "description": "Logical router id",
              "title": "Logical router id"
            },
            "advertise_nat_routes": {
              "default": false,
              "type": "boolean",
              "description": "Flag to advertise all routes of nat",
              "title": "Flag to advertise all routes of nat"
            },
            "enabled": {
              "default": false,
              "type": "boolean",
              "description": "Flag to enable this configuration",
              "title": "Flag to enable this configuration"
            },
            "advertise_lb_snat_ip": {
              "default": false,
              "type": "boolean",
              "description": "Flag to advertise all lb SNAT ips",
              "title": "Flag to advertise all lb SNAT ips"
            }
          }
        }
      ]
    },
    "CloudVirtualMachinesListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/CloudVirtualMachine"
              },
              "type": "array",
              "description": "Regions list result",
              "title": "Regions list result"
            }
          },
          "type": "object"
        }
      ],
      "description": "Regions list",
      "title": "Regions list"
    },
    "ResourceTypeGroup": {
      "required": [
        "count",
        "hits",
        "resource_type"
      ],
      "type": "object",
      "properties": {
        "count": {
          "format": "int64",
          "type": "integer",
          "description": "Total count per resource type",
          "title": "Total count per resource type"
        },
        "hits": {
          "items": {
            "type": "object"
          },
          "type": "array",
          "description": "Hits per resource type",
          "title": "Hits per resource type"
        },
        "resource_type": {
          "type": "string",
          "description": "Resource type",
          "title": "Resource type"
        }
      }
    },
    "License": {
      "description": "license properties",
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "required": [
            "license_key"
          ],
          "type": "object",
          "properties": {
            "features": {
              "readOnly": true,
              "type": "string",
              "description": "semicolon delimited feature list",
              "title": "semicolon delimited feature list"
            },
            "description": {
              "readOnly": true,
              "type": "string",
              "description": "license edition",
              "title": "license edition"
            },
            "product_version": {
              "readOnly": true,
              "type": "string",
              "description": "product version",
              "title": "product version"
            },
            "expiry": {
              "readOnly": true,
              "type": "integer",
              "description": "date that license expires",
              "format": "int64"
            },
            "is_eval": {
              "readOnly": true,
              "type": "boolean",
              "description": "true for evalution license",
              "title": "true for evalution license"
            },
            "is_mh": {
              "readOnly": true,
              "type": "boolean",
              "description": "multi-hypervisor support",
              "title": "multi-hypervisor support"
            },
            "license_key": {
              "type": "string",
              "description": "license key",
              "title": "license key"
            },
            "is_expired": {
              "readOnly": true,
              "type": "boolean",
              "description": "whether the license has expired",
              "title": "whether the license has expired"
            },
            "product_name": {
              "readOnly": true,
              "type": "string",
              "description": "product name",
              "title": "product name"
            },
            "capacity_type": {
              "readOnly": true,
              "enum": [
                "VM",
                "CPU",
                "USER"
              ],
              "type": "string",
              "description": "license metric",
              "title": "license metric"
            },
            "quantity": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "license capacity; 0 for unlimited",
              "title": "license capacity; 0 for unlimited"
            }
          }
        }
      ]
    },
    "NodeStatus": {
      "properties": {
        "mpa_connectivity_status": {
          "readOnly": true,
          "enum": [
            "UP",
            "DOWN",
            "UNKNOWN"
          ],
          "type": "string",
          "description": "Indicates the fabric node's MP<->MPA channel connectivity status, UP, DOWN, UNKNOWN.",
          "title": "Indicates the fabric node's MP<->MPA channel connectivity status, UP, DOWN, UNKNOWN."
        },
        "lcp_connectivity_status_details": {
          "description": "Details, if any, about the current LCP<->CCP channel connectivity status of the fabric node.",
          "title": "Details, if any, about the current LCP<->CCP channel connectivity status of the fabric node.",
          "default": [],
          "items": {
            "$ref": "#/definitions/ControlConnStatus"
          },
          "readOnly": true,
          "type": "array"
        },
        "mpa_connectivity_status_details": {
          "readOnly": true,
          "type": "string",
          "description": "Details, if any, about the current MP<->MPA channel connectivity status of the fabric node.",
          "title": "Details, if any, about the current MP<->MPA channel connectivity status of the fabric node."
        },
        "external_id": {
          "type": "string",
          "description": "HostNode external id",
          "title": "HostNode external id"
        },
        "software_version": {
          "readOnly": true,
          "type": "string",
          "description": "Software version of the fabric node.",
          "title": "Software version of the fabric node."
        },
        "maintenance_mode": {
          "readOnly": true,
          "enum": [
            "OFF",
            "ENTERING",
            "ON",
            "EXITING"
          ],
          "type": "string",
          "description": "Indicates the fabric node's status of maintenance mode, OFF, ENTERING, ON, EXITING.",
          "title": "Indicates the fabric node's status of maintenance mode, OFF, ENTERING, ON, EXITING."
        },
        "inventory_sync_paused": {
          "readOnly": true,
          "type": "boolean",
          "description": "Is true if inventory sync is paused else false",
          "title": "Is true if inventory sync is paused else false"
        },
        "system_status": {
          "readOnly": true,
          "title": "Node status properties",
          "description": "Node status properties",
          "$ref": "#/definitions/NodeStatusProperties"
        },
        "inventory_sync_reenable_time": {
          "readOnly": true,
          "type": "integer",
          "description": "Inventory sync auto re-enable target time, in epoch milis",
          "format": "int64"
        },
        "lcp_connectivity_status": {
          "description": "Indicates the fabric node's LCP<->CCP channel connectivity status, UP, DOWN, DEGRADED, UNKNOWN.",
          "title": "Indicates the fabric node's LCP<->CCP channel connectivity status, UP, DOWN, DEGRADED, UNKNOWN.",
          "default": "UNKNOWN",
          "enum": [
            "UP",
            "DOWN",
            "DEGRADED",
            "UNKNOWN"
          ],
          "readOnly": true,
          "type": "string"
        },
        "last_heartbeat_timestamp": {
          "readOnly": true,
          "type": "integer",
          "description": "Timestamp of the last heartbeat status change, in epoch milliseconds.",
          "format": "int64"
        },
        "last_sync_time": {
          "readOnly": true,
          "type": "integer",
          "description": "Timestamp of the last successful update of Inventory, in epoch milliseconds.",
          "format": "int64"
        },
        "host_node_deployment_status": {
          "readOnly": true,
          "enum": [
            "NOT_PREPARED",
            "INSTALL_IN_PROGRESS",
            "INSTALL_FAILED",
            "INSTALL_SUCCESSFUL",
            "UNINSTALL_IN_PROGRESS",
            "UNINSTALL_FAILED",
            "UNINSTALL_SUCCESSFUL",
            "UPGRADE_IN_PROGRESS",
            "UPGRADE_FAILED",
            "PENDING_UPGRADE",
            "NOT_AVAILABLE",
            "VM_DEPLOYMENT_QUEUED",
            "VM_DEPLOYMENT_IN_PROGRESS",
            "VM_DEPLOYMENT_FAILED",
            "VM_POWER_ON_IN_PROGRESS",
            "VM_POWER_ON_FAILED",
            "REGISTRATION_PENDING",
            "NODE_NOT_READY",
            "NODE_READY",
            "VM_POWER_OFF_IN_PROGRESS",
            "VM_POWER_OFF_FAILED",
            "VM_UNDEPLOY_IN_PROGRESS",
            "VM_UNDEPLOY_FAILED",
            "VM_UNDEPLOY_SUCCESSFUL",
            "EDGE_CONFIG_ERROR"
          ],
          "type": "string",
          "description": "This enum specifies the current nsx install state for host node or\ncurrent deployment and ready state for edge node.\nThe ready status 'NODE_READY' indicates whether edge node is\nready to become a transport node.\nThe status 'EDGE_CONFIG_ERROR' indicates that edge hardware or underlying\nhost is not supported.\n",
          "title": "Install/Uninstall status of deployment."
        }
      },
      "type": "object",
      "description": "Runtime status information of the fabric node.",
      "title": "Runtime status information of the fabric node."
    },
    "HttpServiceProperties": {
      "properties": {
        "session_timeout": {
          "description": "NSX session inactivity timeout, set to 0 to configure no timeout",
          "format": "int64",
          "title": "NSX session inactivity timeout, set to 0 to configure no timeout",
          "maximum": 2147483647,
          "minimum": 0,
          "type": "integer"
        },
        "certificate": {
          "readOnly": true,
          "$ref": "#/definitions/Certificate"
        },
        "redirect_host": {
          "description": "Host name or IP address to use for redirect location headers, or empty string to derive from current request",
          "default": "",
          "pattern": "/^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$|^$/",
          "type": "string"
        },
        "protocol_versions": {
          "minItems": 1,
          "items": {
            "$ref": "#/definitions/ProtocolVersion"
          },
          "type": "array",
          "description": "TLS protocol versions",
          "title": "TLS protocol versions"
        },
        "cipher_suites": {
          "minItems": 1,
          "items": {
            "$ref": "#/definitions/CipherSuite"
          },
          "type": "array",
          "description": "Cipher suites used to secure contents of connection",
          "title": "Cipher suites used to secure contents of connection"
        },
        "connection_timeout": {
          "description": "NSX connection timeout, set to 0 to configure no timeout",
          "format": "int64",
          "title": "NSX connection timeout, set to 0 to configure no timeout",
          "maximum": 2147483647,
          "minimum": 0,
          "type": "integer"
        }
      },
      "type": "object",
      "description": "HTTP Service properties",
      "title": "HTTP Service properties"
    },
    "VlanMirrorSource": {
      "allOf": [
        {
          "$ref": "#/definitions/MirrorSource"
        },
        {
          "required": [
            "vlan_ids"
          ],
          "type": "object",
          "properties": {
            "vlan_ids": {
              "minItems": 1,
              "items": {
                "type": "integer",
                "format": "int64"
              },
              "type": "array",
              "description": "Source VLAN ID list",
              "title": "Source VLAN ID list"
            }
          }
        }
      ]
    },
    "MgmtConnStatus": {
      "type": "object",
      "properties": {
        "connectivity_status": {
          "readOnly": true,
          "enum": [
            "CONNECTED",
            "DISCONNECTED",
            "UNKNOWN"
          ],
          "type": "string",
          "description": "Indicates the controller node's MP channel connectivity status",
          "title": "Indicates the controller node's MP channel connectivity status"
        }
      }
    },
    "LbPersistenceProfileListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LbPersistenceProfile"
              },
              "type": "array",
              "description": "paginated list of load balancer persistence profiles",
              "title": "paginated list of load balancer persistence profiles"
            }
          }
        }
      ]
    },
    "CloudVirtualMachine": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "discriminator": "resource_type",
          "required": [
            "resource_type"
          ],
          "type": "object",
          "properties": {
            "gateway_ha_index": {
              "format": "int64",
              "type": "integer",
              "description": "Index of HA that indicates whether gateway is primary or secondary.\nIf index is 0, then it is primary gateway. Else secondary gateway.\n",
              "title": "Index of HA that indicates whether gateway is primary or secondary.\nIf index is 0, then it is primary gateway. Else secondary gateway.\n"
            },
            "nsx_ip": {
              "readOnly": true,
              "type": "string",
              "description": "IP address provided by Nsx",
              "title": "IP address provided by Nsx"
            },
            "gateway_status": {
              "readOnly": true,
              "enum": [
                "UP",
                "DOWN",
                "DEPLOYING",
                "NOT_AVAILABLE",
                "UNDEPLOYING"
              ],
              "type": "string",
              "description": "Gateway Status",
              "title": "Gateway Status"
            },
            "is_gateway": {
              "readOnly": true,
              "type": "boolean",
              "description": "Flag to identify if this VM is a gateway node",
              "title": "Flag to identify if this VM is a gateway node"
            },
            "is_gateway_active": {
              "readOnly": true,
              "type": "boolean",
              "description": "Flag to identify if this VM is an active gateway node",
              "title": "Flag to identify if this VM is an active gateway node"
            },
            "error_messages": {
              "items": {
                "$ref": "#/definitions/ComputeInstanceErrorMessage"
              },
              "readOnly": true,
              "type": "array",
              "description": "These error messages are recent and are maximum of 1 hour old.\n",
              "title": "List of errors associated to VM"
            },
            "agent_status": {
              "readOnly": true,
              "enum": [
                "UP",
                "DOWN",
                "NO_AGENT"
              ],
              "type": "string",
              "description": "Agent Status",
              "title": "Agent Status"
            },
            "logical_switch_id": {
              "readOnly": true,
              "type": "string",
              "description": "Logical Switch ID",
              "title": "Logical Switch ID"
            },
            "logical_switch_display_name": {
              "readOnly": true,
              "type": "string",
              "description": "Logical Switch display name",
              "title": "Logical Switch display name"
            },
            "private_ip": {
              "readOnly": true,
              "type": "string",
              "description": "Private IP address of the virtual machine",
              "title": "Private IP address of the virtual machine"
            },
            "threat_state": {
              "readOnly": true,
              "enum": [
                "NORMAL",
                "THREAT",
                "INVALID"
              ],
              "type": "string",
              "description": "Indicates the threat state of the VM.\nNORMAL - This state implies no threat has been detected and VM is\nfunctioning as expected.\nTHREAT - This state implies quarantine enabling threat has been\ndetected.\nINVALID - This state implies either VM is unmanaged or threat related\ninformation is not available.\n",
              "title": "Threat State"
            },
            "os_details": {
              "readOnly": true,
              "type": "string",
              "description": "Operating system details",
              "title": "Operating system details"
            },
            "managed_by_nsx": {
              "readOnly": true,
              "type": "boolean",
              "description": "Indicate if vm is managed by NSX or not",
              "title": "Indicate if vm is managed by NSX or not"
            },
            "quarantine_state": {
              "readOnly": true,
              "enum": [
                "QUARANTINED",
                "NOT_QUARANTINED",
                "UNKNOWN",
                "OVERRIDDEN"
              ],
              "type": "string",
              "description": "Indicates the quarantine state of the VM.\nQUARANTINED - This state implies VM is moved to quarantine security\ngroup because some threat has been detected.\nNOT_QUARANTINED - This state implies no quarantine action has been\ntaken.\nUNKNOWN - This state implies either quarantine policy is disabled or\nquarantine information is not available.\nOVERRIDDEN - This state implies VM is associated with vm_override_sg\nwhich overrides any action based on threat detection.\n",
              "title": "Quarantine State"
            },
            "cloud_tags": {
              "items": {
                "$ref": "#/definitions/CloudTag"
              },
              "readOnly": true,
              "type": "array",
              "description": "Cloud tags for the virtual machine",
              "title": "Cloud tags for the virtual machine"
            },
            "public_ip": {
              "readOnly": true,
              "type": "string",
              "description": "Public IP address of the virtual machine",
              "title": "Public IP address of the virtual machine"
            },
            "os_type": {
              "readOnly": true,
              "type": "string",
              "description": "Operating system of the virtual machine",
              "title": "Operating system of the virtual machine"
            },
            "resource_type": {
              "enum": [
                "AwsVirtualMachine",
                "AzureVirtualMachine"
              ],
              "type": "string",
              "description": "Possible values are in the form of VirtualMachine prefixed by cloud\nname. For example, AwsVirtualMachine or AzureVirtualMachine.\n",
              "title": "The type of this resource"
            },
            "agent_version": {
              "readOnly": true,
              "type": "string",
              "description": "Agent version details",
              "title": "Agent version details"
            }
          }
        }
      ]
    },
    "IpPoolRange": {
      "description": "A set of IPv4 or IPv6 addresses defined by a start and end address.",
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "required": [
            "start",
            "end"
          ],
          "type": "object",
          "properties": {
            "start": {
              "format": "ip",
              "type": "string",
              "description": "The start IP Address of the IP Range."
            },
            "end": {
              "format": "ip",
              "type": "string",
              "description": "The end IP Address of the IP Range."
            }
          }
        }
      ]
    },
    "ListResultQueryParameters": {
      "type": "object",
      "properties": {
        "fields": {
          "type": "string",
          "description": "Comma-separated field names to include in query result",
          "title": "Fields to include in query results"
        }
      }
    },
    "DneRuleStats": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "type": "object",
          "properties": {
            "packets_out": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Aggregated number of outgoing packets processed by the rule.",
              "title": "Outgoing packet count"
            },
            "bytes_in": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Aggregated number of incoming bytes processed by the rule.",
              "title": "Incoming byte count"
            },
            "rule_id": {
              "readOnly": true,
              "type": "string",
              "description": "Rule Identifier of the DNE rule. This is a globally unique number.",
              "title": "DNE rule Id"
            },
            "bytes_out": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Aggregated number of outgoing bytes processed by the rule.",
              "title": "Outgoing byte count"
            },
            "packets_in": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Aggregated number of incoming packets processed by the rule.",
              "title": "Incoming packet count"
            }
          }
        }
      ]
    },
    "LogicalPortMacAddressListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "logical_port_id": {
              "readOnly": true,
              "type": "string",
              "description": "The id of the logical port",
              "title": "The id of the logical port"
            },
            "last_update_timestamp": {
              "readOnly": true,
              "type": "integer",
              "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
              "format": "int64"
            },
            "results": {
              "items": {
                "$ref": "#/definitions/LogicalPortMacTableEntry"
              },
              "type": "array"
            },
            "transport_node_id": {
              "readOnly": true,
              "type": "string",
              "description": "Transport node identifier",
              "title": "Transport node identifier"
            }
          }
        }
      ]
    },
    "SshKeyPropertiesListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/SshKeyProperties"
              },
              "type": "array",
              "description": "SSH key properties query results",
              "title": "SSH key properties query results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "SSH key properties query results",
      "title": "SSH key properties query results"
    },
    "LbPoolMemberStatistics": {
      "required": [
        "statistics",
        "ip_address"
      ],
      "type": "object",
      "properties": {
        "statistics": {
          "title": "Pool member statistics counter",
          "description": "Pool member statistics counter",
          "$ref": "#/definitions/LbStatisticsCounter"
        },
        "ip_address": {
          "format": "ip",
          "type": "string",
          "description": "Pool member IP address"
        },
        "port": {
          "format": "port-or-range",
          "type": "string",
          "description": "The port is configured in pool member. For virtual server port range\ncase, pool member port must be null.\n"
        }
      }
    },
    "PortConnectionEntities": {
      "properties": {
        "containers": {
          "$ref": "#/definitions/PortConnectionContainersEntities"
        },
        "hypervisors": {
          "items": {
            "$ref": "#/definitions/PortConnectionHypervisor"
          },
          "type": "array"
        },
        "errors": {
          "items": {
            "$ref": "#/definitions/PortConnectionError"
          },
          "type": "array"
        },
        "logical_switches": {
          "items": {
            "$ref": "#/definitions/PortConnectionLogicalSwitch"
          },
          "type": "array"
        },
        "edge_node_groups": {
          "items": {
            "$ref": "#/definitions/PortConnectionEdgeNodeGroup"
          },
          "type": "array"
        },
        "routers": {
          "items": {
            "$ref": "#/definitions/PortConnectionRouter"
          },
          "type": "array"
        },
        "vms": {
          "items": {
            "$ref": "#/definitions/VirtualMachine"
          },
          "type": "array"
        },
        "tunnels": {
          "items": {
            "$ref": "#/definitions/PortConnectionTunnel"
          },
          "type": "array"
        }
      },
      "required": [
        "errors",
        "logical_switches",
        "hypervisors",
        "tunnels",
        "vms",
        "containers"
      ],
      "type": "object",
      "description": "Port Connection Entities (to help draw a visual picture of entities between two ports)",
      "title": "Port Connection Entities (to help draw a visual picture of entities between two ports)"
    },
    "DonutPart": {
      "properties": {
        "field": {
          "type": "string",
          "description": "A numerical value that represents the portion or entity of the donut chart.",
          "title": "Value of the portion or entity of donut chart"
        },
        "render_configuration": {
          "minItems": 0,
          "items": {
            "$ref": "#/definitions/RenderConfiguration"
          },
          "type": "array",
          "description": "Additional rendering or conditional evaluation of the field values to be performed, if any.",
          "title": "Render Configuration"
        },
        "tooltip": {
          "minItems": 0,
          "items": {
            "$ref": "#/definitions/Tooltip"
          },
          "type": "array",
          "description": "Multi-line text to be shown on tooltip while hovering over the portion.",
          "title": "Multi-line tooltip"
        },
        "label": {
          "title": "Label of the portion or entity of donut chart",
          "description": "If a section 'template' holds this donut part, then the label is auto-generated from the fetched field values after applying the template.",
          "$ref": "#/definitions/Label"
        }
      },
      "required": [
        "field"
      ],
      "type": "object",
      "description": "Represents an entity or portion to be plotted on a donut chart",
      "title": "Portion of a donut chart"
    },
    "LbPoolListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LbPool"
              },
              "type": "array",
              "description": "paginated list of pools",
              "title": "paginated list of pools"
            }
          }
        }
      ]
    },
    "LocalFilestoreBackupFile": {
      "allOf": [
        {
          "$ref": "#/definitions/BackupFile"
        },
        {
          "properties": {
            "name": {
              "type": "string",
              "description": "File name",
              "title": "File name"
            },
            "file_store": {
              "enum": [
                "local"
              ],
              "type": "string",
              "description": "File location",
              "title": "File location"
            }
          },
          "required": [
            "file_store"
          ],
          "type": "object"
        }
      ],
      "description": "Local file store backup file",
      "title": "Local file store backup file"
    },
    "ResourceLink": {
      "type": "object",
      "properties": {
        "action": {
          "readOnly": true,
          "type": "string",
          "description": "Optional action",
          "title": "Optional action"
        },
        "href": {
          "readOnly": true,
          "type": "string"
        },
        "rel": {
          "readOnly": true,
          "type": "string",
          "description": "Custom relation type (follows RFC 5988 where appropriate definitions exist)",
          "title": "Link relation type"
        }
      }
    },
    "AssignedByDhcp": {
      "allOf": [
        {
          "$ref": "#/definitions/IpAssignmentSpec"
        },
        {
          "type": "object"
        }
      ],
      "description": "This type can be specified in ip assignment spec of host switch if DHCP based IP assignment is desired for host switch virtual tunnel endpoints.",
      "title": "DHCP based IP assignment."
    },
    "EdgeCluster": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "type": "object",
          "properties": {
            "member_node_type": {
              "description": "Edge cluster is homogenous collection of transport nodes.\nHence all transport nodes of the cluster must be of same type.\nThis readonly field shows the type of transport nodes.\n",
              "enum": [
                "EDGE_NODE",
                "PUBLIC_CLOUD_GATEWAY_NODE",
                "UNKNOWN"
              ],
              "readOnly": true,
              "type": "string"
            },
            "cluster_profile_bindings": {
              "items": {
                "$ref": "#/definitions/ClusterProfileTypeIdEntry"
              },
              "type": "array",
              "description": "Edge cluster profile bindings",
              "title": "Edge cluster profile bindings"
            },
            "members": {
              "items": {
                "$ref": "#/definitions/EdgeClusterMember"
              },
              "type": "array",
              "description": "EdgeCluster only supports homogeneous members.\nThese member should be backed by either EdgeNode or PublicCloudGatewayNode.\nDeploymentType and TransportNode type of these nodes should be the same.\n",
              "title": "Edge cluster members"
            },
            "deployment_type": {
              "description": "This field is a readonly field which could show deployment_type of members.\nIt would return UNKNOWN if there is no members, and return VIRTUAL_MACHINE|\nPHYSICAL_MACHINE if all edge members are VIRTUAL_MACHINE|PHYSICAL_MACHINE.\n",
              "enum": [
                "VIRTUAL_MACHINE",
                "PHYSICAL_MACHINE",
                "UNKNOWN"
              ],
              "readOnly": true,
              "type": "string"
            }
          }
        }
      ]
    },
    "File": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "file name",
          "title": "file name"
        }
      }
    },
    "ComputeManagerStatus": {
      "properties": {
        "version": {
          "readOnly": true,
          "type": "string",
          "description": "Version of the compute manager",
          "title": "Version of the compute manager"
        },
        "connection_status": {
          "readOnly": true,
          "enum": [
            "UP",
            "DOWN"
          ],
          "type": "string",
          "description": "Status of connection with the compute manager",
          "title": "Status of connection with the compute manager"
        },
        "connection_errors": {
          "items": {
            "$ref": "#/definitions/ErrorInfo"
          },
          "readOnly": true,
          "type": "array",
          "description": "Errors when connecting with compute manager",
          "title": "Errors when connecting with compute manager"
        },
        "last_sync_time": {
          "readOnly": true,
          "type": "integer",
          "description": "Timestamp of the last successful update of Inventory, in epoch milliseconds.",
          "format": "int64"
        },
        "connection_status_details": {
          "readOnly": true,
          "type": "string",
          "description": "Details about connection status",
          "title": "Details about connection status"
        },
        "registration_errors": {
          "items": {
            "$ref": "#/definitions/ErrorInfo"
          },
          "readOnly": true,
          "type": "array",
          "description": "Errors when registering with compute manager",
          "title": "Errors when registering with compute manager"
        },
        "registration_status": {
          "readOnly": true,
          "enum": [
            "REGISTERED",
            "UNREGISTERED"
          ],
          "type": "string",
          "description": "Registration status of compute manager",
          "title": "Registration status of compute manager"
        }
      },
      "type": "object",
      "description": "Runtime status information of the compute manager",
      "title": "Runtime status information of the compute manager"
    },
    "MetadataProxyStatisticsPerLogicalSwitch": {
      "required": [
        "requests_to_nova_server",
        "succeeded_responses_from_nova_server",
        "logical_switch_id",
        "requests_from_clients",
        "responses_to_clients",
        "error_responses_from_nova_server"
      ],
      "type": "object",
      "properties": {
        "requests_to_nova_server": {
          "format": "int64",
          "type": "integer",
          "description": "requests to nova server",
          "title": "requests to nova server"
        },
        "responses_to_clients": {
          "format": "int64",
          "type": "integer",
          "description": "responses to clients",
          "title": "responses to clients"
        },
        "succeeded_responses_from_nova_server": {
          "format": "int64",
          "type": "integer",
          "description": "succeeded responses from  nova server",
          "title": "succeeded responses from  nova server"
        },
        "logical_switch_id": {
          "type": "string",
          "description": "uuid of attached logical switch",
          "title": "uuid of attached logical switch"
        },
        "requests_from_clients": {
          "format": "int64",
          "type": "integer",
          "description": "requests from clients",
          "title": "requests from clients"
        },
        "error_responses_from_nova_server": {
          "format": "int64",
          "type": "integer",
          "description": "error responses from  nova server",
          "title": "error responses from  nova server"
        }
      }
    },
    "QueryPipelineRequest": {
      "properties": {
        "query_pipeline": {
          "items": {
            "$ref": "#/definitions/QueryPipeRequest"
          },
          "type": "array",
          "description": "An array of search queries",
          "title": "Query pipeline"
        }
      },
      "required": [
        "query_pipeline"
      ],
      "type": "object",
      "description": "The query pipeline request, this takes in an array of search queries\n",
      "title": "Query pipeline request"
    },
    "ErrorResolverUserInputData": {
      "required": [
        "data_type",
        "property_name"
      ],
      "type": "object",
      "description": "Corresponds to one property entered by the user",
      "properties": {
        "data_type": {
          "enum": [
            "TEXT",
            "NUMBER",
            "PASSWORD"
          ],
          "type": "string",
          "description": "The datatype of the given property. Useful for data validation",
          "title": "The datatype of the given property. Useful for data validation"
        },
        "property_name": {
          "type": "string",
          "description": "Name of the property supplied by the user",
          "title": "Name of the property supplied by the user"
        },
        "property_value": {
          "type": "string",
          "description": "The value associated with the above property",
          "title": "The value associated with the above property"
        }
      }
    },
    "LbHttpResponseHeaderRewriteAction": {
      "allOf": [
        {
          "$ref": "#/definitions/LbRuleAction"
        },
        {
          "properties": {
            "header_value": {
              "type": "string",
              "description": "Value of header field",
              "title": "Value of header field"
            },
            "header_name": {
              "type": "string",
              "description": "Name of a header field of HTTP request message",
              "title": "Name of a header field of HTTP request message"
            }
          },
          "required": [
            "header_value",
            "header_name"
          ],
          "type": "object"
        }
      ],
      "description": "This action is used to rewrite header fields of HTTP response messages to\nspecified new values at HTTP_RESPONSE_REWRITE phase. One action can be used\nto rewrite one header field. To rewrite multiple header fields, multiple\nactions must be defined.\nCaptured variables and built-in variables can be used in the header_value\nfield, header_name field does not support variables.\n",
      "title": "Action to rewrite HTTP response header fields"
    },
    "LbPoolStatistics": {
      "required": [
        "statistics",
        "pool_id"
      ],
      "type": "object",
      "properties": {
        "last_update_timestamp": {
          "type": "integer",
          "description": "Timestamp when the data was last updated",
          "format": "int64"
        },
        "statistics": {
          "title": "Virtual server statistics counter",
          "description": "Virtual server statistics counter",
          "$ref": "#/definitions/LbStatisticsCounter"
        },
        "pool_id": {
          "type": "string",
          "description": "Load balancer pool identifier",
          "title": "Load balancer pool identifier"
        },
        "members": {
          "items": {
            "$ref": "#/definitions/LbPoolMemberStatistics"
          },
          "type": "array",
          "description": "Statistics of load balancer pool members",
          "title": "Statistics of load balancer pool members"
        }
      }
    },
    "RelatedData": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "alias": {
              "type": "string",
              "description": "Alias for the related type",
              "title": "Alias"
            },
            "results": {
              "items": {
                "type": "object"
              },
              "type": "array",
              "description": "Array of related objects",
              "title": "Related objects"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "The results array will contain all the related objects\n",
      "title": "Related object details"
    },
    "EnforcementPointConnectionInfo": {
      "description": "Contains information required to connect to enforcement point",
      "title": "Enforcement point connection info",
      "required": [
        "resource_type"
      ],
      "discriminator": "resource_type",
      "type": "object",
      "properties": {
        "enforcement_point_address": {
          "format": "hostname_or_ip",
          "type": "string",
          "description": "Address of the Enforcement point",
          "title": "Address of the Enforcement point"
        },
        "resource_type": {
          "enum": [
            "NSXTConnectionInfo",
            "NSXVConnectionInfo"
          ],
          "type": "string"
        }
      }
    },
    "NodeInterfacePropertiesListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/NodeInterfaceProperties"
              },
              "type": "array",
              "description": "Node interface property results",
              "title": "Node interface property results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Node network interface properties list results",
      "title": "Node network interface properties list results"
    },
    "ManagementClusterNodeStatus": {
      "type": "object",
      "properties": {
        "mgmt_cluster_status": {
          "description": "Status of this node's connection to the management cluster",
          "enum": [
            "CONNECTED",
            "DISCONNECTED",
            "UNKNOWN"
          ],
          "readOnly": true,
          "type": "string"
        }
      }
    },
    "DiscoveredNodeListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/DiscoveredNode"
              },
              "type": "array",
              "description": "Discovered Node list results",
              "title": "Discovered Node list results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Discovered Node list result",
      "title": "Discovered Node list result"
    },
    "LogicalRouterPortStatisticsPerNode": {
      "allOf": [
        {
          "$ref": "#/definitions/AggregatedLogicalRouterPortCounters"
        },
        {
          "type": "object",
          "properties": {
            "transport_node_id": {
              "readOnly": true,
              "type": "string",
              "description": "The ID of the TransportNode",
              "title": "The ID of the TransportNode"
            }
          }
        }
      ]
    },
    "RoleBindingListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/RoleBinding"
              },
              "type": "array",
              "description": "List results",
              "title": "List results"
            }
          }
        }
      ]
    },
    "BridgeCluster": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "cluster_profile_bindings": {
              "items": {
                "$ref": "#/definitions/ClusterProfileTypeIdEntry"
              },
              "type": "array",
              "description": "Bridge cluster profile bindings",
              "title": "Bridge cluster profile bindings"
            },
            "bridge_nodes": {
              "items": {
                "$ref": "#/definitions/BridgeClusterNode"
              },
              "type": "array",
              "description": "Nodes used in bridging",
              "maxItems": 2,
              "title": "Nodes used in bridging"
            }
          },
          "required": [
            "bridge_nodes"
          ],
          "type": "object"
        }
      ],
      "description": "Bridge Cluster",
      "title": "Bridge Cluster"
    },
    "ServiceEntry": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "required": [
            "resource_type"
          ],
          "discriminator": "resource_type",
          "type": "object",
          "properties": {
            "resource_type": {
              "enum": [
                "EtherTypeServiceEntry",
                "IPProtocolServiceEntry",
                "IGMPTypeServiceEntry",
                "ICMPTypeServiceEntry",
                "ALGTypeServiceEntry",
                "L4PortSetServiceEntry"
              ],
              "type": "string"
            }
          }
        }
      ],
      "description": "An Service entry that describes traffic",
      "title": "An Service entry that describes traffic"
    },
    "LbMonitorListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LbMonitor"
              },
              "type": "array",
              "description": "paginated list of load balancer monitors",
              "title": "paginated list of load balancer monitors"
            }
          }
        }
      ]
    },
    "AwsAccountStatus": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "inventory_sync_step": {
              "readOnly": true,
              "enum": [
                "SYNCING_AWS_REGIONS",
                "SYNCING_AWS_VPCS",
                "SYNCING_AWS_AZS",
                "SYNCING_VMS",
                "SYNCING_NSX_DATA",
                "SYNCING_AWS_GATEWAYS",
                "SYNCING_MANAGED_INSTANCES",
                "NOT_APPLICABLE"
              ],
              "type": "string",
              "description": "State of inventory sync",
              "title": "State of inventory sync"
            },
            "inventory_sync_status": {
              "readOnly": true,
              "enum": [
                "SYNCED",
                "IN_PROGRESS"
              ],
              "type": "string",
              "description": "State of inventory sync",
              "title": "State of inventory sync"
            },
            "credentials_status": {
              "readOnly": true,
              "enum": [
                "VALID",
                "INVALID"
              ],
              "type": "string",
              "description": "Status of the account credentials synched at the auto interval",
              "title": "Status of the account credentials synched at the auto interval"
            }
          },
          "type": "object"
        }
      ],
      "description": "AWS account status",
      "title": "AWS account status"
    },
    "QuickSearchResponse": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "required": [
            "results",
            "result_count"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/ResourceTypeGroup"
              },
              "type": "array",
              "description": "Search results",
              "title": "Search results"
            },
            "result_count": {
              "format": "int64",
              "type": "integer",
              "description": "Result count",
              "title": "Result count"
            }
          }
        }
      ]
    },
    "BridgeEndpointStatistics": {
      "allOf": [
        {
          "$ref": "#/definitions/AggregatedDataCounter"
        },
        {
          "type": "object",
          "properties": {
            "last_update_timestamp": {
              "readOnly": true,
              "type": "integer",
              "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
              "format": "int64"
            },
            "endpoint_id": {
              "readOnly": true,
              "type": "string",
              "description": "The id of the bridge endpoint",
              "title": "The id of the bridge endpoint"
            }
          }
        }
      ]
    },
    "LbPoolMemberStatus": {
      "required": [
        "status",
        "ip_address"
      ],
      "type": "object",
      "properties": {
        "status": {
          "enum": [
            "UP",
            "DOWN",
            "DISABLED",
            "GRACEFUL_DISABLED"
          ],
          "type": "string",
          "description": "UP means that pool member is enabled and monitors have marked the pool\nmember as UP. If the pool member has no monitor configured, it would\nbe treated as UP.\nDOWN means that pool member is enabled and monitors have marked the\npool member as DOWN.\nDISABLED means that admin state of pool member is set to DISABLED.\nGRACEFUL_DISABLED means that admin state of pool member is set to\nGRACEFUL_DISABLED.\n",
          "title": "Pool member status"
        },
        "failure_cause": {
          "type": "string",
          "description": "The healthcheck failure cause when status is DOWN",
          "title": "The healthcheck failure cause when status is DOWN"
        },
        "last_check_time": {
          "type": "integer",
          "description": "Timestamp in milliseconds since epoch",
          "format": "int64"
        },
        "ip_address": {
          "format": "ip",
          "type": "string",
          "description": "Pool member IP address"
        },
        "last_state_change_time": {
          "type": "integer",
          "description": "Timestamp in milliseconds since epoch",
          "format": "int64"
        },
        "port": {
          "format": "port-or-range",
          "type": "string",
          "description": "The port is configured in pool member. For virtual server port range\ncase, pool member port must be null.\n"
        }
      }
    },
    "MacLearningCounters": {
      "type": "object",
      "properties": {
        "macs_learned": {
          "format": "int64",
          "type": "integer",
          "description": "Number of MACs learned",
          "title": "Number of MACs learned"
        },
        "mac_not_learned_packets_dropped": {
          "format": "int64",
          "type": "integer",
          "description": "The number of packets with unknown source MAC address that are dropped without learning the source MAC address. Applicable only when the MAC limit is reached and MAC Limit policy is MAC_LEARNING_LIMIT_POLICY_DROP.",
          "title": "Number of dropped packets with unknown source MAC address."
        },
        "mac_not_learned_packets_allowed": {
          "format": "int64",
          "type": "integer",
          "description": "The number of packets with unknown source MAC address that are dispatched without learning the source MAC address. Applicable only when the MAC limit is reached and MAC Limit policy is MAC_LEARNING_LIMIT_POLICY_ALLOW.",
          "title": "Number of dispatched packets with unknown source MAC address."
        }
      }
    },
    "EULAAcceptance": {
      "required": [
        "acceptance"
      ],
      "type": "object",
      "description": "Indicate the status of End User License Agreement acceptance",
      "properties": {
        "acceptance": {
          "type": "boolean",
          "description": "End User License Agreement acceptance status",
          "title": "End User License Agreement acceptance status"
        }
      }
    },
    "LbPersistenceCookieTime": {
      "allOf": [
        {
          "$ref": "#/definitions/LbCookieTime"
        },
        {
          "required": [
            "cookie_max_idle"
          ],
          "type": "object",
          "properties": {
            "cookie_max_idle": {
              "description": "HTTP cookie max-age to expire cookie, only available for insert mode.\n",
              "format": "int64",
              "title": "persistence cookie max idle time in seconds",
              "maximum": 2147483647,
              "minimum": 1,
              "type": "integer"
            }
          }
        }
      ]
    },
    "FilePropertiesListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/FileProperties"
              },
              "type": "array",
              "description": "File property results",
              "title": "File property results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "File properties query results",
      "title": "File properties query results"
    },
    "NSGroup": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "member_count": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Count of the members added to this NSGroup",
              "title": "Count of the members added to this NSGroup"
            },
            "members": {
              "items": {
                "$ref": "#/definitions/NSGroupSimpleExpression"
              },
              "type": "array",
              "description": "Reference to the direct/static members of the NSGroup.\nCan be ID based expressions only. VirtualMachine cannot\nbe added as a static member.\n",
              "maxItems": 500,
              "title": "Members of NSGroup"
            },
            "membership_criteria": {
              "items": {
                "$ref": "#/definitions/NSGroupExpression"
              },
              "type": "array",
              "description": "List of tag or name based expressions which define the dynamic membership criteria\nfor this NSGroup. An object must satisfy atleast one of these expressions\nto qualify as a member of this group.\n",
              "maxItems": 5,
              "title": "The criteria for membership of this NSGroup"
            }
          },
          "type": "object"
        }
      ],
      "description": "NSGroups are recursive groupings of different NSX elements (logical and physical), typically used in policy definitions.",
      "title": "Networking and Security Group"
    },
    "DhcpLeases": {
      "required": [
        "timestamp",
        "dhcp_server_id"
      ],
      "type": "object",
      "properties": {
        "timestamp": {
          "type": "integer",
          "description": "timestamp of the lease info",
          "format": "int64"
        },
        "leases": {
          "items": {
            "$ref": "#/definitions/DhcpLeasePerIP"
          },
          "type": "array",
          "description": "The lease info list of the server",
          "title": "The lease info list of the server"
        },
        "dhcp_server_id": {
          "type": "string",
          "description": "dhcp server uuid",
          "title": "dhcp server uuid"
        }
      }
    },
    "NodeIdServicesMap": {
      "required": [
        "service_types",
        "node_id"
      ],
      "type": "object",
      "properties": {
        "service_types": {
          "items": {
            "enum": [
              "MGMT_CLUSTER",
              "MGMT_PLANE",
              "API"
            ],
            "type": "string",
            "description": "Supported service types, that are using certificates."
          },
          "readOnly": false,
          "type": "array",
          "description": "list of ServiceTypes"
        },
        "node_id": {
          "readOnly": false,
          "maxLength": 255,
          "type": "string",
          "description": "NodeId",
          "title": "NodeId"
        }
      }
    },
    "PreconfiguredHostSwitchSpec": {
      "allOf": [
        {
          "$ref": "#/definitions/HostSwitchSpec"
        },
        {
          "properties": {
            "host_switches": {
              "items": {
                "$ref": "#/definitions/PreconfiguredHostSwitch"
              },
              "type": "array",
              "description": "Preconfigured Transport Node host switches",
              "maxItems": 1,
              "title": "Preconfigured Transport Node host switches"
            }
          },
          "required": [
            "host_switches"
          ],
          "type": "object"
        }
      ],
      "description": "Preconfigured host switch specification is used for manually configured transport node. It is user's responsibility to ensure correct configuration is provided to NSX. This type is only valid for supported KVM fabric nodes.",
      "title": "Specification of transport node preconfigured host switch"
    },
    "LbSnatIpElement": {
      "required": [
        "ip_address"
      ],
      "type": "object",
      "properties": {
        "ip_address": {
          "format": "address-or-block-or-range",
          "type": "string",
          "description": "Ip address or ip range such as 1.1.1.1 or 1.1.1.101-1.1.1.160"
        },
        "prefix_length": {
          "format": "int64",
          "type": "integer",
          "description": "Subnet prefix length should be not specified if there is only one single\nIP address or IP range.\n",
          "title": "subnet prefix length"
        }
      }
    },
    "ClasslessStaticRoute": {
      "required": [
        "next_hop",
        "network"
      ],
      "type": "object",
      "properties": {
        "next_hop": {
          "format": "ip",
          "type": "string",
          "description": "router"
        },
        "network": {
          "format": "address-or-block-or-range",
          "type": "string",
          "description": "destination in cidr"
        }
      }
    },
    "VersionedDeploymentSpec": {
      "properties": {
        "service_vm_ovf_url": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "list of service vm ovf urls",
          "title": "list of service vm ovf urls"
        },
        "package_stores": {
          "items": {
            "$ref": "#/definitions/PackageStore"
          },
          "type": "array",
          "description": "Package store contains package url and bulletin_ids",
          "title": "Package store contains package url and bulletin_ids"
        },
        "host_type": {
          "enum": [
            "ESXI",
            "RHELKVM",
            "UBUNTUKVM"
          ],
          "type": "string",
          "description": "type of host",
          "title": "type of host"
        },
        "host_version": {
          "type": "string",
          "description": "version of the host",
          "title": "version of the host"
        }
      },
      "required": [
        "package_stores",
        "host_type",
        "host_version"
      ],
      "type": "object",
      "description": "Versioned DeploymentSpec contains vibs and ofv urls for specific version of fabric module and host type and host version.",
      "title": "Versioned DeploymentSpec contains vibs and ofv urls for specific version of fabric module and host type and host version."
    },
    "ErrorResolverInfoList": {
      "properties": {
        "results": {
          "items": {
            "$ref": "#/definitions/ErrorResolverInfo"
          },
          "type": "array",
          "description": "ErrorResolverInfo list",
          "title": "ErrorResolverInfo list"
        }
      },
      "required": [
        "results"
      ],
      "type": "object",
      "description": "Collection of all registered ErrorResolverInfo",
      "title": "Collection of all registered ErrorResolverInfo"
    },
    "NodeLogPropertyHeaders": {
      "type": "object",
      "description": "Node log property headers",
      "title": "Node log property headers"
    },
    "PolicyNode": {
      "properties": {
        "attributes": {
          "items": {
            "$ref": "#/definitions/PolicyNodeProperty"
          },
          "type": "array"
        },
        "id": {
          "type": "string",
          "description": "id of the node",
          "title": "id of the node"
        },
        "children": {
          "items": {
            "$ref": "#/definitions/PolicyNode"
          },
          "type": "array",
          "description": "None",
          "title": "children of this node"
        }
      },
      "type": "object",
      "description": "Representation of a policy node",
      "title": "PolicyNode"
    },
    "AwsRegion": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "vpc_stats": {
              "readOnly": true,
              "title": "VPC statistics",
              "description": "VPC statistics",
              "$ref": "#/definitions/VpcStats"
            },
            "has_managed_vpc": {
              "readOnly": true,
              "type": "boolean",
              "description": "Has a managed VPC?",
              "title": "Has a managed VPC?"
            },
            "instance_stats": {
              "readOnly": true,
              "title": "Instance statistics",
              "description": "Instance statistics",
              "$ref": "#/definitions/InstanceStats"
            },
            "availability_zones": {
              "items": {
                "$ref": "#/definitions/AwsAvailabilityZoneInfo"
              },
              "readOnly": true,
              "type": "array",
              "description": "Availability zones under this region",
              "title": "Availability zones under this region"
            },
            "gateway_stats": {
              "readOnly": true,
              "title": "Gateway statistics",
              "description": "Gateway statistics",
              "$ref": "#/definitions/GatewayStats"
            }
          },
          "type": "object"
        }
      ],
      "description": "Aws Region Information",
      "title": "Aws Region Information"
    },
    "SearchResponse": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "type": "object"
              },
              "type": "array",
              "description": "Search results",
              "title": "Search results"
            }
          }
        }
      ]
    },
    "EdgeNodeDeploymentConfig": {
      "required": [
        "node_user_settings",
        "vm_deployment_config"
      ],
      "type": "object",
      "properties": {
        "node_user_settings": {
          "title": "Node user settings",
          "description": "Username and password settings for the node.\nNote - these settings will be honored only during node deployment.\nPost deployment, CLI must be used for changing the user settings, changes to these parameters will not have any effect.\n",
          "$ref": "#/definitions/NodeUserSettings"
        },
        "vm_deployment_config": {
          "$ref": "#/definitions/DeploymentConfig"
        },
        "form_factor": {
          "description": "Supported edge form factor.",
          "default": "MEDIUM",
          "enum": [
            "SMALL",
            "MEDIUM",
            "LARGE"
          ],
          "type": "string"
        }
      }
    },
    "MandatoryAccessControlProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "status": {
              "readOnly": true,
              "enum": [
                "ENABLED",
                "DISABLED",
                "ENABLED_PENDING_REBOOT"
              ],
              "type": "string",
              "description": "current status of Mandatory Access Control"
            },
            "enabled": {
              "type": "boolean",
              "description": "Enabled can be True/False"
            }
          },
          "type": "object"
        }
      ],
      "description": "Information about mandatory access control",
      "title": "Information about mandatory access control"
    },
    "CsmConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "csm_appliance_status": {
              "readOnly": false,
              "enum": [
                "UNINITIALIZED",
                "INITIALIZED"
              ],
              "type": "string",
              "description": "Csm appliance status",
              "title": "Csm appliance status"
            },
            "single_region": {
              "readOnly": false,
              "type": "boolean",
              "description": "This property is used only if CSM is running in service mode",
              "title": "Specifies whether this is a single/multi region deployment"
            }
          },
          "type": "object"
        }
      ],
      "description": "Information about status of cloud service manager",
      "title": "Information about status of cloud service manager"
    },
    "VirtualNetworkInterface": {
      "allOf": [
        {
          "$ref": "#/definitions/DiscoveredResource"
        },
        {
          "required": [
            "device_key",
            "owner_vm_id",
            "vm_local_id_on_host",
            "mac_address",
            "host_id",
            "external_id"
          ],
          "type": "object",
          "properties": {
            "mac_address": {
              "type": "string",
              "description": "MAC address of the virtual network interface.",
              "title": "MAC address of the virtual network interface."
            },
            "device_key": {
              "type": "string",
              "description": "Device key of the virtual network interface.",
              "title": "Device key of the virtual network interface."
            },
            "host_id": {
              "type": "string",
              "description": "Id of the host on which the vm exists.",
              "title": "Id of the host on which the vm exists."
            },
            "owner_vm_id": {
              "type": "string",
              "description": "Id of the vm to which this virtual network interface belongs.",
              "title": "Id of the vm to which this virtual network interface belongs."
            },
            "vm_local_id_on_host": {
              "type": "string",
              "description": "Id of the vm unique within the host.",
              "title": "Id of the vm unique within the host."
            },
            "external_id": {
              "type": "string",
              "description": "External Id of the virtual network inferface.",
              "title": "External Id of the virtual network inferface."
            },
            "lport_attachment_id": {
              "type": "string",
              "description": "LPort Attachment Id of the virtual network interface.",
              "title": "LPort Attachment Id of the virtual network interface."
            },
            "ip_address_info": {
              "items": {
                "$ref": "#/definitions/IpAddressInfo"
              },
              "type": "array",
              "description": "IP Addresses of the the virtual network interface, from various sources.",
              "title": "IP Addresses of the the virtual network interface, from various sources."
            },
            "device_name": {
              "type": "string",
              "description": "Device name of the virtual network interface.",
              "title": "Device name of the virtual network interface."
            }
          }
        }
      ]
    },
    "CrlList": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/Crl"
              },
              "readOnly": true,
              "type": "array",
              "description": "CRL list"
            }
          },
          "type": "object"
        }
      ],
      "description": "Crl queries result",
      "title": "Crl queries result"
    },
    "DneKeyPolicyListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/DneKeyPolicy"
              },
              "readOnly": true,
              "type": "array",
              "description": "List of DNE key policies. The list has to be homogenous.",
              "title": "DNE key policy list"
            }
          }
        }
      ]
    },
    "PortConnectionLogicalSwitch": {
      "allOf": [
        {
          "$ref": "#/definitions/PortConnectionEntity"
        },
        {
          "properties": {
            "vm_ports": {
              "items": {
                "$ref": "#/definitions/LogicalPort"
              },
              "readOnly": true,
              "type": "array",
              "description": "Logical Ports that are attached to a VIF/VM",
              "title": "Logical Ports that are attached to a VIF/VM"
            },
            "vm_vnics": {
              "items": {
                "$ref": "#/definitions/VirtualNetworkInterface"
              },
              "readOnly": true,
              "type": "array",
              "description": "Virutal Network Interfaces that are attached to the Logical Ports",
              "title": "Virutal Network Interfaces that are attached to the Logical Ports"
            },
            "router_ports": {
              "items": {
                "$ref": "#/definitions/LogicalPort"
              },
              "readOnly": true,
              "type": "array",
              "description": "Logical Ports that are attached to a router",
              "title": "Logical Ports that are attached to a router"
            }
          },
          "type": "object"
        }
      ],
      "description": "Port Connection Logical Switch Entity",
      "title": "Port Connection Logical Switch Entity"
    },
    "TraceflowObservationForwardedLogical": {
      "allOf": [
        {
          "$ref": "#/definitions/TraceflowObservation"
        },
        {
          "type": "object",
          "properties": {
            "lport_name": {
              "readOnly": true,
              "type": "string",
              "description": "The name of the logical port through which the traceflow packet was forwarded.",
              "title": "The name of the logical port through which the traceflow packet was forwarded."
            },
            "component_id": {
              "readOnly": true,
              "type": "string",
              "description": "The id of the component that forwarded the traceflow packet.",
              "title": "The id of the component that forwarded the traceflow packet."
            },
            "dst_component_type": {
              "description": "The type of the destination component to which the traceflow packet was forwarded.",
              "enum": [
                "PHYSICAL",
                "LR",
                "LS",
                "DFW",
                "BRIDGE",
                "EDGE_TUNNEL",
                "EDGE_HOSTSWITCH",
                "UNKNOWN"
              ],
              "readOnly": true,
              "type": "string"
            },
            "lport_id": {
              "readOnly": true,
              "type": "string",
              "description": "The id of the logical port through which the traceflow packet was forwarded.",
              "title": "The id of the logical port through which the traceflow packet was forwarded."
            },
            "dst_component_id": {
              "readOnly": true,
              "type": "string",
              "description": "The id of the destination component to which the traceflow packet was forwarded.",
              "title": "The id of the destination component to which the traceflow packet was forwarded."
            },
            "acl_rule_id": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "The id of the acl rule that was applied to forward the traceflow packet",
              "title": "The id of the acl rule that was applied to forward the traceflow packet"
            },
            "vni": {
              "readOnly": true,
              "format": "int32",
              "type": "integer",
              "description": "VNI for the logical network on which the traceflow packet was forwarded.",
              "title": "VNI for the logical network on which the traceflow packet was forwarded."
            },
            "dst_component_name": {
              "readOnly": true,
              "type": "string",
              "description": "The name of the destination component to which the traceflow packet was forwarded.",
              "title": "The name of the destination component to which the traceflow packet was forwarded."
            }
          }
        }
      ]
    },
    "AwsSubnetListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/AwsSubnet"
              },
              "type": "array",
              "description": "Aws subnets list result",
              "title": "Aws subnets list result"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Aws subnets list",
      "title": "Aws subnets list"
    },
    "IngressBroadcastRateShaper": {
      "allOf": [
        {
          "$ref": "#/definitions/QosBaseRateShaper"
        },
        {
          "properties": {
            "average_bandwidth_kbps": {
              "description": "Average bandwidth in kb/s",
              "format": "int32",
              "default": 0,
              "title": "Average bandwidth in kb/s",
              "minimum": 0,
              "type": "integer"
            },
            "peak_bandwidth_kbps": {
              "description": "Peak bandwidth in kb/s",
              "format": "int32",
              "default": 0,
              "title": "Peak bandwidth in kb/s",
              "minimum": 0,
              "type": "integer"
            },
            "burst_size_bytes": {
              "description": "Burst size in bytes",
              "format": "int32",
              "default": 0,
              "title": "Burst size in bytes",
              "minimum": 0,
              "type": "integer"
            }
          },
          "type": "object"
        }
      ],
      "description": "A shaper that specifies ingress rate properties in kb/s",
      "title": "A shaper that specifies ingress rate properties in kb/s"
    },
    "RemainingSupportBundleNode": {
      "type": "object",
      "properties": {
        "status": {
          "readOnly": true,
          "enum": [
            "PENDING",
            "PROCESSING"
          ],
          "type": "string",
          "description": "Status of node",
          "title": "Status of node"
        },
        "node_display_name": {
          "readOnly": true,
          "type": "string",
          "description": "Display name of node",
          "title": "Display name of node"
        },
        "node_id": {
          "readOnly": true,
          "type": "string",
          "description": "UUID of node",
          "title": "UUID of node"
        }
      }
    },
    "AdvertisementRuleFilter": {
      "required": [
        "prefix_operator",
        "match_route_types"
      ],
      "type": "object",
      "description": "To filter the routes advertised by the TIER1 LR to TIER0 LR. Filtering will be based on the type of route and the prefix operator configured.",
      "properties": {
        "prefix_operator": {
          "default": "GE",
          "enum": [
            "GE",
            "EQ"
          ],
          "type": "string",
          "description": "GE prefix operator filters all the routes having network subset of any of the networks configured in Advertise rule. EQ prefix operator filter all the routes having network equal to any of the network configured in Advertise rule.",
          "title": "Prefix operator to apply on networks"
        },
        "match_route_types": {
          "minItems": 1,
          "items": {
            "enum": [
              "ANY",
              "STATIC",
              "NSX_CONNECTED",
              "T1_NAT",
              "T1_LB_VIP",
              "T1_LB_SNAT"
            ],
            "type": "string",
            "description": "Route types to filter the routes advertised by TIER1 LR. The ANY type filters all routes advertised by TIER1. The STATIC type filters STATIC routes advertised by TIER1. The NSX_CONNECTED type filters routes conrresponding to downlink networks advertised by TIER1. The T1_NAT type filters routes for NAT rules advertised by TIER1. The T1_LB_VIP type filters LB VIP networks advertised by TIER1. The T1_LB_SNAT type filters routes correspoding to LB SNAT rules advertised by TIER1."
          },
          "type": "array",
          "description": "Array of route types to filter routes",
          "title": "Array of route types to filter routes"
        }
      }
    },
    "FireWallServiceAssociationListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ServiceAssociationListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/FirewallRule"
              },
              "readOnly": true,
              "type": "array",
              "description": "Firewall rule list result with pagination support.",
              "title": "Firewall rule list result"
            }
          }
        }
      ]
    },
    "DhcpStaticBindingListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/DhcpStaticBinding"
              },
              "type": "array",
              "description": "paginated list of dhcp static bindings",
              "title": "paginated list of dhcp static bindings"
            }
          }
        }
      ]
    },
    "NodeInstallUpgradeServiceProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/NodeServiceProperties"
        },
        {
          "properties": {
            "service_properties": {
              "title": "install-upgrade Service properties",
              "description": "install-upgrade Service properties",
              "$ref": "#/definitions/InstallUpgradeServiceProperties"
            }
          },
          "type": "object"
        }
      ],
      "description": "Node install-upgrade service properties",
      "title": "Node install-upgrade service properties"
    },
    "AggregateResponse": {
      "properties": {
        "primary": {
          "type": "object",
          "description": "Requested properties of the primary object",
          "title": "Primary object properties"
        },
        "related": {
          "items": {
            "$ref": "#/definitions/RelatedData"
          },
          "type": "array",
          "description": "Requested properties of the related objects",
          "title": "Related objects properties"
        }
      },
      "required": [
        "primary",
        "related"
      ],
      "type": "object",
      "description": "Response for the primary/related types",
      "title": "Aggregate response"
    },
    "LogicalSwitchStatusSummary": {
      "required": [
        "total_switches",
        "fully_realized_switches"
      ],
      "type": "object",
      "properties": {
        "last_update_timestamp": {
          "readOnly": true,
          "type": "integer",
          "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
          "format": "int64"
        },
        "total_switches": {
          "format": "int64",
          "type": "integer",
          "description": "The total number of logical switches.",
          "title": "The total number of logical switches."
        },
        "filters": {
          "items": {
            "$ref": "#/definitions/Filter"
          },
          "type": "array",
          "description": "The filters used to find the logical switches- TransportZone id, LogicalSwitchProfile id or TransportType",
          "title": "The filters used to find the logical switches- TransportZone id, LogicalSwitchProfile id or TransportType"
        },
        "fully_realized_switches": {
          "format": "int64",
          "type": "integer",
          "description": "The number of logical switches that are realized in all transport nodes.",
          "title": "The number of logical switches that are realized in all transport nodes."
        }
      }
    },
    "LogicalRouterPortStatisticsSummary": {
      "allOf": [
        {
          "$ref": "#/definitions/AggregatedLogicalRouterPortCounters"
        },
        {
          "required": [
            "logical_router_port_id"
          ],
          "type": "object",
          "properties": {
            "logical_router_port_id": {
              "type": "string",
              "description": "The ID of the logical router port",
              "title": "The ID of the logical router port"
            }
          }
        }
      ]
    },
    "FeatureUsageCsvRecord": {
      "allOf": [
        {
          "$ref": "#/definitions/CsvRecord"
        },
        {
          "type": "object",
          "properties": {
            "cpu_usage_count": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "count of number of cpu sockets used by this feature",
              "title": "count of number of cpu sockets used by this feature"
            },
            "feature": {
              "readOnly": true,
              "type": "string",
              "description": "name of the feature",
              "title": "name of the feature"
            },
            "vm_usage_count": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "count of number of vms used by this feature",
              "title": "count of number of vms used by this feature"
            }
          }
        }
      ]
    },
    "LogicalSwitch": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "transport_zone_id",
            "admin_state"
          ],
          "type": "object",
          "properties": {
            "replication_mode": {
              "enum": [
                "MTEP",
                "SOURCE"
              ],
              "type": "string",
              "description": "Replication mode of the Logical Switch",
              "title": "Replication mode of the Logical Switch"
            },
            "admin_state": {
              "enum": [
                "UP",
                "DOWN"
              ],
              "type": "string",
              "description": "Represents Desired state of the Logical Switch",
              "title": "Represents Desired state of the Logical Switch"
            },
            "address_bindings": {
              "description": "Address bindings for the Logical switch",
              "title": "Address bindings for the Logical switch",
              "minItems": 0,
              "items": {
                "$ref": "#/definitions/PacketAddressClassifier"
              },
              "maxItems": 100,
              "type": "array"
            },
            "transport_zone_id": {
              "type": "string",
              "description": "Id of the TransportZone to which this LogicalSwitch is associated",
              "title": "Id of the TransportZone to which this LogicalSwitch is associated"
            },
            "ip_pool_id": {
              "type": "string",
              "description": "IP pool id that associated with a LogicalSwitch.",
              "title": "Allocation ip pool associated with the Logical switch"
            },
            "vlan": {
              "type": "integer",
              "format": "int64"
            },
            "switching_profile_ids": {
              "items": {
                "$ref": "#/definitions/SwitchingProfileTypeIdEntry"
              },
              "type": "array"
            },
            "mac_pool_id": {
              "type": "string",
              "description": "Mac pool id that associated with a LogicalSwitch.",
              "title": "Allocation mac pool associated with the Logical switch"
            },
            "vni": {
              "readOnly": true,
              "format": "int32",
              "type": "integer",
              "description": "VNI for this LogicalSwitch.",
              "title": "VNI for this LogicalSwitch."
            }
          }
        }
      ]
    },
    "LbSslProtocolInfo": {
      "properties": {
        "is_default": {
          "type": "boolean",
          "description": "Default SSL protocol flag",
          "title": "Default SSL protocol flag"
        },
        "is_secure": {
          "type": "boolean",
          "description": "Secure/insecure SSL protocol flag",
          "title": "Secure/insecure SSL protocol flag"
        },
        "protocol": {
          "type": "string",
          "description": "SSL protocol",
          "enum": [
            "SSL_V2",
            "SSL_V3",
            "TLS_V1",
            "TLS_V1_1",
            "TLS_V1_2"
          ]
        }
      },
      "required": [
        "is_default",
        "is_secure",
        "protocol"
      ],
      "type": "object",
      "description": "SSL protocol",
      "title": "SSL protocol"
    },
    "UpgradeUnitTypeStatsList": {
      "type": "object",
      "properties": {
        "results": {
          "items": {
            "$ref": "#/definitions/UpgradeUnitTypeStats"
          },
          "readOnly": true,
          "type": "array",
          "description": "List of upgrade unit type stats",
          "title": "List of upgrade unit type stats"
        }
      }
    },
    "PolicyTemplate": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "template_body": {
              "title": "Template Body",
              "description": "Template Body",
              "$ref": "#/definitions/AbstractSpace"
            },
            "template_placeholders": {
              "items": {
                "$ref": "#/definitions/PolicyTemplatePlaceholder"
              },
              "type": "array",
              "description": "Template placeholders",
              "title": "Template placeholders"
            }
          },
          "required": [
            "template_body",
            "template_placeholders"
          ],
          "type": "object"
        }
      ],
      "description": "Policy Template",
      "title": "Policy Template"
    },
    "ComponentTargetVersion": {
      "type": "object",
      "properties": {
        "target_version": {
          "readOnly": true,
          "type": "string"
        },
        "component_type": {
          "readOnly": true,
          "type": "string"
        }
      }
    },
    "AggregateDataResponse": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/AggregateResponse"
              },
              "type": "array",
              "description": "Array containing the primary and the related object details",
              "title": "Results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Final data aggregation response.\nThe results array holds the primary and the related objects\n",
      "title": "Data aggregation response"
    },
    "NtpServiceProperties": {
      "properties": {
        "servers": {
          "items": {
            "pattern": "/^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/",
            "type": "string",
            "description": "Hostname or IPv4 address"
          },
          "type": "array",
          "description": "NTP servers",
          "title": "NTP servers"
        }
      },
      "required": [
        "servers"
      ],
      "type": "object",
      "description": "NTP Service properties",
      "title": "NTP Service properties"
    },
    "RealizedNSGroup": {
      "allOf": [
        {
          "$ref": "#/definitions/RealizedGroup"
        },
        {
          "properties": {
            "evaluations": {
              "description": "Reference to the evaluated members of the NSGroup.\n",
              "title": "Evaluated members of NSGroup",
              "items": {
                "$ref": "#/definitions/RealizedNSGroupMemberEvaluation"
              },
              "readOnly": true,
              "maxItems": 500,
              "type": "array"
            }
          },
          "type": "object"
        }
      ],
      "description": "Realized Network and Security Group",
      "title": "Realized Network and Security Group"
    },
    "HostSwitch": {
      "properties": {
        "pnics": {
          "items": {
            "$ref": "#/definitions/Pnic"
          },
          "type": "array",
          "description": "Physical NICs connected to the host switch",
          "title": "Physical NICs connected to the host switch"
        },
        "host_switch_name": {
          "default": "nsxDefaultHostSwitch",
          "type": "string",
          "description": "If this name is unset or empty then the default host switch name will be used. The name must be unique among all host switches specified in a given Transport Node; unset name, empty name and the default host switch name are considered the same in terms of uniqueness.",
          "title": "HostSwitch name. This name will be used to reference this HostSwitch."
        },
        "static_ip_pool_id": {
          "type": "string",
          "description": "ID of configured Static IP Pool. If specified allocate IP for Endpoints from Pool. Else assume IP will be assigned for Endpoints from DHCP. This field is deprecated, use ip_assignment_spec field instead.",
          "x-deprecated": true,
          "title": "ID of already configured Static IP Pool."
        },
        "host_switch_profile_ids": {
          "items": {
            "$ref": "#/definitions/HostSwitchProfileTypeIdEntry"
          },
          "type": "array",
          "description": "HostSwitch profiles bound to this HostSwitch. If a profile ID is not provided for any HostSwitchProfileType that is supported by the Transport Node, the corresponding default profile will be bound to the HostSwitch.",
          "title": "Id's of HostSwitch profiles to be associated with this HostSwitch."
        }
      },
      "type": "object",
      "description": "Host Switch specification",
      "title": "Host Switch specification"
    },
    "ComponentUpgradeStatus": {
      "type": "object",
      "properties": {
        "status": {
          "readOnly": true,
          "enum": [
            "SUCCESS",
            "FAILED",
            "IN_PROGRESS",
            "NOT_STARTED",
            "PAUSED"
          ],
          "type": "string",
          "description": "Upgrade status of component",
          "title": "Upgrade status of component"
        },
        "percent_complete": {
          "readOnly": true,
          "type": "number",
          "description": "Indicator of upgrade progress in percentage",
          "title": "Indicator of upgrade progress in percentage"
        },
        "can_skip": {
          "readOnly": true,
          "type": "boolean",
          "description": "Can the upgrade of the remaining units in this component be skipped",
          "title": "Can the upgrade of the remaining units in this component be skipped"
        },
        "details": {
          "readOnly": true,
          "type": "string",
          "description": "Details about the upgrade status",
          "title": "Details about the upgrade status"
        },
        "component_type": {
          "readOnly": true,
          "type": "string",
          "description": "Component type for the upgrade status",
          "title": "Component type for the upgrade status"
        }
      }
    },
    "ControllerClusterRoleConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/ClusterRoleConfig"
        },
        {
          "type": "object",
          "properties": {
            "mpa_msg_client_info": {
              "$ref": "#/definitions/MsgClientInfo"
            },
            "host_msg_client_info": {
              "$ref": "#/definitions/MsgClientInfo"
            },
            "control_plane_listen_addr": {
              "readOnly": true,
              "title": "The IP and port for the control plane service on this node",
              "description": "The IP and port for the control plane service on this node",
              "$ref": "#/definitions/ServiceEndpoint"
            },
            "control_cluster_listen_addr": {
              "readOnly": true,
              "title": "The IP and port for the control cluster service on this node",
              "description": "The IP and port for the control cluster service on this node",
              "$ref": "#/definitions/ServiceEndpoint"
            }
          }
        }
      ]
    },
    "TunnelStatusCount": {
      "allOf": [
        {
          "$ref": "#/definitions/StatusCount"
        },
        {
          "type": "object",
          "properties": {
            "bfd_diagnostic": {
              "title": "BFD Diagnostic",
              "description": "BFD Diagnostic",
              "$ref": "#/definitions/BFDDiagnosticCount"
            },
            "bfd_status": {
              "title": "BFD Status",
              "description": "BFD Status",
              "$ref": "#/definitions/BFDStatusCount"
            }
          }
        }
      ]
    },
    "AwsSubnet": {
      "allOf": [
        {
          "$ref": "#/definitions/DiscoveredResource"
        },
        {
          "properties": {
            "vpc_id": {
              "type": "string",
              "description": "ID of the vpc",
              "title": "ID of the vpc"
            },
            "cidr": {
              "format": "ipv4_cidr_block",
              "type": "string",
              "description": "IPV4 CIDR Block for the Vpc",
              "title": "IPV4 CIDR Block for the Vpc"
            },
            "id": {
              "type": "string",
              "description": "ID of subnet",
              "title": "ID of subnet"
            },
            "availability_zone": {
              "type": "string"
            }
          },
          "required": [
            "vpc_id",
            "cidr",
            "id"
          ],
          "type": "object"
        }
      ],
      "description": "Aws subnet",
      "title": "Aws subnet"
    },
    "Csr": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "key_size",
            "algorithm",
            "subject"
          ],
          "type": "object",
          "properties": {
            "key_size": {
              "readOnly": false,
              "type": "integer",
              "description": "size measured in bits of the public key used in a cryptographic algorithm",
              "format": "int64"
            },
            "pem_encoded": {
              "readOnly": true,
              "type": "string",
              "description": "pem encoded certificate data"
            },
            "algorithm": {
              "readOnly": false,
              "enum": [
                "RSA",
                "DSA"
              ],
              "type": "string",
              "description": "Cryptographic algorithm(asymmetric ) used by the public key for data encryption"
            },
            "subject": {
              "readOnly": false,
              "description": "the certificate owner's information (CN, O, OU, C, ST, L)",
              "$ref": "#/definitions/Principal"
            }
          }
        }
      ]
    },
    "Footer": {
      "properties": {
        "condition": {
          "type": "string",
          "description": "If the condition is met then the footer will be applied. Examples of expression syntax are provided under 'example_request' section of 'CreateWidgetConfiguration' API.",
          "title": "Expression for evaluating condition"
        },
        "actions": {
          "minItems": 0,
          "items": {
            "$ref": "#/definitions/FooterAction"
          },
          "type": "array",
          "description": "Action to be performed at the footer of a widget. An action at the footer can be simple text description or a hyperlink to a UI page. Action allows a clickable url for navigation. An example usage of footer action is provided under 'example_request' section of 'CreateWidgetConfiguration' API.",
          "title": "Footer Actions"
        }
      },
      "type": "object",
      "description": "Footer of a widget that provides additional information or allows an action such as clickable url for navigation. An example usage of footer is provided under 'example_request' section of 'CreateWidgetConfiguration' API.",
      "title": "Widget Footer"
    },
    "MsgClientInfo": {
      "type": "object",
      "properties": {
        "account_name": {
          "readOnly": false,
          "type": "string",
          "description": "Account name for the messaging client. Identifies the client on the management plane message bus."
        },
        "certificate": {
          "readOnly": false,
          "type": "string",
          "description": "Messaging client's certificate. Used to authenticate to the control plane messaging endpoint."
        },
        "shared_secret": {
          "readOnly": false,
          "type": "string",
          "description": "Messaging client's secret. Used to authenticate to the management plane messaging broker."
        }
      }
    },
    "ErrorResolverMetadata": {
      "required": [
        "error_id",
        "entity_id"
      ],
      "type": "object",
      "description": "Error along with its metadata",
      "properties": {
        "error_id": {
          "format": "int64",
          "type": "integer",
          "description": "The error id as reported by the entity where the error occurred.",
          "title": "The error id as reported by the entity where the error occurred."
        },
        "system_metadata": {
          "title": "This can come from some external system like syslog collector",
          "description": "This can come from some external system like syslog collector",
          "$ref": "#/definitions/ErrorResolverSystemMetadata"
        },
        "entity_id": {
          "type": "string",
          "description": "The entity/node UUID where the error has occurred.",
          "title": "The entity/node UUID where the error has occurred."
        },
        "user_metadata": {
          "title": "User supplied metadata that might be required by the resolver",
          "description": "User supplied metadata that might be required by the resolver",
          "$ref": "#/definitions/ErrorResolverUserMetadata"
        }
      }
    },
    "VniPoolListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/VniPool"
              },
              "type": "array",
              "description": "VNI pool list results",
              "title": "VNI pool list results"
            }
          }
        }
      ]
    },
    "LbService": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "type": "object",
          "properties": {
            "access_log_enabled": {
              "default": false,
              "type": "boolean",
              "description": "whether access log is enabled",
              "title": "whether access log is enabled"
            },
            "attachment": {
              "title": "The target which is used to instantiate Lb service.",
              "description": "LBS could be instantiated (or created) on the Logical router, etc.\nTypically, it could be applied to Tier1 LogicalRouter. It can be\nattached to Tier0 LogicalRouter either in non-multi-tenant environments\nor to provide load balancing for infrastructure services offered by\nthe provider.\n",
              "$ref": "#/definitions/ResourceReference"
            },
            "error_log_level": {
              "description": "Load balancer engine writes information about encountered issues of\ndifferent severity levels to the error log. This setting is used to\ndefine the severity level of the error log.\n",
              "default": "INFO",
              "enum": [
                "DEBUG",
                "INFO",
                "WARNING",
                "ERROR",
                "CRITICAL",
                "ALERT",
                "EMERGENCY"
              ],
              "type": "string"
            },
            "enabled": {
              "default": true,
              "type": "boolean",
              "description": "whether the load balancer service is enabled",
              "title": "whether the load balancer service is enabled"
            },
            "virtual_server_ids": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "virtual servers can be associated to LbService(which is\nsimilar to physical/virtual load balancer), Lb virtual servers,\npools and other entities could be defined independently, the virtual\nserver identifier list here would be used to maintain the relationship of\nLbService and other Lb entities.\n",
              "title": "virtual server identifier list"
            },
            "size": {
              "description": "the size of load balancer service",
              "default": "SMALL",
              "enum": [
                "SMALL",
                "MEDIUM",
                "LARGE"
              ],
              "type": "string"
            }
          }
        }
      ]
    },
    "WidgetConfigurationList": {
      "properties": {
        "widgetconfigurations": {
          "items": {
            "$ref": "#/definitions/WidgetConfiguration"
          },
          "readOnly": true,
          "type": "array",
          "description": "Array of widget configurations",
          "title": "Array of widget configurations"
        }
      },
      "type": "object",
      "description": "Represents a list of widget configurations.",
      "title": "List of Widget Configurations"
    },
    "LbVirtualServerStatusListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LbVirtualServerStatus"
              },
              "type": "array",
              "description": "paginated status list of virtual servers",
              "title": "paginated status list of virtual servers"
            }
          }
        }
      ]
    },
    "DeploymentSpec": {
      "properties": {
        "versioned_deployment_specs": {
          "items": {
            "$ref": "#/definitions/VersionedDeploymentSpec"
          },
          "type": "array",
          "description": "List of Versioned deployment specs",
          "title": "List of Versioned deployment specs"
        },
        "fabric_module_version": {
          "type": "string",
          "description": "version of fabric module",
          "title": "version of fabric module"
        }
      },
      "required": [
        "versioned_deployment_specs",
        "fabric_module_version"
      ],
      "type": "object",
      "description": "Deployment spec is a specific version of fabric module",
      "title": "Deployment spec is a specific version of fabric module"
    },
    "PnicBondStatusListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/PnicBondStatus"
              },
              "type": "array",
              "description": "List of pNIC statuses belonging to the transport node",
              "title": "List of pNIC/bond statuses"
            }
          },
          "type": "object"
        }
      ],
      "description": "This object contains reference to list of pNIC/bond statuses",
      "title": "pNIC status list container"
    },
    "QosSwitchingProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/BaseSwitchingProfile"
        },
        {
          "type": "object",
          "properties": {
            "shaper_configuration": {
              "minItems": 0,
              "items": {
                "$ref": "#/definitions/QosBaseRateShaper"
              },
              "type": "array",
              "maxItems": 3
            },
            "class_of_service": {
              "description": "Class of service",
              "title": "Class of service",
              "default": 0,
              "format": "int32",
              "maximum": 7,
              "minimum": 0,
              "type": "integer"
            },
            "dscp": {
              "$ref": "#/definitions/Dscp"
            }
          }
        }
      ]
    },
    "NatStatisticsPerLogicalRouter": {
      "type": "object",
      "properties": {
        "last_update_timestamp": {
          "readOnly": true,
          "type": "integer",
          "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
          "format": "int64"
        },
        "per_transport_node_statistics": {
          "items": {
            "$ref": "#/definitions/NatStatisticsPerTransportNode"
          },
          "readOnly": true,
          "type": "array",
          "description": "Detailed per node statistics",
          "title": "Detailed per node statistics"
        },
        "statistics_across_all_nodes": {
          "readOnly": true,
          "title": "Rolled-up statistics for all rules on the logical router across all the nodes",
          "description": "Rolled-up statistics for all rules on the logical router across all the nodes",
          "$ref": "#/definitions/NatCounters"
        },
        "logical_router_id": {
          "readOnly": true,
          "type": "string",
          "description": "Id for the logical router",
          "title": "Id for the logical router"
        }
      }
    },
    "CrlObjectData": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "pem_encoded"
          ],
          "type": "object",
          "properties": {
            "pem_encoded": {
              "readOnly": false,
              "type": "string",
              "description": "pem encoded crl data"
            }
          }
        }
      ]
    },
    "CommunicationProfileListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/CommunicationProfile"
              },
              "type": "array",
              "description": "CommunicationProfile list results",
              "title": "CommunicationProfile list results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Paged Collection of CommunicationProfiles",
      "title": "Paged Collection of CommunicationProfiles"
    },
    "ComputeCollectionListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/ComputeCollection"
              },
              "type": "array",
              "description": "Compute Collection list results",
              "title": "Compute Collection list results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Compute Collection list result",
      "title": "Compute Collection list result"
    },
    "NormalizedResourceListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/ResourceReference"
              },
              "type": "array",
              "description": "Normalized resource list results",
              "title": "Normalized resource list results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Paged Collection of normalized resources",
      "title": "Paged Collection of normalized resources"
    },
    "IpBlockSubnetListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/IpBlockSubnet"
              },
              "type": "array",
              "description": "IP block subnet list results",
              "title": "IP block subnet list results"
            }
          }
        }
      ]
    },
    "VniPool": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "ranges"
          ],
          "type": "object",
          "properties": {
            "ranges": {
              "items": {
                "$ref": "#/definitions/VniRange"
              },
              "type": "array",
              "description": "VNI range list results",
              "title": "VNI range list results"
            }
          }
        }
      ]
    },
    "EtherTypeServiceEntry": {
      "allOf": [
        {
          "$ref": "#/definitions/ServiceEntry"
        },
        {
          "properties": {
            "ether_type": {
              "format": "int64",
              "type": "integer",
              "description": "Type of the encapsulated protocol",
              "title": "Type of the encapsulated protocol"
            }
          },
          "required": [
            "ether_type"
          ],
          "type": "object"
        }
      ],
      "description": "A ServiceEntry that represents an ethertype protocol",
      "title": "A ServiceEntry that represents an ethertype protocol"
    },
    "LbCookieTime": {
      "discriminator": "type",
      "required": [
        "type"
      ],
      "type": "object",
      "properties": {
        "type": {
          "enum": [
            "LbSessionCookieTime",
            "LbPersistenceCookieTime"
          ],
          "type": "string",
          "description": "Both session cookie and persistence cookie are supported,\nUse LbSessionCookieTime for session cookie time setting,\nUse LbPersistenceCookieTime for persistence cookie time setting\n"
        }
      }
    },
    "AppDiscoverySessionResultSummary": {
      "allOf": [
        {
          "$ref": "#/definitions/AppDiscoverySession"
        },
        {
          "properties": {
            "app_profile_summary_list": {
              "items": {
                "$ref": "#/definitions/AppDiscoveryAppProfileResultSummary"
              },
              "type": "array",
              "description": "List of App Profiles summary discovered in this session",
              "title": "List of App Profiles summary discovered in this session"
            },
            "ns_groups": {
              "items": {
                "$ref": "#/definitions/NSGroupMetaInfo"
              },
              "type": "array",
              "description": "List of NSGroups provided for discovery for this session",
              "title": "List of NSGroups provided for discovery for this session"
            },
            "app_profiles": {
              "items": {
                "$ref": "#/definitions/AppProfileMetaInfo"
              },
              "type": "array",
              "description": "List of app profiles targeted to be classified for this session",
              "title": "List of app profiles targeted to be classified for this session"
            }
          },
          "type": "object"
        }
      ],
      "description": "Contains the summary of the results of an application discovery session\n",
      "title": "Contains the summary of the results of an application discovery session"
    },
    "NodeHttpServiceProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/NodeServiceProperties"
        },
        {
          "properties": {
            "service_properties": {
              "title": "HTTP Service properties",
              "description": "HTTP Service properties",
              "$ref": "#/definitions/HttpServiceProperties"
            }
          },
          "type": "object"
        }
      ],
      "description": "Node HTTP service properties",
      "title": "Node HTTP service properties"
    },
    "LbRuleCondition": {
      "description": "Match conditions are used to match application traffic passing through\nload balancers. Multiple match conditions can be specified in one load\nbalancer rule, each match condition defines a criterion for application\ntraffic.\nIf inverse field is set to true, the match result of the condition is\ninverted.\nIf more than one match condition is specified, match strategy determines\nif all conditions should match or any one condition should match for the\nload balancer rule to be considered a match.\nCurrently only HTTP messages are supported by load balancer rules.\nEach load balancer rule is used at a specific phase of load balancer\nprocessing. Currently three phases are supported, HTTP_REQUEST_REWRITE,\nHTTP_FORWARDING and HTTP_RESPONSE_REWRITE.\nEach phase supports certain types of match conditions, supported match\nconditions in HTTP_REQUEST_REWRITE phase are:\nLbHttpRequestMethodCondition\nLbHttpRequestUriCondition\nLbHttpRequestUriArgumentsCondition\nLbHttpRequestVersionCondition\nLbHttpRequestHeaderCondition\nLbHttpRequestBodyCondition\nLbTcpHeaderCondition\nLbIpHeaderCondition\nSupported match conditions in HTTP_FORWARDING phase are:\nLbHttpRequestMethodCondition\nLbHttpRequestUriCondition\nLbHttpRequestVersionCondition\nLbHttpRequestHeaderCondition\nLbHttpRequestBodyCondition\nLbTcpHeaderCondition\nLbIpHeaderCondition\nSupported match condition in HTTP_RESPONSE_REWRITE phase is:\nLbHttpResponseHeaderCondition\n",
      "title": "Match condition of load balancer rule",
      "required": [
        "type"
      ],
      "discriminator": "type",
      "type": "object",
      "properties": {
        "inverse": {
          "default": false,
          "type": "boolean",
          "description": "A flag to indicate whether reverse the match result of this condition",
          "title": "A flag to indicate whether reverse the match result of this condition"
        },
        "type": {
          "type": "string",
          "description": "Type of load balancer rule condition",
          "enum": [
            "LbHttpRequestMethodCondition",
            "LbHttpRequestUriCondition",
            "LbHttpRequestUriArgumentsCondition",
            "LbHttpRequestVersionCondition",
            "LbHttpRequestHeaderCondition",
            "LbHttpRequestBodyCondition",
            "LbHttpResponseHeaderCondition",
            "LbTcpHeaderCondition",
            "LbIpHeaderCondition"
          ]
        }
      }
    },
    "ApplianceManagementTaskListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/ApplianceManagementTaskProperties"
              },
              "type": "array",
              "description": "Task property results",
              "title": "Task property results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Appliance management task query results",
      "title": "Appliance management task query results"
    },
    "DeploymentZoneListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/DeploymentZone"
              },
              "type": "array",
              "description": "Deployment Zones",
              "title": "Deployment Zones"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Paged Collection of Deployment Zones",
      "title": "Paged Collection of Deployment Zones"
    },
    "LogicalRouterStatusPerNode": {
      "required": [
        "high_availability_status",
        "transport_node_id"
      ],
      "type": "object",
      "properties": {
        "high_availability_status": {
          "enum": [
            "ACTIVE",
            "STANDBY",
            "DOWN",
            "SYNC",
            "UNKNOWN"
          ],
          "type": "string",
          "description": "A service router's HA status on an edge node",
          "title": "A service router's HA status on an edge node"
        },
        "service_router_id": {
          "type": "string",
          "description": "id of the service router where the router status is retrieved.",
          "title": "id of the service router where the router status is retrieved."
        },
        "transport_node_id": {
          "type": "string",
          "description": "id of the transport node where the router status is retrieved.",
          "title": "id of the transport node where the router status is retrieved."
        }
      }
    },
    "DhcpRelayService": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "dhcp_relay_profile_id"
          ],
          "type": "object",
          "properties": {
            "dhcp_relay_profile_id": {
              "type": "string",
              "description": "dhcp relay profile referenced by the dhcp relay service",
              "title": "dhcp relay profile referenced by the dhcp relay service"
            }
          }
        }
      ]
    },
    "VtepLabelPool": {
      "description": "A collection of ranges of virtual tunnel endpoint labels",
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "ranges"
          ],
          "type": "object",
          "properties": {
            "ranges": {
              "items": {
                "$ref": "#/definitions/VtepLabelRange"
              },
              "type": "array",
              "description": "Array of ranges for virtual tunnel endpoint labels",
              "title": "Array of ranges for virtual tunnel endpoint labels"
            },
            "pool_usage": {
              "readOnly": true,
              "title": "Pool usage statistics",
              "description": "Pool usage statistics",
              "$ref": "#/definitions/VtepLabelPoolUsage"
            }
          }
        }
      ]
    },
    "SupportBundleRequest": {
      "required": [
        "nodes"
      ],
      "type": "object",
      "properties": {
        "remote_file_server": {
          "title": "Remote file server to copy bundles to, bundle in response body if not specified",
          "description": "Remote file server to copy bundles to, bundle in response body if not specified",
          "$ref": "#/definitions/SupportBundleRemoteFileServer"
        },
        "nodes": {
          "minItems": 1,
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "List of cluster/fabric node UUIDs processed in specified order",
          "title": "List of cluster/fabric node UUIDs processed in specified order"
        },
        "content_filters": {
          "description": "Bundle should include content of specified type",
          "title": "Bundle should include content of specified type",
          "default": [
            "DEFAULT"
          ],
          "items": {
            "enum": [
              "ALL",
              "DEFAULT"
            ],
            "type": "string",
            "description": "Support bundle content filter allowed values"
          },
          "minItems": 1,
          "type": "array"
        },
        "log_age_limit": {
          "format": "int64",
          "minimum": 1,
          "type": "integer",
          "description": "Include log files with modified times not past the age limit in days",
          "title": "Include log files with modified times not past the age limit in days"
        }
      }
    },
    "IngressRateShaper": {
      "allOf": [
        {
          "$ref": "#/definitions/QosBaseRateShaper"
        },
        {
          "properties": {
            "average_bandwidth_mbps": {
              "description": "Average bandwidth in Mb/s",
              "format": "int32",
              "default": 0,
              "title": "Average bandwidth in Mb/s",
              "minimum": 0,
              "type": "integer"
            },
            "peak_bandwidth_mbps": {
              "description": "Peak bandwidth in Mb/s",
              "format": "int32",
              "default": 0,
              "title": "Peak bandwidth in Mb/s",
              "minimum": 0,
              "type": "integer"
            },
            "burst_size_bytes": {
              "description": "Burst size in bytes",
              "format": "int32",
              "default": 0,
              "title": "Burst size in bytes",
              "minimum": 0,
              "type": "integer"
            }
          },
          "type": "object"
        }
      ],
      "description": "A shaper that specifies ingress rate properties in Mb/s",
      "title": "A shaper that specifies ingress rate properties in Mb/s"
    },
    "PacketTypeAndCounter": {
      "required": [
        "counter",
        "packet_type"
      ],
      "type": "object",
      "properties": {
        "counter": {
          "format": "int64",
          "type": "integer",
          "description": "The number of packets.",
          "title": "The number of packets."
        },
        "packet_type": {
          "type": "string",
          "description": "The type of the packets",
          "title": "The type of the packets"
        }
      }
    },
    "WidgetItem": {
      "properties": {
        "widget_id": {
          "type": "string",
          "description": "Id of the widget configuration that is held by a multi-widget or a container.",
          "title": "Id of the widget configuration"
        },
        "label": {
          "title": "Label of the the report",
          "description": "Applicable for 'DonutConfiguration' reports only. If label is not specified, then it defaults to the label of the donut report.",
          "$ref": "#/definitions/Label"
        }
      },
      "required": [
        "widget_id"
      ],
      "type": "object",
      "description": "Represents a reference to a widget that is held by a container or a multi-widget.",
      "title": "Widget held by MultiWidgetConfiguration or Container"
    },
    "NatRule": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "action"
          ],
          "type": "object",
          "properties": {
            "match_destination_network": {
              "type": "string",
              "description": "IP Address | CIDR | (null implies Any)\n",
              "title": "match destination network"
            },
            "translated_network": {
              "type": "string",
              "description": "IP Address | IP Range | CIDR",
              "title": "IP Address | IP Range | CIDR"
            },
            "rule_priority": {
              "default": 1024,
              "format": "int64",
              "type": "integer",
              "description": "Ascending, valid range [0-2147483647]. If multiple rules have the same\npriority, evaluation sequence is undefined.\n",
              "title": "NAT rule priority"
            },
            "match_service": {
              "title": "match service on source port, destination port, protocol, icmp, etc",
              "description": "A NSServiceElement that specifies the matching services of source\nports, destination ports, ip protocol version and number, sub protocol\nversion and number, ICMP type and code, etc.\n",
              "$ref": "#/definitions/NSServiceElement"
            },
            "enabled": {
              "default": true,
              "type": "boolean",
              "description": "enable/disable the rule",
              "title": "enable/disable the rule"
            },
            "logical_router_id": {
              "readOnly": true,
              "type": "string",
              "description": "Logical router id",
              "title": "Logical router id"
            },
            "translated_ports": {
              "type": "string",
              "description": "port number or port range. DNAT only",
              "title": "port number or port range. DNAT only"
            },
            "action": {
              "type": "string",
              "description": "valid actions: SNAT, DNAT, NO_NAT, REFLEXIVE. All rules in a logical\nrouter are either stateless or stateful. Mix is not supported.\nSNAT and DNAT are stateful, can NOT be supported when the logical router is\nrunning at active-active HA mode; REFLEXIVE is stateless. NO_NAT has no\ntranslated_fields, only match fields.\n",
              "enum": [
                "SNAT",
                "DNAT",
                "NO_NAT",
                "REFLEXIVE"
              ]
            },
            "logging": {
              "default": false,
              "type": "boolean",
              "description": "enable/disable the logging of rule",
              "title": "enable/disable the logging of rule"
            },
            "nat_pass": {
              "default": true,
              "type": "boolean",
              "description": "Default is true. If the nat_pass is set to true, the following firewall\nstage will be skipped. Please note, if action is NO_NAT, then nat_pass\nmust be set to true or omitted.\n",
              "title": "enable/disable to bypass following firewall stage"
            },
            "match_source_network": {
              "type": "string",
              "description": "IP Address | CIDR | (null implies Any)\n",
              "title": "match source network"
            }
          }
        }
      ]
    },
    "LogicalDhcpServerListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LogicalDhcpServer"
              },
              "type": "array",
              "description": "paginated list of dhcp servers",
              "title": "paginated list of dhcp servers"
            }
          }
        }
      ]
    },
    "IPv4DhcpServer": {
      "required": [
        "dhcp_server_ip"
      ],
      "type": "object",
      "properties": {
        "dhcp_server_ip": {
          "format": "ipv4-cidr-block",
          "type": "string",
          "description": "dhcp server ip in cidr format"
        },
        "options": {
          "title": "dhcp options",
          "description": "Defines the default options for all ip-pools and static-bindings of this server.\nThese options will be ignored if options are defined for ip-pools or static-bindings.\n",
          "$ref": "#/definitions/DhcpOptions"
        },
        "dns_nameservers": {
          "description": "dns ips",
          "title": "dns ips",
          "minItems": 0,
          "items": {
            "format": "ipv4",
            "type": "string",
            "description": "IPv4 address"
          },
          "maxItems": 2,
          "type": "array"
        },
        "domain_name": {
          "format": "hostname",
          "type": "string",
          "description": "domain name",
          "title": "domain name"
        },
        "gateway_ip": {
          "format": "ipv4",
          "type": "string",
          "description": "gateway ip"
        }
      }
    },
    "PrincipalIdentityList": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/PrincipalIdentity"
              },
              "readOnly": false,
              "type": "array",
              "description": "PrincipalIdentity list"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "PrincipalIdentity query result",
      "title": "PrincipalIdentity query result"
    },
    "ComputeInstanceErrorMessage": {
      "properties": {
        "error_id": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "an error id contract obtained from PCM",
          "title": "an error id contract obtained from PCM"
        },
        "detailed_message": {
          "readOnly": true,
          "type": "string",
          "description": "Error message string to indicate, if it is NSX or cloud operation generated error.",
          "title": "Error details"
        }
      },
      "type": "object",
      "description": "An error id and message pair",
      "title": "An error id and message pair"
    },
    "SecurityCertificate": {
      "required": [
        "pem_encoded"
      ],
      "type": "object",
      "properties": {
        "text": {
          "minLength": 52,
          "readOnly": true,
          "type": "string",
          "description": "X.509 certificate in text form",
          "title": "X.509 certificate in text form"
        },
        "valid_from": {
          "readOnly": true,
          "type": "string",
          "description": "The time when the certificate starts being valid",
          "title": "The time when the certificate starts being valid"
        },
        "ssh_public_key": {
          "readOnly": true,
          "type": "string"
        },
        "valid_to": {
          "readOnly": true,
          "type": "string",
          "description": "The time when the certificate stops being valid",
          "title": "The time when the certificate stops being valid"
        },
        "pem_encoded": {
          "minLength": 52,
          "readOnly": false,
          "type": "string",
          "description": "The certificate must include the enclosing \"-----BEGIN CERTIFICATE-----\" and \"-----END CERTIFICATE-----\"",
          "title": "PEM encoded X.509 certificate"
        }
      }
    },
    "AdvanceClusterRestoreInput": {
      "required": [
        "resources"
      ],
      "type": "object",
      "properties": {
        "id": {
          "readOnly": true,
          "type": "string",
          "description": "Unique id of an instruction (as returned by the GET /restore/status\ncall) for which input is to be provided\n",
          "title": "Unique id of an instruction (as returned by the GET /restore/status\ncall) for which input is to be provided\n"
        },
        "resources": {
          "items": {
            "$ref": "#/definitions/SelectableResourceReference"
          },
          "type": "array",
          "description": "List of resources for which the instruction is applicable.",
          "title": "List of resources for which the instruction is applicable."
        }
      }
    },
    "LbAppProfileListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LbAppProfile"
              },
              "type": "array",
              "description": "paginated list of load balancer application profiles",
              "title": "paginated list of load balancer application profiles"
            }
          }
        }
      ]
    },
    "HostUpgradeStatus": {
      "allOf": [
        {
          "$ref": "#/definitions/ComponentUpgradeStatus"
        },
        {
          "type": "object"
        }
      ],
      "description": "Status of host upgrade",
      "title": "Status of host upgrade"
    },
    "RevisionedResource": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "type": "object",
          "properties": {
            "_revision": {
              "format": "int64",
              "type": "integer",
              "description": "The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected.",
              "title": "Generation of this resource config"
            }
          }
        }
      ]
    },
    "CpuCoreConfigForEnhancedNetworkingStackSwitch": {
      "properties": {
        "num_lcores": {
          "description": "Number of Logical cpu cores (Lcores) to be placed on a specified NUMA node",
          "format": "int32",
          "title": "Number of Logical cpu cores (Lcores) to be placed on a specified NUMA node",
          "readOnly": false,
          "minimum": 1,
          "type": "integer"
        },
        "numa_node_index": {
          "description": "Unique index of the Non Uniform Memory Access (NUMA) node",
          "format": "int32",
          "title": "Unique index of the Non Uniform Memory Access (NUMA) node",
          "readOnly": false,
          "minimum": 0,
          "type": "integer"
        }
      },
      "required": [
        "num_lcores",
        "numa_node_index"
      ],
      "type": "object",
      "description": "Non Uniform Memory Access (NUMA) nodes and Logical cpu cores (Lcores) per NUMA node configuration for Enhanced Networking Stack enabled HostSwitch.",
      "title": "Enhanced Networking Stack CPU configuration"
    },
    "VtepListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "last_update_timestamp": {
              "readOnly": true,
              "type": "integer",
              "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
              "format": "int64"
            },
            "logical_switch_id": {
              "readOnly": true,
              "type": "string",
              "description": "The id of the logical Switch",
              "title": "The id of the logical Switch"
            },
            "results": {
              "items": {
                "$ref": "#/definitions/VtepTableEntry"
              },
              "type": "array"
            },
            "transport_node_id": {
              "readOnly": true,
              "type": "string",
              "description": "Transport node identifier",
              "title": "Transport node identifier"
            }
          }
        }
      ]
    },
    "UnassociatedVMListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "last_update_timestamp": {
              "type": "integer",
              "description": "Timestamp in milliseconds since epoch",
              "format": "int64"
            },
            "results": {
              "items": {
                "$ref": "#/definitions/VirtualMachine"
              },
              "type": "array",
              "description": "List of VMs which are not associated with any NSGroup\n",
              "title": "Unassociated Vitual Machine list results\n"
            }
          }
        }
      ]
    },
    "StandardHostSwitchSpec": {
      "allOf": [
        {
          "$ref": "#/definitions/HostSwitchSpec"
        },
        {
          "properties": {
            "host_switches": {
              "description": "Transport Node host switches",
              "title": "Transport Node host switches",
              "minItems": 0,
              "items": {
                "$ref": "#/definitions/StandardHostSwitch"
              },
              "maxItems": 5,
              "type": "array"
            }
          },
          "required": [
            "host_switches"
          ],
          "type": "object"
        }
      ],
      "description": "Standard host switch specification is used for NSX configured transport node.",
      "title": "Specification of transport node standard host switch"
    },
    "ErrorResolverUserMetadata": {
      "type": "object",
      "description": "User supplied metadata needed for resolving errors",
      "properties": {
        "user_input_list": {
          "items": {
            "$ref": "#/definitions/ErrorResolverUserInputData"
          },
          "type": "array",
          "description": "List of user supplied input data.",
          "title": "List of user supplied input data."
        }
      }
    },
    "ListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "type": "object",
          "properties": {
            "cursor": {
              "readOnly": true,
              "type": "string",
              "description": "Opaque cursor to be used for getting next page of records (supplied by current result page)",
              "title": "Opaque cursor to be used for getting next page of records (supplied by current result page)"
            },
            "sort_ascending": {
              "readOnly": true,
              "type": "boolean"
            },
            "sort_by": {
              "readOnly": true,
              "type": "string",
              "description": "Field by which records are sorted",
              "title": "Field by which records are sorted"
            },
            "result_count": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Count of results found (across all pages), set only on first page",
              "title": "Count of results found (across all pages), set only on first page"
            }
          }
        }
      ]
    },
    "ReorderRequest": {
      "required": [
        "id"
      ],
      "type": "object",
      "properties": {
        "is_before": {
          "default": true,
          "readOnly": false,
          "type": "boolean",
          "description": "flag indicating whether the upgrade unit group/upgrade unit is to be placed before or after the specified upgrade unit group/upgrade unit",
          "title": "flag indicating whether the upgrade unit group/upgrade unit is to be placed before or after the specified upgrade unit group/upgrade unit"
        },
        "id": {
          "readOnly": false,
          "type": "string",
          "description": "id of the upgrade unit group/upgrade unit before/after which the upgrade unit group/upgrade unit is to be placed",
          "title": "id of the upgrade unit group/upgrade unit before/after which the upgrade unit group/upgrade unit is to be placed"
        }
      }
    },
    "PolicyNodeProperty": {
      "properties": {
        "value": {
          "type": "string",
          "description": "value of the property",
          "title": "value of the property"
        },
        "key": {
          "type": "string",
          "description": "key of the property",
          "title": "key of the property"
        }
      },
      "type": "object",
      "description": "Representation of a policy node property",
      "title": "PolicyNodeProperty"
    },
    "FirewallStatusListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/FirewallStatus"
              },
              "readOnly": true,
              "type": "array"
            }
          },
          "type": "object"
        }
      ],
      "description": "List of firewall statuses for a context or all context",
      "title": "Firewall Statuses"
    },
    "DhcpIpPoolUsage": {
      "required": [
        "allocated_percentage",
        "pool_size",
        "allocated_number",
        "dhcp_ip_pool_id"
      ],
      "type": "object",
      "properties": {
        "allocated_percentage": {
          "format": "int64",
          "type": "integer",
          "description": "allocated percentage. COULD BE INACCURATE, REFERENCE ONLY.",
          "title": "allocated percentage. COULD BE INACCURATE, REFERENCE ONLY."
        },
        "pool_size": {
          "format": "int64",
          "type": "integer",
          "description": "pool size",
          "title": "pool size"
        },
        "allocated_number": {
          "format": "int64",
          "type": "integer",
          "description": "allocated number. COULD BE INACCURATE, REFERENCE ONLY.",
          "title": "allocated number. COULD BE INACCURATE, REFERENCE ONLY."
        },
        "dhcp_ip_pool_id": {
          "type": "string",
          "description": "uuid of dhcp ip pool",
          "title": "uuid of dhcp ip pool"
        }
      }
    },
    "CloudUserInfo": {
      "properties": {
        "display_name": {
          "readOnly": true,
          "type": "string",
          "description": "Display name of the user",
          "title": "Display name of the user"
        },
        "id": {
          "readOnly": true,
          "type": "string",
          "description": "ID of the user",
          "title": "ID of the user"
        }
      },
      "type": "object",
      "description": "User information",
      "title": "User information"
    },
    "ReadNodesStatusRequestParameters": {
      "properties": {
        "node_ids": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "A comma separated list of request Node Ids.",
          "title": "List of requested Nodes."
        }
      },
      "required": [
        "node_ids"
      ],
      "type": "object",
      "description": "Node Status list request parameters",
      "title": "Node Status list request parameters"
    },
    "UcMessageMetadata": {
      "required": [
        "correlation_id"
      ],
      "type": "object",
      "properties": {
        "correlation_id": {
          "readOnly": false,
          "type": "string",
          "description": "Correlation ID generated by RPC",
          "title": "Correlation ID generated by RPC"
        }
      }
    },
    "NSGroupListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/NSGroup"
              },
              "type": "array",
              "description": "NSGroup list results",
              "title": "NSGroup list results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Paged Collection of NSGroups",
      "title": "Paged Collection of NSGroups"
    },
    "UnboundedKeyValuePair": {
      "required": [
        "value",
        "key"
      ],
      "type": "object",
      "properties": {
        "value": {
          "readOnly": false,
          "type": "string",
          "description": "Value",
          "title": "Value"
        },
        "key": {
          "readOnly": false,
          "type": "string",
          "description": "Key",
          "title": "Key"
        }
      }
    },
    "LicensesListResult": {
      "description": "Licenses queries result",
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/License"
              },
              "readOnly": true,
              "type": "array",
              "description": "Licenses Results",
              "title": "Licenses Results"
            }
          }
        }
      ]
    },
    "ComputeCollectionTransportNodeTemplateState": {
      "properties": {
        "compute_collection_id": {
          "readOnly": true,
          "type": "string",
          "description": "Associated compute collection id",
          "title": "Associated compute collection id"
        },
        "template_states": {
          "items": {
            "$ref": "#/definitions/TransportNodeTemplateState"
          },
          "readOnly": true,
          "type": "array",
          "description": "Transport node template states in compute collection",
          "title": "Transport node template states in compute collection"
        }
      },
      "type": "object",
      "description": "Transport node state per compute collection",
      "title": "Transport node state per compute collection"
    },
    "VIPSubnet": {
      "required": [
        "prefix_length",
        "active_vip_addresses"
      ],
      "type": "object",
      "properties": {
        "prefix_length": {
          "description": "Subnet Prefix Length",
          "format": "int64",
          "title": "Subnet Prefix Length",
          "maximum": 31,
          "minimum": 1,
          "type": "integer"
        },
        "active_vip_addresses": {
          "description": "Array of IP address subnets which will be used as floating IP addresses. | These IPs will move and will be owned by Active node.",
          "title": "IPv4 Addresses which will be owned by uplink on active node.",
          "minItems": 1,
          "items": {
            "format": "ipv4",
            "type": "string",
            "description": "IPv4 address"
          },
          "maxItems": 1,
          "type": "array"
        }
      }
    },
    "TransportZoneStatusListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/TransportZoneStatus"
              },
              "type": "array",
              "description": "Transport Zone Runtime Status Info Results",
              "title": "Transport Zone Runtime Status Info Results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Transport zone runtime status queries result",
      "title": "Transport zone runtime status queries result"
    },
    "AppInfoListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/AppInfo"
              },
              "type": "array",
              "description": "Application details corresponding to the App Profile",
              "title": "Application details corresponding to the App Profile"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "AppInfo Sessions list results",
      "title": "AppInfo Sessions list results"
    },
    "AllocationIpAddress": {
      "description": "Allocation parameters for the IP address (e.g. specific IP address) can be specified. Tags, display_name and description attributes are not supported in this release.",
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "type": "object",
          "properties": {
            "allocation_id": {
              "description": "Address that is allocated from pool",
              "format": "ip",
              "readOnly": true,
              "type": "string"
            }
          }
        }
      ]
    },
    "CurrentBackupOperationStatus": {
      "required": [
        "operation_type"
      ],
      "type": "object",
      "properties": {
        "current_step": {
          "enum": [
            "BACKUP_CREATING_CLUSTER_BACKUP",
            "BACKUP_CREATING_NODE_BACKUP"
          ],
          "type": "string",
          "description": "Current step of operation",
          "title": "Current step of operation"
        },
        "backup_id": {
          "type": "string",
          "description": "Unique identifier of current backup",
          "title": "Unique identifier of current backup"
        },
        "current_step_message": {
          "type": "string",
          "description": "Additional human-readable status information about current step",
          "title": "Additional human-readable status information about current step"
        },
        "end_time": {
          "type": "integer",
          "description": "Time when operation is expected to end",
          "format": "int64"
        },
        "operation_type": {
          "enum": [
            "NONE",
            "BACKUP"
          ],
          "type": "string",
          "description": "Type of operation that is in progress. Returns none if no operation is in progress, in which case\nnone of the other fields will be set.\n",
          "title": "Type of operation that is in progress. Returns none if no operation is in progress, in which case\nnone of the other fields will be set.\n"
        },
        "start_time": {
          "type": "integer",
          "description": "Time when operation was started",
          "format": "int64"
        }
      }
    },
    "CsmStatus": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "ip_address": {
              "readOnly": true,
              "type": "string",
              "description": "IP address of Csm instance",
              "title": "IP address of Csm instance"
            },
            "version": {
              "readOnly": true,
              "type": "string",
              "description": "Version of Csm",
              "title": "Version of Csm"
            },
            "display_name": {
              "readOnly": true,
              "type": "string",
              "description": "Name of the Csm instance",
              "title": "Name of the Csm instance"
            },
            "id": {
              "readOnly": true,
              "type": "string",
              "description": "Identifier of the Csm appliance",
              "title": "UUID of the Csm appliance"
            },
            "managed_by_vmware": {
              "readOnly": true,
              "type": "boolean",
              "description": "This property is used only if CSM is running in service mode",
              "title": "Mode of running of Csm instance"
            }
          },
          "type": "object"
        }
      ],
      "description": "Information about status of cloud service manager",
      "title": "Information about status of cloud service manager"
    },
    "UpgradeUnitAggregateInfo": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "type": "object",
          "properties": {
            "status": {
              "readOnly": true,
              "enum": [
                "SUCCESS",
                "FAILED",
                "IN_PROGRESS",
                "NOT_STARTED",
                "PAUSED"
              ],
              "type": "string",
              "description": "Status of upgrade unit",
              "title": "Status of upgrade unit"
            },
            "errors": {
              "items": {
                "type": "string"
              },
              "readOnly": true,
              "type": "array",
              "description": "List of errors occurred during upgrade of this upgrade unit",
              "title": "List of errors occurred during upgrade of this upgrade unit"
            },
            "group": {
              "readOnly": true,
              "title": "Info of the group to which this upgrade unit belongs",
              "description": "Info of the group to which this upgrade unit belongs",
              "$ref": "#/definitions/UpgradeUnitGroupInfo"
            },
            "display_name": {
              "readOnly": false,
              "type": "string",
              "description": "Name of the upgrade unit",
              "title": "Name of the upgrade unit"
            },
            "warnings": {
              "items": {
                "type": "string"
              },
              "readOnly": true,
              "type": "array",
              "description": "List of warnings indicating issues with the upgrade unit that may result in upgrade failure",
              "title": "List of warnings indicating issues with the upgrade unit that may result in upgrade failure"
            },
            "current_version": {
              "readOnly": true,
              "type": "string",
              "description": "This is component version e.g. if upgrade unit is of type edge, then this is edge version.",
              "title": "Current version of upgrade unit"
            },
            "percent_complete": {
              "readOnly": true,
              "type": "number",
              "description": "Indicator of upgrade progress in percentage",
              "title": "Indicator of upgrade progress in percentage"
            },
            "type": {
              "readOnly": false,
              "type": "string",
              "description": "Upgrade unit type",
              "title": "Upgrade unit type"
            },
            "id": {
              "readOnly": true,
              "type": "string",
              "description": "Identifier of the upgrade unit",
              "title": "Identifier of the upgrade unit"
            },
            "metadata": {
              "items": {
                "$ref": "#/definitions/KeyValuePair"
              },
              "readOnly": true,
              "type": "array",
              "description": "Metadata about upgrade unit",
              "title": "Metadata about upgrade unit"
            }
          }
        }
      ]
    },
    "AdvertiseRuleList": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "type": "object",
          "properties": {
            "rules": {
              "description": "List of advertisement rules",
              "title": "List of advertisement rules",
              "default": [],
              "items": {
                "$ref": "#/definitions/AdvertiseRule"
              },
              "minItems": 0,
              "type": "array"
            },
            "logical_router_id": {
              "readOnly": true,
              "type": "string",
              "description": "Logical router id",
              "title": "Logical router id"
            }
          }
        }
      ]
    },
    "DomainListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/Domain"
              },
              "type": "array",
              "description": "Domain list results",
              "title": "Domain list results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Paged Collection of Domains",
      "title": "Paged Collection of Domains"
    },
    "TraceflowObservationDropped": {
      "allOf": [
        {
          "$ref": "#/definitions/TraceflowObservation"
        },
        {
          "type": "object",
          "properties": {
            "reason": {
              "readOnly": true,
              "enum": [
                "FW_RULE",
                "NO_ROUTE",
                "TTL_ZERO",
                "ARP_FAIL",
                "UNKNOWN"
              ],
              "type": "string",
              "description": "The reason traceflow packet was dropped",
              "title": "The reason traceflow packet was dropped"
            },
            "lport_name": {
              "readOnly": true,
              "type": "string",
              "description": "The name of the logical port at which the traceflow packet was dropped",
              "title": "The name of the logical port at which the traceflow packet was dropped"
            },
            "acl_rule_id": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "The id of the acl rule that was applied to drop the traceflow packet",
              "title": "The id of the acl rule that was applied to drop the traceflow packet"
            },
            "lport_id": {
              "readOnly": true,
              "type": "string",
              "description": "The id of the logical port at which the traceflow packet was dropped",
              "title": "The id of the logical port at which the traceflow packet was dropped"
            }
          }
        }
      ]
    },
    "LogicalPortOperationalStatus": {
      "required": [
        "status"
      ],
      "type": "object",
      "properties": {
        "logical_port_id": {
          "readOnly": true,
          "type": "string",
          "description": "The id of the logical port",
          "title": "The id of the logical port"
        },
        "status": {
          "enum": [
            "UP",
            "DOWN",
            "UNKNOWN"
          ],
          "type": "string",
          "description": "The Operational status of the logical port",
          "title": "The Operational status of the logical port"
        },
        "last_update_timestamp": {
          "readOnly": true,
          "type": "integer",
          "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
          "format": "int64"
        }
      }
    },
    "ClustersAggregateInfo": {
      "required": [
        "management_cluster",
        "controller_cluster"
      ],
      "type": "object",
      "properties": {
        "management_cluster": {
          "items": {
            "$ref": "#/definitions/ManagementNodeAggregateInfo"
          },
          "type": "array",
          "description": "Array of Management Nodes",
          "title": "Array of Management Nodes"
        },
        "controller_cluster": {
          "items": {
            "$ref": "#/definitions/ControllerNodeAggregateInfo"
          },
          "type": "array",
          "description": "Array of Controller Nodes",
          "title": "Array of Controller Nodes"
        }
      }
    },
    "TraceflowObservationDroppedLogical": {
      "allOf": [
        {
          "$ref": "#/definitions/TraceflowObservationDropped"
        },
        {
          "type": "object",
          "properties": {
            "component_id": {
              "readOnly": true,
              "type": "string",
              "description": "The id of the component that dropped the traceflow packet.",
              "title": "The id of the component that dropped the traceflow packet."
            }
          }
        }
      ]
    },
    "RealizedEnforcementPointListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "title": "Enforcement point list result",
                "$ref": "#/definitions/RealizedEnforcementPoint"
              },
              "type": "array",
              "description": "Paged Collection of Enforcement Point's",
              "title": "Paged Collection of Enforcement Point's"
            }
          }
        }
      ]
    },
    "RealizedState": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyRealizedResource"
        },
        {
          "properties": {
            "enforcement_points": {
              "items": {
                "$ref": "#/definitions/RealizedEnforcementPoint"
              },
              "type": "array",
              "description": "Enforcement points for realized policy",
              "title": "Enforcement points for realized policy"
            }
          },
          "type": "object"
        }
      ],
      "description": "Root of realized policy state",
      "title": "Root of realized policy state"
    },
    "IntervalBackupSchedule": {
      "allOf": [
        {
          "$ref": "#/definitions/BackupSchedule"
        },
        {
          "required": [
            "seconds_between_backups"
          ],
          "type": "object",
          "properties": {
            "seconds_between_backups": {
              "default": 3600,
              "minimum": 300,
              "type": "integer",
              "maximum": 86400,
              "format": "int64"
            }
          }
        }
      ]
    },
    "SwitchingProfileSupplementaryInfo": {
      "properties": {
        "bpdu_filter_allowed_macs": {
          "items": {
            "pattern": "/^(([0-9A-Fa-f]{2}[:]){5}([0-9A-Fa-f]{2}))|(([0-9A-Fa-f]{2}[-]){5}([0-9A-Fa-f]{2}))$/",
            "type": "string",
            "description": "A MAC address. Must be 6 pairs of hexadecimal digits, upper or lower case,\nseparated by colons or dashes. Examples: 01:23:45:67:89:ab, 01-23-45-67-89-AB.\n"
          },
          "readOnly": true,
          "type": "array",
          "description": "Allowed MAC addresses for BPDU filter white list",
          "title": "Allowed MAC addresses for BPDU filter white list"
        }
      },
      "type": "object",
      "description": "Additional information related to switching profiles",
      "title": "Additional information related to switching profiles"
    },
    "LbHttpRejectAction": {
      "allOf": [
        {
          "$ref": "#/definitions/LbRuleAction"
        },
        {
          "properties": {
            "reply_status": {
              "type": "string",
              "description": "HTTP response status code",
              "title": "HTTP response status code"
            },
            "reply_message": {
              "type": "string",
              "description": "Response message",
              "title": "Response message"
            }
          },
          "required": [
            "reply_status"
          ],
          "type": "object"
        }
      ],
      "description": "This action is used to reject HTTP request messages. The specified\nreply_status value is used as the status code for the corresponding HTTP\nresponse message which is sent back to client (Normally a browser)\nindicating the reason it was rejected. Reference official HTTP status code\nlist for your specific HTTP version to set the reply_status properly.\nLbHttpRejectAction does not support variables.\n",
      "title": "Action to reject HTTP request messages"
    },
    "PreconfiguredEndpoint": {
      "properties": {
        "device_name": {
          "readOnly": false,
          "type": "string",
          "description": "Name of the virtual tunnel endpoint",
          "title": "Name of the virtual tunnel endpoint"
        }
      },
      "required": [
        "device_name"
      ],
      "type": "object",
      "description": "Tunnel endpoint configuration of preconfigured host switch",
      "title": "Tunnel endpoint configuration of preconfigured host switch"
    },
    "DhcpLeasePerIP": {
      "required": [
        "subnet",
        "ip_address",
        "mac_address"
      ],
      "type": "object",
      "properties": {
        "subnet": {
          "type": "string",
          "description": "subnet of client network",
          "title": "subnet of client network"
        },
        "lease_time": {
          "type": "string",
          "description": "lease time of the ip address, in seconds",
          "title": "lease time of the ip address, in seconds"
        },
        "mac_address": {
          "type": "string",
          "description": "mac address of client",
          "title": "mac address of client"
        },
        "expire_time": {
          "type": "string",
          "description": "expire time of the lease",
          "title": "expire time of the lease"
        },
        "start_time": {
          "type": "string",
          "description": "start time of lease",
          "title": "start time of lease"
        },
        "ip_address": {
          "type": "string",
          "description": "ip address of client",
          "title": "ip address of client"
        }
      }
    },
    "LbVirtualServerListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LbVirtualServer"
              },
              "type": "array",
              "description": "paginated list of virtual servers",
              "title": "paginated list of virtual servers"
            }
          }
        }
      ]
    },
    "BinaryPacketData": {
      "allOf": [
        {
          "$ref": "#/definitions/PacketData"
        },
        {
          "type": "object",
          "properties": {
            "payload": {
              "maxLength": 1336,
              "type": "string",
              "description": "Up to 1000 bytes of payload may be supplied (with a base64-encoded length of 1336 bytes.) Additional bytes of traceflow metadata will be appended to the payload. The payload must contain all headers (Ethernet, IP, etc). Note that VLAN is not supported in the logical space. Hence, payload must not contain 802.1Q headers.",
              "title": "RFC3548 compatible base64 encoded full payload"
            }
          }
        }
      ]
    },
    "ClusterProfileListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/ClusterProfile"
              },
              "readOnly": true,
              "type": "array",
              "description": "Cluster Profile Results",
              "title": "Cluster Profile Results"
            }
          },
          "type": "object"
        }
      ],
      "description": "Cluster Profile queries result",
      "title": "Cluster Profile queries result"
    },
    "UsernamePasswordLoginCredential": {
      "allOf": [
        {
          "$ref": "#/definitions/LoginCredential"
        },
        {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "description": "The username for login",
              "title": "The username for login"
            },
            "password": {
              "type": "string",
              "description": "The authentication password for login",
              "title": "The authentication password for login"
            },
            "thumbprint": {
              "type": "string",
              "description": "Thumbprint of the login server",
              "title": "Thumbprint of the login server"
            }
          }
        }
      ]
    },
    "RealizedFirewallSectionListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "title": "Firewall list results",
                "$ref": "#/definitions/RealizedFirewallSection"
              },
              "readOnly": true,
              "type": "array",
              "description": "Paged Collection of firewall sections",
              "title": "Paged Collection of firewall sections"
            }
          }
        }
      ]
    },
    "ControllerNodeAggregateInfo": {
      "allOf": [
        {
          "$ref": "#/definitions/BaseNodeAggregateInfo"
        },
        {
          "type": "object",
          "properties": {
            "role_config": {
              "readOnly": true,
              "$ref": "#/definitions/ControllerClusterRoleConfig"
            }
          }
        }
      ]
    },
    "NodeSummary": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "type": "object",
          "properties": {
            "node_count": {
              "readOnly": true,
              "format": "int32",
              "type": "integer",
              "description": "Number of nodes of the type and at the component version",
              "title": "Count of nodes"
            },
            "type": {
              "readOnly": true,
              "type": "string",
              "description": "Node type",
              "title": "Node type"
            },
            "component_version": {
              "readOnly": true,
              "type": "string",
              "description": "Component version",
              "title": "Component version"
            }
          }
        }
      ]
    },
    "ComputeCollectionFabricTemplateListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/ComputeCollectionFabricTemplate"
              },
              "readOnly": true,
              "type": "array",
              "description": "List of compute collection fabric template",
              "title": "List of compute collection fabric template"
            }
          },
          "type": "object"
        }
      ],
      "description": "List of compute collection fabric template",
      "title": "List of compute collection fabric template"
    },
    "SwitchSecuritySwitchingProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/BaseSwitchingProfile"
        },
        {
          "type": "object",
          "properties": {
            "rate_limits": {
              "readOnly": false,
              "title": "Allows configuration of rate limits for broadcast and multicast traffic",
              "description": "Rate limiting is disabled by default",
              "$ref": "#/definitions/RateLimits"
            },
            "bpdu_filter": {
              "readOnly": false,
              "title": "Enables or disables BPDU filtering",
              "description": "BPDU filtering is enabled by default. A pre-defined list of MAC addresses\nare automatically excluded from BPDU filtering.\n",
              "$ref": "#/definitions/BpduFilter"
            },
            "dhcp_filter": {
              "readOnly": false,
              "title": "Filters DHCP server and/or client traffic.",
              "description": "DHCP server blocking is enabled and client blocking is disabled by default",
              "$ref": "#/definitions/DhcpFilter"
            },
            "block_non_ip_traffic": {
              "default": false,
              "readOnly": false,
              "type": "boolean",
              "description": "A flag to block all traffic except IP/(G)ARP/BPDU",
              "title": "A flag to block all traffic except IP/(G)ARP/BPDU"
            }
          }
        }
      ]
    },
    "LbServerSslProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/LbSslProfile"
        },
        {
          "type": "object",
          "properties": {
            "session_cache_enabled": {
              "default": true,
              "type": "boolean",
              "description": "SSL session caching allows SSL client and server to reuse previously\nnegotiated security parameters avoiding the expensive public key\noperation during handshake.\n",
              "title": "session cache enable/disable falg"
            },
            "is_secure": {
              "readOnly": true,
              "type": "boolean",
              "description": "This flag is set to true when all the ciphers and protocols are secure.\nIt is set to false when one of the ciphers or protocols is insecure.\n",
              "title": "Secure/Insecure SSL profile flag"
            },
            "ciphers": {
              "items": {
                "enum": [
                  "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
                  "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
                  "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
                  "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
                  "TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA",
                  "TLS_ECDH_RSA_WITH_AES_256_CBC_SHA",
                  "TLS_RSA_WITH_AES_256_CBC_SHA",
                  "TLS_RSA_WITH_AES_128_CBC_SHA",
                  "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
                  "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
                  "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
                  "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384",
                  "TLS_RSA_WITH_AES_128_CBC_SHA256",
                  "TLS_RSA_WITH_AES_128_GCM_SHA256",
                  "TLS_RSA_WITH_AES_256_CBC_SHA256",
                  "TLS_RSA_WITH_AES_256_GCM_SHA384",
                  "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
                  "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
                  "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
                  "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384",
                  "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
                  "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA",
                  "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256",
                  "TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256",
                  "TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384",
                  "TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384",
                  "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA",
                  "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256",
                  "TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256",
                  "TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384",
                  "TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384"
                ],
                "type": "string",
                "description": "SSL cipher"
              },
              "type": "array",
              "description": "supported SSL cipher list to client side",
              "title": "supported SSL cipher list to client side"
            },
            "protocols": {
              "items": {
                "enum": [
                  "SSL_V2",
                  "SSL_V3",
                  "TLS_V1",
                  "TLS_V1_1",
                  "TLS_V1_2"
                ],
                "type": "string",
                "description": "SSL protocol"
              },
              "type": "array",
              "description": "SSL versions TLS1.1 and TLS1.2 are supported and enabled by default.\nSSLv2, SSLv3, and TLS1.0 are supported, but disabled by default.\n",
              "title": "supported SSL protocol list to client side"
            }
          }
        }
      ]
    },
    "DhcpStatistics": {
      "required": [
        "errors",
        "releases",
        "informs",
        "timestamp",
        "dhcp_server_id",
        "nacks",
        "offers",
        "discovers",
        "acks",
        "declines",
        "requests"
      ],
      "type": "object",
      "properties": {
        "errors": {
          "format": "int64",
          "type": "integer",
          "description": "The total number of DHCP errors",
          "title": "The total number of DHCP errors"
        },
        "releases": {
          "format": "int64",
          "type": "integer",
          "description": "The total number of DHCP RELEASE packets",
          "title": "The total number of DHCP RELEASE packets"
        },
        "informs": {
          "format": "int64",
          "type": "integer",
          "description": "The total number of DHCP INFORM packets",
          "title": "The total number of DHCP INFORM packets"
        },
        "declines": {
          "format": "int64",
          "type": "integer",
          "description": "The total number of DHCP DECLINE packets",
          "title": "The total number of DHCP DECLINE packets"
        },
        "dhcp_server_id": {
          "type": "string",
          "description": "dhcp server uuid",
          "title": "dhcp server uuid"
        },
        "nacks": {
          "format": "int64",
          "type": "integer",
          "description": "The total number of DHCP NACK packets",
          "title": "The total number of DHCP NACK packets"
        },
        "offers": {
          "format": "int64",
          "type": "integer",
          "description": "The total number of DHCP OFFER packets",
          "title": "The total number of DHCP OFFER packets"
        },
        "discovers": {
          "format": "int64",
          "type": "integer",
          "description": "The total number of DHCP DISCOVER packets",
          "title": "The total number of DHCP DISCOVER packets"
        },
        "acks": {
          "format": "int64",
          "type": "integer",
          "description": "The total number of DHCP ACK packets",
          "title": "The total number of DHCP ACK packets"
        },
        "timestamp": {
          "type": "integer",
          "description": "timestamp of the statistics",
          "format": "int64"
        },
        "requests": {
          "format": "int64",
          "type": "integer",
          "description": "The total number of DHCP REQUEST packets",
          "title": "The total number of DHCP REQUEST packets"
        },
        "ip_pool_stats": {
          "items": {
            "$ref": "#/definitions/DhcpIpPoolUsage"
          },
          "type": "array",
          "description": "The DHCP ip pool usage statistics",
          "title": "The DHCP ip pool usage statistics"
        }
      }
    },
    "DneGlobalConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "allow_mirrored"
          ],
          "type": "object",
          "properties": {
            "allow_mirrored": {
              "type": "boolean",
              "description": "It is a boolean flag which reflects whether DNE protected EastWest traffic will be dropped at mirroring stage.",
              "title": "flag to indicate if DNE packets will be droped at mirroring stage"
            },
            "rekey_margin_time": {
              "description": "Time period during which both old and new keys are valid, to accommodate key distribution delay. Default 1 mins, minimum 1 mins and maximum 4 mins.",
              "title": "Allowed margin time for rekey",
              "default": 60,
              "format": "int64",
              "maximum": 240,
              "minimum": 60,
              "type": "integer"
            }
          }
        }
      ]
    },
    "NSXVConnectionInfo": {
      "allOf": [
        {
          "$ref": "#/definitions/EnforcementPointConnectionInfo"
        },
        {
          "properties": {
            "username": {
              "type": "string",
              "description": "UserName",
              "title": "UserName"
            },
            "password": {
              "type": "string",
              "description": "Password",
              "title": "Password"
            },
            "thumbprint": {
              "type": "string",
              "description": "Thumbprint of EnforcementPoint. sha-256 hash represented in lower case hex.\n",
              "title": "Thumbprint of Enforcement Point"
            }
          },
          "required": [
            "username",
            "password",
            "thumbprint"
          ],
          "type": "object"
        }
      ],
      "description": "Credential info to connect to NSXV enforcement type",
      "title": "Credential info to connect to NSXV enforcement type"
    },
    "AggregatedDataCounterEx": {
      "allOf": [
        {
          "$ref": "#/definitions/AggregatedDataCounter"
        },
        {
          "type": "object",
          "properties": {
            "mac_learning": {
              "readOnly": true,
              "$ref": "#/definitions/MacLearningCounters"
            },
            "dropped_by_security_packets": {
              "readOnly": true,
              "$ref": "#/definitions/PacketsDroppedBySecurity"
            }
          }
        }
      ]
    },
    "LbSnatTranslation": {
      "discriminator": "type",
      "required": [
        "type"
      ],
      "type": "object",
      "properties": {
        "type": {
          "enum": [
            "LbSnatAutoMap",
            "LbSnatIpPool"
          ],
          "type": "string",
          "description": "Load balancers may need to perform SNAT to ensure reverse traffic from\nthe server can be received and processed by them.\nThere are two modes:\nLbSnatAutoMap uses the load balancer interface IP and an\nephemeral port as the source IP and port of the server side connection.\nLbSnatIpPool allows user to specify one or more IP addresses\nalong with their subnet masks that should be used for SNAT while\nconnecting to any of the servers in the pool.\n"
        },
        "port_overload": {
          "description": "Both SNAT automap and SNAT IP list modes support port overloading\nwhich allows the same SNAT IP and port to be used for multiple\nbackend connections as long as the tuple (source IP, source port,\ndestination IP, destination port, IP protocol) after SNAT is\nperformed is unique.\nThe valid number is 1, 2, 4, 8, 16, 32.\n",
          "title": "port overloading with same SNAT IP and port",
          "default": 1,
          "format": "int64",
          "maximum": 32,
          "minimum": 1,
          "type": "integer"
        }
      }
    },
    "UpgradeTaskProperties": {
      "properties": {
        "bundle_name": {
          "type": "string",
          "description": "Name of Bundle",
          "title": "Name of Bundle"
        },
        "parameters": {
          "items": {
            "$ref": "#/definitions/KeyValuePair"
          },
          "readOnly": true,
          "type": "array",
          "description": "Bundle arguments",
          "title": "Bundle arguments"
        },
        "action_name": {
          "type": "string",
          "description": "helper for the task",
          "title": "helper for the task"
        }
      },
      "required": [
        "bundle_name"
      ],
      "type": "object",
      "description": "Task properties",
      "title": "Task properties"
    },
    "RestoreConfiguration": {
      "required": [
        "remote_file_server"
      ],
      "type": "object",
      "properties": {
        "remote_file_server": {
          "title": "The server from which backup files will be retrieved for restore.",
          "description": "The server from which backup files will be retrieved for restore.",
          "$ref": "#/definitions/RemoteFileServer"
        },
        "passphrase": {
          "type": "string",
          "description": "Passphrase used to encrypt backup files.",
          "title": "Passphrase used to encrypt backup files."
        }
      }
    },
    "LogicalRouterPortListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LogicalRouterPort"
              },
              "type": "array",
              "description": "Logical router port list results",
              "title": "Logical router port list results"
            }
          }
        }
      ]
    },
    "SwitchingProfilesListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/BaseSwitchingProfile"
              },
              "readOnly": true,
              "type": "array",
              "description": "Switching Profile Results",
              "title": "Switching Profile Results"
            }
          },
          "type": "object"
        }
      ],
      "description": "Switching Profile queries result",
      "title": "Switching Profile queries result"
    },
    "LbAppProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "discriminator": "resource_type",
          "required": [
            "resource_type"
          ],
          "type": "object",
          "properties": {
            "resource_type": {
              "enum": [
                "LbHttpProfile",
                "LbFastTcpProfile",
                "LbFastUdpProfile"
              ],
              "type": "string",
              "description": "An application profile can be bound to a virtual server\nto specify the application protocol characteristics. It is used to\ninfluence how load balancing is performed. Currently, three types of\napplication profiles are supported: LbFastTCPProfile,\nLbFastUDPProfile and LbHttpProfile.\nLbFastTCPProfile or LbFastUDPProfile is typically\nused when the application is using a custom protocol or a standard protocol\nnot supported by the load balancer. It is also used in cases where the user\nonly wants L4 load balancing mainly because L4 load balancing has much\nhigher performance and scalability, and/or supports connection mirroring.\nLbHttpProfile is used for both HTTP and HTTPS applications.\nThough application rules, if bound to the virtual server, can be used\nto accomplish the same goal, LbHttpProfile is intended to\nsimplify enabling certain common use cases.\n"
            }
          }
        }
      ]
    },
    "NetworkEncryptionStatus": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "type": "object",
          "properties": {
            "status": {
              "readOnly": true,
              "enum": [
                "INSTALLED_DISABLED",
                "ENABLED",
                "UNKNOWN"
              ],
              "type": "string",
              "description": "Network encryption status for the given context.",
              "title": "Network encryption status for the context."
            },
            "context": {
              "readOnly": true,
              "type": "string",
              "description": "Network encryption status for a particular context. Context could represent all or specific logical entities where firewall is supported. Examples of logical entities are hypervisors and logical routers.",
              "title": "context for which network encryption status being returned."
            }
          }
        }
      ]
    },
    "RealizedFirewallRule": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyRealizedResource"
        },
        {
          "properties": {
            "disabled": {
              "readOnly": true,
              "type": "boolean",
              "description": "Flag to disable rule. Disabled will only be persisted but never provisioned/realized.",
              "title": "Rule enable/disable flag"
            },
            "sources": {
              "description": "List of sources. Null will be treated as any.",
              "title": "Source List",
              "items": {
                "$ref": "#/definitions/ResourceReference"
              },
              "readOnly": true,
              "maxItems": 128,
              "type": "array"
            },
            "direction": {
              "description": "Rule direction in case of stateless firewall rules. This will only considered if section level parameter is set to stateless. Default to IN_OUT if not specified.",
              "title": "Rule direction",
              "default": "IN_OUT",
              "enum": [
                "IN",
                "OUT",
                "IN_OUT"
              ],
              "readOnly": true,
              "type": "string"
            },
            "services": {
              "description": "List of the services. Null will be treated as any.",
              "title": "Service List",
              "items": {
                "$ref": "#/definitions/ResourceReference"
              },
              "readOnly": true,
              "maxItems": 128,
              "type": "array"
            },
            "action": {
              "readOnly": true,
              "enum": [
                "ALLOW",
                "DROP",
                "REJECT"
              ],
              "type": "string",
              "description": "Action enforced on the packets which matches the firewall rule.",
              "title": "Action"
            },
            "destinations": {
              "description": "List of the destinations. Null will be treated as any.",
              "title": "Destination List",
              "items": {
                "$ref": "#/definitions/ResourceReference"
              },
              "readOnly": true,
              "maxItems": 128,
              "type": "array"
            }
          },
          "type": "object"
        }
      ],
      "description": "Realized Firewall Rule",
      "title": "Realized Firewall Rule"
    },
    "PortConnectionError": {
      "properties": {
        "error_summary": {
          "type": "string"
        },
        "error_details": {
          "type": "object"
        },
        "entity_type": {
          "type": "string"
        }
      },
      "type": "object",
      "description": "Errors encountered while fetching entities in the forwarding path",
      "title": "Errors encountered while fetching entities in the forwarding path"
    },
    "CertificateKeyPair": {
      "required": [
        "rsa_private_key",
        "certificate"
      ],
      "type": "object",
      "properties": {
        "rsa_private_key": {
          "minLength": 60,
          "readOnly": false,
          "type": "string",
          "description": "The private key must include the enclosing \"-----BEGIN RSA PRIVATE KEY-----\" and \"-----END RSA PRIVATE KEY-----\". An empty string is returned in read responses.",
          "title": "PEM encoded RSA private key"
        },
        "certificate": {
          "readOnly": false,
          "$ref": "#/definitions/SecurityCertificate"
        }
      }
    },
    "AuthenticationScheme": {
      "required": [
        "scheme_name"
      ],
      "type": "object",
      "properties": {
        "scheme_name": {
          "type": "string",
          "description": "Authentication scheme name",
          "title": "Authentication scheme name"
        }
      }
    },
    "DhcpProfileListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/DhcpProfile"
              },
              "type": "array",
              "description": "paginated list of dhcp profiles",
              "title": "paginated list of dhcp profiles"
            }
          }
        }
      ]
    },
    "HostNodeLoginCredential": {
      "properties": {
        "username": {
          "type": "string",
          "description": "The username of the account on the host node",
          "title": "The username of the account on the host node"
        },
        "password": {
          "type": "string",
          "description": "The authentication password of the host node",
          "title": "The authentication password of the host node"
        },
        "thumbprint": {
          "type": "string",
          "description": "For ESXi hosts, the thumbprint of the ESXi management service.\nFor KVM hosts, the SSH key fingerprint.\n",
          "title": "ESXi thumbprint or SSH key fingerprint of the host node"
        }
      },
      "type": "object",
      "description": "The credentials to login into the host node",
      "title": "The credentials to login into the host node"
    },
    "LogicalSwitchListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LogicalSwitch"
              },
              "readOnly": true,
              "type": "array",
              "description": "Logical Switch Results",
              "title": "Logical Switch Results"
            }
          },
          "type": "object"
        }
      ],
      "description": "Logical Switch queries result",
      "title": "Logical Switch queries result"
    },
    "NodeSummaryList": {
      "required": [
        "results"
      ],
      "type": "object",
      "properties": {
        "results": {
          "items": {
            "$ref": "#/definitions/NodeSummary"
          },
          "type": "array",
          "description": "List of Node Summary",
          "title": "List of Node Summary"
        }
      }
    },
    "UpgradeUnit": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "type": "object",
          "properties": {
            "group": {
              "readOnly": true,
              "title": "Info of the group to which this upgrade unit belongs",
              "description": "Info of the group to which this upgrade unit belongs",
              "$ref": "#/definitions/UpgradeUnitGroupInfo"
            },
            "warnings": {
              "items": {
                "type": "string"
              },
              "readOnly": true,
              "type": "array",
              "description": "List of warnings indicating issues with the upgrade unit that may result in upgrade failure",
              "title": "List of warnings indicating issues with the upgrade unit that may result in upgrade failure"
            },
            "current_version": {
              "readOnly": true,
              "type": "string",
              "description": "This is component version e.g. if upgrade unit is of type edge, then this is edge version.",
              "title": "Current version of upgrade unit"
            },
            "metadata": {
              "items": {
                "$ref": "#/definitions/KeyValuePair"
              },
              "readOnly": true,
              "type": "array",
              "description": "Metadata about upgrade unit",
              "title": "Metadata about upgrade unit"
            },
            "type": {
              "readOnly": false,
              "type": "string",
              "description": "Upgrade unit type",
              "title": "Upgrade unit type"
            },
            "id": {
              "readOnly": true,
              "type": "string",
              "description": "Identifier of the upgrade unit",
              "title": "UUID of the upgrade unit"
            },
            "display_name": {
              "readOnly": false,
              "type": "string",
              "description": "Name of the upgrade unit",
              "title": "Name of the upgrade unit"
            }
          }
        }
      ]
    },
    "TraceflowObservationForwarded": {
      "allOf": [
        {
          "$ref": "#/definitions/TraceflowObservation"
        },
        {
          "type": "object",
          "properties": {
            "uplink_name": {
              "type": "string",
              "description": "The name of the uplink the traceflow packet is forwarded on",
              "title": "The name of the uplink the traceflow packet is forwarded on"
            },
            "vtep_label": {
              "format": "int64",
              "type": "integer",
              "description": "The virtual tunnel endpoint label",
              "title": "The virtual tunnel endpoint label"
            },
            "remote_ip_address": {
              "format": "ip",
              "type": "string",
              "description": "IP address of the destination end of the tunnel"
            },
            "context": {
              "format": "int64",
              "type": "integer",
              "description": "The 64bit tunnel context carried on the wire.",
              "title": "The 64bit tunnel context carried on the wire."
            },
            "local_ip_address": {
              "format": "ip",
              "type": "string",
              "description": "IP address of the source end of the tunnel"
            },
            "dst_transport_node_id": {
              "readOnly": true,
              "type": "string",
              "description": "This field will not be always available. Use remote_ip_address when this field is not set.",
              "title": "The id of the transport node to which the traceflow packet is forwarded"
            },
            "dst_transport_node_name": {
              "readOnly": true,
              "type": "string",
              "description": "The name of the transport node to which the traceflow packet is forwarded",
              "title": "The name of the transport node to which the traceflow packet is forwarded"
            }
          }
        }
      ]
    },
    "LogicalSwitchStatistics": {
      "allOf": [
        {
          "$ref": "#/definitions/AggregatedDataCounterEx"
        },
        {
          "type": "object",
          "properties": {
            "last_update_timestamp": {
              "readOnly": true,
              "type": "integer",
              "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
              "format": "int64"
            },
            "logical_switch_id": {
              "readOnly": true,
              "type": "string",
              "description": "The id of the logical Switch",
              "title": "The id of the logical Switch"
            }
          }
        }
      ]
    },
    "DneSectionRuleList": {
      "allOf": [
        {
          "$ref": "#/definitions/DneSection"
        },
        {
          "required": [
            "rules"
          ],
          "type": "object",
          "properties": {
            "rules": {
              "description": "List of DNE rules in the section. Only homogenous rules are supported.",
              "title": "List of the DNE rules",
              "items": {
                "$ref": "#/definitions/DneRule"
              },
              "readOnly": false,
              "maxItems": 1000,
              "type": "array"
            }
          }
        }
      ]
    },
    "VtepTableEntry": {
      "required": [
        "vtep_label",
        "vtep_mac_address"
      ],
      "type": "object",
      "properties": {
        "vtep_label": {
          "format": "int64",
          "type": "integer",
          "description": "The virtual tunnel endpoint label",
          "title": "The virtual tunnel endpoint label"
        },
        "vtep_mac_address": {
          "type": "string",
          "description": "The virtual tunnel endpoint MAC address",
          "title": "The virtual tunnel endpoint MAC address"
        },
        "vtep_ip": {
          "format": "ip",
          "type": "string",
          "description": "The virtual tunnel endpoint IP address"
        },
        "segment_id": {
          "type": "string",
          "description": "The segment Id",
          "title": "The segment Id"
        }
      }
    },
    "SwitchingProfileTypeIdEntry": {
      "required": [
        "value"
      ],
      "type": "object",
      "properties": {
        "value": {
          "readOnly": false,
          "type": "string",
          "description": "key value"
        },
        "key": {
          "enum": [
            "QosSwitchingProfile",
            "PortMirroringSwitchingProfile",
            "IpDiscoverySwitchingProfile",
            "SpoofGuardSwitchingProfile",
            "SwitchSecuritySwitchingProfile",
            "MacManagementSwitchingProfile"
          ],
          "type": "string",
          "description": "Supported switching profiles."
        }
      }
    },
    "NodeSearchDomainsProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "search_domains": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "Search domains",
              "title": "Search domains"
            }
          },
          "required": [
            "search_domains"
          ],
          "type": "object"
        }
      ],
      "description": "Node network search domains properties",
      "title": "Node network search domains properties"
    },
    "VirtualNetworkInterfaceListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/VirtualNetworkInterface"
              },
              "type": "array",
              "description": "VirtualNetworkInterface list results",
              "title": "VirtualNetworkInterface list results"
            }
          }
        }
      ]
    },
    "RestoreStep": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/definitions/PerStepRestoreStatus"
        },
        "step_number": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Restore step number",
          "title": "Restore step number"
        },
        "description": {
          "readOnly": true,
          "type": "string",
          "description": "Restore step description",
          "title": "Restore step description"
        },
        "value": {
          "readOnly": true,
          "type": "string",
          "description": "Restore step value",
          "title": "Restore step value"
        }
      }
    },
    "NSGroupTagExpression": {
      "allOf": [
        {
          "$ref": "#/definitions/NSGroupExpression"
        },
        {
          "properties": {
            "tag_op": {
              "default": "EQUALS",
              "enum": [
                "EQUALS"
              ],
              "type": "string",
              "description": "Operator of the tag expression eg- tag.tag = \"Production\"",
              "title": "Operator of the tag expression eg- tag.tag = \"Production\""
            },
            "scope": {
              "maxLength": 30,
              "type": "string",
              "description": "The tag.scope attribute of the object",
              "title": "The tag.scope attribute of the object"
            },
            "scope_op": {
              "default": "EQUALS",
              "enum": [
                "EQUALS"
              ],
              "type": "string",
              "description": "Operator of the scope expression eg- tag.scope = \"S1\".",
              "title": "Operator of the scope expression eg- tag.scope = \"S1\"."
            },
            "tag": {
              "maxLength": 40,
              "type": "string",
              "description": "The tag.tag attribute of the object",
              "title": "The tag.tag attribute of the object"
            },
            "target_type": {
              "enum": [
                "LogicalSwitch",
                "LogicalPort",
                "VirtualMachine"
              ],
              "type": "string",
              "description": "Type of the resource on which this expression is evaluated",
              "title": "Type of the resource on which this expression is evaluated"
            }
          },
          "required": [
            "target_type"
          ],
          "type": "object"
        }
      ],
      "description": "Includes both scope and tag attribute of Tag. The scope and tag expressions\nare logically 'AND' with each other.\neg- tag.scope = \"S1\" AND tag.tag = 'T1'\n",
      "title": "TAG expressions to represent NSGroup membership"
    },
    "RuleState": {
      "allOf": [
        {
          "$ref": "#/definitions/ConfigurationState"
        },
        {
          "type": "object",
          "properties": {
            "revision_desired": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "revision number of the desired state",
              "title": "revision number of the desired state"
            }
          }
        }
      ]
    },
    "HaVipConfig": {
      "required": [
        "ha_vip_subnets",
        "redundant_uplink_port_ids"
      ],
      "type": "object",
      "properties": {
        "ha_vip_subnets": {
          "description": "Array of IP address subnets which will be used as floating IP addresses. | Note - this configuration is applicable only for Active-Standby LogicalRouter. | For Active-Active LogicalRouter this configuration will be rejected.",
          "title": "Floating IP address subnets",
          "minItems": 1,
          "items": {
            "$ref": "#/definitions/VIPSubnet"
          },
          "maxItems": 1,
          "type": "array"
        },
        "redundant_uplink_port_ids": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Identifiers of logical router uplink ports which are to be paired to provide | redundancy. Floating IP will be owned by one of these uplink ports (depending upon | which node is Active).",
          "title": "Identifiers of uplink ports for providing redundancy"
        },
        "enabled": {
          "default": true,
          "type": "boolean",
          "description": "Flag to enable this ha vip config.",
          "title": "Flag to enable this ha vip config."
        }
      }
    },
    "SessionReclassificationParameter": {
      "type": "object",
      "properties": {
        "app_profile_ids": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "App Profile Ids",
          "title": "App Profile Ids"
        }
      }
    },
    "TransportZoneStatus": {
      "properties": {
        "num_logical_ports": {
          "readOnly": true,
          "format": "int32",
          "type": "integer",
          "description": "Count of logical ports in the transport zone",
          "title": "Count of logical ports in the transport zone"
        },
        "transport_zone_id": {
          "readOnly": true,
          "type": "string",
          "description": "Unique ID identifying the transport zone",
          "title": "Unique ID identifying the transport zone"
        },
        "num_logical_switches": {
          "readOnly": true,
          "format": "int32",
          "type": "integer",
          "description": "Count of logical switches in the transport zone",
          "title": "Count of logical switches in the transport zone"
        },
        "num_transport_nodes": {
          "readOnly": true,
          "format": "int32",
          "type": "integer",
          "description": "Count of transport nodes in the transport zone",
          "title": "Count of transport nodes in the transport zone"
        }
      },
      "type": "object",
      "description": "Transport zone runtime status information",
      "title": "Transport zone runtime status information"
    },
    "AppInfoHostVmCsvRecord": {
      "allOf": [
        {
          "$ref": "#/definitions/CsvRecord"
        },
        {
          "type": "object",
          "properties": {
            "host_vms": {
              "readOnly": true,
              "type": "string",
              "description": "vm ids that this application belongs to",
              "title": "vm ids that this application belongs to"
            },
            "version": {
              "readOnly": true,
              "type": "string",
              "description": "Version of the app",
              "title": "Version of the app"
            },
            "display_name": {
              "readOnly": true,
              "type": "string",
              "description": "Name of the app",
              "title": "Name of the app"
            },
            "id": {
              "readOnly": true,
              "type": "string",
              "description": "Id of the app",
              "title": "Id of the app"
            },
            "manufacturer": {
              "readOnly": true,
              "type": "string",
              "description": "Manufacturer of the app",
              "title": "Manufacturer of the app"
            }
          }
        }
      ]
    },
    "LbCookiePersistenceProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/LbPersistenceProfile"
        },
        {
          "required": [
            "cookie_name"
          ],
          "type": "object",
          "properties": {
            "cookie_garble": {
              "default": true,
              "type": "boolean",
              "description": "If garble is set to true, cookie value (server IP and port) would be\nencrypted.\nIf garble is set to false, cookie value would be plain text.\n",
              "title": "cookie persistence garble"
            },
            "cookie_fallback": {
              "default": true,
              "type": "boolean",
              "description": "If fallback is true, once the cookie points to a server that is down\n(i.e. admin state DISABLED or healthcheck state is DOWN), then a new\nserver is selected by default to handle that request.\nIf fallback is false, it will cause the request to be rejected if\ncookie points to a server\n",
              "title": "cookie persistence fallback"
            },
            "cookie_mode": {
              "description": "cookie persistence mode",
              "default": "INSERT",
              "enum": [
                "INSERT",
                "PREFIX",
                "REWRITE"
              ],
              "type": "string"
            },
            "cookie_domain": {
              "type": "string",
              "description": "HTTP cookie domain could be configured, only available for insert mode.\n",
              "title": "cookie domain"
            },
            "cookie_name": {
              "type": "string",
              "description": "cookie name",
              "title": "cookie name"
            },
            "cookie_time": {
              "title": "cookie time setting",
              "description": "Both session cookie and persistence cookie are supported, if not\nspecified, it's a session cookie. It expires when the browser is\nclosed.\n",
              "$ref": "#/definitions/LbCookieTime"
            },
            "cookie_path": {
              "type": "string",
              "description": "HTTP cookie path could be set, only available for insert mode.\n",
              "title": "cookie path"
            }
          }
        }
      ]
    },
    "MetadataProxyStatus": {
      "required": [
        "proxy_status",
        "transport_nodes"
      ],
      "type": "object",
      "properties": {
        "proxy_status": {
          "enum": [
            "UP",
            "DOWN",
            "ERROR",
            "NO_BACKUP"
          ],
          "type": "string",
          "description": "UP means the metadata proxy is working fine on both transport-nodes(if have);\nDOWN means the metadata proxy is is down on both transport-nodes(if have),\nhence the metadata proxy will not repsonse any metadata request;\nError means error happens on transport-node(s) or no status is reported from\ntransport-node(s). The metadata proxy may be working (or not working);\nNO_BACK means metadata proxy is working in one of the transport node while\nnot in the other transport-node (if have). Hence if the metadata proxy in\nthe working transport-node goes down, the metadata proxy will go down.\n"
        },
        "error_message": {
          "type": "string",
          "description": "Error message, if available",
          "title": "Error message, if available"
        },
        "transport_nodes": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Order of the transport nodes is insensitive because Metadata Proxy\nis running in Active-Active mode among target transport nodes.\n",
          "title": "ids of transport nodes where this metadata proxy is running"
        }
      }
    },
    "AddControllerNodeSpec": {
      "required": [
        "mpa_msg_client_info",
        "host_msg_client_info",
        "type"
      ],
      "type": "object",
      "properties": {
        "mpa_msg_client_info": {
          "$ref": "#/definitions/MsgClientInfo"
        },
        "host_msg_client_info": {
          "$ref": "#/definitions/MsgClientInfo"
        },
        "control_plane_server_certificate": {
          "type": "string",
          "description": "Deprecated. Do not supply a value for this property.",
          "x-deprecated": true
        },
        "type": {
          "readOnly": false,
          "enum": [
            "AddControllerNodeSpec"
          ],
          "type": "string",
          "description": "must be set to AddControllerNodeSpec",
          "title": "must be set to AddControllerNodeSpec"
        }
      }
    },
    "AcceptableComponentVersion": {
      "allOf": [
        {
          "$ref": "#/definitions/VersionList"
        },
        {
          "required": [
            "component_type"
          ],
          "type": "object",
          "properties": {
            "component_type": {
              "enum": [
                "HOST",
                "EDGE",
                "CCP",
                "MP"
              ],
              "type": "string",
              "description": "Node type",
              "title": "Node type"
            }
          }
        }
      ]
    },
    "UcMessageMetadataList": {
      "required": [
        "message_metadata"
      ],
      "type": "object",
      "properties": {
        "message_metadata": {
          "items": {
            "$ref": "#/definitions/UcMessageMetadata"
          },
          "readOnly": false,
          "type": "array",
          "description": "List of UC message metadata",
          "title": "List of UC message metadata"
        }
      }
    },
    "BFDProperties": {
      "properties": {
        "active": {
          "readOnly": true,
          "type": "boolean",
          "description": "True if tunnel is active in a gateway HA setup",
          "title": "True if tunnel is active in a gateway HA setup"
        },
        "state": {
          "readOnly": true,
          "enum": [
            "UNKNOWN_STATE",
            "ADMIN_DOWN",
            "DOWN",
            "INIT",
            "UP"
          ],
          "type": "string",
          "description": "State of the BFD session",
          "title": "State of the BFD session"
        },
        "remote_state": {
          "readOnly": true,
          "enum": [
            "UNKNOWN_STATE",
            "ADMIN_DOWN",
            "DOWN",
            "INIT",
            "UP"
          ],
          "type": "string",
          "description": "State of the remote interface's BFD session",
          "title": "State of the remote interface's BFD session"
        },
        "remote_diagnostic": {
          "readOnly": true,
          "type": "string",
          "description": "A short message indicating what the remote interface's BFD session thinks is wrong in case of a problem",
          "title": "Diagnostic message of a problem"
        },
        "forwarding": {
          "readOnly": true,
          "type": "boolean",
          "description": "True if the BFD session believes this interface may be used to forward traffic",
          "title": "True if the BFD session believes this interface may be used to forward traffic"
        },
        "diagnostic": {
          "readOnly": true,
          "type": "string",
          "description": "A short message indicating what the BFD session thinks is wrong in case of a problem",
          "title": "Diagnostic message of a problem"
        }
      },
      "type": "object",
      "description": "BFD information",
      "title": "BFD information"
    },
    "InterfaceNeighborPropertyListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/InterfaceNeighborProperties"
              },
              "type": "array",
              "description": "Interface neighbor property results",
              "title": "Interface neighbor property results"
            }
          },
          "type": "object"
        }
      ],
      "description": "Interface neighbor property query results",
      "title": "Interface neighbor property query results"
    },
    "SnmpCommunity": {
      "required": [
        "community_string"
      ],
      "type": "object",
      "properties": {
        "access": {
          "default": "read_only",
          "enum": [
            "read_only"
          ],
          "type": "string",
          "description": "Type of access",
          "title": "Type of access"
        },
        "community_string": {
          "type": "string",
          "description": "Community string at most 64 characters long",
          "title": "Community string at most 64 characters long"
        }
      }
    },
    "FileProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "created_epoch_ms": {
              "format": "int64",
              "type": "integer",
              "description": "File creation time in epoch milliseconds",
              "title": "File creation time in epoch milliseconds"
            },
            "modified_epoch_ms": {
              "format": "int64",
              "type": "integer",
              "description": "File modification time in epoch milliseconds",
              "title": "File modification time in epoch milliseconds"
            },
            "name": {
              "type": "string",
              "description": "File name",
              "title": "File name"
            },
            "size": {
              "format": "int64",
              "type": "integer",
              "description": "Size of the file in bytes",
              "title": "Size of the file in bytes"
            }
          },
          "required": [
            "created_epoch_ms",
            "modified_epoch_ms",
            "name",
            "size"
          ],
          "type": "object"
        }
      ],
      "description": "File properties",
      "title": "File properties"
    },
    "NatStatisticsPerTransportNode": {
      "allOf": [
        {
          "$ref": "#/definitions/NatCounters"
        },
        {
          "type": "object",
          "properties": {
            "last_update_timestamp": {
              "readOnly": true,
              "type": "integer",
              "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
              "format": "int64"
            },
            "transport_node_id": {
              "readOnly": true,
              "type": "string",
              "description": "Id for the transport node",
              "title": "Id for the transport node"
            }
          }
        }
      ]
    },
    "MacTableCsvRecord": {
      "allOf": [
        {
          "$ref": "#/definitions/CsvRecord"
        },
        {
          "required": [
            "mac_address"
          ],
          "type": "object",
          "properties": {
            "vtep_mac_address": {
              "type": "string",
              "description": "The virtual tunnel endpoint MAC address",
              "title": "The virtual tunnel endpoint MAC address"
            },
            "vtep_ip": {
              "format": "ip",
              "type": "string",
              "description": "The virtual tunnel endpoint IP address"
            },
            "mac_address": {
              "type": "string",
              "description": "The MAC address",
              "title": "The MAC address"
            }
          }
        }
      ]
    },
    "NodeUserSettings": {
      "type": "object",
      "properties": {
        "root_password": {
          "type": "string",
          "description": "Password for the node root user. For deployment,\nthis property is required. After deployment, this property is ignored, and\nthe node cli must be used to change the password.\nThe password specified must be at least 8 characters in length and must\ncontain at least one lowercase, one uppercase, one numeric character and one\nspecial character (except quotes).\n",
          "title": "Node root user password"
        },
        "cli_password": {
          "type": "string",
          "description": "Password for the node cli user. For deployment,\nthis property is required. After deployment, this property is ignored, and\nthe node cli must be used to change the password.\nThe password specified must be at least 8 characters in length and must\ncontain at least one lowercase, one uppercase, one numeric character and one\nspecial character (except quotes).\n",
          "title": "Node cli password"
        }
      }
    },
    "IpfixCollectorConfig": {
      "description": "This managed entity contains a set of IPFIX collectors.\n",
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "collectors"
          ],
          "type": "object",
          "properties": {
            "collectors": {
              "description": "IPFIX Collectors",
              "title": "IPFIX Collectors",
              "minItems": 1,
              "items": {
                "$ref": "#/definitions/IpfixCollector"
              },
              "maxItems": 4,
              "type": "array"
            }
          }
        }
      ]
    },
    "TraceflowObservationReceivedLogical": {
      "allOf": [
        {
          "$ref": "#/definitions/TraceflowObservation"
        },
        {
          "type": "object",
          "properties": {
            "src_component_id": {
              "readOnly": true,
              "type": "string",
              "description": "The id of the source component from which the traceflow packet was received.",
              "title": "The id of the source component from which the traceflow packet was received."
            },
            "component_id": {
              "readOnly": true,
              "type": "string",
              "description": "The id of the component that received the traceflow packet.",
              "title": "The id of the component that received the traceflow packet."
            },
            "lport_id": {
              "readOnly": true,
              "type": "string",
              "description": "The id of the logical port at which the traceflow packet was received",
              "title": "The id of the logical port at which the traceflow packet was received"
            },
            "src_component_type": {
              "description": "The type of the source component from which the traceflow packet was received.",
              "enum": [
                "PHYSICAL",
                "LR",
                "LS",
                "DFW",
                "BRIDGE",
                "EDGE_TUNNEL",
                "EDGE_HOSTSWITCH",
                "UNKNOWN"
              ],
              "readOnly": true,
              "type": "string"
            },
            "lport_name": {
              "readOnly": true,
              "type": "string",
              "description": "The name of the logical port at which the traceflow packet was received",
              "title": "The name of the logical port at which the traceflow packet was received"
            },
            "src_component_name": {
              "readOnly": true,
              "type": "string",
              "description": "The name of source component from which the traceflow packet was received.",
              "title": "The name of source component from which the traceflow packet was received."
            },
            "vni": {
              "readOnly": true,
              "format": "int32",
              "type": "integer",
              "description": "VNI for the logical network on which the traceflow packet was received.",
              "title": "VNI for the logical network on which the traceflow packet was received."
            }
          }
        }
      ]
    },
    "DneSection": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "type": "object",
          "properties": {
            "is_default": {
              "readOnly": true,
              "type": "boolean",
              "description": "It is a boolean flag which reflects whether a DNE section is default section or not. Each Layer 2 and Layer 3 section. has one and only one default section.",
              "title": "Default DNE section flag"
            },
            "rule_count": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Number of rules in this section.",
              "title": "Rule count"
            },
            "section_type": {
              "description": "Type of the rules which a section can contain. Only homogeneous sections are supported.",
              "title": "DNE Section Type",
              "default": "LAYER3",
              "enum": [
                "LAYER3"
              ],
              "readOnly": false,
              "type": "string"
            }
          }
        }
      ]
    },
    "NSServiceGroupListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/NSServiceGroup"
              },
              "type": "array",
              "description": "Paged collection of NSServiceGroups",
              "title": "Paged collection of NSServiceGroups"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "List result of NSServiceGroups",
      "title": "List result of NSServiceGroups"
    },
    "PolicyTemplatePlaceholder": {
      "properties": {
        "placeholder_message": {
          "type": "string",
          "description": "Placeholder message",
          "title": "Placeholder message"
        },
        "placeholder_id": {
          "type": "string",
          "description": "Placeholder id",
          "title": "Placeholder id"
        }
      },
      "required": [
        "placeholder_message",
        "placeholder_id"
      ],
      "type": "object",
      "description": "Policy template placeholdder",
      "title": "Policy template placeholdder"
    },
    "Principal": {
      "required": [
        "attributes"
      ],
      "type": "object",
      "properties": {
        "attributes": {
          "items": {
            "$ref": "#/definitions/KeyValue"
          },
          "readOnly": false,
          "type": "array",
          "description": "Certificate list"
        }
      }
    },
    "TransportZoneInfo": {
      "type": "object",
      "properties": {
        "is_underlay_transport_zone": {
          "readOnly": true,
          "type": "boolean",
          "description": "Flag to identify if this is the underlay transport zone",
          "title": "Flag to identify if this is the underlay transport zone"
        },
        "transport_zone_id": {
          "readOnly": true,
          "type": "string",
          "description": "ID of the transport zone",
          "title": "ID of the transport zone"
        },
        "transport_zone_display_name": {
          "readOnly": true,
          "type": "string",
          "description": "Name of the transport zone",
          "title": "Name of the transport zone"
        },
        "logical_switches": {
          "items": {
            "$ref": "#/definitions/LogicalSwitchInfo"
          },
          "readOnly": true,
          "type": "array",
          "description": "Logical switches for the transport zone",
          "title": "Logical switches for the transport zone"
        }
      }
    },
    "TraceflowObservation": {
      "required": [
        "resource_type"
      ],
      "type": "object",
      "properties": {
        "resource_type": {
          "default": "TraceflowObservationReceived",
          "enum": [
            "TraceflowObservationForwarded",
            "TraceflowObservationDropped",
            "TraceflowObservationDelivered",
            "TraceflowObservationReceived",
            "TraceflowObservationForwardedLogical",
            "TraceflowObservationDroppedLogical",
            "TraceflowObservationReceivedLogical"
          ],
          "type": "string"
        },
        "component_type": {
          "description": "The type of the component that issued the observation.",
          "enum": [
            "PHYSICAL",
            "LR",
            "LS",
            "DFW",
            "BRIDGE",
            "EDGE_TUNNEL",
            "EDGE_HOSTSWITCH",
            "UNKNOWN"
          ],
          "readOnly": true,
          "type": "string"
        },
        "transport_node_id": {
          "readOnly": true,
          "type": "string",
          "description": "id of the transport node that observed a traceflow packet",
          "title": "id of the transport node that observed a traceflow packet"
        },
        "timestamp": {
          "readOnly": true,
          "type": "integer",
          "description": "Timestamp when the observation was created by the transport node (milliseconds epoch)",
          "format": "int64"
        },
        "transport_node_name": {
          "readOnly": true,
          "type": "string",
          "description": "name of the transport node that observed a traceflow packet",
          "title": "name of the transport node that observed a traceflow packet"
        },
        "sequence_no": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "the hop count for observations on the transport node that a traceflow packet is injected in will be 0. The hop count is incremented each time a subsequent transport node receives the traceflow packet. The sequence number of 999 indicates that the hop count could not be determined for the containing observation.",
          "title": "the sequence number is the traceflow observation hop count"
        },
        "timestamp_micro": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Timestamp when the observation was created by the transport node (microseconds epoch)",
          "title": "Timestamp when the observation was created by the transport node"
        },
        "component_name": {
          "readOnly": true,
          "type": "string",
          "description": "The name of the component that issued the observation.",
          "title": "The name of the component that issued the observation."
        }
      }
    },
    "DneKeyManager": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "host",
            "port",
            "certificate"
          ],
          "type": "object",
          "properties": {
            "status": {
              "readOnly": true,
              "type": "string",
              "description": "Health status check for the key manager server. The value is updated and displayed everytime an API call(GET/POST/PUT) is made on the key manager entity.",
              "title": "Health status check"
            },
            "host": {
              "type": "string",
              "description": "Host server of key manager appliance. The value could be an IP address or a server name.",
              "title": "Key manager host"
            },
            "port": {
              "description": "A port number of key manager instance.",
              "format": "int64",
              "title": "Key manager port",
              "maximum": 65535,
              "minimum": 0,
              "type": "integer"
            },
            "certificate": {
              "type": "string",
              "description": "The certificate of key manager appliance.",
              "title": "Key manager X.509 certificate"
            }
          }
        }
      ]
    },
    "ClientTypeCollectionConfiguration": {
      "properties": {
        "client_type": {
          "enum": [
            "HYPERVISOR",
            "EDGE",
            "CONTROL_PLANE",
            "CONTROL_PLANE_PLATFORM",
            "MANAGEMENT_PLANE",
            "MANAGEMENT_PLANE_PLATFORM"
          ],
          "type": "string",
          "description": "The client type for which this data collection frequency setting applies",
          "title": "Client Type"
        },
        "data_type_configurations": {
          "items": {
            "$ref": "#/definitions/DataTypeCollectionConfiguration"
          },
          "type": "array",
          "description": "The set of data collection type configurations, one for each data collection type",
          "title": "Data type configurations"
        }
      },
      "required": [
        "client_type",
        "data_type_configurations"
      ],
      "type": "object",
      "description": "HPM client data collection configuration",
      "title": "HPM client data collection configuration"
    },
    "MacAddressListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "last_update_timestamp": {
              "readOnly": true,
              "type": "integer",
              "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
              "format": "int64"
            },
            "logical_switch_id": {
              "readOnly": true,
              "type": "string",
              "description": "The id of the logical Switch",
              "title": "The id of the logical Switch"
            },
            "results": {
              "items": {
                "$ref": "#/definitions/MacTableEntry"
              },
              "type": "array"
            },
            "transport_node_id": {
              "readOnly": true,
              "type": "string",
              "description": "Transport node identifier",
              "title": "Transport node identifier"
            }
          }
        }
      ]
    },
    "DomainDeploymentMap": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "properties": {
            "enforcement_point_path": {
              "type": "string",
              "description": "Path of enforcement point on which domain will be deployed",
              "title": "Absolute path of enforcement point"
            }
          },
          "required": [
            "enforcement_point_path"
          ],
          "type": "object"
        }
      ],
      "description": "Binding of domains to the enforcement point.",
      "title": "Domain deployment map"
    },
    "Role": {
      "properties": {
        "role": {
          "type": "string",
          "description": "Role name",
          "title": "Role name"
        }
      },
      "required": [
        "role"
      ],
      "type": "object",
      "description": "Role",
      "title": "Role"
    },
    "FirewallService": {
      "allOf": [
        {
          "$ref": "#/definitions/ResourceReference"
        },
        {
          "type": "object",
          "properties": {
            "service": {
              "readOnly": false,
              "title": "Firewall Network and Security Service element",
              "description": "Firewall API accepts raw protocol and ports as part of NS service element\nin Firewall Rule that describes traffic corresponding to an NSService.\n",
              "$ref": "#/definitions/NSServiceElement"
            }
          }
        }
      ]
    },
    "RealizedGroup": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyRealizedResource"
        },
        {
          "required": [
            "resource_type"
          ],
          "discriminator": "resource_type",
          "type": "object",
          "properties": {
            "resource_type": {
              "enum": [
                "RealizedNSGroup",
                "RealizedSecurityGroup"
              ],
              "type": "string"
            }
          }
        }
      ],
      "description": "Realized group",
      "title": "Realized group"
    },
    "LogicalRouterPortStatistics": {
      "required": [
        "logical_router_port_id"
      ],
      "type": "object",
      "properties": {
        "per_node_statistics": {
          "description": "Per Node Statistics",
          "title": "Per Node Statistics",
          "items": {
            "$ref": "#/definitions/LogicalRouterPortStatisticsPerNode"
          },
          "readOnly": true,
          "additionalProperties": false,
          "type": "array"
        },
        "logical_router_port_id": {
          "type": "string",
          "description": "The ID of the logical router port",
          "title": "The ID of the logical router port"
        }
      }
    },
    "ActionableResource": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "type": "object",
          "properties": {
            "ip_address": {
              "format": "ip",
              "type": "string",
              "description": "A resource reference on which actions can be performed"
            }
          }
        }
      ]
    },
    "IncludedFieldsParameters": {
      "type": "object",
      "properties": {
        "included_fields": {
          "type": "string",
          "description": "Comma separated list of fields that should be included to result of query",
          "title": "Comma separated list of fields that should be included to result of query"
        }
      }
    },
    "IPSubnet": {
      "required": [
        "ip_addresses",
        "prefix_length"
      ],
      "type": "object",
      "properties": {
        "ip_addresses": {
          "description": "IPv4 Addresses",
          "title": "IPv4 Addresses",
          "minItems": 1,
          "items": {
            "format": "ipv4",
            "type": "string",
            "description": "IPv4 address"
          },
          "maxItems": 1,
          "type": "array"
        },
        "prefix_length": {
          "description": "Subnet Prefix Length",
          "format": "int64",
          "title": "Subnet Prefix Length",
          "maximum": 32,
          "minimum": 1,
          "type": "integer"
        }
      }
    },
    "NodeInterfaceProperties": {
      "properties": {
        "source": {
          "type": "string",
          "description": "Source of status data",
          "enum": [
            "realtime",
            "cached"
          ]
        },
        "admin_status": {
          "enum": [
            "UP",
            "DOWN"
          ],
          "type": "string",
          "description": "Interface administration status",
          "title": "Interface administration status"
        },
        "link_status": {
          "enum": [
            "UP",
            "DOWN"
          ],
          "type": "string",
          "description": "Interface administration status",
          "title": "Interface administration status"
        },
        "interface_alias": {
          "items": {
            "$ref": "#/definitions/NodeInterfaceAlias"
          },
          "type": "array",
          "description": "IP Alias",
          "title": "IP Alias"
        },
        "ens_enabled": {
          "type": "boolean",
          "description": "Indicates whether interface is enabled for Enhanced Networking Stack",
          "title": "Indicates whether interface is enabled for Enhanced Networking Stack"
        },
        "interface_type": {
          "enum": [
            "PHYSICAL",
            "VIRTUAL"
          ],
          "type": "string",
          "description": "Interface Type",
          "title": "Interface Type"
        },
        "interface_id": {
          "type": "string",
          "description": "Interface ID",
          "title": "Interface ID"
        },
        "connected_switch": {
          "type": "string",
          "description": "Connected switch",
          "title": "Connected switch"
        },
        "ens_capable": {
          "type": "boolean",
          "description": "Interface capability for Enhanced Networking Stack",
          "title": "Interface capability for Enhanced Networking Stack"
        },
        "mtu": {
          "format": "int64",
          "type": "integer",
          "description": "Interface MTU",
          "title": "Interface MTU"
        }
      },
      "type": "object",
      "description": "Node network interface properties",
      "title": "Node network interface properties"
    },
    "LbServiceStatistics": {
      "required": [
        "service_id"
      ],
      "type": "object",
      "properties": {
        "pools": {
          "items": {
            "$ref": "#/definitions/LbPoolStatistics"
          },
          "type": "array",
          "description": "Statistics of load balancer pools",
          "title": "Statistics of load balancer pools"
        },
        "service_id": {
          "type": "string",
          "description": "load balancer service identifier",
          "title": "load balancer service identifier"
        },
        "virtual_servers": {
          "items": {
            "$ref": "#/definitions/LbVirtualServerStatistics"
          },
          "type": "array",
          "description": "Statistics of load balancer virtual servers",
          "title": "Statistics of load balancer virtual servers"
        },
        "last_update_timestamp": {
          "type": "integer",
          "description": "Timestamp when the data was last updated",
          "format": "int64"
        },
        "statistics": {
          "title": "Load balancer service statistics counter",
          "description": "Load balancer service statistics counter",
          "$ref": "#/definitions/LbServiceStatisticsCounter"
        }
      }
    },
    "FileTransferProtocol": {
      "required": [
        "protocol_name",
        "ssh_fingerprint",
        "authentication_scheme"
      ],
      "type": "object",
      "properties": {
        "protocol_name": {
          "default": "sftp",
          "enum": [
            "sftp"
          ],
          "type": "string",
          "description": "Protocol name",
          "title": "Protocol name"
        },
        "ssh_fingerprint": {
          "type": "string",
          "description": "The expected SSH fingerprint of the server. If the server's fingerprint\ndoes not match this fingerprint, the connection will be terminated.\n\nOnly ECDSA fingerprints hashed with SHA256 are supported. To obtain the\nhost's ssh fingerprint, you should connect via some method other than\nSSH to obtain this information. You can use one of these commands to\nview the key's fingerprint:\n1. ssh-keygen -l -E sha256 -f ssh_host_ecdsa_key.pub\n2. awk '{print $2}' ssh_host_ecdsa_key.pub | base64 -d | sha256sum -b |\n   sed 's/ .*$//' | xxd -r -p | base64 | sed 's/.//44g' |\n   awk '{print \"SHA256:\"$1}'\n",
          "title": "SSH fingerprint of server"
        },
        "authentication_scheme": {
          "title": "Scheme to authenticate if required",
          "description": "Scheme to authenticate if required",
          "$ref": "#/definitions/FileTransferAuthenticationScheme"
        }
      }
    },
    "FeaturePermissionListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/FeaturePermission"
              },
              "type": "array",
              "description": "List results",
              "title": "List results"
            }
          }
        }
      ]
    },
    "ProtonServiceProperties": {
      "properties": {
        "package_logging_level": {
          "items": {
            "$ref": "#/definitions/ProtonPackageLoggingLevels"
          },
          "type": "array",
          "description": "Package logging levels",
          "title": "Package logging levels"
        },
        "logging_level": {
          "enum": [
            "ERROR",
            "WARN",
            "INFO",
            "DEBUG",
            "TRACE"
          ],
          "type": "string",
          "description": "Service logging level",
          "title": "Service logging level"
        }
      },
      "required": [
        "logging_level"
      ],
      "type": "object",
      "description": "Service properties",
      "title": "Service properties"
    },
    "NSService": {
      "description": "A Networking and Security Service allows users to specify characteristics to use\nfor matching network traffic. For example the user can specify port and protocol\npair.\n",
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "nsservice_element"
          ],
          "type": "object",
          "properties": {
            "default_service": {
              "readOnly": true,
              "type": "boolean",
              "description": "The default NSServices are created in the system by default. These NSServices\ncan't be modified/deleted\n",
              "title": "NSServices created in the system by default"
            },
            "nsservice_element": {
              "title": "An NSService Element that describes traffic corresponding to this NSService",
              "description": "An NSService Element that describes traffic corresponding to this NSService",
              "$ref": "#/definitions/NSServiceElement"
            }
          }
        }
      ]
    },
    "VersionList": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "acceptable_versions"
          ],
          "type": "object",
          "properties": {
            "acceptable_versions": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "List of component versions",
              "title": "List of component versions"
            }
          }
        }
      ]
    },
    "NodeSshServiceProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/NodeServiceProperties"
        },
        {
          "properties": {
            "service_properties": {
              "title": "SSH Service properties",
              "description": "SSH Service properties",
              "$ref": "#/definitions/SshServiceProperties"
            }
          },
          "type": "object"
        }
      ],
      "description": "Node SSH service properties",
      "title": "Node SSH service properties"
    },
    "RealizedMACSetListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "title": "Realized MACSet list result",
                "$ref": "#/definitions/RealizedMACSet"
              },
              "type": "array",
              "description": "Paged Collection of Realized MACSets",
              "title": "Paged Collection of Realized MACSets"
            }
          }
        }
      ]
    },
    "PublicCloudGatewayNode": {
      "allOf": [
        {
          "$ref": "#/definitions/EdgeNode"
        },
        {
          "type": "object"
        }
      ]
    },
    "LoginCredential": {
      "discriminator": "credential_type",
      "required": [
        "credential_type"
      ],
      "type": "object",
      "properties": {
        "credential_type": {
          "type": "string",
          "description": "Login credential, for example username-password-thumbprint or certificate based, etc",
          "title": "Login credential, for example username-password-thumbprint or certificate based, etc"
        }
      }
    },
    "LbFastTcpProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/LbAppProfile"
        },
        {
          "type": "object",
          "properties": {
            "close_timeout": {
              "description": "It is used to specify how long a closing TCP connection (both FINs\nreceived or a RST is received) should be kept for this application\nbefore cleaning up the connection.\n",
              "title": "TCP connection idle timeout in seconds",
              "default": 8,
              "format": "int64",
              "maximum": 60,
              "minimum": 1,
              "type": "integer"
            },
            "idle_timeout": {
              "description": "It is used to configure how long an idle TCP connection in ESTABLISHED\nstate should be kept for this application before cleaning up.\n",
              "format": "int64",
              "default": 1800,
              "title": "TCP connection idle timeout in seconds",
              "minimum": 1,
              "type": "integer"
            },
            "ha_flow_mirroring_enabled": {
              "default": false,
              "type": "boolean",
              "description": "If flow mirroring is enabled, all the flows to the bounded virtual\nserver are mirrored to the standby node.\n",
              "title": "flow mirroring enabled flag"
            }
          }
        }
      ]
    },
    "L4PortSetServiceEntry": {
      "allOf": [
        {
          "$ref": "#/definitions/ServiceEntry"
        },
        {
          "properties": {
            "destination_ports": {
              "items": {
                "format": "port-or-range",
                "type": "string",
                "description": "Examples- Single port \"8080\", Range of ports \"8090-8095\"\n"
              },
              "type": "array",
              "maxItems": 15
            },
            "l4_protocol": {
              "enum": [
                "TCP",
                "UDP"
              ],
              "type": "string"
            },
            "source_ports": {
              "items": {
                "format": "port-or-range",
                "type": "string",
                "description": "Examples- Single port \"8080\", Range of ports \"8090-8095\"\n"
              },
              "type": "array",
              "maxItems": 15
            }
          },
          "required": [
            "destination_ports",
            "l4_protocol"
          ],
          "type": "object"
        }
      ],
      "description": "L4PortSet can be specified in comma separated notation of parts. Parts of a\nL4PortSet includes single integer or range of port in hyphen notation.\nExample of a PortSet: \"22, 33-70, 44\".\n",
      "title": "An ServiceEntry that represents TCP or UDP protocol"
    },
    "AggregatedDataCounter": {
      "type": "object",
      "properties": {
        "tx_bytes": {
          "readOnly": true,
          "$ref": "#/definitions/DataCounter"
        },
        "rx_packets": {
          "readOnly": true,
          "$ref": "#/definitions/DataCounter"
        },
        "tx_packets": {
          "readOnly": true,
          "$ref": "#/definitions/DataCounter"
        },
        "rx_bytes": {
          "readOnly": true,
          "$ref": "#/definitions/DataCounter"
        }
      }
    },
    "LogicalPortMacTableEntry": {
      "required": [
        "mac_type",
        "mac_address"
      ],
      "type": "object",
      "properties": {
        "mac_type": {
          "type": "string",
          "description": "The type of the MAC address",
          "enum": [
            "STATIC",
            "LEARNED"
          ]
        },
        "mac_address": {
          "type": "string",
          "description": "The MAC address",
          "title": "The MAC address"
        }
      }
    },
    "LbSourceIpPersistenceProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/LbPersistenceProfile"
        },
        {
          "type": "object",
          "properties": {
            "purge": {
              "description": "persistence purge setting",
              "default": "FULL",
              "enum": [
                "NO_PURGE",
                "FULL"
              ],
              "type": "string"
            },
            "ha_persistence_mirroring_enabled": {
              "default": false,
              "type": "boolean",
              "description": "Persistence entries are not synchronized to the HA peer by default.\n",
              "title": "mirroring enabled flag to synchronize persistence entries"
            },
            "timeout": {
              "description": "When all connections complete (reference count reaches 0), persistence\nentry timer is started with the expiration time.\n",
              "format": "int64",
              "default": 300,
              "title": "persistence entry expiration time in seconds",
              "minimum": 1,
              "type": "integer"
            }
          }
        }
      ]
    },
    "AppProfileMemberAppsListInCsvFormat": {
      "allOf": [
        {
          "$ref": "#/definitions/CsvListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/AppProfileMemberAppsCsvRecord"
              },
              "type": "array",
              "description": "List of app profiles for an application discovery session",
              "title": "List of app profiles for an application discovery session"
            }
          }
        }
      ]
    },
    "LogicalPortStatistics": {
      "allOf": [
        {
          "$ref": "#/definitions/AggregatedDataCounterEx"
        },
        {
          "type": "object",
          "properties": {
            "logical_port_id": {
              "readOnly": true,
              "type": "string",
              "description": "The id of the logical port",
              "title": "The id of the logical port"
            },
            "last_update_timestamp": {
              "readOnly": true,
              "type": "integer",
              "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
              "format": "int64"
            }
          }
        }
      ]
    },
    "NodeServiceStatusProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "pids": {
              "items": {
                "type": "integer",
                "format": "int64"
              },
              "readOnly": true,
              "type": "array",
              "description": "Service process ids",
              "title": "Service process ids"
            },
            "runtime_state": {
              "readOnly": true,
              "enum": [
                "running",
                "stopped"
              ],
              "type": "string",
              "description": "Service runtime state",
              "title": "Service runtime state"
            },
            "monitor_runtime_state": {
              "readOnly": true,
              "enum": [
                "running",
                "stopped"
              ],
              "type": "string",
              "description": "Service monitor runtime state",
              "title": "Service monitor runtime state"
            },
            "monitor_pid": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Service monitor process id",
              "title": "Service monitor process id"
            }
          },
          "type": "object"
        }
      ],
      "description": "Node service status properties",
      "title": "Node service status properties"
    },
    "InitiateClusterRestoreRequest": {
      "type": "object",
      "properties": {
        "timestamp": {
          "readOnly": true,
          "type": "integer",
          "description": "Timestamp of the backed-up configuration from which\nthe appliance will be restored\n",
          "format": "int64"
        },
        "node_id": {
          "readOnly": true,
          "type": "string",
          "description": "Unique id of the backed-up configuration from which\nthe appliance will be restored\n",
          "title": "Unique id of the backed-up configuration from which\nthe appliance will be restored\n"
        }
      }
    },
    "KnownHostParameter": {
      "required": [
        "host"
      ],
      "type": "object",
      "properties": {
        "host": {
          "pattern": "/^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/",
          "type": "string",
          "description": "Known host hostname or IP address"
        },
        "port": {
          "description": "Known host port",
          "title": "Known host port",
          "default": 22,
          "format": "int64",
          "maximum": 65535,
          "minimum": 1,
          "type": "integer"
        }
      }
    },
    "UpgradeUnitGroupAggregateInfoListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/UpgradeUnitGroupAggregateInfo"
              },
              "readOnly": true,
              "type": "array",
              "description": "Paged collection of upgrade status for upgrade unit groups",
              "title": "Paged collection of upgrade status for upgrade unit groups"
            }
          }
        }
      ]
    },
    "AggregatedLogicalRouterPortCounters": {
      "type": "object",
      "properties": {
        "last_update_timestamp": {
          "readOnly": true,
          "type": "integer",
          "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
          "format": "int64"
        },
        "rx": {
          "readOnly": true,
          "$ref": "#/definitions/LogicalRouterPortCounters"
        },
        "tx": {
          "readOnly": true,
          "$ref": "#/definitions/LogicalRouterPortCounters"
        }
      }
    },
    "DeploymentConfig": {
      "discriminator": "placement_type",
      "required": [
        "placement_type"
      ],
      "type": "object",
      "properties": {
        "placement_type": {
          "enum": [
            "VsphereDeploymentConfig"
          ],
          "type": "string"
        }
      }
    },
    "AwsGatewayInstanceStatus": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "gateway_tn_id": {
              "type": "string",
              "description": "NSX transport node id of the public cloud gateway",
              "title": "NSX transport node id of the public cloud gateway"
            },
            "gateway_ha_index": {
              "format": "int64",
              "type": "integer",
              "description": "Index of HA that indicates whether gateway is primary or secondary.\nIf index is 0, then it is primary gateway. Else secondary gateway.\n",
              "title": "Index of HA that indicates whether gateway is primary or secondary.\nIf index is 0, then it is primary gateway. Else secondary gateway.\n"
            },
            "error_message": {
              "readOnly": true,
              "type": "string",
              "description": "Error message for gateway deployment/undeployment failure",
              "title": "Error message for gateway deployment/undeployment failure"
            },
            "gateway_name": {
              "type": "string",
              "description": "Name of the gateway instance",
              "title": "Name of the gateway instance"
            },
            "gateway_status": {
              "readOnly": true,
              "enum": [
                "UP",
                "DOWN",
                "DEPLOYING",
                "NOT_AVAILABLE",
                "UNDEPLOYING"
              ],
              "type": "string",
              "description": "Gateway instance status",
              "title": "Gateway instance status"
            },
            "gateway_instance_id": {
              "type": "string",
              "description": "ID of the gateway instance",
              "title": "ID of the gateway instance"
            },
            "is_gateway_active": {
              "readOnly": true,
              "type": "boolean",
              "description": "Flag to identify if this is an active gateway",
              "title": "Flag to identify if this is an active gateway"
            },
            "public_ip": {
              "readOnly": true,
              "type": "string",
              "description": "Public IP address of the virtual machine",
              "title": "Public IP address of the virtual machine"
            },
            "deployment_step": {
              "readOnly": true,
              "enum": [
                "CREATING_SECURITY_GROUPS",
                "LAUNCHING_GATEWAY",
                "ATTACHING_NETWORK_INTERFACES",
                "CONFIGURING_GATEWAY",
                "CREATING_LOGICAL_NETWORK_CONSTRUCTS",
                "DEPLOYMENT_SUCCESSFUL",
                "DEPLOYMENT_FAILED",
                "UNCONFIGURING_GATEWAY",
                "RELEASING_EIPS",
                "TERMINATING_GATEWAY",
                "DELETING_SECURITY_GROUPS",
                "UNDEPLOYMENT_SUCCESSFUL",
                "UNDEPLOYMENT_FAILED",
                "NOT_APPLICABLE"
              ],
              "type": "string",
              "description": "Different states of gateway deployment",
              "title": "Different states of gateway deployment"
            },
            "error_code": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Error code for gateway deployment/undeployment failure",
              "title": "Error code for gateway deployment/undeployment failure"
            },
            "private_ip": {
              "readOnly": true,
              "type": "string",
              "description": "Private IP address of the virtual machine",
              "title": "Private IP address of the virtual machine"
            },
            "gateway_node_id": {
              "type": "string",
              "description": "NSX Node ID of the public cloud gateway",
              "title": "NSX Node ID of the public cloud gateway"
            }
          },
          "type": "object"
        }
      ],
      "description": "Aws gateway instance status",
      "title": "Aws gateway instance status"
    },
    "IpfixDfwTemplateParameters": {
      "properties": {
        "source_icmp_type": {
          "default": true,
          "readOnly": true,
          "type": "boolean",
          "description": "Type of the IPv4 ICMP message.\n"
        },
        "icmp_code": {
          "default": true,
          "readOnly": true,
          "type": "boolean",
          "description": "Code of the IPv4 ICMP message.\n"
        },
        "destination_transport_port": {
          "default": true,
          "readOnly": true,
          "type": "boolean",
          "description": "The destination transport port of a monitored network flow.\n"
        },
        "octet_delta_count": {
          "default": true,
          "readOnly": true,
          "type": "boolean",
          "description": "The number of octets since the previous report (if any) in incoming\npackets for this flow at the observation point. The number of octets\ninclude IP header(s) and payload.\n"
        },
        "vif_uuid": {
          "default": true,
          "readOnly": true,
          "type": "boolean",
          "description": "VIF UUID - enterprise specific Information Element that uniquely identifies VIF.\n"
        },
        "protocol_identifier": {
          "default": true,
          "readOnly": true,
          "type": "boolean",
          "description": "The value of the protocol number in the IP packet header.\n"
        },
        "firewall_event": {
          "default": true,
          "readOnly": true,
          "type": "boolean",
          "description": "Five valid values are allowed: 1. Flow Created. 2. Flow Deleted.\n3. Flow Denied. 4. Flow Alert (not used in DropKick implementation).\n5. Flow Update.\n"
        },
        "flow_direction": {
          "default": true,
          "readOnly": true,
          "type": "boolean",
          "description": "Two valid values are allowed: 1. 0x00: igress flow to VM. 2. 0x01:\negress flow from VM.\n"
        },
        "flow_end": {
          "default": true,
          "readOnly": true,
          "type": "boolean",
          "description": "The absolute timestamp (seconds) of the last packet of this flow.\n"
        },
        "source_transport_port": {
          "default": true,
          "readOnly": true,
          "type": "boolean",
          "description": "The source transport port of a monitored network flow.\n"
        },
        "packet_delta_count": {
          "default": true,
          "readOnly": true,
          "type": "boolean",
          "description": "The number of incoming packets since the previous report (if any)\nfor this flow at the observation point.\n"
        },
        "destination_address": {
          "default": true,
          "readOnly": true,
          "type": "boolean",
          "description": "The destination IP address of a monitored network flow.\n"
        },
        "source_address": {
          "default": true,
          "readOnly": true,
          "type": "boolean",
          "description": "The source IP address of a monitored network flow.\n"
        },
        "rule_id": {
          "default": true,
          "readOnly": true,
          "type": "boolean",
          "description": "Firewall rule Id - enterprise specific Information Element that uniquely identifies\nfirewall rule.\n"
        },
        "flow_start": {
          "default": true,
          "readOnly": true,
          "type": "boolean",
          "description": "The absolute timestamp (seconds) of the first packet of this flow.\n"
        }
      },
      "type": "object",
      "description": "This entity represents the flow parameters which are exported.\n",
      "title": "IPFIX DFW Template Parameters"
    },
    "FileThumbprint": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "sha256": {
              "type": "string",
              "description": "File's SHA256 thumbprint",
              "title": "File's SHA256 thumbprint"
            },
            "name": {
              "type": "string",
              "description": "File name",
              "title": "File name"
            },
            "sha1": {
              "type": "string",
              "description": "File's SHA1 thumbprint",
              "title": "File's SHA1 thumbprint"
            }
          },
          "required": [
            "sha256",
            "name",
            "sha1"
          ],
          "type": "object"
        }
      ],
      "description": "File thumbprint",
      "title": "File thumbprint"
    },
    "AppProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "app_profile_category": {
              "type": "string",
              "description": "Category of the app profile, value could be any string that describes the profile",
              "title": "Category of the app profile, value could be any string that describes the profile"
            },
            "default_app_profile": {
              "type": "boolean",
              "description": "True if this App Profile is a default profile (automatically created by the system)",
              "title": "True if this App Profile is a default profile (automatically created by the system)"
            },
            "app_profile_criteria": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "Criteria of the app profile, value could be any string or \"*\"\n(match any string)\n",
              "title": "Criteria of the app profile, value could be any string or \"*\"\n(match any string)\n"
            }
          },
          "required": [
            "app_profile_criteria"
          ],
          "type": "object"
        }
      ],
      "description": "AppProfile details",
      "title": "AppProfile details"
    },
    "ClientSslProfileBinding": {
      "required": [
        "default_certificate_id"
      ],
      "type": "object",
      "properties": {
        "client_auth": {
          "description": "client authentication mode",
          "default": "IGNORE",
          "enum": [
            "REQUIRED",
            "IGNORE"
          ],
          "type": "string"
        },
        "ssl_profile_id": {
          "type": "string",
          "description": "Client SSL profile defines reusable, application-independent client side\nSSL properties.\n",
          "title": "client SSL profile identifier"
        },
        "certificate_chain_depth": {
          "description": "authentication depth is used to set the verification depth in the client\ncertificates chain.\n",
          "format": "int64",
          "default": 3,
          "title": "the maximum traversal depth of client certificate chain",
          "minimum": 1,
          "type": "integer"
        },
        "client_auth_ca_ids": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "If client auth type is REQUIRED, client certificate must be signed by\none of the trusted Certificate Authorities (CAs), also referred to as\nroot CAs, whose self signed certificates are specified.\n",
          "title": "CA identifier list to verify client certificate"
        },
        "default_certificate_id": {
          "type": "string",
          "description": "A default certificate should be specified which will be used if the\nserver does not host multiple hostnames on the same IP address or if\nthe client does not support SNI extension.\n",
          "title": "default service certificate identifier"
        },
        "sni_certificate_ids": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Client-side SSL profile binding allows multiple certificates, for\ndifferent hostnames, to be bound to the same virtual server.\n",
          "title": "SNI certificate identifier list"
        },
        "client_auth_crl_ids": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "A Certificate Revocation List (CRL) can be specified in the client-side\nSSL profile binding to disallow compromised client certificates.\n",
          "title": "CRL identifier list to verify client certificate"
        }
      }
    },
    "ClusterNodeConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "type": "object",
          "properties": {
            "manager_role": {
              "$ref": "#/definitions/ManagementClusterRoleConfig"
            },
            "controller_role": {
              "$ref": "#/definitions/ControllerClusterRoleConfig"
            },
            "external_id": {
              "readOnly": true,
              "type": "string",
              "description": "Internal identifier provided by the node",
              "title": "Internal identifier provided by the node"
            },
            "appliance_mgmt_listen_addr": {
              "readOnly": true,
              "type": "string",
              "description": "The IP and port for the appliance management API service on this node",
              "title": "The IP and port for the appliance management API service on this node"
            }
          }
        }
      ]
    },
    "EffectiveIPAddressMemberListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "format": "address-or-block-or-range",
                "type": "string",
                "description": "IPElement can be a single IP address, IP address range or a Subnet. Its\ntype can be of IPv4 or IPv6. Supported list of formats are 192.168.1.1,\n192.168.1.1-192.168.1.100, 192.168.0.0/24,\nfe80::250:56ff:fe83:318c,\nfe80::250:56ff:fe83:3181-fe80::250:56ff:fe83:318c,\nfe80::250:56ff:fe83:318c/64\n"
              },
              "type": "array",
              "description": "Paged Collection of effective ip addresses for the given NSGroup",
              "title": "Paged Collection of effective ip addresses for the given NSGroup"
            }
          }
        }
      ]
    },
    "TransportNodeStateListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/TransportNodeState"
              },
              "readOnly": true,
              "type": "array",
              "description": "Transport Node State Results",
              "title": "Transport Node State Results"
            }
          },
          "type": "object"
        }
      ],
      "description": "Transport node state queries result",
      "title": "Transport node state queries result"
    },
    "RealizedService": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyRealizedResource"
        },
        {
          "required": [
            "resource_type"
          ],
          "discriminator": "resource_type",
          "type": "object",
          "properties": {
            "resource_type": {
              "enum": [
                "RealizedNSService"
              ],
              "type": "string",
              "description": "Realized services",
              "title": "Realized services"
            }
          }
        }
      ],
      "description": "Realized Service",
      "title": "Realized Service"
    },
    "ServerSslProfileBinding": {
      "type": "object",
      "properties": {
        "server_auth_crl_ids": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "A Certificate Revocation List (CRL) can be specified in the server-side\nSSL profile binding to disallow compromised server certificates.\n",
          "title": "CRL identifier list to verify server certificate"
        },
        "server_auth": {
          "description": "server authentication mode",
          "default": "IGNORE",
          "enum": [
            "REQUIRED",
            "IGNORE"
          ],
          "type": "string"
        },
        "certificate_chain_depth": {
          "description": "authentication depth is used to set the verification depth in the server\ncertificates chain.\n",
          "format": "int64",
          "default": 3,
          "title": "the maximum traversal depth of server certificate chain",
          "minimum": 1,
          "type": "integer"
        },
        "client_certificate_id": {
          "type": "string",
          "description": "To support client authentication (load balancer acting as a client\nauthenticating to the backend server), client certificate can be\nspecified in the server-side SSL profile binding\n",
          "title": "client certificate identifier"
        },
        "server_auth_ca_ids": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "If server auth type is REQUIRED, server certificate must be signed by\none of the trusted Certificate Authorities (CAs), also referred to as\nroot CAs, whose self signed certificates are specified.\n",
          "title": "CA identifier list to verify server certificate"
        },
        "ssl_profile_id": {
          "type": "string",
          "description": "Server SSL profile defines reusable, application-independent server side\nSSL properties.\n",
          "title": "server SSL profile identifier"
        }
      }
    },
    "LogicalPortMacAddressCsvListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/CsvListResult"
        },
        {
          "type": "object",
          "properties": {
            "last_update_timestamp": {
              "readOnly": true,
              "type": "integer",
              "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
              "format": "int64"
            },
            "results": {
              "items": {
                "$ref": "#/definitions/LogicalPortMacTableCsvEntry"
              },
              "type": "array"
            }
          }
        }
      ]
    },
    "FeatureStackCollectionConfigurationList": {
      "properties": {
        "results": {
          "items": {
            "$ref": "#/definitions/FeatureStackCollectionConfiguration"
          },
          "readOnly": true,
          "type": "array",
          "description": "The complete set of feature stack data collection configurations",
          "title": "Feature stack configurations"
        }
      },
      "type": "object",
      "description": "Feature stack collection configuration list result",
      "title": "Feature stack collection configuration list result"
    },
    "LbActiveMonitor": {
      "allOf": [
        {
          "$ref": "#/definitions/LbMonitor"
        },
        {
          "type": "object",
          "properties": {
            "monitor_port": {
              "format": "port-or-range",
              "type": "string",
              "description": "If the monitor port is specified, it would override pool member port\nsetting for healthcheck. A port range is not supported.\n"
            },
            "fall_count": {
              "description": "num of consecutive checks must fail before marking it down",
              "format": "int64",
              "default": 3,
              "title": "num of consecutive checks must fail before marking it down",
              "minimum": 1,
              "type": "integer"
            },
            "interval": {
              "description": "the frequency at which the system issues the monitor check (in second)",
              "format": "int64",
              "default": 5,
              "title": "the frequency at which the system issues the monitor check (in second)",
              "minimum": 1,
              "type": "integer"
            },
            "rise_count": {
              "description": "num of consecutive checks must pass before marking it up",
              "format": "int64",
              "default": 3,
              "title": "num of consecutive checks must pass before marking it up",
              "minimum": 1,
              "type": "integer"
            },
            "timeout": {
              "description": "the number of seconds the target has in which to respond to the monitor\nrequest\n",
              "format": "int64",
              "default": 15,
              "title": "the number of seconds the target has in which to respond to the monitor\nrequest\n",
              "minimum": 1,
              "type": "integer"
            }
          }
        }
      ]
    },
    "FieldsPacketData": {
      "allOf": [
        {
          "$ref": "#/definitions/PacketData"
        },
        {
          "type": "object",
          "properties": {
            "ip_header": {
              "title": "The IPv4 header.",
              "description": "The IPv4 header.",
              "$ref": "#/definitions/Ipv4Header"
            },
            "eth_header": {
              "title": "The ethernet header",
              "description": "The ethernet header",
              "$ref": "#/definitions/EthernetHeader"
            },
            "transport_header": {
              "title": "The transport header",
              "description": "This field contains a protocol that is above IP. It is not restricted to the 'transport' defined by the OSI model (e.g., ICMP is supported).",
              "$ref": "#/definitions/TransportProtocolHeader"
            },
            "payload": {
              "maxLength": 1336,
              "type": "string",
              "description": "Up to 1000 bytes of payload may be supplied (with a base64-encoded length of 1336 bytes.) Additional bytes of traceflow metadata will be appended to the payload. The payload contains any data the user wants to put after the transport header.",
              "title": "RFC3548 compatible base64-encoded payload"
            }
          }
        }
      ]
    },
    "VirtualMachineTagUpdate": {
      "required": [
        "external_id",
        "tags"
      ],
      "type": "object",
      "properties": {
        "external_id": {
          "type": "string",
          "description": "External id of the virtual machine to which tags are to be applied",
          "title": "External id of the virtual machine to which tags are to be applied"
        },
        "tags": {
          "items": {
            "$ref": "#/definitions/Tag"
          },
          "type": "array",
          "description": "List of tags to be applied to the virtual machine",
          "title": "List of tags to be applied to the virtual machine"
        }
      }
    },
    "LogicalPortStatusSummary": {
      "required": [
        "total_ports",
        "up_ports"
      ],
      "type": "object",
      "properties": {
        "total_ports": {
          "format": "int64",
          "type": "integer",
          "description": "The total number of logical ports.",
          "title": "The total number of logical ports."
        },
        "last_update_timestamp": {
          "readOnly": true,
          "type": "integer",
          "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
          "format": "int64"
        },
        "up_ports": {
          "format": "int64",
          "type": "integer",
          "description": "The number of logical ports whose Operational status is UP",
          "title": "The number of logical ports whose Operational status is UP"
        },
        "filters": {
          "items": {
            "$ref": "#/definitions/Filter"
          },
          "type": "array",
          "description": "The filters used to find the logical ports- TransportZone id, LogicalSwitch id or LogicalSwitchProfile id",
          "title": "The filters used to find the logical ports- TransportZone id, LogicalSwitch id or LogicalSwitchProfile id"
        }
      }
    },
    "PolicyTemplateParameters": {
      "properties": {
        "placeholders": {
          "items": {
            "$ref": "#/definitions/PolicyTemplateParameter"
          },
          "type": "array",
          "description": "List of Policy template parameter",
          "title": "List of Policy template parameter"
        }
      },
      "required": [
        "placeholders"
      ],
      "type": "object",
      "description": "Policy template parameters",
      "title": "Policy template parameters"
    },
    "PasswordAuthenticationScheme": {
      "allOf": [
        {
          "$ref": "#/definitions/AuthenticationScheme"
        },
        {
          "required": [
            "username",
            "scheme_name",
            "password"
          ],
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "description": "User name to authenticate with",
              "title": "User name to authenticate with"
            },
            "scheme_name": {
              "enum": [
                "password"
              ],
              "type": "string",
              "description": "Authentication scheme name",
              "title": "Authentication scheme name"
            },
            "password": {
              "type": "string",
              "description": "Password to authenticate with",
              "title": "Password to authenticate with"
            }
          }
        }
      ]
    },
    "LbSnatAutoMap": {
      "allOf": [
        {
          "$ref": "#/definitions/LbSnatTranslation"
        },
        {
          "type": "object"
        }
      ]
    },
    "TransportZone": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "transport_type"
          ],
          "type": "object",
          "properties": {
            "host_switch_name": {
              "default": "nsxDefaultHostSwitch",
              "type": "string",
              "description": "If this name is unset or empty then the default host switch name will be used.",
              "title": "Name of the host switch on all transport nodes in this transport zone that will be used to run NSX network traffic."
            },
            "host_switch_mode": {
              "description": "STANDARD mode applies to all the hypervisors. ENS mode stands for Enhanced Networking Stack. This feature is only available for ESX hypervisor. It is not available on KVM, EDGE and Public Cloud Gateway etc. When a Transport Zone mode is set to ENS, only Transport Nodes of type ESX can participate in such a Transport Zone.",
              "title": "Operational mode of Transport Zone.",
              "default": "STANDARD",
              "enum": [
                "STANDARD",
                "ENS"
              ],
              "readOnly": false,
              "type": "string"
            },
            "transport_type": {
              "type": "string",
              "description": "The transport type of this transport zone.",
              "enum": [
                "OVERLAY",
                "VLAN"
              ]
            },
            "nested_nsx": {
              "default": false,
              "type": "boolean",
              "description": "The flag only need to be set in nested NSX environment.",
              "title": "Flag to indicate if transport nodes in this transport zone are connected through nested NSX."
            },
            "transport_zone_profile_ids": {
              "items": {
                "$ref": "#/definitions/TransportZoneProfileTypeIdEntry"
              },
              "type": "array",
              "description": "Identifiers of the transport zone profiles associated with this TransportZone.",
              "title": "Identifiers of the transport zone profiles associated with this TransportZone."
            }
          }
        }
      ]
    },
    "PortMirroringSession": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "direction",
            "mirror_sources",
            "mirror_destination"
          ],
          "type": "object",
          "properties": {
            "direction": {
              "type": "string",
              "description": "Port mirroring session direction",
              "enum": [
                "INGRESS",
                "EGRESS",
                "BIDIRECTIONAL"
              ]
            },
            "encapsulation_vlan_id": {
              "type": "integer",
              "description": "Only for Remote SPAN Port Mirror.",
              "format": "int64"
            },
            "snap_length": {
              "description": "If this property is unset, entire package will be mirrored",
              "format": "int64",
              "title": "Max package length for package truncation",
              "maximum": 65535,
              "minimum": 60,
              "type": "integer"
            },
            "mirror_sources": {
              "description": "Mirror sources",
              "title": "Mirror sources",
              "minItems": 1,
              "items": {
                "$ref": "#/definitions/MirrorSource"
              },
              "maxItems": 6,
              "type": "array"
            },
            "preserve_original_vlan": {
              "default": false,
              "type": "boolean",
              "description": "Only for Remote SPAN Port Mirror. Whether to preserve original VLAN.",
              "title": "Only for Remote SPAN Port Mirror. Whether to preserve original VLAN."
            },
            "mirror_destination": {
              "title": "Mirror destination",
              "description": "Mirror destination",
              "$ref": "#/definitions/MirrorDestination"
            }
          }
        }
      ]
    },
    "PnicMirrorSource": {
      "allOf": [
        {
          "$ref": "#/definitions/MirrorSource"
        },
        {
          "required": [
            "node_id",
            "encapsulated",
            "source_pnics"
          ],
          "type": "object",
          "properties": {
            "node_id": {
              "type": "string",
              "description": "Transport node identifier for the pnic located.",
              "title": "Transport node identifier for the pnic located."
            },
            "encapsulated": {
              "default": false,
              "type": "boolean",
              "description": "Whether to filter encapsulated packet.",
              "title": "Whether to filter encapsulated packet."
            },
            "source_pnics": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "Source physical NIC device names",
              "title": "Source physical NIC device names"
            }
          }
        }
      ]
    },
    "EdgeClusterMemberListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/EdgeClusterMember"
              },
              "type": "array",
              "description": "edge cluster member list results",
              "title": "edge cluster member list results"
            }
          }
        }
      ]
    },
    "LbPoolStatusListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LbPoolStatus"
              },
              "type": "array",
              "description": "paginated status list of pools",
              "title": "paginated status list of pools"
            }
          }
        }
      ]
    },
    "VidmInfo": {
      "properties": {
        "display_name": {
          "readOnly": true,
          "type": "string",
          "description": "User's Full Name Or User Group's Display Name",
          "title": "User's Full Name Or User Group's Display Name"
        },
        "type": {
          "readOnly": true,
          "enum": [
            "remote_user",
            "remote_group"
          ],
          "type": "string",
          "description": "Type",
          "title": "Type"
        },
        "name": {
          "readOnly": true,
          "type": "string",
          "description": "Username Or Groupname",
          "title": "Username Or Groupname"
        }
      },
      "type": "object",
      "description": "Vidm Info",
      "title": "Vidm Info"
    },
    "PortMirroringSwitchingProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/BaseSwitchingProfile"
        },
        {
          "type": "object",
          "properties": {
            "snap_length": {
              "description": "If this property not set, original package will not be truncated.",
              "format": "int64",
              "title": "Snap length for package truncation",
              "maximum": 65535,
              "minimum": 60,
              "type": "integer"
            },
            "direction": {
              "enum": [
                "INGRESS",
                "EGRESS",
                "BIDIRECTIONAL"
              ],
              "type": "string",
              "description": "port mirroring direction"
            },
            "key": {
              "format": "int64",
              "type": "integer",
              "description": "User-configurable 32-bit key",
              "title": "User-configurable 32-bit key"
            },
            "destinations": {
              "items": {
                "format": "ip",
                "type": "string",
                "description": "IPv4 or IPv6 address"
              },
              "type": "array",
              "description": "List of destination addresses",
              "maxItems": 3,
              "title": "List of destination addresses"
            }
          }
        }
      ]
    },
    "GlobalCollectionConfiguration": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "is_data_collection_enabled",
            "aggregated_data_collection_frequency"
          ],
          "type": "object",
          "properties": {
            "modified_feature_stack_collection_configurations": {
              "readOnly": true,
              "title": "Modified feature stack collection configurations",
              "description": "The list of the locally modified feature stack data collection frequency settings.  If all feature stack data collection configurations are set to their default values, this list will be empty.",
              "$ref": "#/definitions/FeatureStackCollectionConfigurationList"
            },
            "is_data_collection_enabled": {
              "type": "boolean",
              "description": "Indicates whether data collection required by the aggregation service is enabled.  If false, no aggregation service data will be collected.  Changing this property will not affect the existing data collection frequency settings.",
              "title": "Is data collection enabled"
            },
            "aggregated_data_collection_frequency": {
              "description": "The frequency in seconds at which data, which is subject to the aggregation function, is collected.",
              "format": "int64",
              "title": "Aggregated Data Collection Frequency In Seconds",
              "maximum": 86400,
              "minimum": 10,
              "type": "integer"
            }
          }
        }
      ]
    },
    "DneKeyPolicy": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "encrypt_type",
            "encrypt_algorithm",
            "mac_algorithm"
          ],
          "type": "object",
          "properties": {
            "is_default": {
              "default": false,
              "readOnly": false,
              "type": "boolean",
              "description": "It is a boolean flag which reflects whether a DNE key policy is default or not.",
              "title": "Default DNE key policy flag"
            },
            "encrypt_algorithm": {
              "enum": [
                "ENC_NULL",
                "ENC_AES_GCM_128"
              ],
              "type": "string",
              "description": "DNE key encryption algorithm",
              "title": "DNE key encryption algorithm"
            },
            "mac_algorithm": {
              "enum": [
                "MAC_ALG_AES_GCM_128"
              ],
              "type": "string",
              "description": "MAC algorithm type",
              "title": "MAC algorithm type"
            },
            "type": {
              "description": "key policy type",
              "title": "key policy type",
              "default": "REGULAR",
              "enum": [
                "REGULAR",
                "BUM_TRAFFIC"
              ],
              "readOnly": true,
              "type": "string"
            },
            "encrypt_type": {
              "enum": [
                "INTEGRITY_ONLY",
                "ENCRYPTION_AND_INTEGRITY"
              ],
              "type": "string",
              "description": "Key policy encryption type",
              "title": "Key policy encryption type"
            },
            "rekey_frequency": {
              "description": "Frequency of key policy rekey (in seconds). Default 30 days, minimum 1 day, maximum 10000 days.",
              "title": "Key policy rekey frequency",
              "default": 2592000,
              "format": "int64",
              "maximum": 864000000,
              "minimum": 86400,
              "type": "integer"
            },
            "notes": {
              "readOnly": false,
              "maxLength": 2048,
              "type": "string",
              "description": "User notes specific to the key policy.",
              "title": "Key Policy Notes"
            },
            "is_sys_default": {
              "readOnly": true,
              "type": "boolean",
              "description": "It is a boolean flag which reflects whether a DNE key policy is system default or not. System default key policies are created while dne system is booting up. User can't change the value of the system default flag. User created key policy always has system default flag set to false, however a user can change default flag (not the system default) value from false to true of any key policy, but not from true to false (when setting a key policy as default, the current default key policy is automatically unset).",
              "title": "System Default DNE key policy flag"
            }
          }
        }
      ]
    },
    "NodeNtpServiceProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/NodeServiceProperties"
        },
        {
          "properties": {
            "service_properties": {
              "title": "NTP Service properties",
              "description": "NTP Service properties",
              "$ref": "#/definitions/NtpServiceProperties"
            }
          },
          "type": "object"
        }
      ],
      "description": "Node NTP service properties",
      "title": "Node NTP service properties"
    },
    "MetadataProxyStatistics": {
      "required": [
        "timestamp",
        "metadata_proxy_id"
      ],
      "type": "object",
      "properties": {
        "timestamp": {
          "type": "integer",
          "description": "timestamp of the statistics",
          "format": "int64"
        },
        "statistics": {
          "items": {
            "$ref": "#/definitions/MetadataProxyStatisticsPerLogicalSwitch"
          },
          "type": "array",
          "description": "metadata proxy statistics per logical switch",
          "title": "metadata proxy statistics per logical switch"
        },
        "metadata_proxy_id": {
          "type": "string",
          "description": "metadata proxy uuid",
          "title": "metadata proxy uuid"
        }
      }
    },
    "UpdatePolicyUIPreferencesRequestParams": {
      "required": [
        "path"
      ],
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "Specifies the entity for which the UI preferences have\nto be updated.\n",
          "title": "Specifies the entity for which the UI preferences have\nto be updated.\n"
        }
      }
    },
    "TraceflowObservationDelivered": {
      "allOf": [
        {
          "$ref": "#/definitions/TraceflowObservation"
        },
        {
          "type": "object",
          "properties": {
            "lport_name": {
              "readOnly": true,
              "type": "string",
              "description": "The name of the logical port into which the traceflow packet was delivered",
              "title": "The name of the logical port into which the traceflow packet was delivered"
            },
            "vlan_id": {
              "type": "integer",
              "description": "VLAN on bridged network",
              "format": "int64"
            },
            "lport_id": {
              "readOnly": true,
              "type": "string",
              "description": "The id of the logical port into which the traceflow packet was delivered",
              "title": "The id of the logical port into which the traceflow packet was delivered"
            }
          }
        }
      ]
    },
    "BgpConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "type": "object",
          "properties": {
            "as_number": {
              "description": "This is a deprecated property, Please use 'as_num' instead.",
              "title": "Autonomous System Number",
              "format": "int64",
              "maximum": 4294967296,
              "x-deprecated": true,
              "minimum": 1,
              "type": "integer"
            },
            "logical_router_id": {
              "readOnly": true,
              "type": "string",
              "description": "Logical router id",
              "title": "Logical router id"
            },
            "graceful_restart": {
              "default": false,
              "type": "boolean",
              "description": "Flag to enable graceful restart",
              "title": "Flag to enable graceful restart"
            },
            "as_num": {
              "type": "string",
              "description": "4 Byte ASN in ASPLAIN/ASDOT Format",
              "title": "4 Byte ASN in ASPLAIN/ASDOT Format"
            },
            "enabled": {
              "default": false,
              "type": "boolean",
              "description": "Flag to enable this configuration",
              "title": "Flag to enable this configuration"
            },
            "route_aggregation": {
              "description": "List of routes to be aggregated",
              "title": "List of routes to be aggregated",
              "minItems": 0,
              "items": {
                "$ref": "#/definitions/BgpRouteAggregation"
              },
              "maxItems": 1000,
              "type": "array"
            },
            "ecmp": {
              "default": true,
              "type": "boolean",
              "description": "Flag to enable ECMP",
              "title": "Flag to enable ECMP"
            }
          }
        }
      ]
    },
    "LogicalSwitchStateListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LogicalSwitchState"
              },
              "readOnly": true,
              "type": "array",
              "description": "Logical Switch State Results",
              "title": "Logical Switch State Results"
            }
          },
          "type": "object"
        }
      ],
      "description": "Logical Switch state queries result",
      "title": "Logical Switch state queries result"
    },
    "ApplianceFileUsage": {
      "required": [
        "files",
        "type",
        "build"
      ],
      "type": "object",
      "properties": {
        "files": {
          "items": {
            "$ref": "#/definitions/File"
          },
          "type": "array",
          "description": "list of files",
          "title": "File List"
        },
        "type": {
          "type": "string",
          "description": "Appliance type",
          "title": "Appliance type"
        },
        "build": {
          "type": "string",
          "description": "Appliance build number",
          "title": "Appliance build number"
        }
      }
    },
    "BridgeClusterNode": {
      "properties": {
        "ha_mac": {
          "description": "MAC address used for HA protocol",
          "pattern": "/^(([0-9A-Fa-f]{2}[:]){5}([0-9A-Fa-f]{2}))|(([0-9A-Fa-f]{2}[-]){5}([0-9A-Fa-f]{2}))$/",
          "readOnly": true,
          "type": "string"
        },
        "transport_node_id": {
          "maxLength": 36,
          "type": "string",
          "description": "UUID of the transport node",
          "title": "UUID of the transport node"
        }
      },
      "required": [
        "transport_node_id"
      ],
      "type": "object",
      "description": "Bridge transport node",
      "title": "Bridge transport node"
    },
    "TransportNodeTemplateListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/ComputeCollectionTransportNodeTemplate"
              },
              "readOnly": true,
              "type": "array",
              "description": "Compute collection transport node template results",
              "title": "Compute collection transport node template results"
            }
          },
          "type": "object"
        }
      ],
      "description": "Compute collection transport node template list result",
      "title": "Compute collection transport node template list result"
    },
    "ICMPTypeServiceEntry": {
      "allOf": [
        {
          "$ref": "#/definitions/ServiceEntry"
        },
        {
          "properties": {
            "icmp_code": {
              "format": "int64",
              "type": "integer",
              "description": "ICMP message code",
              "title": "ICMP message code"
            },
            "icmp_type": {
              "format": "int64",
              "type": "integer",
              "description": "ICMP message type",
              "title": "ICMP message type"
            },
            "protocol": {
              "enum": [
                "ICMPv4",
                "ICMPv6"
              ],
              "type": "string"
            }
          },
          "required": [
            "protocol"
          ],
          "type": "object"
        }
      ],
      "description": "A ServiceEntry that represents IPv4 or IPv6 ICMP protocol",
      "title": "A ServiceEntry that represents IPv4 or IPv6 ICMP protocol"
    },
    "LbUdpMonitor": {
      "allOf": [
        {
          "$ref": "#/definitions/LbActiveMonitor"
        },
        {
          "required": [
            "receive",
            "send"
          ],
          "type": "object",
          "properties": {
            "receive": {
              "type": "string",
              "description": "Expected data, can be anywhere in the response and it has to be a\nstring, regular expressions are not supported.\nUDP healthcheck is considered failed if there is no server response\nwithin the timeout period.\n",
              "title": "expected data received from server"
            },
            "send": {
              "type": "string",
              "description": "The data to be sent to the monitored server.\n",
              "title": "data to send"
            }
          }
        }
      ]
    },
    "DhcpStaticBinding": {
      "allOf": [
        {
          "$ref": "#/definitions/IpAllocationBase"
        },
        {
          "required": [
            "ip_address",
            "mac_address"
          ],
          "type": "object",
          "properties": {
            "ip_address": {
              "format": "ip",
              "type": "string",
              "description": "ip addres"
            },
            "host_name": {
              "format": "hostname",
              "type": "string",
              "description": "host name",
              "title": "host name"
            },
            "mac_address": {
              "pattern": "/^(([0-9A-Fa-f]{2}[:]){5}([0-9A-Fa-f]{2}))|(([0-9A-Fa-f]{2}[-]){5}([0-9A-Fa-f]{2}))$/",
              "type": "string",
              "description": "mac address"
            }
          }
        }
      ]
    },
    "LogicalPortMacTableCsvEntry": {
      "allOf": [
        {
          "$ref": "#/definitions/CsvRecord"
        },
        {
          "required": [
            "mac_type",
            "mac_address"
          ],
          "type": "object",
          "properties": {
            "mac_type": {
              "type": "string",
              "description": "The type of the MAC address",
              "enum": [
                "STATIC",
                "LEARNED"
              ]
            },
            "mac_address": {
              "type": "string",
              "description": "The MAC address",
              "title": "The MAC address"
            }
          }
        }
      ]
    },
    "AwsAccountsListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "all_accounts_vpc_stats": {
              "readOnly": true,
              "title": "VPC statistics",
              "description": "Vpc statistics accross all accounts managed by CSM",
              "$ref": "#/definitions/VpcStats"
            },
            "all_accounts_instance_stats": {
              "readOnly": true,
              "title": "Instance statistics",
              "description": "Instance statistics accross all accounts managed by CSM",
              "$ref": "#/definitions/InstanceStats"
            },
            "results": {
              "items": {
                "$ref": "#/definitions/AwsAccount"
              },
              "type": "array",
              "description": "AWS accounts list result",
              "title": "AWS accounts list result"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Cloud accounts list",
      "title": "Cloud accounts list"
    },
    "CopyToRemoteFileProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/CopyRemoteFileProperties"
        },
        {
          "required": [
            "protocol"
          ],
          "type": "object",
          "properties": {
            "protocol": {
              "description": "Protocol to use to copy file",
              "title": "Protocol to use to copy file"
            }
          }
        }
      ]
    },
    "LbHttpRedirectAction": {
      "allOf": [
        {
          "$ref": "#/definitions/LbRuleAction"
        },
        {
          "properties": {
            "redirect_status": {
              "type": "string",
              "description": "HTTP response status code",
              "title": "HTTP response status code"
            },
            "redirect_url": {
              "type": "string",
              "description": "The URL that the HTTP request is redirected to",
              "title": "The URL that the HTTP request is redirected to"
            }
          },
          "required": [
            "redirect_status",
            "redirect_url"
          ],
          "type": "object"
        }
      ],
      "description": "This action is used to redirect HTTP request messages to a new URL. The\nreply_status value specified in this action is used as the status code of\nHTTP response message which is sent back to client (Normally a browser).\nThe HTTP status code for redirection is 3xx, for example, 301, 302, 303,\n307, etc. The redirect_url is the new URL that the HTTP request message is\nredirected to. Normally browser will send another HTTP request to the new\nURL after receiving a redirection response message.\nCaptured variables and built-in variables can be used in redirect_url field.\nFor example, to redirect all HTTP requests to HTTPS requests for a virtual\nserver. We create an LbRule without any conditions, add an\nLbHttpRedirectAction to the rule. Set the\nredirect_url field of the LbHttpRedirectAction to:\n  https://$_host$_request_uri\nAnd set redirect_status to \"302\", which means found. This rule will\nredirect all HTTP requests to HTTPS server port on the same host.\n",
      "title": "Action to redirect HTTP request messages"
    },
    "LogicalRouterUpLinkPort": {
      "allOf": [
        {
          "$ref": "#/definitions/LogicalRouterPort"
        },
        {
          "required": [
            "subnets",
            "edge_cluster_member_index"
          ],
          "type": "object",
          "properties": {
            "subnets": {
              "description": "Logical router port subnets",
              "title": "Logical router port subnets",
              "minItems": 1,
              "items": {
                "$ref": "#/definitions/IPSubnet"
              },
              "maxItems": 1,
              "type": "array"
            },
            "urpf_mode": {
              "description": "Unicast Reverse Path Forwarding mode",
              "default": "STRICT",
              "enum": [
                "NONE",
                "STRICT"
              ],
              "type": "string"
            },
            "linked_logical_switch_port_id": {
              "title": "Reference to the logical switch port to connect to",
              "description": "Reference to the logical switch port to connect to",
              "$ref": "#/definitions/ResourceReference"
            },
            "edge_cluster_member_index": {
              "items": {
                "type": "integer",
                "format": "int64"
              },
              "type": "array",
              "description": "Member index of the edge node on the cluster",
              "title": "Member index of the edge node on the cluster"
            }
          }
        }
      ]
    },
    "IPSetListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/IPSet"
              },
              "type": "array",
              "description": "IPSet list results",
              "title": "IPSet list results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Paged collection of IPSets",
      "title": "Paged collection of IPSets"
    },
    "DataTypeCollectionConfiguration": {
      "properties": {
        "collection_frequency": {
          "description": "The frequency in seconds at which data is collected",
          "format": "int64",
          "title": "Data Collection Frequency In Seconds",
          "maximum": 86400,
          "minimum": 1,
          "type": "integer"
        },
        "data_type": {
          "enum": [
            "STATUS",
            "STATISTICS"
          ],
          "type": "string",
          "description": "Defines the type of data being collected",
          "title": "Data type"
        }
      },
      "required": [
        "collection_frequency",
        "data_type"
      ],
      "type": "object",
      "description": "Data type collection configuration",
      "title": "Data type collection configuration"
    },
    "AppInfo": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "version": {
              "type": "string",
              "description": "Version of the app",
              "title": "Version of the app"
            },
            "name": {
              "type": "string",
              "description": "Name of the app",
              "title": "Name of the app"
            },
            "vm_ids": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "Ids of the VMs in which this app is installed",
              "title": "Ids of the VMs in which this app is installed"
            },
            "manufacturer": {
              "type": "string",
              "description": "Manufacturer of the app",
              "title": "Manufacturer of the app"
            }
          },
          "type": "object"
        }
      ],
      "description": "AppInfo details",
      "title": "AppInfo details"
    },
    "StatusCount": {
      "type": "object",
      "properties": {
        "status": {
          "enum": [
            "UP",
            "DOWN",
            "DEGRADED",
            "UNKNOWN"
          ],
          "type": "string",
          "description": "Roll-up status",
          "title": "Roll-up status"
        },
        "degraded_count": {
          "format": "int32",
          "type": "integer",
          "description": "Degraded count",
          "title": "Degraded count"
        },
        "down_count": {
          "format": "int32",
          "type": "integer",
          "description": "Down count",
          "title": "Down count"
        },
        "up_count": {
          "format": "int32",
          "type": "integer",
          "description": "Up count",
          "title": "Up count"
        }
      }
    },
    "AppProfileListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/AppProfile"
              },
              "type": "array",
              "description": "AppProfile IDs",
              "title": "AppProfile IDs"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "App Profile ID list",
      "title": "App Profile ID list"
    },
    "X509Certificate": {
      "type": "object",
      "properties": {
        "rsa_public_key_modulus": {
          "readOnly": true,
          "type": "string",
          "description": "An RSA public key is made up of the modulus and the public exponent. Modulus is wrap around number"
        },
        "dsa_public_key_y": {
          "readOnly": true,
          "type": "string",
          "description": "One of the DSA cryptogaphic algorithm's strength parameters"
        },
        "is_ca": {
          "readOnly": true,
          "type": "boolean",
          "description": "True if this is a CA certificate"
        },
        "issuer": {
          "readOnly": true,
          "type": "string",
          "description": "the certificate issuers complete distinguished name"
        },
        "not_after": {
          "readOnly": true,
          "type": "integer",
          "description": "the time in epoch milliseconds at which the certificate becomes invalid",
          "format": "int64"
        },
        "signature": {
          "readOnly": true,
          "type": "string",
          "description": "the signature value(the raw signature bits) used for signing and validate the cert"
        },
        "dsa_public_key_q": {
          "readOnly": true,
          "type": "string",
          "description": "One of the DSA cryptogaphic algorithm's strength parameters, sub-prime"
        },
        "dsa_public_key_p": {
          "readOnly": true,
          "type": "string",
          "description": "One of the DSA cryptogaphic algorithm's strength parameters, prime"
        },
        "rsa_public_key_exponent": {
          "readOnly": true,
          "type": "string",
          "description": "An RSA public key is made up of the modulus and the public exponent. Exponent is a power number"
        },
        "public_key_algo": {
          "readOnly": true,
          "enum": [
            "RSA",
            "DSA"
          ],
          "type": "string",
          "description": "Cryptographic algorithm used by the public key for data encryption"
        },
        "is_valid": {
          "readOnly": true,
          "type": "boolean",
          "description": "True if this certificate is valid"
        },
        "issuer_cn": {
          "readOnly": true,
          "type": "string",
          "description": "the certificate issuer's common name"
        },
        "version": {
          "readOnly": true,
          "type": "string",
          "description": "Certificate version (default v1)"
        },
        "subject_cn": {
          "readOnly": true,
          "type": "string",
          "description": "the certificate owner's common name"
        },
        "signature_algorithm": {
          "readOnly": true,
          "type": "string",
          "description": "the algorithm used by the Certificate Authority to sign the certificate"
        },
        "serial_number": {
          "readOnly": true,
          "type": "string",
          "description": "certificate's serial number"
        },
        "dsa_public_key_g": {
          "readOnly": true,
          "type": "string",
          "description": "One of the DSA cryptogaphic algorithm's strength parameters, base"
        },
        "public_key_length": {
          "readOnly": true,
          "type": "integer",
          "description": "size measured in bits of the public/private keys used in a cryptographic algorithm",
          "format": "int64"
        },
        "not_before": {
          "readOnly": true,
          "type": "integer",
          "description": "the time in epoch milliseconds at which the certificate becomes valid",
          "format": "int64"
        },
        "subject": {
          "readOnly": true,
          "type": "string",
          "description": "the certificate owners complete distinguished name"
        }
      }
    },
    "FeatureStackCollectionConfiguration": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "feature_stack_name": {
              "type": "string",
              "description": "The name of the feature stack",
              "title": "Feature stack name"
            },
            "client_type_collection_configurations": {
              "items": {
                "$ref": "#/definitions/ClientTypeCollectionConfiguration"
              },
              "type": "array",
              "description": "The set of client type data collection configurations",
              "title": "Client type collection configurations"
            }
          },
          "required": [
            "feature_stack_name"
          ],
          "type": "object"
        }
      ],
      "description": "HPM feature stack data collection frequency configuration",
      "title": "HPM feature stack data collection frequency configuration"
    },
    "LbSelectPoolAction": {
      "allOf": [
        {
          "$ref": "#/definitions/LbRuleAction"
        },
        {
          "properties": {
            "pool_id": {
              "type": "string",
              "description": "UUID of load balancer pool",
              "title": "UUID of load balancer pool"
            }
          },
          "required": [
            "pool_id"
          ],
          "type": "object"
        }
      ],
      "description": "This action is used to select a pool for matched HTTP request messages. The\npool is specified by UUID. The matched HTTP request messages are forwarded\nto the specified pool.\n",
      "title": "Action to select a pool for HTTP request messages"
    },
    "ControllerClusterStatus": {
      "type": "object",
      "properties": {
        "status": {
          "readOnly": true,
          "enum": [
            "UNSTABLE",
            "STABLE"
          ],
          "type": "string",
          "description": "The current status of the controller cluster",
          "title": "The current status of the controller cluster"
        }
      }
    },
    "LogicalRouterLinkPortOnTIER0": {
      "allOf": [
        {
          "$ref": "#/definitions/LogicalRouterPort"
        },
        {
          "properties": {
            "subnets": {
              "items": {
                "$ref": "#/definitions/IPSubnet"
              },
              "readOnly": true,
              "type": "array",
              "description": "Logical router port subnets",
              "title": "Logical router port subnets"
            },
            "linked_logical_router_port_id": {
              "readOnly": true,
              "type": "string",
              "description": "Identifier of connected LogicalRouterLinkPortOnTIER1 of TIER1 logical router",
              "title": "Identifier of connected LogicalRouterLinkPortOnTIER1"
            }
          },
          "type": "object"
        }
      ],
      "description": "This port can be configured only on a TIER0 LogicalRouter.\nCreate an empty port to generate an id.\nUse this id in the linked_logical_router_port_id on\nLogicalRouterLinkPortOnTIER1 on TIER1 logical router.\n",
      "title": "Port to connect the LogicalRouterLinkPortOnTIER1 of TIER1 logical router to"
    },
    "LogicalRouterLinkPortOnTIER1": {
      "allOf": [
        {
          "$ref": "#/definitions/LogicalRouterPort"
        },
        {
          "properties": {
            "subnets": {
              "items": {
                "$ref": "#/definitions/IPSubnet"
              },
              "readOnly": true,
              "type": "array",
              "description": "Logical router port subnets",
              "title": "Logical router port subnets"
            },
            "linked_logical_router_port_id": {
              "title": "Reference of TIER0 port to connect the TIER1 to.",
              "description": "Reference of LogicalRouterLinkPortOnTIER0 of TIER0 logical router to connect this TIER1 logical router outwards.\n",
              "$ref": "#/definitions/ResourceReference"
            },
            "edge_cluster_member_index": {
              "items": {
                "type": "integer",
                "format": "int64"
              },
              "type": "array",
              "description": "Member index of the edge node on the cluster",
              "title": "Member index of the edge node on the cluster"
            }
          },
          "type": "object"
        }
      ],
      "description": "This port can be configured only on a TIER1 LogicalRouter.\nUse the id of the LogicalRouterLinkPortOnTIER0 from TIER0 logical router to set\nthe linked_logical_router_port_id on the port on TIER1 logical router.\n",
      "title": "Port to connect the TIER1 logical router to TIER0 logical router"
    },
    "ComputeCollectionTransportNodeTemplate": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "host_switch_spec": {
              "title": "Transport node host switch specification",
              "description": "Property 'host_switch_spec' can be used to create either standard host switch or preconfigured host switch.",
              "$ref": "#/definitions/HostSwitchSpec"
            },
            "transport_zone_endpoints": {
              "items": {
                "$ref": "#/definitions/TransportZoneEndPoint"
              },
              "type": "array",
              "description": "Transport zone endpoints",
              "title": "Transport zone endpoints"
            },
            "compute_collection_ids": {
              "description": "Associated compute collection ids",
              "title": "Associated compute collection ids",
              "minItems": 1,
              "items": {
                "type": "string",
                "title": "Compute collection id"
              },
              "maxItems": 1,
              "type": "array"
            }
          },
          "required": [
            "compute_collection_ids"
          ],
          "type": "object"
        }
      ],
      "description": "Compute collection transport node template",
      "title": "Compute collection transport node template"
    },
    "ClusterStatus": {
      "type": "object",
      "properties": {
        "mgmt_cluster_status": {
          "readOnly": true,
          "title": "The current status of the management cluster",
          "description": "The current status of the management cluster",
          "$ref": "#/definitions/ManagementClusterStatus"
        },
        "control_cluster_status": {
          "readOnly": true,
          "title": "The current status of the control cluster",
          "description": "The current status of the control cluster",
          "$ref": "#/definitions/ControllerClusterStatus"
        }
      }
    },
    "TransportNode": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "host_switches": {
              "items": {
                "$ref": "#/definitions/HostSwitch"
              },
              "type": "array",
              "description": "This property is deprecated in favor of 'host_switch_spec'. Property 'host_switches' can only be used for NSX managed transport nodes. 'host_switch_spec' can be used for both NSX managed or manually preconfigured host switches.",
              "x-deprecated": true,
              "title": "Transport Node switch(s). Prefer host_switch_spec over this."
            },
            "host_switch_spec": {
              "title": "Transport node host switch specification",
              "description": "This property is used to either create standard host switches\nor to inform NSX about preconfigured host switches that already\nexist on the transport node.\n\nPass an array of either StandardHostSwitchSpec objects or\nPreconfiguredHostSwitchSpec objects. It is an error to pass\nan array containing different types of HostSwitchSpec objects.\n",
              "$ref": "#/definitions/HostSwitchSpec"
            },
            "node_id": {
              "type": "string",
              "description": "Unique Id of the fabric node",
              "title": "Unique Id of the fabric node"
            },
            "maintenance_mode": {
              "readOnly": true,
              "enum": [
                "ENABLED",
                "FORCE_ENABLED",
                "DISABLED"
              ],
              "type": "string",
              "description": "The property is read-only, used for querying result. User could update transport node maintenance mode by UpdateTransportNodeMaintenanceMode call.",
              "title": "transport node maintenance mode desired state"
            },
            "transport_zone_endpoints": {
              "items": {
                "$ref": "#/definitions/TransportZoneEndPoint"
              },
              "type": "array",
              "description": "Transport zone endpoints.",
              "title": "Transport zone endpoints."
            }
          },
          "required": [
            "node_id"
          ],
          "type": "object"
        }
      ],
      "description": "Transport Node",
      "title": "Transport Node"
    },
    "UpgradeUnitGroupStatus": {
      "type": "object",
      "properties": {
        "status": {
          "readOnly": true,
          "enum": [
            "SUCCESS",
            "FAILED",
            "IN_PROGRESS",
            "NOT_STARTED",
            "PAUSED"
          ],
          "type": "string",
          "description": "Upgrade status of upgrade unit group",
          "title": "Upgrade status of upgrade unit group"
        },
        "upgrade_unit_count": {
          "readOnly": true,
          "format": "int32",
          "type": "integer",
          "description": "Number of upgrade units in the group",
          "title": "Number of upgrade units in the group"
        },
        "failed_count": {
          "readOnly": true,
          "format": "int32",
          "type": "integer",
          "description": "Number of nodes in the upgrade unit group that failed upgrade",
          "title": "Number of nodes in the upgrade unit group that failed upgrade"
        },
        "percent_complete": {
          "readOnly": true,
          "type": "number",
          "description": "Indicator of upgrade progress in percentage",
          "title": "Indicator of upgrade progress in percentage"
        },
        "group_id": {
          "readOnly": true,
          "type": "string",
          "description": "Identifier for upgrade unit group",
          "title": "UUID of upgrade unit group"
        },
        "group_name": {
          "readOnly": true,
          "type": "string",
          "description": "Name of the upgrade unit group",
          "title": "Upgrade unit group Name"
        }
      }
    },
    "AwsGatewayUndeployConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "instance_id": {
              "type": "string",
              "description": "ID of the gateway instance",
              "title": "ID of the gateway instance"
            },
            "account_id": {
              "type": "string",
              "description": "ID of the Aws account",
              "title": "ID of the Aws account"
            }
          },
          "required": [
            "instance_id",
            "account_id"
          ],
          "type": "object"
        }
      ],
      "description": "Aws gateway undeployment configuration",
      "title": "Aws gateway undeployment configuration"
    },
    "LogicalRouterLoopbackPort": {
      "allOf": [
        {
          "$ref": "#/definitions/LogicalRouterPort"
        },
        {
          "required": [
            "subnets",
            "edge_cluster_member_index"
          ],
          "type": "object",
          "properties": {
            "subnets": {
              "description": "Loopback port subnets",
              "title": "Loopback port subnets",
              "minItems": 1,
              "items": {
                "$ref": "#/definitions/IPSubnet"
              },
              "maxItems": 1,
              "type": "array"
            },
            "edge_cluster_member_index": {
              "items": {
                "type": "integer",
                "format": "int64"
              },
              "type": "array",
              "description": "Member index of the edge node on the cluster",
              "title": "Member index of the edge node on the cluster"
            }
          }
        }
      ]
    },
    "FileRequestHeaders": {
      "properties": {
        "Range": {
          "readOnly": true,
          "type": "string"
        }
      },
      "type": "object",
      "description": "Header definition for requests to transfer files.",
      "title": "File request headers"
    },
    "ManagementClusterRoleConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/ClusterRoleConfig"
        },
        {
          "type": "object",
          "properties": {
            "mgmt_cluster_listen_addr": {
              "readOnly": true,
              "title": "The IP and port for the management cluster service on this node",
              "description": "The IP and port for the management cluster service on this node",
              "$ref": "#/definitions/ServiceEndpoint"
            },
            "mpa_msg_client_info": {
              "$ref": "#/definitions/MsgClientInfo"
            },
            "api_listen_addr": {
              "readOnly": true,
              "title": "The IP and port for the public API service on this node",
              "description": "The IP and port for the public API service on this node",
              "$ref": "#/definitions/ServiceEndpoint"
            },
            "mgmt_plane_listen_addr": {
              "readOnly": true,
              "title": "The IP and port for the management plane service on this node",
              "description": "The IP and port for the management plane service on this node",
              "$ref": "#/definitions/ServiceEndpoint"
            }
          }
        }
      ]
    },
    "NodeProcessProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "mem_used": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Virtual memory used by process in bytes",
              "title": "Virtual memory used by process in bytes"
            },
            "cpu_time": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "CPU time (user and system) consumed by process in milliseconds",
              "title": "CPU time (user and system) consumed by process in milliseconds"
            },
            "ppid": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Parent process id",
              "title": "Parent process id"
            },
            "start_time": {
              "readOnly": true,
              "type": "integer",
              "description": "Process start time expressed in milliseconds since epoch",
              "format": "int64"
            },
            "process_name": {
              "readOnly": true,
              "type": "string",
              "description": "Process name",
              "title": "Process name"
            },
            "pid": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Process id",
              "title": "Process id"
            },
            "uptime": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Milliseconds since process started",
              "title": "Milliseconds since process started"
            },
            "mem_resident": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Resident set size of process in bytes",
              "title": "Resident set size of process in bytes"
            }
          },
          "type": "object"
        }
      ],
      "description": "Node process properties",
      "title": "Node process properties"
    },
    "NsxRole": {
      "properties": {
        "role": {
          "enum": [
            "read_only_api_users",
            "read_write_api_users"
          ],
          "type": "string",
          "description": "Role name",
          "title": "Role name"
        },
        "permissions": {
          "items": {
            "enum": [
              "read-api",
              "read-write-api"
            ],
            "type": "string"
          },
          "type": "array",
          "description": "Permissions",
          "title": "Permissions"
        }
      },
      "required": [
        "role",
        "permissions"
      ],
      "type": "object",
      "description": "Role",
      "title": "Role"
    },
    "HostSwitchProfilesListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/BaseHostSwitchProfile"
              },
              "readOnly": true,
              "type": "array",
              "description": "HostSwitch Profile Results",
              "title": "HostSwitch Profile Results"
            }
          },
          "type": "object"
        }
      ],
      "description": "HostSwitch Profile queries result",
      "title": "HostSwitch Profile queries result"
    },
    "LogicalRouterRouteTableInCsvFormat": {
      "allOf": [
        {
          "$ref": "#/definitions/CsvListResult"
        },
        {
          "type": "object",
          "properties": {
            "last_update_timestamp": {
              "readOnly": true,
              "type": "integer",
              "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
              "format": "int64"
            },
            "results": {
              "items": {
                "$ref": "#/definitions/LogicalRouterRouteCsvRecord"
              },
              "type": "array"
            }
          }
        }
      ]
    },
    "NodeServicePropertiesListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/NodeServiceProperties"
              },
              "type": "array",
              "description": "Node service property results",
              "title": "Node service property results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Node service property query results",
      "title": "Node service property query results"
    },
    "AppDiscoveryVmInfoListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/AppDiscoveryVmInfo"
              },
              "type": "array",
              "description": "list of AppDiscoveryVmInfos",
              "title": "list of AppDiscoveryVmInfos"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "AppDiscoveryVmInfo list",
      "title": "AppDiscoveryVmInfo list"
    },
    "DhcpFilter": {
      "properties": {
        "client_block_enabled": {
          "readOnly": false,
          "type": "boolean",
          "description": "Indicates whether DHCP client blocking is enabled",
          "title": "Indicates whether DHCP client blocking is enabled"
        },
        "server_block_enabled": {
          "readOnly": false,
          "type": "boolean",
          "description": "Indicates whether DHCP server blocking is enabled",
          "title": "Indicates whether DHCP server blocking is enabled"
        }
      },
      "required": [
        "client_block_enabled",
        "server_block_enabled"
      ],
      "type": "object",
      "description": "DHCP filtering configuration",
      "title": "DHCP filtering configuration"
    },
    "IGMPTypeNSService": {
      "allOf": [
        {
          "$ref": "#/definitions/NSServiceElement"
        },
        {
          "type": "object"
        }
      ],
      "description": "A NSService that represents IGMP protocol",
      "title": "A NSService that represents IGMP protocol"
    },
    "RealizedFirewallUIResource": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "properties": {
            "intent_communication_map": {
              "$ref": "#/definitions/CommunicationMap"
            },
            "realized_firewall_sections": {
              "items": {
                "$ref": "#/definitions/RealizedFirewall"
              },
              "type": "array",
              "description": "Realized firewall sections associated to the communication map",
              "title": "Realized firewall sections associated to the communication map"
            }
          },
          "required": [
            "realized_firewall_sections"
          ],
          "type": "object"
        }
      ],
      "description": "Realized Firewall Sections and associated communication map",
      "title": "Realized Firewall Sections and associated communication map"
    },
    "StaticHopBfdPeer": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "peer_ip_address"
          ],
          "type": "object",
          "properties": {
            "bfd_config": {
              "title": "Configuration for the BFD peer",
              "description": "If not specified then BFD peer will inherit configuration from the BFD global config.",
              "$ref": "#/definitions/BfdConfigParameters"
            },
            "enabled": {
              "default": true,
              "type": "boolean",
              "description": "Indicate BFD peer is enabled or disabled. Default is true.",
              "title": "status of BFD peer"
            },
            "peer_ip_address": {
              "format": "ipv4",
              "type": "string",
              "description": "IP address of BFD peer. This should be same as next hop IP address."
            }
          }
        }
      ]
    },
    "MacAddressCsvListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/CsvListResult"
        },
        {
          "type": "object",
          "properties": {
            "last_update_timestamp": {
              "readOnly": true,
              "type": "integer",
              "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
              "format": "int64"
            },
            "results": {
              "items": {
                "$ref": "#/definitions/MacTableCsvRecord"
              },
              "type": "array"
            }
          }
        }
      ]
    },
    "BridgeHighAvailabilityClusterProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/ClusterProfile"
        },
        {
          "properties": {
            "enable": {
              "default": true,
              "type": "boolean",
              "description": "whether the heartbeat is enabled",
              "title": "whether the heartbeat is enabled"
            },
            "bfd_probe_interval": {
              "description": "the time interval (in millisec) between probe packets for heartbeat purpose",
              "title": "the time interval (in millisec) between probe packets for heartbeat purpose",
              "default": 1000,
              "format": "int64",
              "maximum": 60000,
              "minimum": 300,
              "type": "integer"
            }
          },
          "type": "object"
        }
      ],
      "description": "Profile for BFD HA cluster setting",
      "title": "Profile for BFD HA cluster setting"
    },
    "DneKeyPolicyStats": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "type": "object",
          "properties": {
            "bytes_decrypted": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "The number of bytes decrypted by the key policy. If key policy action is integrity only, it indicates the number of bytes which passed integrity check.",
              "title": "number of bytes decrypted"
            },
            "bytes_dropped": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "The number of bytes dropped for the key policy.",
              "title": "number of bytes dropped"
            },
            "packets_dropped": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "The number of dropped packets for the key policy.",
              "title": "number of packets dropped"
            },
            "packets_encrypted": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "The number of packets encrypted by the key policy. If key policy action is integrity only, it indicates the number of packets with the addition of integrity check.",
              "title": "number of packets encrypted"
            },
            "key_policy_identifier": {
              "readOnly": true,
              "type": "string",
              "description": "Key policy identifier of the DNE key policy. This is a globally unique number.",
              "title": "DNE key policy identifier"
            },
            "bytes_encrypted": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "The number of bytes encrypted by the key policy. If key policy action is integrity only, it indicates the number of bytes with the addition of integrity check.",
              "title": "number of bytes encrypted"
            },
            "packets_decrypted": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "The number of packets decrypted by the key policy. If key policy action is integrity only, it indicates the number of packets which passed integrity check.",
              "title": "number of packets decrypted"
            }
          }
        }
      ]
    },
    "DneSectionState": {
      "allOf": [
        {
          "$ref": "#/definitions/ConfigurationState"
        },
        {
          "type": "object",
          "properties": {
            "revision_desired": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "revision number of the desired state",
              "title": "revision number of the desired state"
            }
          }
        }
      ]
    },
    "AppProfileMetaInfo": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "app_profile_category": {
              "type": "string",
              "description": "Categories of the app profile",
              "title": "Categories of the app profile"
            },
            "app_profile_id": {
              "type": "string",
              "description": "ID of the App Profile",
              "title": "ID of the App Profile"
            },
            "app_profile_name": {
              "type": "string",
              "description": "Name of the App Profile",
              "title": "Name of the App Profile"
            }
          },
          "type": "object"
        }
      ],
      "description": "Contains the metadata of an App Profile\n",
      "title": "Metadata about App Profile"
    },
    "TransportNodeListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/TransportNode"
              },
              "readOnly": true,
              "type": "array",
              "description": "TransportNode Results",
              "title": "TransportNode Results"
            }
          },
          "type": "object"
        }
      ],
      "description": "Transport Node queries result",
      "title": "Transport Node queries result"
    },
    "ClusterInitializationNodeInfo": {
      "type": "object",
      "description": "The type provides the information of a non-running cluster node required for the initialization of a management cluster. The administrator needs to start this node for management cluster to initialize properly (or decommission it explicitly).",
      "properties": {
        "disk_store_id": {
          "readOnly": true,
          "type": "string",
          "description": "The (internal) disk-store ID of the member",
          "title": "The (internal) disk-store ID of the member"
        },
        "host_address": {
          "readOnly": true,
          "type": "string",
          "description": "The IP address (or domain name) of the cluster node",
          "title": "The IP address (or domain name) of the cluster node"
        }
      }
    },
    "LbPoolStatisticsListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LbPoolStatistics"
              },
              "type": "array",
              "description": "paginated statistics list of pools",
              "title": "paginated statistics list of pools"
            }
          }
        }
      ]
    },
    "ServiceAssociationListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "discriminator": "service_type",
          "required": [
            "service_type"
          ],
          "type": "object",
          "properties": {
            "service_type": {
              "enum": [
                "FireWallServiceAssociationListResult",
                "DNEServiceAssociationListResult",
                "IpfixServiceAssociationListResult"
              ],
              "type": "string"
            }
          }
        }
      ]
    },
    "GenericDhcpOption": {
      "required": [
        "code",
        "values"
      ],
      "type": "object",
      "properties": {
        "code": {
          "description": "dhcp option code, [0-255]",
          "format": "int64",
          "title": "dhcp option code, [0-255]",
          "maximum": 255,
          "minimum": 0,
          "type": "integer"
        },
        "values": {
          "description": "dhcp option value",
          "title": "dhcp option value",
          "minItems": 1,
          "items": {
            "type": "string"
          },
          "maxItems": 10,
          "type": "array"
        }
      }
    },
    "FeatureUsageList": {
      "description": "list of feature usage items",
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "type": "object",
          "properties": {
            "feature_usage_info": {
              "items": {
                "$ref": "#/definitions/FeatureUsage"
              },
              "readOnly": true,
              "type": "array",
              "description": "Feature Usage List",
              "title": "Feature Usage List"
            }
          }
        }
      ]
    },
    "SwitchingProfileStatus": {
      "type": "object",
      "properties": {
        "num_logical_ports": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Number of logical ports using a switching profile",
          "title": "Number of logical ports using a switching profile"
        },
        "switching_profile_id": {
          "type": "string",
          "description": "Identifier for the switching profile",
          "title": "Identifier for the switching profile"
        },
        "num_logical_switches": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Number of logical switches using a switching profile",
          "title": "Number of logical switches using a switching profile"
        }
      }
    },
    "SftpProtocol": {
      "allOf": [
        {
          "$ref": "#/definitions/Protocol"
        },
        {
          "required": [
            "ssh_fingerprint",
            "name",
            "authentication_scheme"
          ],
          "type": "object",
          "properties": {
            "ssh_fingerprint": {
              "type": "string",
              "description": "SSH fingerprint of server",
              "title": "SSH fingerprint of server"
            },
            "name": {
              "enum": [
                "sftp"
              ],
              "type": "string",
              "description": "Protocol name",
              "title": "Protocol name"
            },
            "authentication_scheme": {
              "description": "Scheme to authenticate if required",
              "title": "Scheme to authenticate if required"
            }
          }
        }
      ]
    },
    "BgpNeighborStatus": {
      "type": "object",
      "properties": {
        "transport_node": {
          "readOnly": true,
          "title": "Transport node id and name",
          "description": "Transport node id and name",
          "$ref": "#/definitions/ResourceReference"
        },
        "connection_state": {
          "readOnly": true,
          "enum": [
            "INVALID",
            "IDLE",
            "CONNECT",
            "ACTIVE",
            "OPEN_SENT",
            "OPEN_CONFIRM",
            "ESTABLISHED"
          ],
          "type": "string",
          "description": "Current state of the BGP session.",
          "title": "Current state of the BGP session."
        },
        "neighbor_address": {
          "description": "The IP of the BGP neighbor",
          "format": "ip",
          "readOnly": true,
          "type": "string"
        },
        "messages_sent": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Count of messages sent to the neighbor",
          "title": "Count of messages sent to the neighbor"
        },
        "connection_drop_count": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Count of connection drop",
          "title": "Count of connection drop"
        },
        "remote_port": {
          "description": "TCP port number of remote BGP Connection",
          "title": "TCP port number of remote BGP Connection",
          "format": "int64",
          "maximum": 65535,
          "readOnly": true,
          "minimum": 1,
          "type": "integer"
        },
        "source_address": {
          "description": "The Ip address of logical port",
          "format": "ip",
          "readOnly": true,
          "type": "string"
        },
        "total_in_prefix_count": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Count of in prefixes",
          "title": "Count of in prefixes"
        },
        "messages_received": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Count of messages received from the neighbor",
          "title": "Count of messages received from the neighbor"
        },
        "neighbor_router_id": {
          "description": "Router ID of the BGP neighbor.",
          "format": "ip",
          "readOnly": true,
          "additionalProperties": false,
          "type": "string"
        },
        "total_out_prefix_count": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Count of out prefixes",
          "title": "Count of out prefixes"
        },
        "lr_component_id": {
          "readOnly": true,
          "type": "string",
          "description": "Logical router component(Service Router/Distributed Router) id",
          "title": "Logical router component(Service Router/Distributed Router) id"
        },
        "graceful_restart": {
          "readOnly": true,
          "type": "boolean",
          "description": "Indicate current state of graceful restart where graceful_restart = true indicate graceful restart is enabled and graceful_restart = false indicate graceful restart is disabled.",
          "title": "Indicate current state of graceful restart where graceful_restart = true indicate graceful restart is enabled and graceful_restart = false indicate graceful restart is disabled."
        },
        "remote_as_number": {
          "readOnly": true,
          "type": "string",
          "description": "AS number of the BGP neighbor",
          "title": "AS number of the BGP neighbor"
        },
        "announced_capabilities": {
          "items": {
            "type": "string"
          },
          "readOnly": true,
          "type": "array",
          "description": "BGP capabilities sent to BGP neighbor.",
          "title": "BGP capabilities sent to BGP neighbor."
        },
        "local_port": {
          "description": "TCP port number of Local BGP connection",
          "title": "TCP port number of Local BGP connection",
          "format": "int64",
          "maximum": 65535,
          "readOnly": true,
          "minimum": 1,
          "type": "integer"
        },
        "keep_alive_interval": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Time in ms to wait for HELLO packet from BGP peer",
          "title": "Time in ms to wait for HELLO packet from BGP peer"
        },
        "time_since_established": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Time(in milliseconds) since connection was established.",
          "title": "Time(in milliseconds) since connection was established."
        },
        "hold_time": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Time in ms to wait for HELLO from BGP peer. If a HELLO packet is not seen from BGP Peer withing hold_time then BGP neighbor will be marked as down.",
          "title": "Time in ms to wait for HELLO from BGP peer. If a HELLO packet is not seen from BGP Peer withing hold_time then BGP neighbor will be marked as down."
        },
        "negotiated_capability": {
          "items": {
            "type": "string"
          },
          "readOnly": true,
          "type": "array",
          "description": "BGP capabilities negotiated with BGP neighbor.",
          "title": "BGP capabilities negotiated with BGP neighbor."
        },
        "established_connection_count": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Count of connections established",
          "title": "Count of connections established"
        }
      }
    },
    "PortConnectionTunnel": {
      "properties": {
        "src_node_id": {
          "type": "string",
          "description": "Id of the source transport node",
          "title": "Id of the source transport node"
        },
        "tunnel_properties": {
          "title": "Tunnel properties between the source and the destination transport node",
          "description": "Tunnel properties between the source and the destination transport node",
          "$ref": "#/definitions/TunnelProperties"
        }
      },
      "required": [
        "src_node_id",
        "tunnel_properties"
      ],
      "type": "object",
      "description": "Tunnel information between two given transport nodes",
      "title": "Tunnel information between two given transport nodes"
    },
    "VsphereDeploymentConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/DeploymentConfig"
        },
        {
          "required": [
            "data_network_ids",
            "management_network_id",
            "hostname",
            "compute_id",
            "vc_id",
            "storage_id"
          ],
          "type": "object",
          "properties": {
            "data_network_ids": {
              "description": "List of distributed portgroup identifiers to which the datapath serving vnics\nof edge node vm will be connected.\n",
              "title": "Portgroup identifiers for datapath connectivity.",
              "minItems": 3,
              "items": {
                "type": "string"
              },
              "maxItems": 3,
              "type": "array"
            },
            "host_id": {
              "type": "string",
              "description": "The edge node vm will be deployed on the specified Host within the cluster\nif host_id is specified.\nNote - User must ensure that storage and specified networks are accessible by this host.\n",
              "title": "Host identifier in the specified vcenter server."
            },
            "management_network_id": {
              "type": "string",
              "description": "Distributed portgroup identifier to which the management vnic of edge node vm\nwill be connected. This portgroup must have connectivity with MP and CCP.\n",
              "title": "Portgroup identifier for management network connectivity."
            },
            "vc_id": {
              "type": "string",
              "description": "The vc specific identifiers will be resolved on this VC.\nSo all other identifiers specified here must belong to this vcenter server.\n",
              "title": "Vsphere compute identifier for identifying the vcenter server."
            },
            "storage_id": {
              "type": "string",
              "description": "The edge node vm will be deployed on the specified datastore. User must ensure\nthat storage is accessible by the specified cluster/host.\n",
              "title": "Storage/datastore identifier in the specified vcenter server."
            },
            "default_gateway_addresses": {
              "description": "The default gateway for edge node must be specified if all the nodes it\ncommunicates with are not in the same subnet.\nNote: only single IPv4 default gateway address is supported and it must belong to management network.\nDo not specify this field and management_port_subnets to use DHCP.\n",
              "title": "Default gateway for the node.",
              "minItems": 1,
              "items": {
                "format": "ip",
                "type": "string",
                "description": "IPv4 or IPv6 address"
              },
              "maxItems": 1,
              "type": "array"
            },
            "management_port_subnets": {
              "description": "IP Address and subnet configuration for the management port. Note: only one IPv4\naddress is supported for the management port.\nDo not specify this field and default_gateway_addresses to use DHCP.\n",
              "title": "Port subnets for management port. Only one IPv4 Address is supported.",
              "minItems": 1,
              "items": {
                "$ref": "#/definitions/IPSubnet"
              },
              "maxItems": 1,
              "type": "array"
            },
            "hostname": {
              "type": "string",
              "description": "Host name or FQDN for edge node.",
              "title": "Host name or FQDN for edge node."
            },
            "compute_id": {
              "type": "string",
              "description": "The edge node vm will be deployed on the specified cluster or resourcepool.\nNote - all the hosts must have nsx fabric prepared in the specified cluster.\n",
              "title": "Cluster identifier or resourcepool identifier for specified vcenter server."
            }
          }
        }
      ]
    },
    "ClusterConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/RevisionedResource"
        },
        {
          "required": [
            "mgmt_cluster_changes_allowed",
            "control_cluster_changes_allowed"
          ],
          "type": "object",
          "properties": {
            "control_cluster_changes_allowed": {
              "type": "boolean",
              "description": "True if control cluster nodes may be added or removed",
              "title": "True if control cluster nodes may be added or removed"
            },
            "mgmt_cluster_changes_allowed": {
              "type": "boolean",
              "description": "True if management cluster nodes may be added or removed",
              "title": "True if management cluster nodes may be added or removed"
            },
            "cluster_id": {
              "readOnly": true,
              "type": "string",
              "description": "Unique identifier of this cluster",
              "title": "Unique identifier of this cluster"
            }
          }
        }
      ]
    },
    "UpgradeHistory": {
      "required": [
        "timestamp",
        "target_version",
        "initial_version",
        "upgrade_status"
      ],
      "type": "object",
      "properties": {
        "timestamp": {
          "type": "integer",
          "description": "Timestamp (in milliseconds since epoch) when the upgrade was performed",
          "format": "int64"
        },
        "target_version": {
          "type": "string",
          "description": "Version being upgraded to",
          "title": "Target Version"
        },
        "initial_version": {
          "type": "string",
          "description": "Version before the upgrade started",
          "title": "Initial Version"
        },
        "upgrade_status": {
          "enum": [
            "STARTED",
            "SUCCESS",
            "FAILED"
          ],
          "type": "string",
          "description": "Status of the upgrade",
          "title": "Status of the upgrade"
        }
      }
    },
    "LogicalRouterRouteCsvRecord": {
      "allOf": [
        {
          "$ref": "#/definitions/CsvRecord"
        },
        {
          "required": [
            "route_type",
            "network"
          ],
          "type": "object",
          "properties": {
            "lr_component_id": {
              "type": "string",
              "description": "Logical router component(Service Router/Distributed Router) id",
              "title": "Logical router component(Service Router/Distributed Router) id"
            },
            "next_hop": {
              "format": "ip",
              "type": "string",
              "description": "The IP of the next hop"
            },
            "lr_component_type": {
              "type": "string",
              "description": "Logical router component(Service Router/Distributed Router) type",
              "title": "Logical router component(Service Router/Distributed Router) type"
            },
            "network": {
              "format": "ipv4-cidr-block",
              "type": "string",
              "description": "CIDR network address"
            },
            "route_type": {
              "type": "string",
              "description": "Route type (USER, CONNECTED, NSX_INTERNAL,..)",
              "title": "Route type (USER, CONNECTED, NSX_INTERNAL,..)"
            },
            "logical_router_port_id": {
              "type": "string",
              "description": "The id of the logical router port which is used as the next hop",
              "title": "The id of the logical router port which is used as the next hop"
            },
            "admin_distance": {
              "format": "int64",
              "type": "integer",
              "description": "The admin distance of the next hop",
              "title": "The admin distance of the next hop"
            }
          }
        }
      ]
    },
    "CryptoAlgorithm": {
      "type": "object",
      "properties": {
        "key_size": {
          "items": {
            "type": "integer",
            "description": "Crypto key size",
            "format": "int64"
          },
          "readOnly": true,
          "type": "array",
          "description": "supported key sizes for the algorithm"
        },
        "name": {
          "readOnly": true,
          "type": "string",
          "description": "crypto algorithm name"
        }
      }
    },
    "Dscp": {
      "properties": {
        "priority": {
          "description": "Internal Forwarding Priority",
          "title": "Internal Forwarding Priority",
          "default": 0,
          "format": "int32",
          "maximum": 63,
          "minimum": 0,
          "type": "integer"
        },
        "mode": {
          "enum": [
            "TRUSTED",
            "UNTRUSTED"
          ],
          "type": "string",
          "description": "Trust settings"
        }
      },
      "type": "object",
      "description": "Dscp value is ignored in case of 'TRUSTED' DscpMode.",
      "title": "One of Quality-of-Service or Encapsulated-Remote-Switched-Port-Analyzer"
    },
    "DiscoveredNode": {
      "allOf": [
        {
          "$ref": "#/definitions/DiscoveredResource"
        },
        {
          "type": "object",
          "properties": {
            "display_name": {
              "readOnly": true,
              "type": "string",
              "description": "Display name of discovered node",
              "title": "Display name of discovered node"
            },
            "certificate": {
              "type": "string",
              "description": "Certificate of the discovered node",
              "title": "Certificate of the discovered node"
            },
            "origin_id": {
              "readOnly": true,
              "type": "string",
              "description": "Id of the compute manager from where this node was discovered",
              "title": "Id of the compute manager from where this node was discovered"
            },
            "ip_addresses": {
              "items": {
                "format": "ip",
                "type": "string",
                "description": "IPv4 or IPv6 address"
              },
              "readOnly": true,
              "type": "array",
              "description": "IP Addresses of the the discovered node.",
              "title": "IP Addresses of the the discovered node."
            },
            "os_version": {
              "readOnly": true,
              "type": "string",
              "description": "OS version of the discovered node",
              "title": "OS version of the discovered node"
            },
            "node_type": {
              "readOnly": true,
              "type": "string",
              "description": "Discovered Node type like Host",
              "title": "Discovered Node type like Host"
            },
            "parent_compute_collection": {
              "readOnly": true,
              "type": "string",
              "description": "External id of the compute collection to which this node belongs",
              "title": "External id of the compute collection to which this node belongs"
            },
            "os_type": {
              "readOnly": true,
              "type": "string",
              "description": "OS type of the discovered node",
              "title": "OS type of the discovered node"
            },
            "origin_properties": {
              "items": {
                "$ref": "#/definitions/KeyValuePair"
              },
              "readOnly": true,
              "type": "array",
              "description": "Key-Value map of additional specific properties of discovered\nnode in the Compute Manager\n",
              "title": "Key-Value map of additional specific properties of discovered\nnode in the Compute Manager\n"
            },
            "external_id": {
              "readOnly": true,
              "type": "string",
              "description": "External id of the discovered node, ex. a mo-ref from VC",
              "title": "External id of the discovered node, ex. a mo-ref from VC"
            },
            "cm_local_id": {
              "readOnly": true,
              "type": "string",
              "description": "Local Id of the discovered node in the Compute Manager",
              "title": "Local Id of the discovered node in the Compute Manager"
            }
          }
        }
      ]
    },
    "ErrorResolverSystemMetadata": {
      "type": "object",
      "description": "Metadata fetched from an external system like Syslog or LogInsight.",
      "properties": {
        "value": {
          "type": "string",
          "description": "The value fetched from another system",
          "title": "The value fetched from another system"
        }
      }
    },
    "BaseHostSwitchProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "discriminator": "resource_type",
          "required": [
            "resource_type"
          ],
          "type": "object",
          "properties": {
            "required_capabilities": {
              "items": {
                "type": "string"
              },
              "readOnly": true,
              "type": "array"
            },
            "resource_type": {
              "enum": [
                "UplinkHostSwitchProfile",
                "LldpHostSwitchProfile"
              ],
              "type": "string",
              "description": "Supported HostSwitch profiles."
            }
          }
        }
      ]
    },
    "NodeNameServersProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "name_servers": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "Name servers",
              "maxItems": 3,
              "title": "Name servers"
            }
          },
          "required": [
            "name_servers"
          ],
          "type": "object"
        }
      ],
      "description": "Node network name servers properties",
      "title": "Node network name servers properties"
    },
    "EdgeUpgradeStatus": {
      "allOf": [
        {
          "$ref": "#/definitions/ComponentUpgradeStatus"
        },
        {
          "type": "object"
        }
      ],
      "description": "Status of edge upgrade",
      "title": "Status of edge upgrade"
    },
    "UserInfo": {
      "properties": {
        "user_name": {
          "readOnly": true,
          "type": "string",
          "description": "User Name",
          "title": "User Name"
        },
        "roles": {
          "items": {
            "$ref": "#/definitions/NsxRole"
          },
          "readOnly": true,
          "type": "array",
          "description": "Permissions",
          "title": "Permissions"
        }
      },
      "type": "object",
      "description": "Authenticated User Info",
      "title": "Authenticated User Info"
    },
    "LbVirtualServer": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "application_profile_id",
            "ip_address",
            "port"
          ],
          "type": "object",
          "properties": {
            "ip_protocol": {
              "description": "Assigned Internet Protocol in IP header, TCP, UDP are supported.\n",
              "default": "TCP",
              "enum": [
                "TCP",
                "UDP"
              ],
              "type": "string"
            },
            "server_ssl_profile_binding": {
              "title": "Pool side SSL binding setting",
              "description": "The setting is used when load balancer acts as an SSL client and\nestablishing a connection to the backend server.\n",
              "$ref": "#/definitions/ServerSslProfileBinding"
            },
            "enabled": {
              "default": true,
              "type": "boolean",
              "description": "whether the virtual server is enabled",
              "title": "whether the virtual server is enabled"
            },
            "max_concurrent_connections": {
              "format": "int64",
              "minimum": 1,
              "type": "integer",
              "description": "To ensure one virtual server does not over consume resources,\naffecting other applications hosted on the same LBS, connections\nto a virtual server can be capped.\nIf it is not specified, it means that connections are unlimited.\n",
              "title": "maximum concurrent connection number"
            },
            "pool_id": {
              "type": "string",
              "description": "The server pool(LbPool) contains backend servers. Server pool\nconsists of one or more servers, also referred to as pool members, that\nare similarly configured and are running the same application.\n",
              "title": "default server pool identifier"
            },
            "application_profile_id": {
              "type": "string",
              "description": "The application profile defines the application protocol characteristics.\nIt is used to influence how load balancing is performed. Currently,\nLbFastTCPProfile, LbFastUDPProfile and\nLbHttpProfile, etc are supported.\n",
              "title": "application profile identifier"
            },
            "rule_ids": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "Load balancer rules allow customization of load balancing behavior using\nmatch/action rules. Currently, load balancer rules are supported for\nonly layer 7 virtual servers with LbHttpProfile.\n",
              "maxItems": 512,
              "title": "List of load balancer rule identifiers"
            },
            "max_new_connection_rate": {
              "format": "int64",
              "minimum": 1,
              "type": "integer",
              "description": "To ensure one virtual server does not over consume resources,\nconnections to a member can be rate limited.\nIf it is not specified, it means that connection rate is unlimited.\n",
              "title": "maximum new connection rate in second"
            },
            "persistence_profile_id": {
              "type": "string",
              "description": "Persistence profile is used to allow related client connections to be\nsent to the same backend server.\n",
              "title": "persistence profile identifier"
            },
            "client_ssl_profile_binding": {
              "title": "Virtual server side SSL binding setting",
              "description": "The setting is used when load balancer acts as an SSL server and\nterminating the client SSL connection\n",
              "$ref": "#/definitions/ClientSslProfileBinding"
            },
            "default_pool_member_port": {
              "format": "port-or-range",
              "type": "string",
              "description": "default pool member port when member port is not defined."
            },
            "ip_address": {
              "format": "ip",
              "type": "string",
              "description": "virtual server IP address"
            },
            "port": {
              "format": "port-or-range",
              "type": "string",
              "description": "Port setting could be single port for both L7 mode and L4 mode.\nFor L4 mode, a single port range is also supported.\nThe port setting could be a single port or port range such as\n\"80\", \"1234-1236\".\n"
            }
          }
        }
      ]
    },
    "IGMPTypeServiceEntry": {
      "allOf": [
        {
          "$ref": "#/definitions/ServiceEntry"
        },
        {
          "type": "object"
        }
      ],
      "description": "A ServiceEntry that represents IGMP protocol",
      "title": "A ServiceEntry that represents IGMP protocol"
    },
    "LbHttpRequestHeaderRewriteAction": {
      "allOf": [
        {
          "$ref": "#/definitions/LbRuleAction"
        },
        {
          "properties": {
            "header_value": {
              "type": "string",
              "description": "Value of HTTP request header",
              "title": "Value of HTTP request header"
            },
            "header_name": {
              "type": "string",
              "description": "Name of HTTP request header",
              "title": "Name of HTTP request header"
            }
          },
          "required": [
            "header_value",
            "header_name"
          ],
          "type": "object"
        }
      ],
      "description": "This action is used to rewrite header fields of matched HTTP request\nmessages to specified new values. One action can be used to rewrite one\nheader field. To rewrite multiple header fields, multiple actions must be\ndefined.\nCaptured variables and built-in variables can be used in the header_value\nfield, header_name field does not support variables.\n",
      "title": "Action to rewrite header fields of HTTP request messages."
    },
    "ProtocolVersion": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enable status for this protocol version",
          "title": "Enable status for this protocol version"
        },
        "name": {
          "type": "string",
          "description": "Name of the TLS protocol version",
          "title": "Name of the TLS protocol version"
        }
      },
      "required": [
        "enabled",
        "name"
      ],
      "type": "object",
      "description": "HTTP protocol version",
      "title": "HTTP protocol version"
    },
    "LbSessionCookieTime": {
      "allOf": [
        {
          "$ref": "#/definitions/LbCookieTime"
        },
        {
          "type": "object",
          "properties": {
            "cookie_max_idle": {
              "description": "Instead of using HTTP Cookie max-age and relying on client to expire\nthe cookie, max idle time and/or max lifetime of the cookie can be used.\nMax idle time, if configured, specifies the maximum interval the cookie\nis valid for from the last time it was seen in a request.\nIt is available for insert mode.\n",
              "format": "int64",
              "title": "session cookie max idle time in seconds",
              "maximum": 2147483647,
              "minimum": 1,
              "type": "integer"
            },
            "cookie_max_life": {
              "description": "Max life time, if configured, specifies the maximum interval the cookie\nis valid for from the first time the cookie was seen in a request.\nIt is available for insert mode.\n",
              "format": "int64",
              "title": "session cookie max lifetime in seconds",
              "maximum": 2147483647,
              "minimum": 1,
              "type": "integer"
            }
          }
        }
      ]
    },
    "StartAppDiscoverySessionParameters": {
      "properties": {
        "ns_group_ids": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "NSGroup Ids",
          "title": "NSGroup Ids"
        },
        "app_profile_ids": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "App Profile Ids",
          "title": "App Profile Ids"
        }
      },
      "required": [
        "ns_group_ids"
      ],
      "type": "object",
      "description": "Parameters to start an application discovery session. It can have NSGroup\nIds as well as the App Profile Ids.\n",
      "title": "Parameters to start an application discovery session"
    },
    "DneRule": {
      "allOf": [
        {
          "$ref": "#/definitions/EmbeddedResource"
        },
        {
          "type": "object",
          "properties": {
            "rule_tag": {
              "readOnly": false,
              "maxLength": 32,
              "type": "string",
              "description": "User level field which will be printed in CLI and packet logs.",
              "title": "Tag"
            },
            "ip_protocol": {
              "description": "Type of IP packet that should be matched while enforcing the rule.",
              "title": "IPv4 vs IPv6 packet type",
              "default": "IPV4_IPV6",
              "enum": [
                "IPV4",
                "IPV6",
                "IPV4_IPV6"
              ],
              "readOnly": false,
              "type": "string"
            },
            "key_policy_identifier": {
              "readOnly": false,
              "type": "string",
              "description": "Identifier of key policy. Section's key policy, if exists, overrides Rule's key policy.",
              "title": "key policy identifier"
            },
            "applied_tos": {
              "description": "List of object where rule will be enforced. The section level field overrides this one. Null will be treated as any.",
              "title": "AppliedTo List",
              "items": {
                "$ref": "#/definitions/ResourceReference"
              },
              "readOnly": false,
              "maxItems": 128,
              "type": "array"
            },
            "logged": {
              "default": false,
              "readOnly": false,
              "type": "boolean",
              "description": "Flag to enable packet logging. Default is disabled.",
              "title": "Enable logging flag"
            },
            "comments": {
              "readOnly": false,
              "maxLength": 2048,
              "type": "string",
              "description": "User notes specific to the rule.",
              "title": "Notes"
            },
            "disabled": {
              "default": false,
              "readOnly": false,
              "type": "boolean",
              "description": "Flag to disable rule. Disabled rule will only be persisted but never provisioned/realized.",
              "title": "Rule enable/disable flag"
            },
            "sources": {
              "description": "List of sources. Null will be treated as any.",
              "title": "Source List",
              "items": {
                "$ref": "#/definitions/ResourceReference"
              },
              "readOnly": false,
              "maxItems": 128,
              "type": "array"
            },
            "services": {
              "description": "List of the services. Null will be treated as any.",
              "title": "Service List",
              "items": {
                "$ref": "#/definitions/DneService"
              },
              "readOnly": false,
              "maxItems": 128,
              "type": "array"
            },
            "key_policy_name": {
              "readOnly": true,
              "type": "string",
              "description": "A display name of rule's key policy. This is a read-only field for UI display purpose only. If not set by user, this name will be key policy's UUID.",
              "title": "Rule's key policy display name"
            },
            "action": {
              "readOnly": true,
              "type": "string",
              "description": "This is a read-only field that for UI display purpose only. It is to show what type of protection the rule's key policy provides.",
              "title": "DNE rule action"
            },
            "destinations": {
              "description": "List of the destinations. Null will be treated as any.",
              "title": "Destination List",
              "items": {
                "$ref": "#/definitions/ResourceReference"
              },
              "readOnly": false,
              "maxItems": 128,
              "type": "array"
            }
          }
        }
      ]
    },
    "CCPUpgradeStatus": {
      "allOf": [
        {
          "$ref": "#/definitions/ComponentUpgradeStatus"
        },
        {
          "type": "object"
        }
      ],
      "description": "Status of CCP upgrade",
      "title": "Status of CCP upgrade"
    },
    "PoolMemberGroup": {
      "required": [
        "grouping_object",
        "max_ip_list_size"
      ],
      "type": "object",
      "properties": {
        "grouping_object": {
          "title": "Grouping object resource reference",
          "description": "Load balancer pool support grouping object as dynamic pool members.\nThe IP list of the grouping object such as NSGroup would be used as\npool member IP setting.\n",
          "$ref": "#/definitions/ResourceReference"
        },
        "ip_revision_filter": {
          "default": "IPV4",
          "enum": [
            "IPV4",
            "IPV6",
            "IPV4_IPV6"
          ],
          "type": "string",
          "description": "Ip revision filter is used to filter IPv4 or IPv6 addresses from the\ngrouping object.\nIf the filter is not specified, both IPv4 and IPv6 addresses would be\nused as server IPs.\nThe link local and loopback addresses would be always filtered out.\n",
          "title": "Filter of ipv4 or ipv6 address of grouping object IP list"
        },
        "max_ip_list_size": {
          "format": "int64",
          "minimum": 0,
          "type": "integer",
          "description": "The size is used to define the maximum number of grouping object IP\naddress list. These IP addresses would be used as pool members.\nIf the grouping object includes more than certain number of\nIP addresses, the redundant parts would be ignored and those IP\naddresses would not be treated as pool members.\n",
          "title": "Maximum number of grouping object IP address list"
        },
        "customized_members": {
          "items": {
            "$ref": "#/definitions/PoolMemberSetting"
          },
          "readOnly": false,
          "type": "array",
          "description": "The list is used to show the customized pool member settings. User can\nonly user pool member action API to update the admin state for a specific\nIP address.\n",
          "title": "List of customized pool member settings"
        }
      }
    },
    "SupportBundleFileTransferProtocol": {
      "required": [
        "ssh_fingerprint",
        "name",
        "authentication_scheme"
      ],
      "type": "object",
      "properties": {
        "ssh_fingerprint": {
          "type": "string",
          "description": "SSH fingerprint of server",
          "title": "SSH fingerprint of server"
        },
        "name": {
          "enum": [
            "SCP",
            "SFTP"
          ],
          "type": "string",
          "description": "Protocol name",
          "title": "Protocol name"
        },
        "authentication_scheme": {
          "title": "Scheme to authenticate if required",
          "description": "Scheme to authenticate if required",
          "$ref": "#/definitions/SupportBundleFileTransferAuthenticationScheme"
        }
      }
    },
    "IpBlockListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/IpBlock"
              },
              "type": "array",
              "description": "IP block list results",
              "title": "IP block list results"
            }
          }
        }
      ]
    },
    "FirewallSectionListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/FirewallSection"
              },
              "readOnly": true,
              "type": "array",
              "description": "List of the firewall sections. The list has to be homogenous.",
              "title": "Section list"
            }
          }
        }
      ]
    },
    "CloudAccount": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "tenant_id": {
              "readOnly": true,
              "type": "string",
              "description": "Tenant ID of the cloud account",
              "title": "Tenant ID of the cloud account"
            },
            "instance_stats": {
              "readOnly": true,
              "title": "Instance statistics",
              "description": "Instance statistics",
              "$ref": "#/definitions/InstanceStats"
            },
            "cloud_type": {
              "readOnly": false,
              "enum": [
                "AWS",
                "AZURE",
                "GOOGLE"
              ],
              "type": "string",
              "description": "Cloud Type",
              "title": "Cloud Type"
            },
            "cloud_tags_enabled": {
              "default": true,
              "readOnly": false,
              "type": "boolean",
              "description": "Booolean flag to enable or disable cloud tags discovery. The discovered\ncloud tags can be used to define security group membership.\n",
              "title": "Booolean flag to enable or disable cloud tags discovery"
            },
            "auth_users": {
              "items": {
                "$ref": "#/definitions/CloudUserInfo"
              },
              "readOnly": true,
              "type": "array",
              "description": "List of authorized users",
              "title": "List of authorized users"
            }
          },
          "required": [
            "cloud_type"
          ],
          "type": "object"
        }
      ],
      "description": "Cloud account structure",
      "title": "Cloud account structure"
    },
    "Crl": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "pem_encoded"
          ],
          "type": "object",
          "properties": {
            "details": {
              "readOnly": true,
              "description": "details of the X509Crl object",
              "$ref": "#/definitions/X509Crl"
            },
            "pem_encoded": {
              "readOnly": false,
              "type": "string",
              "description": "pem encoded crl data"
            }
          }
        }
      ]
    },
    "NodeUserPropertiesListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/NodeUserProperties"
              },
              "type": "array",
              "description": "List of node users",
              "title": "List of node users"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Node users list results",
      "title": "Node users list results"
    },
    "TcpHeader": {
      "type": "object",
      "properties": {
        "tcp_flags": {
          "description": "TCP flags (9bits)",
          "format": "int64",
          "title": "TCP flags (9bits)",
          "maximum": 511,
          "minimum": 0,
          "type": "integer"
        },
        "src_port": {
          "description": "Source port of tcp header",
          "format": "int64",
          "title": "Source port of tcp header",
          "maximum": 65535,
          "minimum": 0,
          "type": "integer"
        },
        "dst_port": {
          "description": "Destination port of tcp header",
          "format": "int64",
          "title": "Destination port of tcp header",
          "maximum": 65535,
          "minimum": 0,
          "type": "integer"
        }
      }
    },
    "LogicalDhcpServer": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "ipv4_dhcp_server",
            "dhcp_profile_id"
          ],
          "type": "object",
          "properties": {
            "attached_logical_port_id": {
              "readOnly": true,
              "type": "string",
              "description": "id of attached logical port",
              "title": "id of attached logical port"
            },
            "ipv4_dhcp_server": {
              "title": "dhcp server for ipv4 addresses",
              "description": "dhcp server for ipv4 addresses",
              "$ref": "#/definitions/IPv4DhcpServer"
            },
            "dhcp_profile_id": {
              "type": "string",
              "description": "dhcp profile uuid",
              "title": "dhcp profile uuid"
            }
          }
        }
      ]
    },
    "LogicalSwitchStatusListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LogicalSwitchStatus"
              },
              "readOnly": true,
              "type": "array",
              "description": "LogicalSwitchStatus Results",
              "title": "LogicalSwitchStatus Results"
            }
          },
          "type": "object"
        }
      ],
      "description": "Logical Switch runtime status queries result",
      "title": "Logical Switch runtime status queries result"
    },
    "CommunicationMap": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "properties": {
            "communication_entries": {
              "items": {
                "$ref": "#/definitions/CommunicationEntry"
              },
              "type": "array",
              "description": "CommunicationEntries that are a part of this CommunicationMap",
              "title": "CommunicationEntries that are a part of this CommunicationMap"
            },
            "precedence": {
              "format": "int32",
              "type": "integer",
              "description": "This field is used to resolve conflicts between communication maps\nacross domains. In order to change the precedence of a communication\nmap, it is recommended to send a POST request to the following URL\n/infra/domains/<domain-id>/communication-map?action=revise\nThe precedence field will reflect the value of the computed precedence\nupon execution of the above mentioned POST request.\nFor scenarios where the administrator is using a template to update\nseveral communication maps, the only way to set the precedence is to\nexplicitly specify the precedence number for each communication map.\n",
              "title": "Precedence to resolve conflicts across Domains"
            }
          },
          "type": "object"
        }
      ],
      "description": "Ordered list of CommunicationEntries. This object is created by default\nalong with the Domain.\n",
      "title": "Contains ordered list of CommunicationEntries"
    },
    "UrlAlias": {
      "properties": {
        "url": {
          "type": "string",
          "description": "Url to fetch data from.",
          "title": "Url"
        },
        "alias": {
          "type": "string",
          "description": "Short name or alias of url, if any. If not specified, the url can be referenced by its index in the array of urls of the datasource instance as $<index> (for example, $0).",
          "title": "Url Alias Name"
        },
        "query": {
          "type": "string",
          "description": "Search query to be applied, if any. If query string is not provided, it will be ignored.",
          "title": "Search query of the search api, if any"
        }
      },
      "required": [
        "url"
      ],
      "type": "object",
      "description": "Short name or alias of a url. It is used to represent the url.",
      "title": "Url Alias"
    },
    "AuthenticationPolicyProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "api_failed_auth_reset_period": {
              "description": "In order to trigger an account lockout, all authentication failures must occur in this time window. If the reset period expires, the failed login count is reset to zero. Only applies to NSX Manager nodes. Ignored on other node types.",
              "format": "int64",
              "default": 900,
              "title": "Period, in seconds, for authentication failures to trigger lockout",
              "minimum": 0,
              "type": "integer"
            },
            "minimum_password_length": {
              "description": "Minimum number of characters required in account passwords",
              "format": "int64",
              "default": 8,
              "title": "Minimum number of characters required in account passwords",
              "minimum": 8,
              "type": "integer"
            },
            "cli_failed_auth_lockout_period": {
              "description": "Once a lockout occurs, the account remains locked out of the CLI for this time period.",
              "format": "int64",
              "default": 900,
              "title": "Lockout period in seconds",
              "minimum": 0,
              "type": "integer"
            },
            "api_max_auth_failures": {
              "description": "Only applies to NSX Manager nodes. Ignored on other node types.",
              "format": "int64",
              "default": 5,
              "title": "Number of authentication failures that trigger API lockout",
              "minimum": 0,
              "type": "integer"
            },
            "api_failed_auth_lockout_period": {
              "description": "Once a lockout occurs, the account remains locked out of the API for this time period. Only applies to NSX Manager nodes. Ignored on other node types.",
              "format": "int64",
              "default": 900,
              "title": "Lockout period in seconds",
              "minimum": 0,
              "type": "integer"
            },
            "cli_max_auth_failures": {
              "description": "Number of authentication failures that trigger CLI lockout",
              "format": "int64",
              "default": 5,
              "title": "Number of authentication failures that trigger CLI lockout",
              "minimum": 0,
              "type": "integer"
            }
          },
          "type": "object"
        }
      ],
      "description": "Configuration of authentication policies for the NSX node",
      "title": "Configuration of authentication policies for the NSX node"
    },
    "RouteMapListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/RouteMap"
              },
              "type": "array",
              "description": "Paginated list of RouteMaps",
              "title": "Paginated list of RouteMaps"
            }
          }
        }
      ]
    },
    "ServiceProfileListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/ServiceProfile"
              },
              "type": "array",
              "description": "service profile list results",
              "title": "service profile list results"
            }
          }
        }
      ]
    },
    "IpfixObsPointsListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/IpfixObsPointConfig"
              },
              "type": "array",
              "description": "IPFIX observation points",
              "title": "IPFIX observation points"
            }
          },
          "type": "object"
        }
      ],
      "description": "List of logical IPFIX observation points",
      "title": "List of logical IPFIX observation points"
    },
    "RealizedLogicalPort": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyRealizedResource"
        },
        {
          "properties": {
            "logical_port_id": {
              "readOnly": true,
              "type": "string",
              "description": "The id of the logical port",
              "title": "The id of the logical port"
            },
            "status": {
              "readOnly": true,
              "enum": [
                "UP",
                "DOWN",
                "UNKNOWN"
              ],
              "type": "string",
              "description": "The Operational status of the logical port",
              "title": "The Operational status of the logical port"
            }
          },
          "type": "object"
        }
      ],
      "description": "Realized Logical Port",
      "title": "Realized Logical Port"
    },
    "LogicalServiceListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LogicalService"
              },
              "type": "array",
              "description": "Logical router service list results",
              "title": "Logical router service list results"
            }
          }
        }
      ]
    },
    "InterfaceStatistics": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "type": "object",
          "properties": {
            "rx_packets": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Count of packets received on this port",
              "title": "Count of packets received on this port"
            },
            "rx_errors": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Count of receive errors occurring on this port",
              "title": "Count of receive errors occurring on this port"
            },
            "rx_bytes": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Count of bytes received on this port",
              "title": "Count of bytes received on this port"
            },
            "tx_errors": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Count of transmit errors occurring on this port",
              "title": "Count of transmit errors occurring on this port"
            },
            "tx_bytes": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Count of bytes transmitted on this port",
              "title": "Count of bytes transmitted on this port"
            },
            "tx_packets": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Count of packets transmitted on this port",
              "title": "Count of packets transmitted on this port"
            }
          }
        }
      ]
    },
    "NodeProcessPropertiesListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/NodeProcessProperties"
              },
              "type": "array",
              "description": "Node process property results",
              "title": "Node process property results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Node process property query results",
      "title": "Node process property query results"
    },
    "CipherSuite": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enable status for this cipher suite",
          "title": "Enable status for this cipher suite"
        },
        "name": {
          "type": "string",
          "description": "Name of the TLS cipher suite",
          "title": "Name of the TLS cipher suite"
        }
      },
      "required": [
        "enabled",
        "name"
      ],
      "type": "object",
      "description": "HTTP cipher suite",
      "title": "HTTP cipher suite"
    },
    "QuickSearchRequest": {
      "required": [
        "query"
      ],
      "type": "object",
      "properties": {
        "query": {
          "type": "string",
          "description": "Search query",
          "title": "Search query"
        },
        "group_count": {
          "description": "Maximum number of groups",
          "title": "Maximum number of groups",
          "default": 10,
          "format": "int64",
          "maximum": 100,
          "minimum": 1,
          "type": "integer"
        },
        "group_size": {
          "description": "Number of items per group",
          "title": "Number of items per group",
          "default": 5,
          "format": "int64",
          "maximum": 100,
          "minimum": 1,
          "type": "integer"
        }
      }
    },
    "MacManagementSwitchingProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/BaseSwitchingProfile"
        },
        {
          "type": "object",
          "properties": {
            "mac_learning": {
              "readOnly": false,
              "title": "MAC learning configuration",
              "description": "MAC learning configuration",
              "$ref": "#/definitions/MacLearningSpec"
            },
            "mac_change_allowed": {
              "default": false,
              "readOnly": false,
              "type": "boolean",
              "description": "Allowing source MAC address change",
              "title": "Allowing source MAC address change"
            }
          }
        }
      ]
    },
    "AwsVpc": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "gateway_info": {
              "readOnly": true,
              "title": "Gateway details for the Vpc",
              "description": "Gateway details for the Vpc",
              "$ref": "#/definitions/AwsGatewayInfo"
            },
            "ami_id": {
              "readOnly": true,
              "type": "string",
              "description": "AMI id",
              "title": "AMI id"
            },
            "instance_stats": {
              "readOnly": true,
              "title": "Managed, unmanaged and error instance counts for the Vpc",
              "type": "object",
              "description": "Managed, unmanaged and error instance counts for the Vpc",
              "$ref": "#/definitions/InstanceStats"
            },
            "region_id": {
              "readOnly": true,
              "type": "string",
              "description": "Id of the AWS region",
              "title": "Id of the AWS region"
            },
            "op_status": {
              "readOnly": true,
              "enum": [
                "NSX_MANAGED",
                "NSX_UNMANAGED"
              ],
              "type": "string",
              "description": "State of the Vpc",
              "title": "State of the Vpc"
            },
            "cidr": {
              "readOnly": true,
              "format": "ipv4_cidr_block",
              "type": "string",
              "description": "IPV4 CIDR Block for the Vpc",
              "title": "IPV4 CIDR Block for the Vpc"
            },
            "is_management_vpc": {
              "default": false,
              "readOnly": true,
              "type": "boolean",
              "description": "Flag to identify if this is the management Vpc",
              "title": "Flag to identify if this is the management Vpc"
            },
            "transport_zones": {
              "items": {
                "$ref": "#/definitions/TransportZoneInfo"
              },
              "readOnly": true,
              "type": "array",
              "description": "Transport zones for the Vpc",
              "title": "Transport zones for the Vpc"
            }
          },
          "type": "object"
        }
      ],
      "description": "Vpc Information",
      "title": "Vpc Information"
    },
    "EdgeClusterMember": {
      "required": [
        "transport_node_id"
      ],
      "type": "object",
      "properties": {
        "member_index": {
          "readOnly": true,
          "format": "int32",
          "type": "integer",
          "description": "System generated index for cluster member",
          "title": "System generated index for cluster member"
        },
        "display_name": {
          "type": "string",
          "description": "display name of edge cluster member",
          "title": "display name of edge cluster member"
        },
        "description": {
          "type": "string",
          "description": "description of edge cluster member",
          "title": "description of edge cluster member"
        },
        "transport_node_id": {
          "type": "string",
          "description": "Identifier of the transport node backed by an Edge node",
          "title": "UUID of edge transport node"
        }
      }
    },
    "AwsRegionsListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/AwsRegion"
              },
              "type": "array",
              "description": "Aws Regions list result",
              "title": "Aws Regions list result"
            }
          },
          "type": "object"
        }
      ],
      "description": "AwsRegions list",
      "title": "AwsRegions list"
    },
    "ServiceProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "server_addresses",
            "resource_type"
          ],
          "type": "object",
          "properties": {
            "server_addresses": {
              "items": {
                "format": "ip",
                "type": "string",
                "description": "IPv4 or IPv6 address"
              },
              "type": "array"
            },
            "resource_type": {
              "type": "string",
              "description": "Resource type of the service profile",
              "enum": [
                "DhcpRelayProfile"
              ]
            }
          }
        }
      ]
    },
    "BridgeEndpoint": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "ha_enable": {
              "default": true,
              "type": "boolean",
              "description": "Controls the enabling of HA on the VLAN for this endpoint",
              "title": "Controls the enabling of HA on the VLAN for this endpoint"
            },
            "bridge_cluster_id": {
              "maxLength": 36,
              "type": "string",
              "description": "UUID of the bridge cluster for this bridge endpoint",
              "title": "UUID of the bridge cluster for this bridge endpoint"
            },
            "vlan": {
              "type": "integer",
              "format": "int64"
            }
          },
          "required": [
            "bridge_cluster_id",
            "vlan"
          ],
          "type": "object"
        }
      ],
      "description": "Bridge Endpoint",
      "title": "Bridge Endpoint"
    },
    "PortConnectionEdgeNodeGroup": {
      "allOf": [
        {
          "$ref": "#/definitions/PortConnectionEntity"
        },
        {
          "properties": {
            "edge_nodes": {
              "items": {
                "$ref": "#/definitions/TransportNode"
              },
              "type": "array"
            },
            "logical_router_id": {
              "type": "string",
              "description": "Id of the logical router",
              "title": "Id of the logical router"
            }
          },
          "required": [
            "logical_router_id"
          ],
          "type": "object"
        }
      ],
      "description": "Collection of edge nodes backing a logical router",
      "title": "Collection of edge nodes backing a logical router"
    },
    "LbStatisticsCounter": {
      "required": [
        "bytes_out",
        "max_sessions",
        "total_sessions",
        "bytes_in",
        "current_sessions"
      ],
      "type": "object",
      "properties": {
        "source_ip_persistence_entry_size": {
          "format": "int64",
          "type": "integer",
          "description": "Number of source IP persistence entries",
          "title": "Number of source IP persistence entries"
        },
        "packets_out": {
          "format": "int64",
          "type": "integer",
          "description": "Number of packets out",
          "title": "Number of packets out"
        },
        "bytes_out_rate": {
          "type": "number",
          "description": "The average number of outbound bytes per second, the number is\naveraged over the last 5 one-second intervals.\n",
          "title": "The average number of outbound bytes per second, the number is\naveraged over the last 5 one-second intervals.\n"
        },
        "total_sessions": {
          "format": "int64",
          "type": "integer",
          "description": "Number of total sessions",
          "title": "Number of total sessions"
        },
        "http_request_rate": {
          "type": "number",
          "description": "The average number of http requests per second, the number is\naveraged over the last 5 one-second intervals.\n",
          "title": "The average number of http requests per second, the number is\naveraged over the last 5 one-second intervals.\n"
        },
        "bytes_out": {
          "format": "int64",
          "type": "integer",
          "description": "Number of bytes out",
          "title": "Number of bytes out"
        },
        "packets_in_rate": {
          "type": "number",
          "description": "The average number of inbound packets per second, the number is\naveraged over the last 5 one-second intervals.\n",
          "title": "The average number of inbound packets per second, the number is\naveraged over the last 5 one-second intervals.\n"
        },
        "bytes_in_rate": {
          "type": "number",
          "description": "The average number of inbound bytes per second, the number is\naveraged over the last 5 one-second intervals.\n",
          "title": "The average number of inbound bytes per second, the number is\naveraged over the last 5 one-second intervals.\n"
        },
        "current_sessions": {
          "format": "int64",
          "type": "integer",
          "description": "Number of current sessions",
          "title": "Number of current sessions"
        },
        "max_sessions": {
          "format": "int64",
          "type": "integer",
          "description": "Number of maximum sessions",
          "title": "Number of maximum sessions"
        },
        "packets_out_rate": {
          "type": "number",
          "description": "The average number of outbound packets per second, the number is\naveraged over the last 5 one-second intervals.\n",
          "title": "The average number of outbound packets per second, the number is\naveraged over the last 5 one-second intervals.\n"
        },
        "bytes_in": {
          "format": "int64",
          "type": "integer",
          "description": "Number of bytes in",
          "title": "Number of bytes in"
        },
        "current_session_rate": {
          "type": "number",
          "description": "The average number of current sessions per second, the number is\naveraged over the last 5 one-second intervals.\n",
          "title": "The average number of current sessions per second, the number is\naveraged over the last 5 one-second intervals.\n"
        },
        "packets_in": {
          "format": "int64",
          "type": "integer",
          "description": "Number of packets in",
          "title": "Number of packets in"
        }
      }
    },
    "NodeNetworkProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "type": "object"
        }
      ],
      "description": "Network configuration properties",
      "title": "Network configuration properties"
    },
    "CommunicationEntry": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "properties": {
            "communication_profile_path": {
              "type": "string",
              "description": "Path of the CommunicationProfile participating in this map",
              "title": "Path of the CommunicationProfile participating in this map"
            },
            "logged": {
              "default": false,
              "readOnly": false,
              "type": "boolean",
              "description": "Flag to enable packet logging. Default is disabled.",
              "title": "Enable logging flag"
            },
            "destination_groups": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "We need paths as duplicate names may exist for groups under different\ndomains.In order to specify all groups, use the constant \"ANY\". This\nis case insensitive. If \"ANY\" is used, it should be the ONLY element\nin the group array. Error will be thrown if ANY is used in conjunction\nwith other values.\n",
              "title": "Destination group paths"
            },
            "sequence_number": {
              "format": "int32",
              "type": "integer",
              "description": "This field is used to resolve conflicts between multiple\nCommunicationEntries under CommunicationMap for a Domain\n",
              "title": "Sequence number of the this CommunicationEntry"
            },
            "source_groups": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "We need paths as duplicate names may exist for groups under different\ndomains. In order to specify all groups, use the constant \"ANY\". This\nis case insensitive. If \"ANY\" is used, it should be the ONLY element\nin the group array. Error will be thrown if ANY is used in conjunction\nwith other values.\n",
              "title": "Source group paths"
            }
          },
          "type": "object"
        }
      ],
      "description": "Binding of source and destination groups to a CommunicationProfile",
      "title": "Binding of source and destination groups to a CommunicationProfile"
    },
    "BaseSwitchingProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "discriminator": "resource_type",
          "required": [
            "resource_type"
          ],
          "type": "object",
          "properties": {
            "required_capabilities": {
              "items": {
                "type": "string"
              },
              "readOnly": true,
              "type": "array"
            },
            "resource_type": {
              "type": "string"
            }
          }
        }
      ]
    },
    "LogicalRouterListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LogicalRouter"
              },
              "type": "array",
              "description": "Logical router list results",
              "title": "Logical router list results"
            }
          }
        }
      ]
    },
    "LogicalPort": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "logical_switch_id",
            "admin_state"
          ],
          "type": "object",
          "properties": {
            "logical_switch_id": {
              "type": "string",
              "description": "Id of the Logical switch that this port belongs to.",
              "title": "Id of the Logical switch that this port belongs to."
            },
            "switching_profile_ids": {
              "items": {
                "$ref": "#/definitions/SwitchingProfileTypeIdEntry"
              },
              "type": "array"
            },
            "attachment": {
              "title": "Logical port attachment",
              "description": "Logical port attachment",
              "$ref": "#/definitions/LogicalPortAttachment"
            },
            "admin_state": {
              "enum": [
                "UP",
                "DOWN"
              ],
              "type": "string",
              "description": "Represents Desired state of the logical port",
              "title": "Represents Desired state of the logical port"
            },
            "address_bindings": {
              "description": "Address bindings for logical port",
              "title": "Address bindings for logical port",
              "minItems": 0,
              "items": {
                "$ref": "#/definitions/PacketAddressClassifier"
              },
              "maxItems": 128,
              "type": "array"
            }
          }
        }
      ]
    },
    "RouteMapSequence": {
      "required": [
        "action",
        "match_criteria"
      ],
      "type": "object",
      "properties": {
        "set_criteria": {
          "title": "Set Criteria for the RouteMap Sequence",
          "description": "Set Criteria for the RouteMap Sequence",
          "$ref": "#/definitions/RouteMapSequenceSet"
        },
        "action": {
          "type": "string",
          "description": "Action for the Sequence",
          "enum": [
            "PERMIT",
            "DENY"
          ]
        },
        "match_criteria": {
          "title": "Match Criteria for the RouteMap Sequence",
          "description": "Match Criteria for the RouteMap Sequence",
          "$ref": "#/definitions/RouteMapSequenceMatch"
        }
      }
    },
    "MACAddressElementListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/MACAddressElement"
              },
              "type": "array",
              "description": "MAC address element list",
              "title": "MAC address element list"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Collection of MAC address elements",
      "title": "Collection of MAC address elements"
    },
    "RealizedGroupUIResource": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "properties": {
            "intent_group": {
              "$ref": "#/definitions/Group"
            },
            "realized_groups": {
              "items": {
                "$ref": "#/definitions/RealizedGroup"
              },
              "type": "array",
              "description": "Realized groups associated to the intent group",
              "title": "Realized groups associated to the intent group"
            }
          },
          "required": [
            "realized_groups"
          ],
          "type": "object"
        }
      ],
      "description": "Realized Groups and associated Intent Group",
      "title": "Realized Groups and associated Intent Group"
    },
    "ClusterProfileTypeIdEntry": {
      "required": [
        "profile_id"
      ],
      "type": "object",
      "properties": {
        "profile_id": {
          "readOnly": false,
          "type": "string",
          "description": "key value"
        },
        "resource_type": {
          "enum": [
            "EdgeHighAvailabilityProfile",
            "BridgeHighAvailabilityClusterProfile"
          ],
          "type": "string",
          "description": "Supported cluster profiles."
        }
      }
    },
    "NSGroupMetaInfo": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "no_of_vms": {
              "format": "int64",
              "type": "integer",
              "description": "Number of VMs discovered for this NSGroup when session was started",
              "title": "Number of VMs discovered for this NSGroup when session was started"
            },
            "ns_group_id": {
              "type": "string",
              "description": "ID of the NS Group",
              "title": "ID of the NS Group"
            }
          },
          "required": [
            "ns_group_id"
          ],
          "type": "object"
        }
      ],
      "description": "Contains the metadata of a NSGroup when the application discovery session\nwas started\n",
      "title": "Metadata about NSGroup"
    },
    "UpgradeUnitList": {
      "required": [
        "list"
      ],
      "type": "object",
      "properties": {
        "list": {
          "items": {
            "$ref": "#/definitions/UpgradeUnit"
          },
          "type": "array",
          "description": "Collection of Upgrade units",
          "title": "Collection of Upgrade units"
        }
      }
    },
    "LogicalSwitchState": {
      "allOf": [
        {
          "$ref": "#/definitions/ConfigurationState"
        },
        {
          "type": "object",
          "properties": {
            "logical_switch_id": {
              "readOnly": true,
              "type": "string",
              "description": "Id of the logical switch",
              "title": "Id of the logical switch"
            }
          }
        }
      ]
    },
    "CreateRemoteDirectoryProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/CopyRemoteFileProperties"
        },
        {
          "required": [
            "protocol"
          ],
          "type": "object",
          "properties": {
            "protocol": {
              "description": "Protocol to use to copy file",
              "title": "Protocol to use to copy file"
            }
          }
        }
      ]
    },
    "SelectableResourceReference": {
      "allOf": [
        {
          "$ref": "#/definitions/ResourceReference"
        },
        {
          "required": [
            "selected"
          ],
          "type": "object",
          "properties": {
            "selected": {
              "type": "boolean",
              "description": "Set to true if this resource has been selected to be acted upon",
              "title": "Set to true if this resource has been selected to be acted upon"
            }
          }
        }
      ]
    },
    "LogicalRouterConfig": {
      "type": "object",
      "properties": {
        "internal_transit_network": {
          "format": "ipv4-cidr-block",
          "type": "string",
          "description": "CIDR block defining Service router to distributed router links"
        },
        "ha_vip_configs": {
          "items": {
            "$ref": "#/definitions/HaVipConfig"
          },
          "type": "array",
          "description": "This configuration can be defined only for Active-Standby LogicalRouter to provide | redundancy. For mulitple uplink ports, multiple HaVipConfigs must be defined | and each config will pair exactly two uplink ports. The VIP will move and will | always be owned by the Active node. Note - when HaVipConfig[s] are defined, | configuring dynamic-routing is disallowed.",
          "title": "Array of HA VIP Config."
        },
        "external_transit_networks": {
          "items": {
            "format": "ipv4-cidr-block",
            "type": "string",
            "description": "IPv4 CIDR Block"
          },
          "type": "array",
          "description": "CIDR block defining tier0 to tier1 links",
          "title": "CIDR block defining tier0 to tier1 links"
        }
      }
    },
    "IpAllocationBase": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "type": "object",
          "properties": {
            "lease_time": {
              "description": "lease time, in seconds, [60-(2^32-1)], default 86400",
              "title": "lease time, in seconds, [60-(2^32-1)], default 86400",
              "default": 86400,
              "format": "int64",
              "maximum": 4294967295,
              "minimum": 60,
              "type": "integer"
            },
            "gateway_ip": {
              "format": "ip",
              "type": "string",
              "description": "gateway ip"
            },
            "options": {
              "title": "dhcp options",
              "description": "If an option is defined at server level and not configred at\nip-pool/static-binding level, the option will be inherited to\nip-pool/static-binding. If both define a same-code option, the\noption defined at ip-pool/static-binding level take precedence\nover that defined at server level.\n",
              "$ref": "#/definitions/DhcpOptions"
            }
          }
        }
      ]
    },
    "LbSnatIpPool": {
      "allOf": [
        {
          "$ref": "#/definitions/LbSnatTranslation"
        },
        {
          "required": [
            "ip_addresses"
          ],
          "type": "object",
          "properties": {
            "ip_addresses": {
              "items": {
                "$ref": "#/definitions/LbSnatIpElement"
              },
              "type": "array",
              "description": "Currently, only one single IP address or IP range is supported.\nIf an IP range is specified, the range may contain no more than 64\nIP addresses.\n",
              "maxItems": 1,
              "title": "List of Ip address or ip range"
            }
          }
        }
      ]
    },
    "PacketsDroppedBySecurity": {
      "type": "object",
      "properties": {
        "spoof_guard_dropped": {
          "items": {
            "$ref": "#/definitions/PacketTypeAndCounter"
          },
          "type": "array",
          "description": "The packets dropped by Spoof Guard; supported packet types are IPv4, IPv6, ARP, ND, non-IP.",
          "title": "The packets dropped by Spoof Guard; supported packet types are IPv4, IPv6, ARP, ND, non-IP."
        },
        "dhcp_server_dropped_ipv4": {
          "format": "int64",
          "type": "integer",
          "description": "The number of IPv4 packets dropped by DHCP server block.",
          "title": "The number of IPv4 packets dropped by DHCP server block."
        },
        "dhcp_server_dropped_ipv6": {
          "format": "int64",
          "type": "integer",
          "description": "The number of IPv6 packets dropped by DHCP server block.",
          "title": "The number of IPv6 packets dropped by DHCP server block."
        },
        "dhcp_client_dropped_ipv4": {
          "format": "int64",
          "type": "integer",
          "description": "The number of IPv4 packets dropped by DHCP client block.",
          "title": "The number of IPv4 packets dropped by DHCP client block."
        },
        "bpdu_filter_dropped": {
          "format": "int64",
          "type": "integer",
          "description": "The number of packets dropped by BPDU filter.",
          "title": "The number of packets dropped by BPDU filter."
        },
        "dhcp_client_dropped_ipv6": {
          "format": "int64",
          "type": "integer",
          "description": "The number of IPv6 packets dropped by DHCP client block.",
          "title": "The number of IPv6 packets dropped by DHCP client block."
        }
      }
    },
    "FirewallStatus": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "global_status": {
              "description": "Firewall status for a fabric entity or in global context where firewall is supported.",
              "enum": [
                "DISABLED",
                "ENABLED"
              ],
              "readOnly": false,
              "type": "string"
            },
            "context": {
              "description": "Types of firewall contexts.",
              "enum": [
                "transport_nodes"
              ],
              "readOnly": false,
              "type": "string"
            }
          },
          "required": [
            "global_status",
            "context"
          ],
          "type": "object"
        }
      ],
      "description": "Firewall Status Response",
      "title": "Firewall Status Response"
    },
    "ResourceReference": {
      "type": "object",
      "description": "A weak reference to an NSX resource.",
      "properties": {
        "target_display_name": {
          "readOnly": true,
          "maxLength": 255,
          "type": "string",
          "description": "Display name of the NSX resource.",
          "title": "Target display name"
        },
        "is_valid": {
          "readOnly": true,
          "type": "boolean",
          "description": "Will be set to false if the referenced NSX resource has been deleted.",
          "title": "Target validity"
        },
        "target_id": {
          "readOnly": false,
          "maxLength": 64,
          "type": "string",
          "description": "Identifier of the NSX resource.",
          "title": "Target ID"
        },
        "target_type": {
          "readOnly": false,
          "maxLength": 255,
          "type": "string",
          "description": "Type of the NSX resource.",
          "title": "Target type"
        }
      }
    },
    "PackageLoggingLevels": {
      "type": "object",
      "properties": {
        "logging_level": {
          "enum": [
            "ERROR",
            "WARN",
            "INFO",
            "DEBUG",
            "TRACE"
          ],
          "type": "string",
          "description": "Logging levels per package",
          "title": "Logging levels per package"
        },
        "package_name": {
          "type": "string",
          "description": "Package name",
          "title": "Package name"
        }
      }
    },
    "RealizedNSServiceListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "title": "Realized nsservice list results",
                "$ref": "#/definitions/RealizedNSService"
              },
              "readOnly": true,
              "type": "array",
              "description": "Paged Collection of realized services",
              "title": "Paged Collection of realized services"
            }
          }
        }
      ]
    },
    "PortConnectionContainersEntities": {
      "properties": {
        "logical_ports": {
          "items": {
            "$ref": "#/definitions/LogicalPort"
          },
          "type": "array"
        }
      },
      "type": "object",
      "description": "Port Connection Containers Entities",
      "title": "Port Connection Containers Entities"
    },
    "X509CrlEntry": {
      "properties": {
        "revocation_date": {
          "readOnly": true,
          "type": "string",
          "description": "Revocation date"
        },
        "serial_number": {
          "readOnly": true,
          "type": "string",
          "description": "the revoked certificate's serial number"
        }
      },
      "type": "object",
      "description": "Each revoked certificate is identified in a CRL by its certificate serial number.",
      "title": "Each revoked certificate is identified in a CRL by its certificate serial number."
    },
    "NsxManagerAccount": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "username": {
              "type": "string",
              "description": "Username of the NSX Manager Account",
              "title": "Username of the NSX Manager Account"
            },
            "public_ip": {
              "type": "string",
              "description": "Public IP Address of the NSX Manager Account",
              "title": "Public IP Address of the NSX Manager Account"
            },
            "token": {
              "type": "string",
              "description": "This field can be used for using one time access token for Nsx Manager\nregistration.\n",
              "title": "One time access token for Nsx Manager registration"
            },
            "private_ip": {
              "type": "string",
              "description": "Private IP Address of the NSX Manager Account",
              "title": "Private IP Address of the NSX Manager Account"
            },
            "thumbprint": {
              "type": "string",
              "description": "Thumb print of the NSX Manager Account",
              "title": "Thumb print of the NSX Manager Account"
            },
            "tenant_id": {
              "type": "string",
              "description": "Tenant ID of the NSX Manager account",
              "title": "Tenant ID of the NSX Manager account"
            },
            "password": {
              "type": "string",
              "description": "Password of the NSX Manager Account",
              "title": "Password of the NSX Manager Account"
            },
            "fqdn": {
              "type": "string",
              "description": "Fully Qualified Domain Name",
              "title": "Fully Qualified Domain Name"
            }
          },
          "required": [
            "username"
          ],
          "type": "object"
        }
      ],
      "description": "NSX Manager Account Structure",
      "title": "NSX Manager Account Structure"
    },
    "LogicalRouterStatus": {
      "required": [
        "logical_router_id"
      ],
      "type": "object",
      "properties": {
        "last_update_timestamp": {
          "readOnly": true,
          "type": "integer",
          "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
          "format": "int64"
        },
        "logical_router_id": {
          "type": "string",
          "description": "The id of the logical router",
          "title": "The id of the logical router"
        },
        "per_node_status": {
          "description": "Per Node Status",
          "title": "Per Node Status",
          "items": {
            "$ref": "#/definitions/LogicalRouterStatusPerNode"
          },
          "readOnly": true,
          "additionalProperties": false,
          "type": "array"
        }
      }
    },
    "ErrorResolverMetadataList": {
      "required": [
        "errors"
      ],
      "type": "object",
      "description": "List of errors with their metadata",
      "properties": {
        "errors": {
          "items": {
            "$ref": "#/definitions/ErrorResolverMetadata"
          },
          "type": "array",
          "description": "List of errors with their corresponding metadata.",
          "title": "List of errors with their corresponding metadata."
        }
      }
    },
    "SoftwareModule": {
      "properties": {
        "module_name": {
          "type": "string",
          "description": "Name of the module in the node",
          "title": "Name of the module in the node"
        },
        "module_version": {
          "type": "string",
          "description": "Version of the module in the node",
          "title": "Version of the module in the node"
        }
      },
      "required": [
        "module_name",
        "module_version"
      ],
      "type": "object",
      "description": "Software module details",
      "title": "Software module details"
    },
    "UplinkHostSwitchProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/BaseHostSwitchProfile"
        },
        {
          "properties": {
            "mtu": {
              "description": "Maximum Transmission Unit used for uplinks",
              "title": "Maximum Transmission Unit used for uplinks",
              "default": 1600,
              "format": "int32",
              "maximum": 9000,
              "minimum": 1280,
              "type": "integer"
            },
            "teaming": {
              "title": "TeamingPolicy associated with this UplinkProfile",
              "description": "TeamingPolicy associated with this UplinkProfile",
              "$ref": "#/definitions/TeamingPolicy"
            },
            "transport_vlan": {
              "default": 0,
              "type": "integer",
              "description": "VLAN used for tagging Overlay traffic of associated HostSwitch",
              "format": "int64"
            },
            "lags": {
              "items": {
                "$ref": "#/definitions/Lag"
              },
              "type": "array",
              "description": "list of LACP group",
              "maxItems": 64,
              "title": "list of LACP group"
            }
          },
          "required": [
            "teaming"
          ],
          "type": "object"
        }
      ],
      "description": "Profile for uplink policies",
      "title": "Profile for uplink policies"
    },
    "Resource": {
      "type": "object",
      "properties": {
        "_self": {
          "readOnly": true,
          "$ref": "#/definitions/SelfResourceLink"
        },
        "_links": {
          "items": {
            "$ref": "#/definitions/ResourceLink"
          },
          "readOnly": true,
          "type": "array",
          "description": "The server will populate this field when returing the resource. Ignored on PUT and POST.",
          "title": "References related to this resource"
        },
        "_schema": {
          "readOnly": true,
          "type": "string"
        }
      }
    },
    "LogicalRouterPortArpCsvRecord": {
      "allOf": [
        {
          "$ref": "#/definitions/CsvRecord"
        },
        {
          "required": [
            "ip",
            "mac_address"
          ],
          "type": "object",
          "properties": {
            "ip": {
              "format": "ip",
              "type": "string",
              "description": "The IP address"
            },
            "mac_address": {
              "type": "string",
              "description": "The MAC address",
              "title": "The MAC address"
            }
          }
        }
      ]
    },
    "HeatMapTransportNodesAggregateStatus": {
      "type": "object",
      "properties": {
        "degraded_count": {
          "format": "int32",
          "type": "integer",
          "description": "Number of transport nodes that are degraded",
          "title": "Number of transport nodes that are degraded"
        },
        "down_count": {
          "format": "int32",
          "type": "integer",
          "description": "Number of transport nodes that are down",
          "title": "Number of transport nodes that are down"
        },
        "unknown_count": {
          "format": "int32",
          "type": "integer",
          "description": "Number of transport nodes with unknown status",
          "title": "Number of transport nodes with unknown status"
        },
        "up_count": {
          "format": "int32",
          "type": "integer",
          "description": "Number of transport nodes that are up",
          "title": "Number of transport nodes that are up"
        }
      }
    },
    "PolicyAlarmResource": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyResource"
        },
        {
          "properties": {
            "path": {
              "type": "string",
              "description": "path of the alarm object",
              "title": "path of the alarm object"
            },
            "message": {
              "type": "string",
              "description": "error message to describe the issue",
              "title": "error message to describe the issue"
            },
            "id": {
              "type": "string",
              "description": "error id for the alarm",
              "title": "error id for the alarm"
            }
          },
          "type": "object"
        }
      ],
      "description": "Alarm base class of realized policy object",
      "title": "Alarm base class of realized policy object"
    },
    "AwsKeyPairList": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/AwsKeyPair"
              },
              "type": "array",
              "description": "Aws Key Pairs list",
              "title": "Aws Key Pairs list"
            }
          },
          "type": "object"
        }
      ],
      "description": "List of Aws Key Pairs",
      "title": "List of Aws Key Pairs"
    },
    "BgpNeighborListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/BgpNeighbor"
              },
              "type": "array",
              "description": "Paginated list of bgp neighbors",
              "title": "Paginated list of bgp neighbors"
            }
          }
        }
      ]
    },
    "AwsAvailabilityZoneInfo": {
      "properties": {
        "display_name": {
          "readOnly": true,
          "type": "string",
          "description": "Display name of the availability zone",
          "title": "Display name of the availability zone"
        },
        "id": {
          "readOnly": true,
          "type": "string",
          "description": "ID of the availability zone",
          "title": "ID of the availability zone"
        }
      },
      "type": "object",
      "description": "Availability Zone information",
      "title": "Availability Zone information"
    },
    "FirewallRuleList": {
      "required": [
        "rules"
      ],
      "type": "object",
      "properties": {
        "rules": {
          "items": {
            "$ref": "#/definitions/FirewallRule"
          },
          "type": "array",
          "description": "List of firewall rules in the section. Only homogenous rules are supported.",
          "maxItems": 1000,
          "title": "List of the firewall rules"
        }
      }
    },
    "AddressBindingEntry": {
      "properties": {
        "source": {
          "description": "Address binding source",
          "default": "UNKNOWN",
          "enum": [
            "INVALID",
            "UNKNOWN",
            "USER_DEFINED",
            "ARP_SNOOPING",
            "DHCP_SNOOPING",
            "VM_TOOLS"
          ],
          "type": "string"
        },
        "binding": {
          "title": "Combination of IP-MAC-VLAN binding",
          "description": "Combination of IP-MAC-VLAN binding",
          "$ref": "#/definitions/PacketAddressClassifier"
        },
        "binding_timestamp": {
          "type": "integer",
          "description": "Timestamp of binding",
          "format": "int64"
        }
      },
      "type": "object",
      "description": "An address binding entry is a combination of the IP-MAC-VLAN binding for\na logical port. The address bindings can be obtained via various methods\nlike ARP snooping, DHCP snooping etc. or by user configuration.\n",
      "title": "Combination of IP-MAC-VLAN binding"
    },
    "BpduFilter": {
      "properties": {
        "white_list": {
          "description": "Pre-defined list of allowed MAC addresses to be excluded from BPDU filtering",
          "title": "Pre-defined list of allowed MAC addresses to be excluded from BPDU filtering",
          "minItems": 0,
          "items": {
            "type": "string"
          },
          "readOnly": false,
          "maxItems": 32,
          "type": "array"
        },
        "enabled": {
          "readOnly": false,
          "type": "boolean",
          "description": "Indicates whether BPDU filter is enabled",
          "title": "Indicates whether BPDU filter is enabled"
        }
      },
      "required": [
        "enabled"
      ],
      "type": "object",
      "description": "BPDU filter configuration",
      "title": "BPDU filter configuration"
    },
    "LbSslCipherInfo": {
      "properties": {
        "is_default": {
          "type": "boolean",
          "description": "Default SSL cipher flag",
          "title": "Default SSL cipher flag"
        },
        "is_secure": {
          "type": "boolean",
          "description": "Secure/insecure SSL cipher flag",
          "title": "Secure/insecure SSL cipher flag"
        },
        "cipher": {
          "type": "string",
          "description": "SSL cipher",
          "enum": [
            "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
            "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
            "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
            "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
            "TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA",
            "TLS_ECDH_RSA_WITH_AES_256_CBC_SHA",
            "TLS_RSA_WITH_AES_256_CBC_SHA",
            "TLS_RSA_WITH_AES_128_CBC_SHA",
            "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
            "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
            "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
            "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384",
            "TLS_RSA_WITH_AES_128_CBC_SHA256",
            "TLS_RSA_WITH_AES_128_GCM_SHA256",
            "TLS_RSA_WITH_AES_256_CBC_SHA256",
            "TLS_RSA_WITH_AES_256_GCM_SHA384",
            "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
            "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
            "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
            "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384",
            "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
            "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA",
            "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256",
            "TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256",
            "TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384",
            "TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384",
            "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA",
            "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256",
            "TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256",
            "TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384",
            "TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384"
          ]
        }
      },
      "required": [
        "is_default",
        "is_secure",
        "cipher"
      ],
      "type": "object",
      "description": "SSL cipher",
      "title": "SSL cipher"
    },
    "DomainDeploymentMapListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/DomainDeploymentMap"
              },
              "type": "array",
              "description": "Domain Deployment Map",
              "title": "Domain Deployment Map"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Paged Collection of Domain Deployment map",
      "title": "Paged Collection of Domain Deployment map"
    },
    "AbstractSpace": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "properties": {
            "connectivity_strategy": {
              "default": "NONE",
              "enum": [
                "WHITELIST",
                "BLACKLIST",
                "NONE"
              ],
              "type": "string",
              "description": "This field indicates the default connectivity policy for the infra\nor tenant space\nWHITELIST - Adds a default drop rule. Administrator can then use \"allow\"\nrules (aka whitelist) to allow traffic between groups\nBLACKLIST - Adds a default allow rule. Admin can then use \"drop\" rules\n(aka blacklist) to block traffic between groups\nNONE - No default rules are added. This is the default setting\n",
              "title": "Connectivity strategy used by this tenant"
            },
            "communication_profiles": {
              "items": {
                "$ref": "#/definitions/CommunicationProfile"
              },
              "type": "array",
              "description": "This field is used while creating or updating the space.\n",
              "title": "CommunicationProfiles under this space"
            }
          },
          "type": "object"
        }
      ],
      "description": "Represents the space in which the policy is being defined",
      "title": "The space in which policy is being defined"
    },
    "UpgradeUnitTypeStats": {
      "type": "object",
      "properties": {
        "node_with_issues_count": {
          "readOnly": true,
          "format": "int32",
          "type": "integer",
          "description": "Number of nodes with issues that may cause upgrade failure",
          "title": "Number of nodes with issues that may cause upgrade failure"
        },
        "node_count": {
          "readOnly": true,
          "format": "int32",
          "type": "integer",
          "description": "Number of nodes",
          "title": "Number of nodes"
        },
        "version": {
          "readOnly": true,
          "type": "string",
          "description": "Version of the upgrade unit",
          "title": "Version of the upgrade unit"
        },
        "type": {
          "readOnly": true,
          "type": "string",
          "description": "Type of upgrade unit",
          "title": "Type of upgrade unit"
        }
      }
    },
    "WidgetConfiguration": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "display_name",
            "resource_type"
          ],
          "discriminator": "resource_type",
          "type": "object",
          "properties": {
            "display_name": {
              "type": "string",
              "description": "Title of the widget.",
              "title": "Widget Title"
            },
            "datasources": {
              "minItems": 0,
              "items": {
                "$ref": "#/definitions/Datasource"
              },
              "type": "array",
              "description": "The 'datasources' represent the sources from which data will be fetched. Currently, only NSX-API is supported as a 'default' datasource. An example of specifying 'default' datasource along with the urls to fetch data from is given at 'example_request' section of 'CreateWidgetConfiguration' API.",
              "title": "Array of Datasource Instances with their relative urls"
            },
            "weight": {
              "default": 10000,
              "format": "int32",
              "type": "integer",
              "description": "Determines placement of widget or container relative to other widgets and containers. The lower the weight, the higher it is in the placement order.",
              "title": "Weightage or placement of the widget or container"
            },
            "footer": {
              "$ref": "#/definitions/Footer"
            },
            "shared": {
              "default": false,
              "type": "boolean",
              "description": "Defaults to false. Set to true to publish the widgetconfiguration to other users.",
              "title": "Share the widgetconfiguration with other users"
            },
            "resource_type": {
              "readOnly": true,
              "enum": [
                "LabelValueConfiguration",
                "DonutConfiguration",
                "MultiWidgetConfiguration",
                "ContainerConfiguration"
              ],
              "type": "string",
              "description": "Supported visualization types are LabelValueConfiguration, DonutConfiguration, MultiWidgetConfiguration and ContainerConfiguration.",
              "title": "Widget visualization type"
            }
          }
        }
      ],
      "description": "Describes the configuration of a widget to be displayed on the dashboard. WidgetConfiguration is a base type that provides attributes of a widget in-general.",
      "title": "Dashboard Widget Configuration"
    },
    "LbSslCipherAndProtocolListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "ciphers",
            "protocols"
          ],
          "type": "object",
          "properties": {
            "ciphers": {
              "items": {
                "$ref": "#/definitions/LbSslCipherInfo"
              },
              "type": "array",
              "description": "List of SSL ciphers",
              "title": "List of SSL ciphers"
            },
            "protocols": {
              "items": {
                "$ref": "#/definitions/LbSslProtocolInfo"
              },
              "type": "array",
              "description": "List of SSL protocols",
              "title": "List of SSL protocols"
            }
          }
        }
      ]
    },
    "IpAddressInfo": {
      "properties": {
        "source": {
          "readOnly": true,
          "enum": [
            "VM_TOOLS"
          ],
          "type": "string",
          "description": "Source of the ipaddress information.",
          "title": "Source of the ipaddress information."
        },
        "ip_addresses": {
          "items": {
            "format": "ip",
            "type": "string",
            "description": "IPv4 or IPv6 address"
          },
          "readOnly": true,
          "type": "array",
          "description": "IP Addresses of the the virtual network interface, as discovered in the source.",
          "title": "IP Addresses of the the virtual network interface, as discovered in the source."
        }
      },
      "type": "object",
      "description": "Ipaddress information of the fabric node.",
      "title": "Ipaddress information of the fabric node."
    },
    "NodeServiceProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "service_name": {
              "type": "string",
              "description": "Service name",
              "title": "Service name"
            }
          },
          "required": [
            "service_name"
          ],
          "type": "object"
        }
      ],
      "description": "Node service properties",
      "title": "Node service properties"
    },
    "IpfixCollector": {
      "required": [
        "collector_ip_address"
      ],
      "type": "object",
      "properties": {
        "collector_ip_address": {
          "format": "ip",
          "type": "string",
          "description": "IP address for the IPFIX collector"
        },
        "collector_port": {
          "description": "Port for the IPFIX collector",
          "title": "Port for the IPFIX collector",
          "default": 4739,
          "format": "int32",
          "maximum": 65535,
          "minimum": 0,
          "type": "integer"
        }
      }
    },
    "RateLimits": {
      "properties": {
        "rx_multicast": {
          "description": "Incoming multicast traffic limit in packets per second",
          "title": "Incoming multicast traffic limit in packets per second",
          "default": 0,
          "format": "int32",
          "readOnly": false,
          "minimum": 0,
          "type": "integer"
        },
        "tx_multicast": {
          "description": "Outgoing multicast traffic limit in packets per second",
          "title": "Outgoing multicast traffic limit in packets per second",
          "default": 0,
          "format": "int32",
          "readOnly": false,
          "minimum": 0,
          "type": "integer"
        },
        "enabled": {
          "default": false,
          "readOnly": false,
          "type": "boolean",
          "description": "Whether rate limiting is enabled",
          "title": "Whether rate limiting is enabled"
        },
        "tx_broadcast": {
          "description": "Outgoing broadcast traffic limit in packets per second",
          "title": "Outgoing broadcast traffic limit in packets per second",
          "default": 0,
          "format": "int32",
          "readOnly": false,
          "minimum": 0,
          "type": "integer"
        },
        "rx_broadcast": {
          "description": "Incoming broadcast traffic limit in packets per second",
          "title": "Incoming broadcast traffic limit in packets per second",
          "default": 0,
          "format": "int32",
          "readOnly": false,
          "minimum": 0,
          "type": "integer"
        }
      },
      "type": "object",
      "description": "Enables traffic limit for incoming/outgoing broadcast and multicast packets. Use 0 to disable rate limiting for a specific traffic type",
      "title": "Rate limiting configuration"
    },
    "RealizedIPSetListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "title": "Realized IPSet list result",
                "$ref": "#/definitions/RealizedIPSet"
              },
              "type": "array",
              "description": "Paged Collection of Realized IPSets",
              "title": "Paged Collection of Realized IPSets"
            }
          }
        }
      ]
    },
    "ErrorInfo": {
      "properties": {
        "timestamp": {
          "readOnly": true,
          "type": "integer",
          "description": "Timestamp when the error occurred",
          "format": "int64"
        },
        "error_message": {
          "readOnly": true,
          "type": "string",
          "description": "Error message",
          "title": "Error message"
        }
      },
      "type": "object",
      "description": "Error information",
      "title": "Error information"
    },
    "SshKeyProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/SshKeyBaseProperties"
        },
        {
          "required": [
            "type",
            "value"
          ],
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "description": "SSH key type",
              "title": "SSH key type"
            },
            "value": {
              "type": "string",
              "description": "SSH key value",
              "title": "SSH key value"
            }
          }
        }
      ]
    },
    "IpfixConfigListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/IpfixConfig"
              },
              "readOnly": true,
              "type": "array",
              "description": "IPFIX Config",
              "title": "IPFIX Config"
            }
          },
          "type": "object"
        }
      ],
      "description": "List of IPFIX Config",
      "title": "List of IPFIX Config"
    },
    "TraceflowObservationReceived": {
      "allOf": [
        {
          "$ref": "#/definitions/TraceflowObservation"
        },
        {
          "type": "object",
          "properties": {
            "vtep_label": {
              "format": "int64",
              "type": "integer",
              "description": "The virtual tunnel endpoint label",
              "title": "The virtual tunnel endpoint label"
            },
            "uplink_name": {
              "type": "string",
              "description": "The name of the uplink the traceflow packet is received on",
              "title": "The name of the uplink the traceflow packet is received on"
            },
            "local_ip_address": {
              "format": "ip",
              "type": "string",
              "description": "IP address of the destination end of the tunnel"
            },
            "remote_ip_address": {
              "format": "ip",
              "type": "string",
              "description": "IP address of the source end of the tunnel"
            }
          }
        }
      ]
    },
    "Service": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "properties": {
            "service_entries": {
              "items": {
                "$ref": "#/definitions/ServiceEntry"
              },
              "type": "array",
              "description": "Service type",
              "title": "Service type"
            }
          },
          "required": [
            "service_entries"
          ],
          "type": "object"
        }
      ],
      "description": "Used while defining a CommunicationProfileEntry. A service may have multiple\nservice entries.\n",
      "title": "Contains the information related to a service"
    },
    "RealizedSecurityGroupListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "title": "Security Group list results",
                "$ref": "#/definitions/RealizedSecurityGroup"
              },
              "readOnly": true,
              "type": "array",
              "description": "Paged Collection of realized Security Groups",
              "title": "Paged Collection of realized Security Groups"
            }
          }
        }
      ]
    },
    "VerifiableAsymmetricLoginCredential": {
      "allOf": [
        {
          "$ref": "#/definitions/LoginCredential"
        },
        {
          "type": "object",
          "properties": {
            "asymmetric_credential": {
              "type": "string",
              "description": "Asymmetric login credential",
              "title": "Asymmetric login credential"
            },
            "credential_verifier": {
              "type": "string",
              "description": "Credential verifier",
              "title": "Credential verifier"
            },
            "credential_key": {
              "type": "string",
              "description": "Credential key",
              "title": "Credential key"
            }
          }
        }
      ]
    },
    "VifAttachmentContext": {
      "allOf": [
        {
          "$ref": "#/definitions/AttachmentContext"
        },
        {
          "required": [
            "vif_type"
          ],
          "type": "object",
          "properties": {
            "vif_type": {
              "enum": [
                "PARENT",
                "CHILD",
                "INDEPENDENT"
              ],
              "type": "string",
              "description": "Type of the VIF attached to logical port",
              "title": "Type of the VIF attached to logical port"
            },
            "parent_vif_id": {
              "type": "string",
              "description": "VIF ID of the parent VIF if vif_type is CHILD",
              "title": "VIF ID of the parent VIF if vif_type is CHILD"
            },
            "traffic_tag": {
              "format": "int32",
              "type": "integer",
              "description": "Current we use VLAN id as the traffic tag.\nOnly effective when vif_type is CHILD.\nEach logical port inside a container must have a\nunique traffic tag. If the traffic_tag is not\nunique, no error is generated, but traffic will\nnot be delivered to any port with a non-unique tag.\n",
              "title": "Tag used for the traffic between this VIF and parent VIF"
            },
            "app_id": {
              "type": "string",
              "description": "An application ID used to identify / look up a child VIF\nbehind a parent VIF. Only effective when vif_type is CHILD.\n",
              "title": "ID used to identify/look up a child VIF behind a parent VIF"
            }
          }
        }
      ]
    },
    "AwsGatewayConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "ami_id": {
              "type": "string",
              "description": "The ID of the Amazon Machine Image on which this gateway resides\n",
              "title": "AMI id"
            },
            "nsx_manager_connection": {
              "enum": [
                "PUBLIC_IP",
                "PRIVATE_IP"
              ],
              "type": "string",
              "description": "Determines if connection to NSX Manager is via public IP or private IP\n",
              "title": "Determines if connection to NSX Manager is via public IP or private IP\n"
            },
            "gateway_ha_configuration": {
              "items": {
                "$ref": "#/definitions/AwsGatewayHaConfig"
              },
              "type": "array",
              "description": "Aws Gateway HA configuration",
              "title": "Aws Gateway HA configuration"
            },
            "is_ha_enabled": {
              "type": "boolean",
              "description": "Flag to identify if HA is enabled",
              "title": "Flag to identify if HA is enabled"
            },
            "default_quarantine_policy_enabled": {
              "type": "boolean",
              "description": "Flag to identify if default quarantine policy is enabled",
              "title": "Flag to identify if default quarantine policy is enabled"
            },
            "key_pair_name": {
              "type": "string",
              "description": "The key pair name required to authenticate into any instance",
              "title": "The key pair name required to authenticate into any instance"
            }
          },
          "type": "object"
        }
      ],
      "description": "Aws gateway configuration",
      "title": "Aws gateway configuration"
    },
    "IpPoolSubnet": {
      "description": "A set of IPv4 or IPv6 addresses defined by a network CIDR.",
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "required": [
            "cidr",
            "allocation_ranges"
          ],
          "type": "object",
          "properties": {
            "dns_nameservers": {
              "description": "The collection of upto 3 DNS servers for the subnet.",
              "title": "The collection of upto 3 DNS servers for the subnet.",
              "items": {
                "format": "ip",
                "type": "string",
                "description": "IPv4 or IPv6 address"
              },
              "maxItems": 3,
              "uniqueItems": true,
              "type": "array"
            },
            "cidr": {
              "type": "string",
              "description": "Represents network address and the prefix length which will be associated with a layer-2 broadcast domain",
              "title": "Represents network address and the prefix length which will be associated with a layer-2 broadcast domain"
            },
            "gateway_ip": {
              "format": "ip",
              "type": "string",
              "description": "The default gateway address on a layer-3 router."
            },
            "allocation_ranges": {
              "items": {
                "$ref": "#/definitions/IpPoolRange"
              },
              "type": "array",
              "description": "A collection of IPv4 or IPv6 IP Pool Ranges.",
              "title": "A collection of IPv4 or IPv6 IP Pool Ranges."
            },
            "dns_suffix": {
              "type": "string",
              "description": "The DNS suffix for the DNS server.",
              "title": "The DNS suffix for the DNS server."
            }
          }
        }
      ]
    },
    "CommunicationProfileEntry": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "properties": {
            "services": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "In order to specify all services, use the constant \"ANY\".\nThis is case insensitive. If \"ANY\" is used, it should\nbe the ONLY element in the services array. Error will be thrown\nif ANY is used in conjunction with other values.\n",
              "title": "Names of services that forms this CommunicationProfileEntry"
            },
            "action": {
              "enum": [
                "ALLOW",
                "DROP",
                "REJECT"
              ],
              "type": "string",
              "description": "This action will apply on the all the services specified in the\nabove array.\n",
              "title": "Action"
            },
            "sequence_number": {
              "format": "int32",
              "type": "integer",
              "description": "This field is used to resolve conflicts between multiple\nCommunicationProfileEntries under CommunicationProfile for a Domain.\nThis will be used to resolve conflicts when there are multiple\nCommunicationProfileEntries under a CommunicationProfile that refer\nto the same Service, but have conflicting.\n",
              "title": "Sequence number of the this CommunicationProfileEntry"
            }
          },
          "required": [
            "services",
            "action"
          ],
          "type": "object"
        }
      ],
      "description": "Specifies the service along with the action",
      "title": "Specifies the service along with the action"
    },
    "NodeInterfaceStatisticsProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "tx_dropped": {
              "format": "int64",
              "type": "integer",
              "description": "Number of packets dropped",
              "title": "Number of packets dropped"
            },
            "rx_packets": {
              "format": "int64",
              "type": "integer",
              "description": "Number of packets received",
              "title": "Number of packets received"
            },
            "tx_carrier": {
              "format": "int64",
              "type": "integer",
              "description": "Number of carrier losses detected",
              "title": "Number of carrier losses detected"
            },
            "rx_bytes": {
              "format": "int64",
              "type": "integer",
              "description": "Number of bytes received",
              "title": "Number of bytes received"
            },
            "tx_errors": {
              "format": "int64",
              "type": "integer",
              "description": "Number of transmit errors",
              "title": "Number of transmit errors"
            },
            "interface_id": {
              "type": "string",
              "description": "Interface ID",
              "title": "Interface ID"
            },
            "tx_colls": {
              "format": "int64",
              "type": "integer",
              "description": "Number of collisions detected",
              "title": "Number of collisions detected"
            },
            "rx_frame": {
              "format": "int64",
              "type": "integer",
              "description": "Number of framing errors",
              "title": "Number of framing errors"
            },
            "rx_errors": {
              "format": "int64",
              "type": "integer",
              "description": "Number of receive errors",
              "title": "Number of receive errors"
            },
            "tx_bytes": {
              "format": "int64",
              "type": "integer",
              "description": "Number of bytes transmitted",
              "title": "Number of bytes transmitted"
            },
            "rx_dropped": {
              "format": "int64",
              "type": "integer",
              "description": "Number of packets dropped",
              "title": "Number of packets dropped"
            },
            "tx_packets": {
              "format": "int64",
              "type": "integer",
              "description": "Number of packets transmitted",
              "title": "Number of packets transmitted"
            },
            "source": {
              "type": "string",
              "description": "Source of status data.",
              "enum": [
                "realtime",
                "cached"
              ]
            }
          },
          "type": "object"
        }
      ],
      "description": "Node network interface statistic properties",
      "title": "Node network interface statistic properties"
    },
    "DneRuleListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/DneRule"
              },
              "readOnly": true,
              "type": "array",
              "description": "DNE rule list result with pagination support.",
              "title": "DNE rule list result"
            }
          }
        }
      ]
    },
    "UpgradeHistoryList": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/UpgradeHistory"
              },
              "readOnly": true,
              "type": "array",
              "description": "Upgrade history list",
              "title": "Upgrade history list"
            }
          }
        }
      ]
    },
    "InstanceStats": {
      "properties": {
        "vcpus": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "The number of virtual CPUs.",
          "title": "Virtual CPUs"
        },
        "managed": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "The number of instances with status MANAGED.",
          "title": "Managed Instances"
        },
        "error": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "The number of instances with status ERROR.",
          "title": "Error Instances"
        },
        "unmanaged": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "The number of instances with status UNMANAGED.",
          "title": "Unmanaged Instances"
        },
        "total": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "The total number of instances.",
          "title": "Total number of instances"
        },
        "powered_off": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "The number of instances with status POWERED OFF.",
          "title": "Powered Off Instances"
        }
      },
      "type": "object",
      "description": "Instance statistics",
      "title": "Instance statistics"
    },
    "Filter": {
      "required": [
        "name",
        "value"
      ],
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the filter.",
          "title": "The name of the filter."
        },
        "value": {
          "type": "string",
          "description": "The value of the filter.",
          "title": "The value of the filter."
        }
      }
    },
    "InstallUpgradeServiceProperties": {
      "properties": {
        "enabled_on": {
          "readOnly": true,
          "type": "string",
          "description": "IP of manager on which install-upgrade is enabled",
          "title": "IP of manager on which install-upgrade is enabled"
        },
        "enabled": {
          "type": "boolean",
          "description": "True if service enabled; otherwise, false",
          "title": "True if service enabled; otherwise, false"
        }
      },
      "required": [
        "enabled"
      ],
      "type": "object",
      "description": "install-upgrade service properties",
      "title": "install-upgrade service properties"
    },
    "FirewallSection": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "stateful",
            "section_type"
          ],
          "type": "object",
          "properties": {
            "stateful": {
              "readOnly": false,
              "type": "boolean",
              "description": "Stateful or Stateless nature of firewall section is enforced on all rules inside the section. Layer3 sections can be stateful or stateless. Layer2 sections can only be stateless.",
              "title": "Stateful nature of the firewall rules in the section."
            },
            "is_default": {
              "readOnly": true,
              "type": "boolean",
              "description": "It is a boolean flag which reflects whether a firewall section is default section or not. Each Layer 3 and Layer 2 section will have at least and at most one default section.",
              "title": "Default section flag"
            },
            "applied_tos": {
              "description": "List of objects where the rules in this section will be enforced. This will take precedence over rule level appliedTo.",
              "title": "AppliedTo List",
              "items": {
                "$ref": "#/definitions/ResourceReference"
              },
              "readOnly": false,
              "maxItems": 128,
              "type": "array"
            },
            "rule_count": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Number of rules in this section.",
              "title": "Rule count"
            },
            "section_type": {
              "readOnly": false,
              "enum": [
                "LAYER2",
                "LAYER3"
              ],
              "type": "string",
              "description": "Type of the rules which a section can contain. Only homogeneous sections are supported.",
              "title": "Section Type"
            }
          }
        }
      ]
    },
    "BridgeEndpointStatus": {
      "type": "object",
      "properties": {
        "active_nodes": {
          "items": {
            "type": "string"
          },
          "readOnly": true,
          "type": "array",
          "description": "The Ids of the transport nodes which actively serve the endpoint.",
          "title": "The Ids of the transport nodes which actively serve the endpoint."
        },
        "last_update_timestamp": {
          "readOnly": true,
          "type": "integer",
          "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
          "format": "int64"
        },
        "endpoint_id": {
          "readOnly": true,
          "type": "string",
          "description": "The id of the bridge endpoint",
          "title": "The id of the bridge endpoint"
        }
      }
    },
    "ComputeManager": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "origin_type",
            "server"
          ],
          "type": "object",
          "properties": {
            "credential": {
              "readOnly": false,
              "title": "Login credentials for the compute manager",
              "description": "Login credentials for the compute manager",
              "$ref": "#/definitions/LoginCredential"
            },
            "origin_properties": {
              "items": {
                "$ref": "#/definitions/KeyValuePair"
              },
              "readOnly": true,
              "type": "array",
              "description": "Key-Value map of additional specific properties of compute manager",
              "title": "Key-Value map of additional specific properties of compute manager"
            },
            "origin_type": {
              "readOnly": false,
              "type": "string",
              "description": "Compute manager type like vCenter",
              "title": "Compute manager type like vCenter"
            },
            "server": {
              "readOnly": false,
              "format": "hostname-or-ip",
              "type": "string",
              "description": "IP address or hostname of compute manager",
              "title": "IP address or hostname of compute manager"
            }
          }
        }
      ]
    },
    "FilterRequest": {
      "properties": {
        "field_names": {
          "type": "string",
          "description": "Comma seperated fields to be filtered on",
          "title": "Field Names"
        },
        "value": {
          "type": "string",
          "description": "Filter value",
          "title": "Value"
        }
      },
      "required": [
        "field_names",
        "value"
      ],
      "type": "object",
      "description": "Filter request parameters",
      "title": "Filter request"
    },
    "BFDStatusCount": {
      "type": "object",
      "properties": {
        "bfd_admin_down_count": {
          "format": "int32",
          "type": "integer",
          "description": "Number of tunnels in BFD admin down state",
          "title": "Number of tunnels in BFD admin down state"
        },
        "bfd_up_count": {
          "format": "int32",
          "type": "integer",
          "description": "Number of tunnels in BFD up state",
          "title": "Number of tunnels in BFD up state"
        },
        "bfd_down_count": {
          "format": "int32",
          "type": "integer",
          "description": "Number of tunnels in BFD down state",
          "title": "Number of tunnels in BFD down state"
        },
        "bfd_init_count": {
          "format": "int32",
          "type": "integer",
          "description": "Number of tunnels in BFD init state",
          "title": "Number of tunnels in BFD init state"
        }
      }
    },
    "ContainerConfiguration": {
      "allOf": [
        {
          "$ref": "#/definitions/WidgetConfiguration"
        },
        {
          "properties": {
            "widgets": {
              "minItems": 0,
              "items": {
                "$ref": "#/definitions/WidgetItem"
              },
              "type": "array",
              "description": "If not specified, creates an empty container.",
              "title": "Widgets held by the container"
            },
            "span": {
              "default": 2,
              "format": "int32",
              "type": "integer",
              "description": "Represents the horizontal span of the container.",
              "title": "Number of widgets to be held in this container horizontally"
            }
          },
          "type": "object"
        }
      ],
      "description": "Represents a container to group widgets that belong to a common category or have a common purpose.",
      "title": "Container that holds widgets"
    },
    "PolicyResource": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "path": {
              "readOnly": true,
              "type": "string",
              "description": "Absolute path of this object",
              "title": "Absolute path of this object"
            },
            "relative_path": {
              "readOnly": true,
              "type": "string",
              "description": "Path relative from its parent",
              "title": "Relative path of this object"
            }
          },
          "type": "object"
        }
      ],
      "description": "Abstract base class for all the policy objects",
      "title": "Abstract base class for all the policy objects"
    },
    "AwsGatewayInfo": {
      "type": "object",
      "properties": {
        "gateway_status": {
          "readOnly": true,
          "title": "Array of gateway statuses",
          "description": "Array of gateway statuses",
          "$ref": "#/definitions/AwsGatewayStatus"
        },
        "configuration": {
          "readOnly": true,
          "title": "Configuration of this gateway",
          "description": "Configuration of this gateway",
          "$ref": "#/definitions/AwsGatewayConfig"
        }
      }
    },
    "ConfigurationState": {
      "type": "object",
      "properties": {
        "state": {
          "readOnly": true,
          "enum": [
            "pending",
            "in_progress",
            "success",
            "failed",
            "partial_success",
            "orphaned"
          ],
          "type": "string",
          "description": "Gives details of state of desired configuration",
          "title": "Overall state of desired configuration"
        },
        "details": {
          "items": {
            "$ref": "#/definitions/ConfigurationStateElement"
          },
          "readOnly": true,
          "type": "array",
          "description": "Array of configuration state of various sub systems",
          "title": "Array of configuration state of various sub systems"
        },
        "failure_code": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Error code",
          "title": "Error code"
        },
        "failure_message": {
          "readOnly": true,
          "type": "string",
          "description": "Error message in case of failure",
          "title": "Error message in case of failure"
        }
      }
    },
    "DonutConfiguration": {
      "allOf": [
        {
          "$ref": "#/definitions/WidgetConfiguration"
        },
        {
          "properties": {
            "navigation": {
              "type": "string",
              "description": "Hyperlink of the specified UI page that provides details.",
              "title": "Navigation to a specified UI page"
            },
            "display_count": {
              "default": true,
              "type": "boolean",
              "description": "If true, displays the count of entities in the donut",
              "title": "Show or hide the count of entities"
            },
            "sections": {
              "minItems": 1,
              "items": {
                "$ref": "#/definitions/DonutSection"
              },
              "type": "array",
              "description": "Sections",
              "title": "Sections"
            },
            "label": {
              "title": "Label of the Donut Configuration",
              "description": "Displayed at the middle of the donut, by default. It labels the entities of donut.",
              "$ref": "#/definitions/Label"
            }
          },
          "required": [
            "sections",
            "label"
          ],
          "type": "object"
        }
      ],
      "description": "Represents configuration of a Donut",
      "title": "Donut Configuration"
    },
    "ConjunctionOperator": {
      "allOf": [
        {
          "$ref": "#/definitions/Expression"
        },
        {
          "properties": {
            "conjunction_operator": {
              "enum": [
                "OR",
                "AND"
              ],
              "type": "string",
              "description": "Conjunction Operator Node",
              "title": "Conjunction Operator Node"
            }
          },
          "required": [
            "conjunction_operator"
          ],
          "type": "object"
        }
      ],
      "description": "Represents the operators AND or OR",
      "title": "Represents the operators AND or OR"
    },
    "BfdConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "receive_interval": {
              "description": "the time interval (in milliseconds) between heartbeat packets for BFD when receiving heartbeats.",
              "title": "Receive interval for heartbeats",
              "default": 1000,
              "format": "int64",
              "maximum": 60000,
              "minimum": 100,
              "type": "integer"
            },
            "declare_dead_multiple": {
              "description": "Number of times a packet is missed before BFD declares the neighbor down.",
              "title": "Number of times a packet is missed before BFD declares the neighbor down.",
              "default": 3,
              "format": "int64",
              "maximum": 16,
              "minimum": 2,
              "type": "integer"
            },
            "enabled": {
              "default": false,
              "type": "boolean",
              "description": "Flag to enable BFD for this LogicalRouter",
              "title": "Flag to enable BFD for this LogicalRouter"
            },
            "logical_router_id": {
              "readOnly": true,
              "type": "string",
              "description": "Logical router id",
              "title": "Logical router id"
            },
            "transmit_interval": {
              "description": "the time interval (in milliseconds) between heartbeat packets for BFD when sending heartbeats.",
              "title": "Transmit interval for heartbeats",
              "default": 1000,
              "format": "int64",
              "maximum": 60000,
              "minimum": 100,
              "type": "integer"
            }
          },
          "type": "object"
        }
      ],
      "description": "BFD configuration for LogicalRouter",
      "title": "BFD configuration for LogicalRouter"
    },
    "FileHash": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "name": {
              "type": "string",
              "description": "File name",
              "title": "File name"
            },
            "hash_type": {
              "enum": [
                "SHA1"
              ],
              "type": "string",
              "description": "Algorithm used to compute the file's hash",
              "title": "Algorithm used to compute the file's hash"
            },
            "hash_code": {
              "type": "string",
              "description": "Computed hash of file",
              "title": "Computed hash of file"
            }
          },
          "required": [
            "name",
            "hash_type",
            "hash_code"
          ],
          "type": "object"
        }
      ],
      "description": "File hash code",
      "title": "File hash code"
    },
    "ComputeManagerListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/ComputeManager"
              },
              "type": "array",
              "description": "List of compute managers",
              "title": "List of compute managers"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "List of compute managers",
      "title": "List of compute managers"
    },
    "Pnic": {
      "properties": {
        "uplink_name": {
          "readOnly": false,
          "type": "string",
          "description": "Uplink name for this Pnic. This name will be used to reference this Pnic in other configurations.",
          "title": "Uplink name for this Pnic. This name will be used to reference this Pnic in other configurations."
        },
        "device_name": {
          "readOnly": false,
          "type": "string",
          "description": "device name or key",
          "title": "device name or key"
        }
      },
      "required": [
        "uplink_name",
        "device_name"
      ],
      "type": "object",
      "description": "Physical NIC specification",
      "title": "Physical NIC specification"
    },
    "Icon": {
      "properties": {
        "placement": {
          "default": "PRE",
          "enum": [
            "PRE",
            "POST"
          ],
          "type": "string",
          "description": "If specified as PRE, the icon appears before the UI element. If set as POST, the icon appears after the UI element.",
          "title": "Position at which to display icon, if any"
        },
        "type": {
          "enum": [
            "ERROR",
            "WARNING",
            "INFO",
            "INPROGRESS",
            "SUCCESS",
            "DETAIL",
            "NOT_AVAILABLE"
          ],
          "type": "string",
          "description": "Icon will be rendered based on its type. For example, if ERROR is chosen, then icon representing error will be rendered.",
          "title": "Type of icon"
        },
        "tooltip": {
          "items": {
            "$ref": "#/definitions/Tooltip"
          },
          "type": "array",
          "description": "Multi-line text to be shown on tooltip while hovering over the icon.",
          "title": "Multi-line tooltip"
        }
      },
      "type": "object",
      "description": "Icon to be applied at dashboard for widgets and UI elements.",
      "title": "Icon"
    },
    "SupportBundleResult": {
      "type": "object",
      "properties": {
        "request_properties": {
          "readOnly": true,
          "title": "Request properties",
          "description": "Request properties",
          "$ref": "#/definitions/SupportBundleRequest"
        },
        "remaining_nodes": {
          "items": {
            "$ref": "#/definitions/RemainingSupportBundleNode"
          },
          "type": "array",
          "description": "Nodes where bundle generation is pending or in progress",
          "title": "Nodes where bundle generation is pending or in progress"
        },
        "success_nodes": {
          "items": {
            "$ref": "#/definitions/SuccessNodeSupportBundleResult"
          },
          "readOnly": true,
          "type": "array",
          "description": "Nodes whose bundles were successfully copied to remote file server",
          "title": "Nodes whose bundles were successfully copied to remote file server"
        },
        "failed_nodes": {
          "items": {
            "$ref": "#/definitions/FailedNodeSupportBundleResult"
          },
          "readOnly": true,
          "type": "array",
          "description": "Nodes where bundles were not generated or not copied to remote server",
          "title": "Nodes where bundles were not generated or not copied to remote server"
        }
      }
    },
    "LbPersistenceProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "discriminator": "resource_type",
          "required": [
            "resource_type"
          ],
          "type": "object",
          "properties": {
            "persistence_shared": {
              "default": false,
              "type": "boolean",
              "description": "If persistence shared flag is not set in the cookie persistence profile\nbound to a virtual server, it defaults to cookie persistence that is\nprivate to each virtual server and is qualified by the pool. This is\naccomplished by load balancer inserting a cookie with name in the\nformat &lt;name&gt;.&lt;virtual_server_id&gt;.&lt;pool_id&gt;.\nIf persistence shared flag is set in the cookie persistence profile, in\ncookie insert mode, cookie persistence could be shared across multiple\nvirtual servers that are bound to the same pools. The cookie name would\nbe changed to &lt;name&gt;.&lt;profile-id&gt;.&lt;pool-id&gt;.\nIf persistence shared flag is not set in the sourceIp persistence\nprofile bound to a virtual server, each virtual server that the profile\nis bound to maintains its own private persistence table.\nIf persistence shared flag is set in the sourceIp persistence profile,\nall virtual servers the profile is bound to share the same persistence\ntable.\n",
              "title": "Persistence shared flag for the associated virtual servers"
            },
            "resource_type": {
              "enum": [
                "LbCookiePersistenceProfile",
                "LbSourceIpPersistenceProfile"
              ],
              "type": "string",
              "description": "Source-ip persistence ensures all connections from a client (identified by\nIP address) are sent to the same backend server for a specified period.\nCookie persistence allows related client connections, identified by the\nsame cookie in HTTP requests, to be redirected to the same server.\n"
            }
          }
        }
      ]
    },
    "NodeAuthProviderVidmStatus": {
      "properties": {
        "runtime_state": {
          "type": "string",
          "description": "AAA provider vIDM status",
          "title": "AAA provider vIDM status"
        },
        "vidm_enable": {
          "type": "boolean",
          "description": "vIDM enable flag",
          "title": "vIDM enable flag"
        }
      },
      "required": [
        "runtime_state",
        "vidm_enable"
      ],
      "type": "object",
      "description": "Node AAA provider vIDM status",
      "title": "Node AAA provider vIDM status"
    },
    "VirtualMachine": {
      "allOf": [
        {
          "$ref": "#/definitions/DiscoveredResource"
        },
        {
          "required": [
            "host_id",
            "local_id_on_host",
            "external_id",
            "power_state",
            "compute_ids"
          ],
          "type": "object",
          "properties": {
            "source": {
              "title": "Reference of the Host or Public Cloud Gateway that reported the VM",
              "description": "Reference of the Host or Public Cloud Gateway that reported the VM",
              "$ref": "#/definitions/ResourceReference"
            },
            "local_id_on_host": {
              "type": "string",
              "description": "Id of the vm unique within the host.",
              "title": "Id of the vm unique within the host."
            },
            "type": {
              "readOnly": true,
              "enum": [
                "EDGE",
                "SERVICE",
                "REGULAR"
              ],
              "type": "string",
              "description": "Virtual Machine type; Edge, Service VM or other.",
              "title": "Virtual Machine type; Edge, Service VM or other."
            },
            "power_state": {
              "enum": [
                "VM_RUNNING",
                "VM_STOPPED",
                "VM_SUSPENDED",
                "UNKNOWN"
              ],
              "type": "string",
              "description": "Current power state of this virtual machine in the system.",
              "title": "Current power state of this virtual machine in the system."
            },
            "compute_ids": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "List of external compute ids of the virtual machine in the format 'id-type-key:value' , list of external compute ids ['uuid:xxxx-xxxx-xxxx-xxxx', 'moIdOnHost:moref-11', 'instanceUuid:xxxx-xxxx-xxxx-xxxx']",
              "title": "List of external compute ids of the virtual machine in the format 'id-type-key:value' , list of external compute ids ['uuid:xxxx-xxxx-xxxx-xxxx', 'moIdOnHost:moref-11', 'instanceUuid:xxxx-xxxx-xxxx-xxxx']"
            },
            "host_id": {
              "type": "string",
              "description": "Id of the host in which this virtual machine exists.",
              "title": "Id of the host in which this virtual machine exists."
            },
            "external_id": {
              "type": "string",
              "description": "Current external id of this virtual machine in the system.",
              "title": "Current external id of this virtual machine in the system."
            }
          }
        }
      ]
    },
    "PortMirroringSessionListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/PortMirroringSession"
              },
              "readOnly": true,
              "type": "array",
              "description": "Port mirroring session results",
              "title": "Port mirroring session results"
            }
          },
          "type": "object"
        }
      ],
      "description": "Mirror session queries result",
      "title": "Mirror session queries result"
    },
    "LbPool": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "type": "object",
          "properties": {
            "member_group": {
              "title": "Load balancer member setting with grouping object",
              "description": "Load balancer pool support grouping object as dynamic pool members.\nWhen member group is defined, members setting should not be specified.\n",
              "$ref": "#/definitions/PoolMemberGroup"
            },
            "snat_translation": {
              "title": "snat translation configuration",
              "description": "Depending on the topology, Source NAT (SNAT) may be required to ensure\ntraffic from the server destined to the client is received by the load\nbalancer. SNAT can be enabled per pool. If SNAT is not enabled for a\npool, then load balancer uses the client IP and port (spoofing) while\nestablishing connections to the servers. This is referred to as no-SNAT\nor TRANSPARENT mode.\n",
              "$ref": "#/definitions/LbSnatTranslation"
            },
            "algorithm": {
              "description": "Load balancing algorithm, configurable per pool controls how the\nincoming connections are distributed among the members.\n",
              "default": "ROUND_ROBIN",
              "enum": [
                "ROUND_ROBIN",
                "WEIGHTED_ROUND_ROBIN",
                "LEAST_CONNECTION",
                "IP_HASH"
              ],
              "type": "string"
            },
            "members": {
              "items": {
                "$ref": "#/definitions/PoolMember"
              },
              "type": "array",
              "description": "Server pool consists of one or more pool members. Each pool member\nis identified, typically, by an IP address and a port.\n",
              "title": "load balancer pool members"
            },
            "passive_monitor_id": {
              "type": "string",
              "description": "Passive healthchecks are disabled by default and can be enabled by\nattaching a passive health monitor to a server pool.\nEach time a client connection to a pool member fails, its failed count\nis incremented. For pools bound to L7 virtual servers, a connection is\nconsidered to be failed and failed count is incremented if any TCP\nconnection errors (e.g. TCP RST or failure to send data) or SSL\nhandshake failures occur. For pools bound to L4 virtual servers, if no\nresponse is received to a TCP SYN sent to the pool member or if a TCP\nRST is received in response to a TCP SYN, then the pool member is\nconsidered to have failed and the failed count is incremented.\n",
              "title": "passive monitor identifier"
            },
            "tcp_multiplexing_number": {
              "description": "The maximum number of TCP connections per pool that are idly kept alive\nfor sending future client requests.\n",
              "format": "int64",
              "default": 6,
              "title": "maximum number of TCP connections for multiplexing",
              "minimum": 0,
              "type": "integer"
            },
            "active_monitor_ids": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "In case of active healthchecks, load balancer itself initiates new\nconnections (or sends ICMP ping) to the servers periodically to check\ntheir health, completely independent of any data traffic. Active\nhealthchecks are disabled by default and can be enabled for a server\npool by binding a health monitor to the pool. Currently, only one active\nhealth monitor can be configured per server pool.\n",
              "title": "active monitor identifier list"
            },
            "tcp_multiplexing_enabled": {
              "default": false,
              "type": "boolean",
              "description": "TCP multiplexing allows the same TCP connection between load balancer\nand the backend server to be used for sending multiple client requests\nfrom different client TCP connections.\n",
              "title": "TCP multiplexing enable flag"
            },
            "min_active_members": {
              "description": "A pool is considered active if there are at least certain\nminimum number of members.\n",
              "format": "int64",
              "default": 1,
              "title": "minimum number of active pool members to consider pool as active",
              "minimum": 1,
              "type": "integer"
            }
          }
        }
      ]
    },
    "EdgeClusterListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/EdgeCluster"
              },
              "type": "array",
              "description": "Edge cluster list results",
              "title": "Edge cluster list results"
            }
          }
        }
      ]
    },
    "FeatureUsage": {
      "description": "feature usage result item",
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "type": "object",
          "properties": {
            "capacity_usage": {
              "items": {
                "$ref": "#/definitions/CapacityUsage"
              },
              "readOnly": true,
              "type": "array",
              "description": "Capacity Usage List",
              "title": "Capacity Usage List"
            },
            "feature": {
              "readOnly": true,
              "type": "string",
              "description": "name of the feature",
              "title": "name of the feature"
            }
          }
        }
      ]
    },
    "RoleBinding": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "type": {
              "readOnly": true,
              "enum": [
                "remote_user",
                "remote_group"
              ],
              "type": "string",
              "description": "Type",
              "title": "Type"
            },
            "name": {
              "readOnly": true,
              "type": "string",
              "description": "User/Group's name",
              "title": "User/Group's name"
            },
            "roles": {
              "items": {
                "$ref": "#/definitions/Role"
              },
              "readOnly": true,
              "type": "array",
              "description": "Roles",
              "title": "Roles"
            }
          },
          "type": "object"
        }
      ],
      "description": "User/Group's role binding",
      "title": "User/Group's role binding"
    },
    "RegistrationToken": {
      "properties": {
        "token": {
          "type": "string",
          "description": "Access token",
          "title": "Access token"
        },
        "roles": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "List results",
          "title": "List results"
        }
      },
      "required": [
        "token",
        "roles"
      ],
      "type": "object",
      "description": "Appliance registration access token",
      "title": "Appliance registration access token"
    },
    "Datasource": {
      "properties": {
        "display_name": {
          "type": "string",
          "description": "Name of a datasource instance.",
          "title": "Datasource instance's display name"
        },
        "urls": {
          "items": {
            "$ref": "#/definitions/UrlAlias"
          },
          "type": "array",
          "description": "Array of urls relative to the datasource configuration. For example, api/v1/fabric/nodes is a relative url of nsx-manager instance.",
          "title": "Array of relative urls and their aliases"
        }
      },
      "required": [
        "display_name",
        "urls"
      ],
      "type": "object",
      "description": "An instance of a datasource configuration.",
      "title": "Datasource Instance"
    },
    "NodeRegistrationMessage": {
      "required": [
        "node",
        "msg_client_info"
      ],
      "type": "object",
      "properties": {
        "node": {
          "title": "Information for node",
          "description": "Information for node",
          "$ref": "#/definitions/Node"
        },
        "msg_client_info": {
          "title": "MessageClientInfo used by the Node to connect to message bus",
          "description": "MessageClientInfo used by the Node to connect to message bus",
          "$ref": "#/definitions/MsgClientInfo"
        }
      }
    },
    "NodeSyslogExporterPropertiesListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/NodeSyslogExporterProperties"
              },
              "type": "array",
              "description": "Node syslog exporter results",
              "title": "Node syslog exporter results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Node syslog exporter list results",
      "title": "Node syslog exporter list results"
    },
    "GatewayStats": {
      "properties": {
        "down": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Gateways with status DOWN",
          "title": "Gateways with status DOWN"
        },
        "up": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Gateways with status UP",
          "title": "Gateways with status UP"
        },
        "deploying": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Gateways with status DEPLOYING",
          "title": "Gateways with status DEPLOYING"
        }
      },
      "type": "object",
      "description": "Gateway statistics",
      "title": "Gateway statistics"
    },
    "VniRange": {
      "description": "A range of virtual network identifiers (VNIs)",
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "required": [
            "start",
            "end"
          ],
          "type": "object",
          "properties": {
            "start": {
              "description": "Start value for vni range to be used for virtual networks",
              "title": "Start value of vni range",
              "format": "int64",
              "maximum": 16777215,
              "readOnly": false,
              "minimum": 5000,
              "type": "integer"
            },
            "end": {
              "description": "End value for vni range to be used for virtual networks",
              "title": "End value of vni range",
              "format": "int64",
              "maximum": 16777215,
              "readOnly": false,
              "minimum": 5000,
              "type": "integer"
            }
          }
        }
      ]
    },
    "RoutingConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "type": "object",
          "properties": {
            "forwarding_up_timer": {
              "default": 0,
              "format": "int64",
              "type": "integer",
              "description": "Defines the extra time the router must wait before sending the UP notification\nafter the first BGP session is established. Default means forward immediately.\n",
              "title": "Forwarding up timer"
            },
            "logical_router_id": {
              "readOnly": true,
              "type": "string",
              "description": "Logical router id",
              "title": "Logical router id"
            }
          }
        }
      ]
    },
    "FirewallStats": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "type": "object",
          "properties": {
            "packet_count": {
              "readOnly": true,
              "type": "string",
              "description": "Aggregated number of packets processed by the rule.",
              "title": "packets count"
            },
            "byte_count": {
              "readOnly": true,
              "type": "string",
              "description": "Aggregated number of bytes processed by the rule.",
              "title": "bytes count"
            },
            "rule_id": {
              "readOnly": true,
              "type": "string",
              "description": "Rule Identifier of the Firewall rule. This is a globally unique number.",
              "title": "Firewall rule Id"
            },
            "total_session_count": {
              "readOnly": true,
              "type": "string",
              "description": "Aggregated number of sessions processed by the all firewall rules",
              "title": "Total Sessions count"
            },
            "session_count": {
              "readOnly": true,
              "type": "string",
              "description": "Aggregated number of sessions processed by the rule",
              "title": "sessions count"
            }
          }
        }
      ]
    },
    "NodeProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "kernel_version": {
              "readOnly": true,
              "type": "string",
              "description": "Kernel version",
              "title": "Kernel version"
            },
            "system_time": {
              "readOnly": true,
              "type": "integer",
              "description": "Current time expressed in milliseconds since epoch",
              "format": "int64"
            },
            "node_uuid": {
              "maxLength": 36,
              "type": "string",
              "description": "Node Unique Identifier",
              "title": "Node Unique Identifier"
            },
            "motd": {
              "description": "Message of the day to display when users login to node using the NSX CLI",
              "title": "Message of the day to display when users login to node using the NSX CLI"
            },
            "cli_timeout": {
              "format": "int64",
              "minimum": 0,
              "type": "integer",
              "description": "NSX CLI inactivity timeout, set to 0 to configure no timeout",
              "title": "NSX CLI inactivity timeout, set to 0 to configure no timeout"
            },
            "bios_uuid": {
              "readOnly": true,
              "type": "string",
              "description": "Node BIOS Unique Indentifier",
              "title": "Node BIOS Unique Indentifier"
            },
            "timezone": {
              "type": "string",
              "description": "Timezone",
              "title": "Timezone"
            },
            "hostname": {
              "pattern": "/^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/",
              "type": "string",
              "description": "Host name or fully qualified domain name of node"
            },
            "node_version": {
              "readOnly": true,
              "type": "string",
              "description": "Node version",
              "title": "Node version"
            }
          },
          "type": "object"
        }
      ],
      "description": "Node properties",
      "title": "Node properties"
    },
    "UpgradeUnitStatusListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/UpgradeUnitStatus"
              },
              "type": "array",
              "description": "Paged Collection of upgrade units status",
              "title": "Paged Collection of upgrade units status"
            }
          }
        }
      ]
    },
    "PortStatus": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "indicates if the RabbitMQ management port is set or not",
          "title": "indicates if the RabbitMQ management port is set or not"
        }
      },
      "required": [
        "enabled"
      ],
      "type": "object",
      "description": "indicates if the RabbitMQ management port is set or not",
      "title": "indicates if the RabbitMQ management port is set or not"
    },
    "TransportProtocolHeader": {
      "type": "object",
      "properties": {
        "icmp_echo_request_header": {
          "title": "ICMP echo request header",
          "description": "ICMP echo request header",
          "$ref": "#/definitions/IcmpEchoRequestHeader"
        },
        "tcp_header": {
          "title": "TCP header",
          "description": "TCP header",
          "$ref": "#/definitions/TcpHeader"
        },
        "udp_header": {
          "title": "UDP header",
          "description": "UDP header",
          "$ref": "#/definitions/UdpHeader"
        }
      }
    },
    "BfdConfigParameters": {
      "properties": {
        "receive_interval": {
          "description": "the time interval (in milliseconds) between heartbeat packets for BFD when receiving heartbeats.",
          "title": "the time interval (in milliseconds) between heartbeat packets for BFD when receiving heartbeats.",
          "default": 1000,
          "format": "int64",
          "maximum": 60000,
          "minimum": 300,
          "type": "integer"
        },
        "declare_dead_multiple": {
          "description": "Number of times a packet is missed before BFD declares the neighbor down.",
          "title": "Number of times a packet is missed before BFD declares the neighbor down.",
          "default": 3,
          "format": "int64",
          "maximum": 16,
          "minimum": 2,
          "type": "integer"
        },
        "transmit_interval": {
          "description": "the time interval (in milliseconds) between heartbeat packets for BFD when sending heartbeats.",
          "title": "the time interval (in milliseconds) between heartbeat packets for BFD when sending heartbeats.",
          "default": 1000,
          "format": "int64",
          "maximum": 60000,
          "minimum": 300,
          "type": "integer"
        }
      },
      "type": "object",
      "description": "BFD configuration for the given Peer.",
      "title": "BFD configuration for the given Peer."
    },
    "ConfigurationStateElement": {
      "type": "object",
      "properties": {
        "sub_system_address": {
          "readOnly": true,
          "type": "string",
          "description": "URI of backing resource on sub system",
          "title": "URI of backing resource on sub system"
        },
        "state": {
          "readOnly": true,
          "enum": [
            "in_progress",
            "success",
            "failed",
            "partial_success"
          ],
          "type": "string",
          "description": "State of configuration on this sub system",
          "title": "State of configuration on this sub system"
        },
        "sub_system_type": {
          "readOnly": true,
          "type": "string",
          "description": "Type of backing resource on sub system",
          "title": "Type of backing resource on sub system"
        },
        "failure_message": {
          "readOnly": true,
          "type": "string",
          "description": "Error message in case of failure",
          "title": "Error message in case of failure"
        },
        "failure_code": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Error code",
          "title": "Error code"
        },
        "sub_system_id": {
          "readOnly": true,
          "type": "string",
          "description": "Identifier of backing resource on sub system",
          "title": "Identifier of backing resource on sub system"
        }
      }
    },
    "AwsGatewaysListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/AwsGatewayDeployConfig"
              },
              "type": "array",
              "description": "Vpc list",
              "title": "Vpc list"
            }
          },
          "type": "object"
        }
      ],
      "description": "Vpc list",
      "title": "Vpc list"
    },
    "IPProtocolServiceEntry": {
      "allOf": [
        {
          "$ref": "#/definitions/ServiceEntry"
        },
        {
          "properties": {
            "protocol_number": {
              "type": "integer",
              "format": "int64"
            }
          },
          "required": [
            "protocol_number"
          ],
          "type": "object"
        }
      ],
      "description": "A ServiceEntry that represents an IP protocol",
      "title": "A ServiceEntry that represents an IP protocol"
    },
    "UpgradeUnitGroupInfo": {
      "type": "object",
      "properties": {
        "display_name": {
          "readOnly": true,
          "type": "string",
          "description": "Name of the group",
          "title": "Name of the group"
        },
        "id": {
          "readOnly": true,
          "type": "string",
          "description": "Identifier of group",
          "title": "UUID of group"
        }
      }
    },
    "AwsGatewayAmisListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/AwsGatewayAmiInfo"
              },
              "type": "array",
              "description": "Aws Gateway amis list",
              "title": "Aws Gateway amis list"
            }
          },
          "type": "object"
        }
      ],
      "description": "List of Aws Gateway amis",
      "title": "List of Aws Gateway amis"
    },
    "RealizedSecurityGroupMemberEvaluation": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyRealizedResource"
        },
        {
          "properties": {
            "virtual_machines": {
              "items": {
                "$ref": "#/definitions/RealizedVirtualMachine"
              },
              "readOnly": true,
              "type": "array",
              "description": "list of virtual machines",
              "title": "list of virtual machines"
            },
            "member_count": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Count of the members added to this Security Group",
              "title": "Count of the members added to this Security Group"
            }
          },
          "type": "object"
        }
      ],
      "description": "Realized Security Group member evaluation",
      "title": "Realized Security Group member evaluation"
    },
    "LbVirtualServerStatistics": {
      "required": [
        "statistics",
        "virtual_server_id"
      ],
      "type": "object",
      "properties": {
        "last_update_timestamp": {
          "type": "integer",
          "description": "Timestamp when the data was last updated",
          "format": "int64"
        },
        "statistics": {
          "title": "Virtual server statistics counter",
          "description": "Virtual server statistics counter",
          "$ref": "#/definitions/LbStatisticsCounter"
        },
        "virtual_server_id": {
          "type": "string",
          "description": "load balancer virtual server identifier",
          "title": "load balancer virtual server identifier"
        }
      }
    },
    "BackupConfiguration": {
      "required": [
        "inventory_summary_interval",
        "backup_enabled",
        "remote_file_server"
      ],
      "type": "object",
      "properties": {
        "backup_schedule": {
          "title": "Set when backups should be taken - on a weekly schedule or at regular intervals.",
          "description": "Set when backups should be taken - on a weekly schedule or at regular intervals.",
          "$ref": "#/definitions/BackupSchedule"
        },
        "remote_file_server": {
          "title": "The server to which backups will be sent.",
          "description": "The server to which backups will be sent.",
          "$ref": "#/definitions/RemoteFileServer"
        },
        "passphrase": {
          "type": "string",
          "description": "Passphrase used to encrypt backup files.",
          "title": "Passphrase used to encrypt backup files."
        },
        "backup_enabled": {
          "default": false,
          "type": "boolean",
          "description": "true if automated backup is enabled",
          "title": "true if automated backup is enabled"
        },
        "inventory_summary_interval": {
          "description": "The minimum number of seconds between each upload of the inventory summary to backup server.",
          "title": "The minimum number of seconds between each upload of the inventory summary to backup server.",
          "default": 300,
          "format": "int64",
          "maximum": 3600,
          "minimum": 30,
          "type": "integer"
        }
      }
    },
    "ComputeCollection": {
      "allOf": [
        {
          "$ref": "#/definitions/DiscoveredResource"
        },
        {
          "type": "object",
          "properties": {
            "origin_id": {
              "readOnly": true,
              "type": "string",
              "description": "Id of the compute manager from where this Compute Collection was discovered",
              "title": "Id of the compute manager from where this Compute Collection was discovered"
            },
            "origin_properties": {
              "items": {
                "$ref": "#/definitions/KeyValuePair"
              },
              "readOnly": true,
              "type": "array",
              "description": "Key-Value map of additional specific properties of\ncompute collection in the Compute Manager\n",
              "title": "Key-Value map of additional specific properties of\ncompute collection in the Compute Manager\n"
            },
            "external_id": {
              "readOnly": true,
              "type": "string",
              "description": "External ID of the ComputeCollection in the source Compute manager,\ne.g. mo-ref in VC\n",
              "title": "External ID of the ComputeCollection in the source Compute manager,\ne.g. mo-ref in VC\n"
            },
            "owner_id": {
              "readOnly": true,
              "type": "string",
              "description": "Id of the owner of compute collection in the Compute Manager",
              "title": "Id of the owner of compute collection in the Compute Manager"
            },
            "origin_type": {
              "readOnly": true,
              "type": "string",
              "description": "ComputeCollection type like VC_Cluster. Here the Compute Manager\ntype prefix would help in differentiating similar named Compute\nCollection types from different Compute Managers\n",
              "title": "ComputeCollection type like VC_Cluster. Here the Compute Manager\ntype prefix would help in differentiating similar named Compute\nCollection types from different Compute Managers\n"
            },
            "cm_local_id": {
              "readOnly": true,
              "type": "string",
              "description": "Local Id of the compute collection in the Compute Manager",
              "title": "Local Id of the compute collection in the Compute Manager"
            }
          }
        }
      ]
    },
    "DataCounter": {
      "required": [
        "total"
      ],
      "type": "object",
      "properties": {
        "total": {
          "format": "int64",
          "type": "integer",
          "description": "The total packets or bytes",
          "title": "The total packets or bytes"
        },
        "multicast_broadcast": {
          "format": "int64",
          "type": "integer",
          "description": "The multicast and broadcast packets or bytes",
          "title": "The multicast and broadcast packets or bytes"
        },
        "dropped": {
          "format": "int64",
          "type": "integer",
          "description": "The dropped packets or bytes",
          "title": "The dropped packets or bytes"
        }
      }
    },
    "HttpProtocol": {
      "allOf": [
        {
          "$ref": "#/definitions/Protocol"
        },
        {
          "required": [
            "name"
          ],
          "type": "object",
          "properties": {
            "name": {
              "enum": [
                "http"
              ],
              "type": "string",
              "description": "Protocol name",
              "title": "Protocol name"
            },
            "authentication_scheme": {
              "description": "Scheme to authenticate if required",
              "title": "Scheme to authenticate if required"
            }
          }
        }
      ]
    },
    "NSServiceElement": {
      "description": "An NSService element that describes traffic corresponding to an NSService",
      "title": "An NSService element that describes traffic corresponding to an NSService",
      "required": [
        "resource_type"
      ],
      "discriminator": "resource_type",
      "type": "object",
      "properties": {
        "resource_type": {
          "enum": [
            "EtherTypeNSService",
            "IPProtocolNSService",
            "IGMPTypeNSService",
            "ICMPTypeNSService",
            "ALGTypeNSService",
            "L4PortSetNSService"
          ],
          "type": "string"
        }
      }
    },
    "IPPrefixList": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "prefixes"
          ],
          "type": "object",
          "properties": {
            "prefixes": {
              "description": "Ordered list of PrefixConfig",
              "title": "Ordered list of PrefixConfig",
              "minItems": 1,
              "items": {
                "$ref": "#/definitions/PrefixConfig"
              },
              "maxItems": 1330000,
              "type": "array"
            },
            "logical_router_id": {
              "readOnly": true,
              "type": "string",
              "description": "Logical router id",
              "title": "Logical router id"
            }
          }
        }
      ]
    },
    "LogicalRouter": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "router_type"
          ],
          "type": "object",
          "properties": {
            "failover_mode": {
              "enum": [
                "PREEMPTIVE",
                "NON_PREEMPTIVE"
              ],
              "type": "string",
              "description": "This failover mode determines, whether the preferred service router instance\nfor given logical router will preempt the peer.\nNote - It can be specified if and only if logical router is ACTIVE_STANDBY and\nNON_PREEMPTIVE mode is supported only for a Tier1 logical router. For Tier0 ACTIVE_STANDBY logical router,\nfailover mode is always PREEMPTIVE, i.e. once the preferred node comes up\nafter a failure, it will preempt the peer causing failover from current active to preferred node. For ACTIVE_ACTIVE logical routers, this field must not be populated.\n",
              "title": "Failover mode for active-standby logical router instances."
            },
            "firewall_sections": {
              "items": {
                "$ref": "#/definitions/ResourceReference"
              },
              "readOnly": true,
              "type": "array",
              "description": "List of Firewall sections related to Logical Router.",
              "title": "LR Firewall Section References"
            },
            "advanced_config": {
              "title": "Logical Router Configuration",
              "description": "Contains config properties for tier0 routers",
              "$ref": "#/definitions/LogicalRouterConfig"
            },
            "router_type": {
              "enum": [
                "TIER0",
                "TIER1"
              ],
              "type": "string",
              "description": "Type of Logical Router",
              "title": "Type of Logical Router"
            },
            "preferred_edge_cluster_member_index": {
              "format": "int64",
              "minimum": 0,
              "type": "integer",
              "description": "Used for tier0 routers only",
              "title": "Preferred edge cluster member index in active standby mode\nfor pre-emptive failover\n"
            },
            "high_availability_mode": {
              "enum": [
                "ACTIVE_ACTIVE",
                "ACTIVE_STANDBY"
              ],
              "type": "string",
              "description": "High availability mode",
              "title": "High availability mode"
            },
            "edge_cluster_id": {
              "type": "string",
              "description": "Used for tier0 routers",
              "title": "Identifier of the edge cluster for this Logical Router"
            }
          }
        }
      ]
    },
    "RealizedFirewallSection": {
      "allOf": [
        {
          "$ref": "#/definitions/RealizedFirewall"
        },
        {
          "properties": {
            "rules": {
              "items": {
                "$ref": "#/definitions/RealizedFirewallRule"
              },
              "readOnly": true,
              "type": "array",
              "description": "List of firewall rules in the section.",
              "title": "List of the firewall rules"
            },
            "rule_count": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Number of rules in this section.",
              "title": "Rule count"
            },
            "section_type": {
              "readOnly": true,
              "enum": [
                "LAYER2",
                "LAYER3"
              ],
              "type": "string",
              "description": "Type of the rules which a section can contain.",
              "title": "Section Type"
            }
          },
          "type": "object"
        }
      ],
      "description": "Realized Firewall section",
      "title": "Realized Firewall section"
    },
    "TransportNodeTemplateState": {
      "properties": {
        "state": {
          "readOnly": true,
          "enum": [
            "FAILED_TO_CREATE",
            "IN_PROGRESS",
            "FAILED_TO_REALIZE",
            "SUCCESS"
          ],
          "type": "string",
          "description": "Transport node template state on individual hosts of ComputeCollection\nwhich enabled automated transport code creation.\n'FAILED_TO_CREATE' means transport node isn't created. 'IN_PROGRESS' means\ntransport node is in progress of creation. 'FAILED_TO_REALIZE' means\ntransport node has been created, but failed on host realization, it will\nrepush to host by NSX later. 'SUCCESS' means transport node creation is\nsucceeded.\n",
          "title": "Application state of transport node template on this host"
        },
        "node_id": {
          "type": "string",
          "description": "node id",
          "title": "node id"
        },
        "transport_node_id": {
          "type": "string",
          "description": "transport node id",
          "title": "transport node id"
        }
      },
      "required": [
        "node_id"
      ],
      "type": "object",
      "description": "transport node template application state",
      "title": "transport node template application state"
    },
    "ManagementPlaneBaseNodeInfo": {
      "type": "object",
      "description": "The basic node info of management plane node",
      "properties": {
        "uuid": {
          "readOnly": true,
          "type": "string",
          "description": "Management plane node UUID",
          "title": "Management plane node UUID"
        },
        "mgmt_cluster_listen_ip_address": {
          "readOnly": true,
          "type": "string",
          "description": "The IP address of MP node",
          "title": "The IP address of MP node"
        }
      }
    },
    "AcceptableComponentVersionList": {
      "required": [
        "results"
      ],
      "type": "object",
      "properties": {
        "results": {
          "items": {
            "$ref": "#/definitions/AcceptableComponentVersion"
          },
          "type": "array",
          "description": "Acceptable version whitelist for different components",
          "title": "Acceptable version whitelist for different components"
        }
      }
    },
    "HostNodeAggregateStatus": {
      "properties": {
        "num_nodes_uninstall_successful": {
          "format": "int32",
          "type": "integer",
          "description": "Number of nodes with deployment status uninstall successful",
          "title": "Number of nodes with deployment status uninstall successful"
        },
        "num_nodes_install_failed": {
          "format": "int32",
          "type": "integer",
          "description": "Number of nodes with deployment status install failed",
          "title": "Number of nodes with deployment status install failed"
        },
        "num_nodes_install_in_progress": {
          "format": "int32",
          "type": "integer",
          "description": "Number of nodes with deployment status install in progress",
          "title": "Number of nodes with deployment status install in progress"
        },
        "num_nodes_total": {
          "format": "int32",
          "type": "integer",
          "description": "Total number of nodes irrespective of the deployment status",
          "title": "Total number of nodes irrespective of the deployment status"
        },
        "num_nodes_pending_upgrade": {
          "format": "int32",
          "type": "integer",
          "description": "Number of nodes with deployment status pending upgrade",
          "title": "Number of nodes with deployment status pending upgrade"
        },
        "num_nodes_not_available": {
          "format": "int32",
          "type": "integer",
          "description": "Number of nodes with deployment status not available",
          "title": "Number of nodes with deployment status not available"
        },
        "num_nodes_uninstall_failed": {
          "format": "int32",
          "type": "integer",
          "description": "Number of nodes with deployment status uninstall failed",
          "title": "Number of nodes with deployment status uninstall failed"
        },
        "num_nodes_install_successful": {
          "format": "int32",
          "type": "integer",
          "description": "Number of nodes with deployment status install successful",
          "title": "Number of nodes with deployment status install successful"
        },
        "num_nodes_uninstall_in_progress": {
          "format": "int32",
          "type": "integer",
          "description": "Number of nodes with deployment status uninstall in progress",
          "title": "Number of nodes with deployment status uninstall in progress"
        },
        "num_nodes_upgrade_in_progress": {
          "format": "int32",
          "type": "integer",
          "description": "Number of nodes with deployment status upgrade in progress",
          "title": "Number of nodes with deployment status upgrade in progress"
        },
        "last_sync_time": {
          "type": "integer",
          "description": "Timestamp of the last successful update of Inventory, in epoch milliseconds",
          "format": "int64"
        },
        "aggregate_type": {
          "enum": [
            "GROUPED_HOSTS",
            "STANDALONE_HOSTS",
            "UNMANGED_HOSTS"
          ],
          "type": "string",
          "description": "Type of object for which status aggregated",
          "title": "Type of object for which status aggregated"
        },
        "num_nodes_not_prepared": {
          "format": "int32",
          "type": "integer",
          "description": "Number of nodes with deployment status not prepared",
          "title": "Number of nodes with deployment status not prepared"
        },
        "deployment_status": {
          "enum": [
            "SUCCESSFUL",
            "ERROR",
            "UNKNOWN"
          ],
          "type": "string",
          "description": "Indicates the deployment status of nsx bits on a grouped hosts or standalone hosts\nor unmanaged hosts\n",
          "title": "Indicates the deployment status of nsx bits on a grouped hosts or standalone hosts\nor unmanaged hosts\n"
        }
      },
      "type": "object",
      "description": "Aggregate runtime status information of nodes in grouped hosts or standalone hosts\nor unmanaged hosts\n",
      "title": "Aggregate runtime status information of nodes in grouped hosts or standalone hosts\nor unmanaged hosts\n"
    },
    "Endpoint": {
      "properties": {
        "ip": {
          "description": "Depending upon the EndpointIpConfig used in HostSwitch, IP could be allocated either from DHCP (default) or from Static IP Pool.",
          "format": "ip",
          "readOnly": true,
          "type": "string"
        },
        "subnet_mask": {
          "description": "Subnet mask",
          "format": "ip",
          "readOnly": true,
          "type": "string"
        },
        "default_gateway": {
          "description": "Gateway IP",
          "format": "ip",
          "readOnly": true,
          "type": "string"
        },
        "label": {
          "readOnly": true,
          "format": "int32",
          "type": "integer",
          "description": "Unique label for this Endpoint",
          "title": "Unique label for this Endpoint"
        },
        "device_name": {
          "readOnly": true,
          "type": "string",
          "description": "Name of the virtual tunnel endpoint",
          "title": "Name of the virtual tunnel endpoint"
        }
      },
      "type": "object",
      "description": "An Endpoint object is part of HostSwitch configuration in TransportNode",
      "title": "Tunnel endpoint configuration"
    },
    "BgpNeighborsStatusListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "logical_router_name": {
              "readOnly": true,
              "type": "string",
              "description": "Name of the logical router",
              "title": "Name of the logical router"
            },
            "last_update_timestamp": {
              "readOnly": true,
              "type": "integer",
              "description": "Timestamp when the data was last updated, unset if data source has never updated the data.",
              "format": "int64"
            },
            "logical_router_id": {
              "readOnly": true,
              "type": "string",
              "description": "Logical router id",
              "title": "Logical router id"
            },
            "results": {
              "description": "Status of BGP neighbors of the logical router",
              "title": "Status of BGP neighbors of the logical router",
              "items": {
                "$ref": "#/definitions/BgpNeighborStatus"
              },
              "readOnly": true,
              "additionalProperties": false,
              "type": "array"
            }
          }
        }
      ]
    },
    "RestoreProperties": {
      "properties": {
        "restore_file": {
          "description": "Restore file",
          "title": "Restore file"
        }
      },
      "required": [
        "restore_file"
      ],
      "type": "object",
      "description": "Restore properties",
      "title": "Restore properties"
    },
    "LbPoolStatus": {
      "required": [
        "pool_id"
      ],
      "type": "object",
      "properties": {
        "status": {
          "enum": [
            "UP",
            "PARTIALLY_UP",
            "PRIMARY_DOWN",
            "DOWN",
            "DETACHED"
          ],
          "type": "string",
          "description": "UP means that all primary members are in UP status.\nPARTIALLY_UP means that some(not all) primary members are in UP\nstatus, the number of these active members is larger or equal to\ncertain number(min_active_members) which is defined in LbPool.\nPRIMARY_DOWN means that less than certain(min_active_members) primary\nmembers are in UP status but backup members are in UP status,\nconnections to this pool would be dispatched to backup members.\nDOWN means that all primary and backup members are DOWN.\nDETACHED means that the pool is not bound to any virtual server.\n",
          "title": "Virtual server status"
        },
        "last_update_timestamp": {
          "type": "integer",
          "description": "Timestamp when the data was last updated",
          "format": "int64"
        },
        "pool_id": {
          "type": "string",
          "description": "Load balancer pool identifier",
          "title": "Load balancer pool identifier"
        },
        "members": {
          "items": {
            "$ref": "#/definitions/LbPoolMemberStatus"
          },
          "type": "array",
          "description": "Status of load balancer pool members",
          "title": "Status of load balancer pool members"
        }
      }
    },
    "ServiceEntryListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/ServiceEntry"
              },
              "type": "array",
              "description": "Service entry list results",
              "title": "Service entry list results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Paged Collection of Service entries",
      "title": "Paged Collection of Service entries"
    },
    "RealizedGroupUIResourceListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/RealizedGroupUIResource"
              },
              "type": "array",
              "description": "Intent and realized group list results",
              "title": "Intent and realized group list results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Paged Collection of Intent and Realized Group Pairs",
      "title": "Paged Collection of Intent and Realized Group Pairs"
    },
    "LbHttpRequestVersionCondition": {
      "allOf": [
        {
          "$ref": "#/definitions/LbRuleCondition"
        },
        {
          "properties": {
            "version": {
              "type": "string",
              "description": "HTTP version",
              "enum": [
                "HTTP_VERSION_1_0",
                "HTTP_VERSION_1_1",
                "HTTP_VERSION_2_0"
              ]
            }
          },
          "required": [
            "version"
          ],
          "type": "object"
        }
      ],
      "description": "This condition is used to match the HTTP protocol version of the HTTP\nrequest messages.\n",
      "title": "Condition to match HTTP protocol version of HTTP requests"
    },
    "ScpProtocol": {
      "allOf": [
        {
          "$ref": "#/definitions/Protocol"
        },
        {
          "required": [
            "ssh_fingerprint",
            "name",
            "authentication_scheme"
          ],
          "type": "object",
          "properties": {
            "ssh_fingerprint": {
              "type": "string",
              "description": "SSH fingerprint of server",
              "title": "SSH fingerprint of server"
            },
            "name": {
              "enum": [
                "scp"
              ],
              "type": "string",
              "description": "Protocol name",
              "title": "Protocol name"
            },
            "authentication_scheme": {
              "description": "Scheme to authenticate if required",
              "title": "Scheme to authenticate if required"
            }
          }
        }
      ]
    },
    "PnicBondStatus": {
      "properties": {
        "status": {
          "enum": [
            "UNKNOWN",
            "UP",
            "DOWN",
            "DEGRADED"
          ],
          "type": "string",
          "description": "Status of pNIC/bond",
          "title": "pNic/bond status"
        },
        "type": {
          "enum": [
            "UNKNOWN_TYPE",
            "PNIC",
            "BOND"
          ],
          "type": "string",
          "description": "type, whether the object is a pNIC or a bond",
          "title": "Object type"
        },
        "name": {
          "type": "string",
          "description": "Name of the pNIC/bond",
          "title": "pNIC/bond name"
        }
      },
      "type": "object",
      "description": "pNIC/bond statuses",
      "title": "pNIC/bond status"
    },
    "ClusterNodeConfigListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/ClusterNodeConfig"
              },
              "type": "array",
              "description": "Cluster node configuration results",
              "title": "Cluster node configuration results"
            }
          }
        }
      ]
    },
    "ClusterBackupInfo": {
      "type": "object",
      "properties": {
        "timestamp": {
          "readOnly": true,
          "type": "integer",
          "description": "timestamp of the cluster backup file",
          "format": "int64"
        },
        "node_id": {
          "readOnly": true,
          "type": "string",
          "description": "ID of the node from which the backup was taken",
          "title": "ID of the node from which the backup was taken"
        },
        "ip_address": {
          "description": "IP address of the node from which the backup was taken",
          "format": "ip",
          "readOnly": true,
          "type": "string"
        }
      }
    },
    "DhcpRelayProfileListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/DhcpRelayProfile"
              },
              "type": "array",
              "description": "Dhcp relay profile list results",
              "title": "Dhcp relay profile list results"
            }
          }
        }
      ]
    },
    "Infra": {
      "allOf": [
        {
          "$ref": "#/definitions/AbstractSpace"
        },
        {
          "properties": {
            "domains": {
              "items": {
                "$ref": "#/definitions/Domain"
              },
              "type": "array",
              "description": "This field is used while creating or updating the infra space.\n",
              "title": "Domains for infra"
            }
          },
          "type": "object"
        }
      ],
      "description": "Infra space related policy",
      "title": "Infra"
    },
    "LogicalRouterRouteTable": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "logical_router_id"
          ],
          "type": "object",
          "properties": {
            "logical_router_name": {
              "readOnly": true,
              "type": "string",
              "description": "Name of the logical router",
              "title": "Name of the logical router"
            },
            "last_update_timestamp": {
              "readOnly": true,
              "type": "integer",
              "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
              "format": "int64"
            },
            "logical_router_id": {
              "type": "string",
              "description": "The id of the logical router",
              "title": "The id of the logical router"
            },
            "results": {
              "items": {
                "$ref": "#/definitions/LogicalRouterRouteEntry"
              },
              "type": "array"
            }
          }
        }
      ]
    },
    "ActionDescriptor": {
      "type": "object",
      "properties": {
        "descriptor": {
          "readOnly": true,
          "type": "string",
          "description": "The URI of the REST routine provider that implements the action",
          "title": "The URI of the REST routine provider that implements the action"
        },
        "description": {
          "readOnly": true,
          "type": "string",
          "description": "A description of what the action does",
          "title": "A description of what the action does"
        },
        "name": {
          "readOnly": true,
          "type": "string",
          "description": "The name of the action",
          "title": "The name of the action"
        },
        "uri": {
          "readOnly": true,
          "type": "string",
          "description": "The URI to use to invoke the action",
          "title": "The URI to use to invoke the action"
        }
      }
    },
    "HttpsProtocol": {
      "allOf": [
        {
          "$ref": "#/definitions/Protocol"
        },
        {
          "required": [
            "sha256_thumbprint",
            "name"
          ],
          "type": "object",
          "properties": {
            "sha256_thumbprint": {
              "type": "string",
              "description": "SSL thumbprint of server",
              "title": "SSL thumbprint of server"
            },
            "name": {
              "enum": [
                "https"
              ],
              "type": "string",
              "description": "Protocol name",
              "title": "Protocol name"
            },
            "authentication_scheme": {
              "description": "Scheme to authenticate if required",
              "title": "Scheme to authenticate if required"
            }
          }
        }
      ]
    },
    "CommunicationEntryListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/CommunicationEntry"
              },
              "type": "array",
              "description": "CommunicationEntry list results",
              "title": "CommunicationEntry list results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Paged Collection of CommunicationEntries",
      "title": "Paged Collection of CommunicationEntries"
    },
    "UpgradeUnitGroupStatusListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/UpgradeUnitGroupStatus"
              },
              "readOnly": true,
              "type": "array",
              "description": "Paged collection of upgrade status for upgrade unit groups",
              "title": "Paged collection of upgrade status for upgrade unit groups"
            }
          }
        }
      ]
    },
    "BgpRouteAggregation": {
      "required": [
        "prefix"
      ],
      "type": "object",
      "properties": {
        "summary_only": {
          "default": true,
          "type": "boolean",
          "description": "Flag to send only summarized route",
          "title": "Flag to send only summarized route"
        },
        "prefix": {
          "format": "ipv4-cidr-block",
          "type": "string",
          "description": "cidr of the aggregate address"
        }
      }
    },
    "ApiError": {
      "type": "object",
      "properties": {
        "error_data": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "details": {
          "type": "string"
        },
        "related_errors": {
          "items": {
            "$ref": "#/definitions/ApiError"
          },
          "type": "array"
        },
        "module_name": {
          "type": "string"
        },
        "error_message": {
          "type": "string"
        },
        "error_code": {
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "NSGroupSimpleExpression": {
      "allOf": [
        {
          "$ref": "#/definitions/NSGroupExpression"
        },
        {
          "properties": {
            "target_resource": {
              "readOnly": true,
              "title": "Reference of the target",
              "description": "Reference of the target. Will be populated when\nthe property is a resource id, the op (operator) is EQUALS and\npopulate_references is set to be true.\n",
              "$ref": "#/definitions/ResourceReference"
            },
            "target_property": {
              "type": "string",
              "description": "Field of the resource on which this expression is evaluated",
              "title": "Field of the resource on which this expression is evaluated"
            },
            "target_type": {
              "type": "string",
              "description": "Type of the resource on which this expression is evaluated",
              "enum": [
                "NSGroup",
                "IPSet",
                "MACSet",
                "LogicalSwitch",
                "LogicalPort",
                "VirtualMachine"
              ]
            },
            "value": {
              "type": "string",
              "description": "Value that satisfies this expression",
              "title": "Value that satisfies this expression"
            },
            "op": {
              "enum": [
                "EQUALS",
                "CONTAINS",
                "STARTSWITH"
              ],
              "type": "string",
              "description": "Operator of the expression",
              "title": "Operator of the expression"
            }
          },
          "required": [
            "target_property",
            "target_type",
            "value",
            "op"
          ],
          "type": "object"
        }
      ],
      "description": "Simple expressions to represent NSGroup membership",
      "title": "Simple expressions to represent NSGroup membership"
    },
    "VtepLabelPoolUsage": {
      "type": "object",
      "description": "Pool usage statistics in a pool",
      "properties": {
        "total_ids": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Total number of IDs in a pool",
          "title": "Total number of IDs in a pool"
        },
        "allocated_ids": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Total number of allocated IDs in a pool",
          "title": "Total number of allocated IDs in a pool"
        },
        "free_ids": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Total number of free IDs in a pool",
          "title": "Total number of free IDs in a pool"
        }
      }
    },
    "AggregateDataRequest": {
      "properties": {
        "primary": {
          "title": "Primary type request",
          "description": "Request parameters for the primary type",
          "$ref": "#/definitions/AggregateRequest"
        },
        "related": {
          "items": {
            "$ref": "#/definitions/RelatedDataRequest"
          },
          "type": "array",
          "description": "Request parameters for the related type",
          "title": "Related type request"
        }
      },
      "required": [
        "primary"
      ],
      "type": "object",
      "description": "Request parameters for the primary and the related resource types",
      "title": "Aggregate data request"
    },
    "CapacityUsage": {
      "description": "usage of each capacity type ex. vm, cpu",
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "type": "object",
          "properties": {
            "usage_count": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "count of number of items of capacity_type",
              "title": "count of number of items of capacity_type"
            },
            "capacity_type": {
              "readOnly": true,
              "type": "string",
              "description": "type of the capacity field",
              "title": "type of the capacity field"
            }
          }
        }
      ]
    },
    "AwsAccount": {
      "allOf": [
        {
          "$ref": "#/definitions/CloudAccount"
        },
        {
          "properties": {
            "status": {
              "readOnly": true,
              "title": "Status of the account",
              "description": "Status of the account",
              "$ref": "#/definitions/AwsAccountStatus"
            },
            "access_key": {
              "readOnly": false,
              "type": "string",
              "description": "Access key of cloud account",
              "title": "Access key of cloud account"
            },
            "regions_count": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Count of the regions available",
              "title": "Count of the regions available"
            },
            "auth_mechanism_iam": {
              "readOnly": false,
              "type": "boolean",
              "description": "Is the AWS authorization mechanism based on Identity and Access\nManagement(IAM) service?\n",
              "title": "Is the AWS authorization mechanism based on Identity and Access\nManagement(IAM) service?\n"
            },
            "gateway_role_name": {
              "readOnly": false,
              "type": "string",
              "description": "Service Role Name for IAM role csm needs to assume",
              "title": "Service Role Name for IAM role csm needs to assume"
            },
            "vpc_stats": {
              "readOnly": true,
              "title": "VPC statistics",
              "description": "VPC statistics",
              "$ref": "#/definitions/VpcStats"
            },
            "has_managed_vpc": {
              "readOnly": true,
              "type": "string",
              "description": "Has a managed VPC?",
              "title": "Has a managed VPC?"
            },
            "secret_key": {
              "readOnly": false,
              "type": "string",
              "description": "Secret key of cloud account",
              "title": "Secret key of cloud account"
            },
            "external_id": {
              "readOnly": false,
              "type": "string",
              "description": "External id for the IAM role csm needs to assume",
              "title": "External id for the IAM role csm needs to assume"
            },
            "iam_role_arn": {
              "readOnly": false,
              "type": "string",
              "description": "Amazon Resource Names (ARNs) uniquely identify AWS resources.\nWe will use it here to identify the IAM role csm needs to assume.\n",
              "title": "Amazon Resource Name for IAM role CSM needs to assume"
            }
          },
          "type": "object"
        }
      ],
      "description": "AWS account",
      "title": "AWS account"
    },
    "LbClientSslProfileListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LbClientSslProfile"
              },
              "type": "array",
              "description": "paginated list of load balancer client SSL profiles",
              "title": "paginated list of load balancer client SSL profiles"
            }
          }
        }
      ]
    },
    "DhcpRelayProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "server_addresses"
          ],
          "type": "object",
          "properties": {
            "server_addresses": {
              "items": {
                "format": "ip",
                "type": "string",
                "description": "IPv4 or IPv6 address"
              },
              "type": "array"
            }
          }
        }
      ]
    },
    "ActionParameter": {
      "type": "object",
      "properties": {
        "action": {
          "enum": [
            "retry",
            "force-sync"
          ],
          "type": "string",
          "description": "Action to be done for the entity configuration.",
          "title": "Action to be done for the entity configuration."
        }
      }
    },
    "StaticRouteNextHop": {
      "type": "object",
      "properties": {
        "blackhole_action": {
          "description": "Action to be taken on matching packets for NULL routes.",
          "enum": [
            "DISCARD"
          ],
          "readOnly": true,
          "type": "string"
        },
        "administrative_distance": {
          "description": "Administrative Distance for the next hop IP",
          "title": "Administrative Distance for the next hop IP",
          "default": 1,
          "format": "int64",
          "maximum": 255,
          "minimum": 1,
          "type": "integer"
        },
        "ip_address": {
          "format": "ipv4",
          "type": "string",
          "description": "Next Hop IP"
        },
        "bfd_enabled": {
          "default": false,
          "readOnly": true,
          "type": "boolean",
          "description": "Status of bfd for this next hop where bfd_enabled = true indicate bfd is enabled for this next hop and bfd_enabled = false indicate bfd peer is disabled or not configured for this next hop.",
          "title": "Status of bfd for this next hop where bfd_enabled = true indicate bfd is enabled for this next hop and bfd_enabled = false indicate bfd peer is disabled or not configured for this next hop."
        },
        "logical_router_port_id": {
          "title": "Reference of logical router port to be used for next hop",
          "description": "Reference of logical router port to be used for next hop",
          "$ref": "#/definitions/ResourceReference"
        }
      }
    },
    "PacketAddressClassifier": {
      "properties": {
        "vlan": {
          "type": "integer",
          "format": "int64"
        },
        "ip_address": {
          "format": "address-or-block-or-range",
          "type": "string",
          "description": "A single IP address or a subnet, e.g. x.x.x.x or x.x.x.x/y"
        },
        "mac_address": {
          "pattern": "/^(([0-9A-Fa-f]{2}[:]){5}([0-9A-Fa-f]{2}))|(([0-9A-Fa-f]{2}[-]){5}([0-9A-Fa-f]{2}))$/",
          "type": "string",
          "description": "A single MAC address"
        }
      },
      "type": "object",
      "description": "A packet is classified to have an address binding, if its address\nconfiguration matches with all user specified properties.\n",
      "title": "Address classifications for a packet"
    },
    "ApplianceManagementTaskProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "status": {
              "description": "Current status of the task",
              "enum": [
                "running",
                "error",
                "success",
                "canceling",
                "canceled",
                "killed"
              ],
              "readOnly": true,
              "type": "string"
            },
            "end_time": {
              "readOnly": true,
              "type": "integer",
              "description": "The end time of the task in epoch milliseconds",
              "format": "int64"
            },
            "async_response_available": {
              "readOnly": true,
              "type": "boolean",
              "description": "True if response for asynchronous request is available",
              "title": "True if response for asynchronous request is available"
            },
            "description": {
              "readOnly": true,
              "type": "string",
              "description": "Description of the task",
              "title": "Description of the task"
            },
            "start_time": {
              "readOnly": true,
              "type": "integer",
              "description": "The start time of the task in epoch milliseconds",
              "format": "int64"
            },
            "cancelable": {
              "readOnly": true,
              "type": "boolean",
              "description": "True if this task can be canceled",
              "title": "True if this task can be canceled"
            },
            "request_method": {
              "readOnly": true,
              "type": "string",
              "description": "HTTP request method",
              "title": "HTTP request method"
            },
            "details": {
              "readOnly": true,
              "type": "object",
              "description": "Details about the task if known",
              "title": "Details about the task if known"
            },
            "progress": {
              "description": "Task progress if known, from 0 to 100",
              "title": "Task progress if known, from 0 to 100",
              "format": "int64",
              "maximum": 100,
              "readOnly": true,
              "minimum": 0,
              "type": "integer"
            },
            "message": {
              "readOnly": true,
              "type": "string",
              "description": "A message describing the disposition of the task",
              "title": "A message describing the disposition of the task"
            },
            "user": {
              "readOnly": true,
              "type": "string",
              "description": "Name of the user who created this task",
              "title": "Name of the user who created this task"
            },
            "id": {
              "readOnly": true,
              "type": "string",
              "description": "Identifier for this task",
              "title": "Identifier for this task"
            },
            "request_uri": {
              "readOnly": true,
              "type": "string",
              "description": "URI of the method invocation that spawned this task",
              "title": "URI of the method invocation that spawned this task"
            }
          },
          "type": "object"
        }
      ],
      "description": "Appliance management task properties",
      "title": "Appliance management task properties"
    },
    "RealizedIPSet": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyRealizedResource"
        },
        {
          "type": "object"
        }
      ],
      "description": "Realized IPSet",
      "title": "Realized IPSet"
    },
    "BridgeClusterStatus": {
      "type": "object",
      "properties": {
        "last_update_timestamp": {
          "readOnly": true,
          "type": "integer",
          "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
          "format": "int64"
        },
        "health": {
          "readOnly": true,
          "enum": [
            "UP",
            "DOWN",
            "DEGRADED",
            "UNKNOWN"
          ],
          "type": "string",
          "description": "The health status of the cluster",
          "title": "The health status of the cluster"
        },
        "cluster_id": {
          "readOnly": true,
          "type": "string",
          "description": "The id of the cluster",
          "title": "The id of the cluster"
        }
      }
    },
    "PerStepRestoreStatus": {
      "type": "object",
      "properties": {
        "description": {
          "readOnly": true,
          "type": "string",
          "description": "A description of the restore status",
          "title": "A description of the restore status"
        },
        "value": {
          "readOnly": true,
          "enum": [
            "INITIAL",
            "RUNNING",
            "SUSPENDED_BY_USER",
            "SUSPENDED_FOR_USER_ACTION",
            "FAILED",
            "SUCCESS"
          ],
          "type": "string",
          "description": "Per step restore status value",
          "title": "Per step restore status value"
        }
      }
    },
    "NodeCapability": {
      "properties": {
        "value": {
          "readOnly": true,
          "type": "string",
          "description": "Value of this capability",
          "title": "Value of this capability"
        },
        "version": {
          "readOnly": true,
          "format": "int32",
          "type": "integer",
          "description": "Version of the capability",
          "title": "Version of the capability"
        },
        "description": {
          "readOnly": true,
          "type": "string",
          "description": "Description of this capability that can be displayed in UI",
          "title": "Description of this capability that can be displayed in UI"
        },
        "key": {
          "readOnly": true,
          "type": "string",
          "description": "String that identifies the base capability for all nodes",
          "title": "String that identifies the base capability for all nodes"
        },
        "provider": {
          "readOnly": true,
          "type": "string",
          "description": "Provider of this capability for the node",
          "title": "Provider of this capability for the node"
        }
      },
      "type": "object",
      "description": "Capability of a fabric node",
      "title": "Capability of a fabric node"
    },
    "Domain": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "properties": {
            "communication_map": {
              "title": "CommunicationMap for this Domain",
              "description": "This field is used while creating or updating the CommunicationMap.\n",
              "$ref": "#/definitions/CommunicationMap"
            },
            "groups": {
              "items": {
                "$ref": "#/definitions/Group"
              },
              "type": "array",
              "description": "This field is used while creating or updating the Domain.\nPlease take a look at the UpdateTenant API documentation for details.\n",
              "title": "Groups under this Domain"
            }
          },
          "type": "object"
        }
      ],
      "description": "Domain",
      "title": "Domain"
    },
    "NodeCapabilitiesResult": {
      "properties": {
        "capabilities": {
          "items": {
            "$ref": "#/definitions/NodeCapability"
          },
          "type": "array",
          "description": "Node capability results",
          "title": "Node capability results"
        }
      },
      "required": [
        "capabilities"
      ],
      "type": "object",
      "description": "List of capabilities of a fabric node",
      "title": "List of capabilities of a fabric node"
    },
    "AppProfileMemberAppsCsvRecord": {
      "allOf": [
        {
          "$ref": "#/definitions/CsvRecord"
        },
        {
          "type": "object",
          "properties": {
            "app_profile_category": {
              "readOnly": true,
              "type": "string",
              "description": "Category of the app profile, value could be any string that describes the profile",
              "title": "Category of the app profile, value could be any string that describes the profile"
            },
            "display_name": {
              "readOnly": true,
              "type": "string",
              "description": "Name of the app profile",
              "title": "Name of the app profile"
            },
            "description": {
              "readOnly": true,
              "type": "string",
              "description": "Description of the app profile",
              "title": "Description of the app profile"
            },
            "member_apps": {
              "readOnly": true,
              "type": "string",
              "description": "Applications that are member of this app profile",
              "title": "Applications that are member of this app profile"
            },
            "app_profile_criteria": {
              "readOnly": true,
              "type": "string",
              "description": "Criteria of the app profile, value could be any string or \"*\" (match any string)",
              "title": "Criteria of the app profile, value could be any string or \"*\" (match any string)"
            }
          }
        }
      ]
    },
    "TraceflowRequest": {
      "required": [
        "packet",
        "lport_id"
      ],
      "type": "object",
      "properties": {
        "packet": {
          "title": "Packet configuration",
          "description": "Packet configuration",
          "$ref": "#/definitions/PacketData"
        },
        "timeout": {
          "description": "Maximum time (in ms) the management plane will wait for observation result list to be sent by controller plane.",
          "title": "Timeout (in ms) for traceflow observations result list",
          "default": 10000,
          "format": "int64",
          "maximum": 15000,
          "minimum": 5000,
          "type": "integer"
        },
        "lport_id": {
          "type": "string",
          "description": "id of the source logical port to inject the traceflow packet into",
          "title": "id of the source logical port to inject the traceflow packet into"
        }
      }
    },
    "DneSectionListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/DneSection"
              },
              "readOnly": true,
              "type": "array",
              "description": "List of DNE sections returned.",
              "title": "DNE Section list"
            }
          }
        }
      ]
    },
    "DneRuleState": {
      "allOf": [
        {
          "$ref": "#/definitions/ConfigurationState"
        },
        {
          "type": "object",
          "properties": {
            "revision_desired": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "revision number of the desired state",
              "title": "revision number of the desired state"
            }
          }
        }
      ]
    },
    "LbTcpMonitor": {
      "allOf": [
        {
          "$ref": "#/definitions/LbActiveMonitor"
        },
        {
          "type": "object",
          "properties": {
            "receive": {
              "type": "string",
              "description": "Expected data, if specified, can be anywhere in the response and it has to\nbe a string, regular expressions are not supported.\n",
              "title": "expected data received from server"
            },
            "send": {
              "type": "string",
              "description": "If both send and receive are not specified, then just a TCP connection\nis established (3-way handshake) to validate server is healthy, no\ndata is sent.\n",
              "title": "data to send"
            }
          }
        }
      ]
    },
    "TransportNodeState": {
      "allOf": [
        {
          "$ref": "#/definitions/ConfigurationState"
        },
        {
          "properties": {
            "host_switch_states": {
              "items": {
                "$ref": "#/definitions/HostSwitchState"
              },
              "readOnly": true,
              "type": "array",
              "description": "States of HostSwitches on the host",
              "title": "States of HostSwitches on the host"
            },
            "maintenance_mode_state": {
              "description": "the present realized maintenance mode state",
              "enum": [
                "ENTERING",
                "ENABLED",
                "EXITING",
                "DISABLED"
              ],
              "readOnly": true,
              "type": "string"
            },
            "transport_node_id": {
              "readOnly": true,
              "type": "string",
              "description": "Unique Id of the TransportNode",
              "title": "Unique Id of the TransportNode"
            }
          },
          "type": "object"
        }
      ],
      "description": "Transport Node State",
      "title": "Transport Node State"
    },
    "LogicalPortListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LogicalPort"
              },
              "readOnly": true,
              "type": "array",
              "description": "LogicalPort Results",
              "title": "LogicalPort Results"
            }
          },
          "type": "object"
        }
      ],
      "description": "Logical port queries result",
      "title": "Logical port queries result"
    },
    "AboveRuleIdParameter": {
      "type": "object",
      "properties": {
        "above_rule_id": {
          "type": "string",
          "description": "Uuid of rule above which this rule is to be inserted",
          "title": "Uuid of rule above which this rule is to be inserted"
        }
      }
    },
    "NatRuleListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/NatRule"
              },
              "type": "array",
              "description": "NAT rule list results",
              "title": "NAT rule list results"
            }
          }
        }
      ]
    },
    "ALGTypeNSService": {
      "allOf": [
        {
          "$ref": "#/definitions/NSServiceElement"
        },
        {
          "properties": {
            "alg": {
              "enum": [
                "ORACLE_TNS",
                "FTP",
                "SUN_RPC_TCP",
                "SUN_RPC_UDP",
                "MS_RPC_TCP",
                "MS_RPC_UDP",
                "NBNS_BROADCAST",
                "NBDG_BROADCAST",
                "TFTP"
              ],
              "type": "string"
            },
            "destination_ports": {
              "items": {
                "format": "port-or-range",
                "type": "string",
                "description": "Examples- Single port \"8080\", Range of ports \"8090-8095\"\n"
              },
              "type": "array",
              "description": "The destination_port cannot be empty and must be a single value.",
              "maxItems": 15,
              "title": "The destination_port cannot be empty and must be a single value."
            },
            "source_ports": {
              "items": {
                "format": "port-or-range",
                "type": "string",
                "description": "Examples- Single port \"8080\", Range of ports \"8090-8095\"\n"
              },
              "type": "array",
              "maxItems": 15
            }
          },
          "required": [
            "alg"
          ],
          "type": "object"
        }
      ],
      "description": "An NSService element that represents an ALG protocol",
      "title": "An NSService element that represents an ALG protocol"
    },
    "Timezone": {
      "properties": {
        "tzname": {
          "maxLength": 40,
          "type": "string",
          "description": "Standard abbreviation of timezone",
          "title": "Standard abbreviation of timezone"
        }
      },
      "type": "object",
      "description": "Timezone of system",
      "title": "Timezone of system"
    },
    "VtepLabelRange": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "required": [
            "start",
            "end"
          ],
          "type": "object",
          "properties": {
            "start": {
              "description": "Start value for virtual tunnel endpoint label range",
              "title": "Virtual tunnel endpoint label range start",
              "format": "int64",
              "maximum": 131071,
              "readOnly": false,
              "minimum": 1,
              "type": "integer"
            },
            "end": {
              "description": "End value for virtual tunnel endpoint label range",
              "title": "Virtual tunnel endpoint label range end",
              "format": "int64",
              "maximum": 131071,
              "readOnly": false,
              "minimum": 1,
              "type": "integer"
            }
          }
        }
      ]
    },
    "DonutSection": {
      "properties": {
        "row_list_field": {
          "type": "string",
          "description": "Field of the root of the api result set for forming parts.",
          "title": "Field from which parts of the donut are formed"
        },
        "parts": {
          "minItems": 1,
          "items": {
            "$ref": "#/definitions/DonutPart"
          },
          "type": "array",
          "description": "Array of Portions or Parts of the donut.",
          "title": "Parts of a Donut"
        },
        "template": {
          "default": false,
          "type": "boolean",
          "description": "If true, the section will be appled as template for forming parts. Only one part will be formed from each element of 'row_list_field'.",
          "title": "Template, if any, for automatically forming the donut parts"
        }
      },
      "required": [
        "parts"
      ],
      "type": "object",
      "description": "Represents high level logical grouping of portions or segments of a donut chart.",
      "title": "Donut Section"
    },
    "TraceflowObservationListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/TraceflowObservation"
              },
              "type": "array",
              "description": "TraceflowObservation list results",
              "title": "TraceflowObservation list results"
            }
          }
        }
      ]
    },
    "AppDiscoverySessionsListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/AppDiscoverySession"
              },
              "type": "array",
              "description": "AppProfile Sessions results",
              "title": "AppProfile Sessions results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Application discovery sessions list",
      "title": "Application discovery sessions list"
    },
    "LbHttpRequestMethodCondition": {
      "allOf": [
        {
          "$ref": "#/definitions/LbRuleCondition"
        },
        {
          "properties": {
            "method": {
              "type": "string",
              "description": "Type of HTTP request method",
              "enum": [
                "GET",
                "OPTIONS",
                "POST",
                "HEAD",
                "PUT"
              ]
            }
          },
          "required": [
            "method"
          ],
          "type": "object"
        }
      ],
      "description": "This condition is used to match method of HTTP requests. If the method of an\nHTTP request is same as the method specified in this condition, the HTTP\nrequest match this condition. For example, if the method field is set to\nGET in this condition, any HTTP request with GET method matches the\ncondition.\n",
      "title": "Condition to match method of HTTP request messages"
    },
    "UpgradeUnitGroup": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "type"
          ],
          "type": "object",
          "properties": {
            "enabled": {
              "default": true,
              "readOnly": false,
              "type": "boolean",
              "description": "Flag to indicate whether upgrade of this group is enabled or not",
              "title": "Flag to indicate whether upgrade of this group is enabled or not"
            },
            "upgrade_unit_count": {
              "readOnly": true,
              "format": "int32",
              "type": "integer",
              "description": "Number of upgrade units in the group",
              "title": "Count of upgrade units in the group"
            },
            "type": {
              "readOnly": false,
              "type": "string",
              "description": "Component type",
              "title": "Component type"
            },
            "upgrade_units": {
              "description": "List of upgrade units in the group",
              "title": "List of upgrade units in the group",
              "items": {
                "$ref": "#/definitions/UpgradeUnit"
              },
              "readOnly": false,
              "maxItems": 100,
              "type": "array"
            },
            "extended_configuration": {
              "description": "Extended configuration for the group",
              "title": "Extended configuration for the group",
              "items": {
                "$ref": "#/definitions/KeyValuePair"
              },
              "readOnly": false,
              "maxItems": 100,
              "type": "array"
            },
            "parallel": {
              "default": true,
              "readOnly": false,
              "type": "boolean",
              "description": "Upgrade method to specify whether the upgrade is to be performed in parallel or serially",
              "title": "Upgrade method to specify whether the upgrade is to be performed in parallel or serially"
            }
          }
        }
      ]
    },
    "EthernetHeader": {
      "type": "object",
      "properties": {
        "dst_mac": {
          "type": "string",
          "description": "The destination MAC address of form:\n\"^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$\". For example: 00:00:00:00:00:00.\n",
          "title": "Destination MAC address of the Ethernet header"
        },
        "eth_type": {
          "description": "This field defaults to IPv4.",
          "title": "The value of the type field to be put into the Ethernet header",
          "default": 2048,
          "format": "int64",
          "maximum": 65535,
          "minimum": 1,
          "type": "integer"
        },
        "src_mac": {
          "type": "string",
          "description": "The source MAC address of form:\n\"^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$\". For example: 00:00:00:00:00:00.\n",
          "title": "Source MAC address of the Ethernet header"
        }
      }
    },
    "PacketData": {
      "required": [
        "resource_type"
      ],
      "type": "object",
      "properties": {
        "routed": {
          "type": "boolean",
          "description": "A flag, when set true, indicates that the traceflow packet is of L3 routing.",
          "title": "A flag, when set true, indicates that the traceflow packet is of L3 routing."
        },
        "transport_type": {
          "default": "UNICAST",
          "enum": [
            "BROADCAST",
            "UNICAST",
            "MULTICAST",
            "UNKNOWN"
          ],
          "type": "string",
          "description": "transport type of the traceflow packet",
          "title": "transport type of the traceflow packet"
        },
        "resource_type": {
          "default": "FieldsPacketData",
          "enum": [
            "BinaryPacketData",
            "FieldsPacketData"
          ],
          "type": "string",
          "description": "Packet configuration",
          "title": "Packet configuration"
        },
        "frame_size": {
          "description": "If the requested frame_size is too small (given the payload and traceflow metadata requirement of 16 bytes), the traceflow request will fail with an appropriate message.  The frame will be zero padded to the requested size.",
          "title": "Requested total size of the (logical) packet in bytes",
          "default": 128,
          "format": "int64",
          "maximum": 1000,
          "minimum": 60,
          "type": "integer"
        }
      }
    },
    "CommunicationProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "properties": {
            "communication_profile_entries": {
              "items": {
                "$ref": "#/definitions/CommunicationProfileEntry"
              },
              "type": "array",
              "description": "CommunicationProfileEntries that are a part of this CommunicationProfile",
              "title": "CommunicationProfileEntries that are a part of this CommunicationProfile"
            }
          },
          "required": [
            "communication_profile_entries"
          ],
          "type": "object"
        }
      ],
      "description": "List of CommunicationProfileEntries",
      "title": "Contains ordered list of CommunicationProfileEntries"
    },
    "VtepTableCsvRecord": {
      "allOf": [
        {
          "$ref": "#/definitions/CsvRecord"
        },
        {
          "required": [
            "vtep_label",
            "vtep_mac_address"
          ],
          "type": "object",
          "properties": {
            "vtep_label": {
              "format": "int64",
              "type": "integer",
              "description": "The virtual tunnel endpoint label",
              "title": "The virtual tunnel endpoint label"
            },
            "vtep_mac_address": {
              "type": "string",
              "description": "The virtual tunnel endpoint MAC address",
              "title": "The virtual tunnel endpoint MAC address"
            },
            "vtep_ip": {
              "format": "ip",
              "type": "string",
              "description": "The virtual tunnel endpoint IP address"
            },
            "segment_id": {
              "type": "string",
              "description": "The segment Id",
              "title": "The segment Id"
            }
          }
        }
      ]
    },
    "IPPrefixListListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/IPPrefixList"
              },
              "type": "array",
              "description": "Paginated list of IPPrefixLists",
              "title": "Paginated list of IPPrefixLists"
            }
          }
        }
      ]
    },
    "TrustObjectData": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "pem_encoded"
          ],
          "type": "object",
          "properties": {
            "key_algo": {
              "type": "string",
              "description": "Key algorithm contained in this certificate"
            },
            "private_key": {
              "readOnly": false,
              "type": "string",
              "description": "private key data"
            },
            "passphrase": {
              "readOnly": false,
              "type": "string",
              "description": "Password for private key encryption"
            },
            "pem_encoded": {
              "readOnly": false,
              "type": "string",
              "description": "pem encoded certificate data"
            }
          }
        }
      ]
    },
    "FirewallSectionState": {
      "allOf": [
        {
          "$ref": "#/definitions/ConfigurationState"
        },
        {
          "type": "object",
          "properties": {
            "revision_desired": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "revision number of the desired state",
              "title": "revision number of the desired state"
            }
          }
        }
      ]
    },
    "BfdHealthMonitoringProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/TransportZoneProfile"
        },
        {
          "properties": {
            "probe_interval": {
              "description": "The time interval (in millisec) between probe packets for tunnels between transport nodes.",
              "format": "int64",
              "default": 1000,
              "title": "The time interval (in millisec) between probe packets for tunnels between transport nodes.",
              "minimum": 300,
              "type": "integer"
            },
            "enabled": {
              "type": "boolean",
              "description": "Whether the heartbeat is enabled. A POST or PUT request with \"enabled\" false (with no probe intervals) will set (POST) or reset (PUT) the probe_interval to their default value.",
              "title": "Whether the heartbeat is enabled. A POST or PUT request with \"enabled\" false (with no probe intervals) will set (POST) or reset (PUT) the probe_interval to their default value."
            }
          },
          "required": [
            "enabled"
          ],
          "type": "object"
        }
      ],
      "description": "Profile for BFD health monitoring",
      "title": "Profile for BFD health monitoring"
    },
    "PoolUsage": {
      "type": "object",
      "description": "Pool usage statistics in a pool.",
      "properties": {
        "total_ids": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Total number of IDs in a pool",
          "title": "Total number of IDs in a pool"
        },
        "allocated_ids": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Total number of allocated IDs in a pool",
          "title": "Total number of allocated IDs in a pool"
        },
        "free_ids": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Total number of free IDs in a pool",
          "title": "Total number of free IDs in a pool"
        }
      }
    },
    "IpfixServiceAssociationListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ServiceAssociationListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/IpfixConfig"
              },
              "readOnly": true,
              "type": "array",
              "description": "Ipfix config list result with pagination support.",
              "title": "IpfixConfig list result"
            }
          }
        }
      ]
    },
    "TaskListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/TaskProperties"
              },
              "type": "array",
              "description": "Task property results",
              "title": "Task property results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Task query results",
      "title": "Task query results"
    },
    "LbServerSslProfileListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/LbServerSslProfile"
              },
              "type": "array",
              "description": "paginated list of load balancer server SSL profiles",
              "title": "paginated list of load balancer server SSL profiles"
            }
          }
        }
      ]
    },
    "LbHttpResponseHeaderCondition": {
      "allOf": [
        {
          "$ref": "#/definitions/LbRuleCondition"
        },
        {
          "properties": {
            "header_value": {
              "type": "string",
              "description": "Value of HTTP header field",
              "title": "Value of HTTP header field"
            },
            "match_type": {
              "description": "Match type of HTTP header value",
              "default": "REGEX",
              "enum": [
                "STARTS_WITH",
                "ENDS_WITH",
                "EQUALS",
                "CONTAINS",
                "REGEX"
              ],
              "type": "string"
            },
            "header_name": {
              "type": "string",
              "description": "Name of HTTP header field",
              "title": "Name of HTTP header field"
            }
          },
          "required": [
            "header_value",
            "header_name"
          ],
          "type": "object"
        }
      ],
      "description": "This condition is used to match HTTP response messages from backend servers\nby HTTP header fields. HTTP header fields are components of the header\nsection of HTTP request and response messages. They define the operating\nparameters of an HTTP transaction. For example, Cookie, Authorization,\nUser-Agent, etc. One condition can be used to match one header field, to\nmatch multiple header fields, multiple conditions must be specified.\nThe match_type field defines how header_value field is used to match HTTP\nresponses. The header_name field does not support match types.\n",
      "title": "Condition to match a header field of HTTP response"
    },
    "RoleWithFeatures": {
      "properties": {
        "role": {
          "readOnly": true,
          "type": "string",
          "description": "Role name",
          "title": "Role name"
        },
        "features": {
          "items": {
            "$ref": "#/definitions/FeaturePermission"
          },
          "type": "array",
          "description": "Features",
          "title": "Features"
        }
      },
      "required": [
        "features"
      ],
      "type": "object",
      "description": "Role",
      "title": "Role"
    },
    "BridgeEndpointListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "description": "BridgeEndpoint Results",
              "title": "BridgeEndpoint Results",
              "minItems": 0,
              "items": {
                "$ref": "#/definitions/BridgeEndpoint"
              },
              "readOnly": true,
              "type": "array"
            }
          },
          "type": "object"
        }
      ],
      "description": "Bridge Endpoint queries result",
      "title": "Bridge Endpoint queries result"
    },
    "RouteMapSequenceSet": {
      "type": "object",
      "properties": {
        "as_path_prepend": {
          "type": "string",
          "description": "As Path Prepending to influence path selection",
          "title": "As Path Prepending to influence path selection"
        },
        "community": {
          "type": "string",
          "description": "Either well-known community name or community value in aa:nn(2byte:2byte) format",
          "title": "Either well-known community name or community value in aa:nn(2byte:2byte) format"
        },
        "weight": {
          "description": "Weight used to select certain path",
          "format": "int32",
          "title": "Weight used to select certain path",
          "maximum": 65535,
          "minimum": 0,
          "type": "integer"
        },
        "multi_exit_discriminator": {
          "description": "Multi Exit Discriminator (MED)",
          "format": "int64",
          "title": "Multi Exit Discriminator (MED)",
          "maximum": 4294967295,
          "minimum": 0,
          "type": "integer"
        }
      }
    },
    "DeploymentZone": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyConfigResource"
        },
        {
          "properties": {
            "enforcement_points": {
              "items": {
                "$ref": "#/definitions/EnforcementPoint"
              },
              "type": "array",
              "description": "Logical grouping of enforcement points",
              "title": "Logical grouping of enforcement points"
            }
          },
          "type": "object"
        }
      ],
      "description": "Logical grouping of enforcement points",
      "title": "Deployment zone"
    },
    "AwsGatewayAmiInfo": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "ami_id": {
              "type": "string",
              "description": "The ID of the Amazon Machine Image",
              "title": "AMI id"
            },
            "region_id": {
              "type": "string",
              "description": "Name of the Aws Region in which ami is present",
              "title": "Name of the Aws Region in which ami is present"
            }
          },
          "required": [
            "ami_id",
            "region_id"
          ],
          "type": "object"
        }
      ],
      "description": "Aws Gateway Ami Information",
      "title": "Aws Gateway Ami Information"
    },
    "PortConnectionHypervisor": {
      "allOf": [
        {
          "$ref": "#/definitions/PortConnectionEntity"
        },
        {
          "properties": {
            "pnics": {
              "items": {
                "$ref": "#/definitions/Pnic"
              },
              "type": "array",
              "x-deprecated": true
            },
            "pnics_list": {
              "items": {
                "$ref": "#/definitions/NodeInterfaceProperties"
              },
              "type": "array"
            },
            "neighbors_list": {
              "items": {
                "$ref": "#/definitions/InterfaceNeighborProperties"
              },
              "type": "array"
            },
            "profiles": {
              "items": {
                "$ref": "#/definitions/BaseHostSwitchProfile"
              },
              "type": "array"
            }
          },
          "type": "object"
        }
      ],
      "description": "Port Connection Hypervisor/Transport Node Entity",
      "title": "Port Connection Hypervisor/Transport Node Entity"
    },
    "BaseNodeAggregateInfo": {
      "type": "object",
      "properties": {
        "node_interface_properties": {
          "items": {
            "$ref": "#/definitions/NodeInterfaceProperties"
          },
          "readOnly": true,
          "type": "array",
          "description": "Array of Node interface statistic properties",
          "title": "Array of Node interface statistic properties"
        },
        "node_status": {
          "readOnly": true,
          "$ref": "#/definitions/ClusterNodeStatus"
        },
        "node_interface_statistics": {
          "items": {
            "$ref": "#/definitions/NodeInterfaceStatisticsProperties"
          },
          "readOnly": true,
          "type": "array",
          "description": "Array of Node network interface statistic properties",
          "title": "Array of Node network interface statistic properties"
        },
        "node_status_properties": {
          "items": {
            "$ref": "#/definitions/NodeStatusProperties"
          },
          "type": "array",
          "description": "Time series of the node's system properties",
          "title": "Time series of the node's system properties"
        }
      }
    },
    "UpgradePlanSettings": {
      "type": "object",
      "properties": {
        "pause_after_each_group": {
          "default": false,
          "readOnly": false,
          "type": "boolean",
          "description": "Flag to indicate whether to pause the upgrade after upgrade of each group is completed",
          "title": "Flag to indicate whether to pause the upgrade after upgrade of each group is completed"
        },
        "pause_on_error": {
          "default": false,
          "readOnly": false,
          "type": "boolean",
          "description": "Flag to indicate whether to pause the upgrade plan execution when an error occurs",
          "title": "Flag to indicate whether to pause the upgrade plan execution when an error occurs"
        },
        "parallel": {
          "default": true,
          "readOnly": false,
          "type": "boolean",
          "description": "Upgrade Method to specify whether the upgrade is to be performed serially or in parallel",
          "title": "Upgrade Method to specify whether the upgrade is to be performed serially or in parallel"
        }
      }
    },
    "UpgradeUnitGroupListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/UpgradeUnitGroup"
              },
              "type": "array",
              "description": "Paged Collection of Upgrade unit groups",
              "title": "Paged Collection of Upgrade unit groups"
            }
          }
        }
      ]
    },
    "AppInfoHostVmListInCsvFormat": {
      "allOf": [
        {
          "$ref": "#/definitions/CsvListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/AppInfoHostVmCsvRecord"
              },
              "type": "array",
              "description": "List of appplications discovered during an application discovery session",
              "title": "List of appplications discovered during an application discovery session"
            }
          }
        }
      ]
    },
    "UpgradeUnitAggregateInfoListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/UpgradeUnitAggregateInfo"
              },
              "readOnly": true,
              "type": "array",
              "description": "Paged collection of UpgradeUnit AggregateInfo",
              "title": "Paged collection of UpgradeUnit AggregateInfo"
            }
          }
        }
      ]
    },
    "Condition": {
      "allOf": [
        {
          "$ref": "#/definitions/Expression"
        },
        {
          "properties": {
            "operator": {
              "enum": [
                "EQUALS",
                "CONTAINS",
                "STARTSWITH"
              ],
              "type": "string",
              "description": "operator",
              "title": "operator"
            },
            "value": {
              "type": "string",
              "description": "Value",
              "title": "Value"
            },
            "key": {
              "enum": [
                "Tag",
                "Name"
              ],
              "type": "string",
              "description": "Key",
              "title": "Key"
            },
            "member_type": {
              "enum": [
                "VirtualMachine",
                "LogicalPort"
              ],
              "type": "string",
              "description": "Group member type",
              "title": "Group member type"
            }
          },
          "required": [
            "operator",
            "value",
            "key",
            "member_type"
          ],
          "type": "object"
        }
      ],
      "description": "Represents the leaf level condition",
      "title": "Represents the leaf level condition"
    },
    "LldpHostSwitchProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/BaseHostSwitchProfile"
        },
        {
          "properties": {
            "send_enabled": {
              "type": "boolean",
              "description": "Enabled or disabled sending LLDP packets",
              "title": "Enabled or disabled sending LLDP packets"
            }
          },
          "required": [
            "send_enabled"
          ],
          "type": "object"
        }
      ],
      "description": "Host Switch for LLDP",
      "title": "Host Switch for LLDP"
    },
    "ProtonPackageLoggingLevels": {
      "type": "object",
      "properties": {
        "logging_level": {
          "enum": [
            "ERROR",
            "WARN",
            "INFO",
            "DEBUG",
            "TRACE"
          ],
          "type": "string",
          "description": "Logging levels per package",
          "title": "Logging levels per package"
        },
        "package_name": {
          "type": "string",
          "description": "Package name",
          "title": "Package name"
        }
      }
    },
    "AwsGatewayStatus": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "gateway_cluster_id": {
              "type": "string",
              "description": "NSX gateway cluster id",
              "title": "NSX gateway cluster id"
            },
            "gateway_instances_status": {
              "items": {
                "$ref": "#/definitions/AwsGatewayInstanceStatus"
              },
              "readOnly": true,
              "type": "array",
              "description": "Array of gateway statuses",
              "title": "Array of gateway statuses"
            }
          },
          "type": "object"
        }
      ],
      "description": "Aws logical gateway status",
      "title": "Aws logical gateway status"
    },
    "ControlConnStatus": {
      "type": "object",
      "properties": {
        "status": {
          "readOnly": true,
          "enum": [
            "UP",
            "DOWN"
          ],
          "type": "string",
          "description": "Status of the control Node for e.g  UP, DOWN.",
          "title": "Status of the control Node for e.g  UP, DOWN."
        },
        "control_node_ip": {
          "readOnly": true,
          "type": "string",
          "description": "IP address of the control Node.",
          "title": "IP address of the control Node."
        },
        "failure_status": {
          "readOnly": true,
          "enum": [
            "CONNECTION_REFUSED",
            "INCOMPLETE_HOST_CERT",
            "INCOMPLETE_CONTROLLER_CERT",
            "CONTROLLER_REJECTED_HOST_CERT",
            "HOST_REJECTED_CONTROLLER_CERT",
            "KEEP_ALIVE_TIMEOUT",
            "OTHER_SSL_ERROR",
            "OTHER_ERROR"
          ],
          "type": "string",
          "description": "Failure status of the control Node for e.g CONNECTION_REFUSED,INCOMPLETE_HOST_CERT.",
          "title": "Failure status of the control Node for e.g CONNECTION_REFUSED,INCOMPLETE_HOST_CERT."
        }
      }
    },
    "NodeStatusProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "load_average": {
              "items": {
                "type": "number"
              },
              "readOnly": true,
              "type": "array",
              "description": "One, five, and fifteen minute load averages for the system",
              "title": "One, five, and fifteen minute load averages for the system"
            },
            "swap_used": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Amount of swap disk in use, in kilobytes",
              "title": "Amount of swap disk in use, in kilobytes"
            },
            "mem_used": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Amount of RAM in use on the system, in kilobytes",
              "title": "Amount of RAM in use on the system, in kilobytes"
            },
            "swap_total": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Amount of disk available for swap, in kilobytes",
              "title": "Amount of disk available for swap, in kilobytes"
            },
            "system_time": {
              "readOnly": true,
              "type": "integer",
              "description": "Current time expressed in milliseconds since epoch",
              "format": "int64"
            },
            "cpu_cores": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Number of CPU cores on the system",
              "title": "Number of CPU cores on the system"
            },
            "uptime": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Milliseconds since system start",
              "title": "Milliseconds since system start"
            },
            "mem_cache": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Amount of RAM on the system that can be flushed out to disk, in kilobytes",
              "title": "Amount of RAM on the system that can be flushed out to disk, in kilobytes"
            },
            "mem_total": {
              "readOnly": true,
              "format": "int64",
              "type": "integer",
              "description": "Amount of RAM allocated to the system, in kilobytes",
              "title": "Amount of RAM allocated to the system, in kilobytes"
            },
            "file_systems": {
              "items": {
                "$ref": "#/definitions/NodeFileSystemProperties"
              },
              "readOnly": true,
              "type": "array",
              "description": "File systems configured on the system",
              "title": "File systems configured on the system"
            },
            "source": {
              "description": "Source of status data.",
              "enum": [
                "realtime",
                "cached"
              ],
              "readOnly": true,
              "type": "string"
            }
          },
          "type": "object"
        }
      ],
      "description": "Node status properties",
      "title": "Node status properties"
    },
    "LbHttpRequestHeaderCondition": {
      "allOf": [
        {
          "$ref": "#/definitions/LbRuleCondition"
        },
        {
          "properties": {
            "header_value": {
              "type": "string",
              "description": "Value of HTTP header",
              "title": "Value of HTTP header"
            },
            "match_type": {
              "description": "Match type of HTTP header value",
              "default": "REGEX",
              "enum": [
                "STARTS_WITH",
                "ENDS_WITH",
                "EQUALS",
                "CONTAINS",
                "REGEX"
              ],
              "type": "string"
            },
            "header_name": {
              "type": "string",
              "description": "Name of HTTP header",
              "title": "Name of HTTP header"
            }
          },
          "required": [
            "header_value",
            "header_name"
          ],
          "type": "object"
        }
      ],
      "description": "This condition is used to match HTTP request messages by HTTP header\nfields. HTTP header fields are components of the header section of HTTP\nrequest and response messages. They define the operating parameters of an\nHTTP transaction. For example, Cookie, Authorization, User-Agent, etc. One\ncondition can be used to match one header field, to match multiple header\nfields, multiple conditions must be specified.\nThe match_type field defines how header_value field is used to match HTTP\nrequests. The header_name field does not support match types.\n",
      "title": "Condition to match HTTP request header"
    },
    "SuccessNodeSupportBundleResult": {
      "type": "object",
      "properties": {
        "bundle_name": {
          "readOnly": true,
          "type": "string",
          "description": "Name of support bundle, e.g. nsx_NODETYPE_UUID_YYYYMMDD_HHMMSS.tgz",
          "title": "Name of support bundle, e.g. nsx_NODETYPE_UUID_YYYYMMDD_HHMMSS.tgz"
        },
        "node_display_name": {
          "readOnly": true,
          "type": "string",
          "description": "Display name of node",
          "title": "Display name of node"
        },
        "node_id": {
          "readOnly": true,
          "type": "string",
          "description": "UUID of node",
          "title": "UUID of node"
        },
        "sha256_thumbprint": {
          "readOnly": true,
          "type": "string",
          "description": "File's SHA256 thumbprint",
          "title": "File's SHA256 thumbprint"
        },
        "bundle_size": {
          "readOnly": true,
          "format": "int64",
          "type": "integer",
          "description": "Size of support bundle in bytes",
          "title": "Size of support bundle in bytes"
        }
      }
    },
    "LoggingServiceProperties": {
      "properties": {
        "package_logging_level": {
          "items": {
            "$ref": "#/definitions/PackageLoggingLevels"
          },
          "type": "array",
          "description": "Package logging levels",
          "title": "Package logging levels"
        },
        "logging_level": {
          "enum": [
            "ERROR",
            "WARN",
            "INFO",
            "DEBUG",
            "TRACE"
          ],
          "type": "string",
          "description": "Service logging level",
          "title": "Service logging level"
        }
      },
      "required": [
        "logging_level"
      ],
      "type": "object",
      "description": "Service properties",
      "title": "Service properties"
    },
    "BackupOperationHistory": {
      "type": "object",
      "properties": {
        "inventory_backup_statuses": {
          "items": {
            "$ref": "#/definitions/BackupOperationStatus"
          },
          "type": "array",
          "description": "Statuses of previous inventory backups",
          "title": "Statuses of previous inventory backups"
        },
        "cluster_backup_statuses": {
          "items": {
            "$ref": "#/definitions/BackupOperationStatus"
          },
          "type": "array",
          "description": "Statuses of previous cluser backups",
          "title": "Statuses of previous cluser backups"
        },
        "node_backup_statuses": {
          "items": {
            "$ref": "#/definitions/BackupOperationStatus"
          },
          "type": "array",
          "description": "Statuses of previous node backups",
          "title": "Statuses of previous node backups"
        }
      }
    },
    "RedistributionConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "type": "object",
          "properties": {
            "logical_router_id": {
              "readOnly": true,
              "type": "string",
              "description": "Logical router id",
              "title": "Logical router id"
            },
            "bgp_enabled": {
              "default": false,
              "type": "boolean",
              "description": "Flag to enable redistribution for BGP as destinationProtocol",
              "title": "Flag to enable redistribution for BGP as destinationProtocol"
            }
          }
        }
      ]
    },
    "NSXTConnectionInfo": {
      "allOf": [
        {
          "$ref": "#/definitions/EnforcementPointConnectionInfo"
        },
        {
          "properties": {
            "username": {
              "type": "string",
              "description": "UserName",
              "title": "UserName"
            },
            "password": {
              "type": "string",
              "description": "Password",
              "title": "Password"
            },
            "thumbprint": {
              "type": "string",
              "description": "Thumbprint of EnforcementPoint. sha-256 hash represented in lower case hex.\n",
              "title": "Thumbprint of Enforcement Point"
            }
          },
          "required": [
            "username",
            "password",
            "thumbprint"
          ],
          "type": "object"
        }
      ],
      "description": "Credential info to connect to NSXT enforcement type",
      "title": "Credential info to connect to NSXT enforcement type"
    },
    "DhcpOption121": {
      "required": [
        "static_routes"
      ],
      "type": "object",
      "properties": {
        "static_routes": {
          "description": "dhcp classless static routes",
          "title": "dhcp classless static routes",
          "minItems": 1,
          "items": {
            "$ref": "#/definitions/ClasslessStaticRoute"
          },
          "maxItems": 27,
          "type": "array"
        }
      }
    },
    "VtepLabelPoolListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/VtepLabelPool"
              },
              "type": "array",
              "description": "Virtual tunnel endpoint label pool list results",
              "title": "Virtual tunnel endpoint label pool list results"
            }
          }
        }
      ]
    },
    "BatchResponse": {
      "required": [
        "results"
      ],
      "type": "object",
      "properties": {
        "has_errors": {
          "type": "boolean",
          "description": "Indicates if any of the APIs failed",
          "title": "errors indicator"
        },
        "rolled_back": {
          "type": "boolean",
          "description": "Optional flag indicating that all items were rolled back even if succeeded initially",
          "title": "indicates if all items were rolled back."
        },
        "results": {
          "items": {
            "$ref": "#/definitions/BatchResponseItem"
          },
          "type": "array",
          "description": "Bulk list results",
          "title": "Bulk list results"
        }
      }
    },
    "FabricModuleListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/FabricModule"
              },
              "readOnly": true,
              "type": "array",
              "description": "Fabric Module list results",
              "title": "Fabric Module list results"
            }
          },
          "type": "object"
        }
      ],
      "description": "Fabric Module list result",
      "title": "Fabric Module list result"
    },
    "DhcpIpPoolListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/DhcpIpPool"
              },
              "type": "array",
              "description": "paginated list of dhcp ip pools",
              "title": "paginated list of dhcp ip pools"
            }
          }
        }
      ]
    },
    "SupportBundleRemoteFileServer": {
      "properties": {
        "manager_upload_only": {
          "default": false,
          "type": "boolean",
          "description": "Uploads to the remote file server performed by the manager",
          "title": "Uploads to the remote file server performed by the manager"
        },
        "server": {
          "type": "string",
          "description": "Remote server hostname or IP address",
          "title": "Remote server hostname or IP address"
        },
        "protocol": {
          "title": "Protocol to use to copy file",
          "description": "Protocol to use to copy file",
          "$ref": "#/definitions/SupportBundleFileTransferProtocol"
        },
        "port": {
          "description": "Server port",
          "title": "Server port",
          "default": 22,
          "format": "int64",
          "maximum": 65535,
          "minimum": 1,
          "type": "integer"
        },
        "directory_path": {
          "type": "string",
          "description": "Remote server directory to copy bundle files to",
          "title": "Remote server directory to copy bundle files to"
        }
      },
      "required": [
        "server",
        "protocol",
        "directory_path"
      ],
      "type": "object",
      "description": "Remote file server",
      "title": "Remote file server"
    },
    "CsvRecord": {
      "type": "object",
      "description": "Base type for CSV records."
    },
    "PrincipalIdentity": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "permission_group",
            "node_id",
            "name",
            "certificate_id"
          ],
          "type": "object",
          "properties": {
            "permission_group": {
              "description": "permission group",
              "enum": [
                "read_only_api_users",
                "read_write_api_users",
                "superusers"
              ],
              "readOnly": false,
              "type": "string"
            },
            "node_id": {
              "readOnly": false,
              "maxLength": 255,
              "type": "string",
              "description": "Unique node-id of a principal",
              "title": "Unique node-id"
            },
            "name": {
              "readOnly": false,
              "maxLength": 255,
              "type": "string",
              "description": "Name of the principal",
              "title": "Name"
            },
            "is_protected": {
              "readOnly": false,
              "type": "boolean",
              "description": "Indicator whether the entities created by this principal should be protected",
              "title": "Protection indicator"
            },
            "certificate_id": {
              "readOnly": false,
              "type": "string",
              "description": "Id of the stored certificate",
              "title": "Id of the stored certificate"
            }
          }
        }
      ]
    },
    "VirtualMachineListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/VirtualMachine"
              },
              "type": "array",
              "description": "VirtualMachine list results",
              "title": "VirtualMachine list results"
            }
          }
        }
      ]
    },
    "PropertyItem": {
      "properties": {
        "field": {
          "type": "string",
          "description": "Represents field value of the property.",
          "title": "Field of the Property"
        },
        "render_configuration": {
          "items": {
            "$ref": "#/definitions/RenderConfiguration"
          },
          "type": "array",
          "description": "Render configuration to be applied, if any.",
          "title": "Render Configuration"
        },
        "type": {
          "default": "String",
          "enum": [
            "String",
            "Number",
            "Date",
            "Url"
          ],
          "type": "string",
          "description": "Data type of the field.",
          "title": "field data type"
        },
        "heading": {
          "default": false,
          "type": "boolean",
          "description": "Set to true if the field is a heading. Default is false.",
          "title": "If true, represents the field as a heading"
        },
        "condition": {
          "type": "string",
          "description": "If the condition is met then the property will be displayed. Examples of expression syntax are provided under 'example_request' section of 'CreateWidgetConfiguration' API.",
          "title": "Expression for evaluating condition"
        },
        "label": {
          "title": "Label of the property",
          "description": "If a field represents a heading, then label is not needed",
          "$ref": "#/definitions/Label"
        }
      },
      "required": [
        "field",
        "type"
      ],
      "type": "object",
      "description": "Represents a label-value pair.",
      "title": "LabelValue Property"
    },
    "LbRuleAction": {
      "description": "Load balancer rule actions are used to manipulate application traffic.\nCurrently load balancer rules can be used at three load balancer processing\nphases. Each phase has its own supported type of actions.\nSupported actions in HTTP_REQUST_REWRITE phase are:\n  LbHttpRequestUriRewriteAction\n  LbHttpRequestHeaderRewriteAction\nSupported actions in HTTP_FORWARDING phase are:\n  LbHttpRejectAction\n  LbHttpRedirectAction\n  LbSelectPoolAction\n  LbSelectServerAction\nSupported action in HTTP_RESPONSE_REWRITE phase is:\n  LbHttpResponseHeaderRewriteAction\n\nIf the match type of an LbRuleCondition field is specified as REGEX and\nnamed capturing groups are used in the specified regular expression. The\ngroups can be used as variables in LbRuleAction fields.\nFor example, define a rule with LbHttpRequestUriCondition as match\ncondition and LbHttpRequestUriRewriteAction as action. Set match_type field\nof LbHttpRequestUriCondition to REGEX, and set uri field to\n  \"/news/(?&lt;year&gt;\\d+)/(?&lt;month&gt;\\d+)/(?&lt;article&gt;.*)\".\nSet uri field of LbHttpRequestUriRewriteAction to:\n  \"/news/$year-$month/$article\"\nIn uri field of LbHttpRequestUriCondition, the (?&lt;year&gt;\\d+),\n(?&lt;month&gt;\\d+) and (?&lt;article&gt;.*) are named capturing groups,\nthey define variables named $year, $month and $article respectively. The\ndefined variables are used in LbHttpRequestUriRewriteAction.\nFor a matched HTTP request with URI \"/news/2017/06/xyz.html\", the substring\n\"2017\" is captured in variable $year, \"06\" is captured in variable $month,\nand \"xyz.html\" is captured in variable $article. The\nLbHttpRequestUriRewriteAction will rewrite the URI to:\n  \"/news/2017-06/xyz.html\"\nA set of built-in variables can be used in LbRuleAction as well. The name\nof built-in variables start with underscore, the name of user defined\nvariables is not allowed to start with underscore.\nFollowing are some of the built-in variables:\n  $_scheme: Reference the scheme part of matched HTTP messages, could be\n\"http\" or \"https\".\n  $_host: Host of matched HTTP messages, for example \"www.example.com\".\n  $_server_port: Port part of URI, it is also the port of the server which\naccepted a request. Default port is 80 for http and 443 for https.\n  $_uri: The URI path, for example \"/products/sample.html\".\n  $_request_uri: Full original request URI with arguments, for example,\n    \"/products/sample.html?a=b&c=d\".\n  $_args: URI arguments, for instance \"a=b&c=d\"\n  $_is_args: \"?\" if a request has URI arguments, or an empty string\notherwise.\nFor the full list of built-in variables, please reference the NSX-T\nAdministrator's Guide.\n",
      "title": "Load balancer rule action",
      "required": [
        "type"
      ],
      "discriminator": "type",
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "description": "Type of load balancer rule action",
          "enum": [
            "LbHttpRequestUriRewriteAction",
            "LbHttpRequestHeaderRewriteAction",
            "LbHttpRejectAction",
            "LbHttpRedirectAction",
            "LbSelectPoolAction",
            "LbSelectServerAction",
            "LbHttpResponseHeaderRewriteAction"
          ]
        }
      }
    },
    "NSServiceListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/NSService"
              },
              "type": "array",
              "description": "Paged collection of NSServices",
              "title": "Paged collection of NSServices"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "List result of NSservices",
      "title": "List result of NSservices"
    },
    "UpgradeSummary": {
      "type": "object",
      "properties": {
        "target_version": {
          "readOnly": true,
          "type": "string",
          "description": "Target system version",
          "title": "Target system version"
        },
        "upgrade_coordinator_version": {
          "readOnly": true,
          "type": "string",
          "description": "Current version of upgrade coordinator",
          "title": "Current version of upgrade coordinator"
        },
        "upgrade_status": {
          "readOnly": true,
          "enum": [
            "SUCCESS",
            "FAILED",
            "IN_PROGRESS",
            "NOT_STARTED",
            "PAUSED"
          ],
          "type": "string",
          "description": "Status of upgrade",
          "title": "Status of upgrade"
        },
        "component_target_versions": {
          "items": {
            "$ref": "#/definitions/ComponentTargetVersion"
          },
          "readOnly": true,
          "type": "array"
        },
        "system_version": {
          "readOnly": true,
          "type": "string",
          "description": "Current system version",
          "title": "Current system version"
        },
        "upgrade_bundle_file_name": {
          "readOnly": true,
          "type": "string",
          "description": "Name of the last successfully uploaded upgrade bundle file",
          "title": "Name of the last successfully uploaded upgrade bundle file"
        }
      }
    },
    "MirrorSource": {
      "discriminator": "resource_type",
      "required": [
        "resource_type"
      ],
      "type": "object",
      "properties": {
        "resource_type": {
          "enum": [
            "LogicalPortMirrorSource",
            "PnicMirrorSource",
            "VlanMirrorSource"
          ],
          "type": "string",
          "description": "Resource types of mirror source"
        }
      }
    },
    "SpoofGuardSwitchingProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/BaseSwitchingProfile"
        },
        {
          "properties": {
            "white_list_providers": {
              "items": {
                "enum": [
                  "LPORT_BINDINGS",
                  "LSWITCH_BINDINGS"
                ],
                "type": "string",
                "description": "Ways to provide white listed addresses for SpoofGuard"
              },
              "readOnly": false,
              "type": "array",
              "description": "List of providers for white listed address bindings.",
              "title": "List of providers for white listed address bindings."
            }
          },
          "required": [
            "white_list_providers"
          ],
          "type": "object"
        }
      ],
      "description": "SpoofGuard configuration",
      "title": "SpoofGuard configuration"
    },
    "DiscoveredResource": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "type": "object",
          "properties": {
            "_last_sync_time": {
              "readOnly": true,
              "type": "integer",
              "description": "Timestamp of last modification",
              "format": "int64"
            },
            "display_name": {
              "maxLength": 255,
              "type": "string",
              "description": "Defaults to ID if not set",
              "title": "Identifier to use when displaying entity in logs or GUI"
            },
            "description": {
              "maxLength": 1024,
              "type": "string",
              "description": "Description of this resource",
              "title": "Description of this resource"
            },
            "resource_type": {
              "readOnly": false,
              "type": "string",
              "description": "The type of this resource."
            },
            "tags": {
              "items": {
                "$ref": "#/definitions/Tag"
              },
              "type": "array",
              "description": "Opaque identifiers meaningful to the API user",
              "maxItems": 15,
              "title": "Opaque identifiers meaningful to the API user"
            }
          }
        }
      ]
    },
    "AwsKeyPair": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the Aws Key Pair",
              "title": "Name of the Aws Key Pair"
            }
          },
          "required": [
            "name"
          ],
          "type": "object"
        }
      ],
      "description": "Aws Key Pair",
      "title": "Aws Key Pair"
    },
    "LbRule": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "phase": {
              "enum": [
                "HTTP_REQUEST_REWRITE",
                "HTTP_FORWARDING",
                "HTTP_RESPONSE_REWRITE"
              ],
              "type": "string",
              "description": "Each load balancer rule is used at a specific phase of load balancer\nprocessing. Currently three phases are supported, HTTP_REQUEST_REWRITE,\nHTTP_FORWARDING and HTTP_RESPONSE_REWRITE.\nWhen an HTTP request message is received by load balancer, all\nHTTP_REQUEST_REWRITE rules, if present are executed in the order they\nare applied to virtual server. And then if HTTP_FORWARDING rules\npresent, only first matching rule's action is executed, remaining rules\nare not checked. HTTP_FORWARDING rules can have only one action. If the\nrequest is forwarded to a backend server and the response goes back to\nload balancer, all HTTP_RESPONSE_REWRITE rules, if present, are executed\nin the order they are applied to the virtual server.\n",
              "title": "Load balancer processing phase"
            },
            "match_conditions": {
              "items": {
                "$ref": "#/definitions/LbRuleCondition"
              },
              "type": "array",
              "description": "A list of match conditions used to match application traffic. Multiple\nmatch conditions can be specified in one load balancer rule, each match\ncondition defines a criterion to match application traffic.\nIf no match conditions are specified, then the load balancer rule will\nalways match and it is used typically to define default rules. If more\nthan one match condition is specified, then match strategy determines\nif all conditions should match or any one condition should match for the\nload balancer rule to considered a match.\n",
              "maxItems": 60,
              "title": "Conditions to match application traffic"
            },
            "actions": {
              "items": {
                "$ref": "#/definitions/LbRuleAction"
              },
              "type": "array",
              "description": "A list of actions to be executed at specified phase when load balancer\nrule matches. The actions are used to manipulate application traffic,\nsuch as rewrite URI of HTTP messages, redirect HTTP messages, etc.\n",
              "maxItems": 60,
              "title": "Actions to be executed"
            },
            "match_strategy": {
              "enum": [
                "ALL",
                "ANY"
              ],
              "type": "string",
              "description": "Strategy to define how load balancer rule is considered a match when\nmultiple match conditions are specified in one rule. If match_stragety\nis set to ALL, then load balancer rule is considered a match only if all\nthe conditions match. If match_strategy is set to ANY, then load\nbalancer rule is considered a match if any one of the conditions match.\n",
              "title": "Strategy to match multiple conditions"
            }
          },
          "required": [
            "phase",
            "actions",
            "match_strategy"
          ],
          "type": "object"
        }
      ],
      "description": "Load balancer rules allow customization of load balancing behavior using\nmatch/action rules. Currently, load balancer rules are supported for only\nlayer 7 virtual servers with application profile LbHttpProfile.\nEach application rule consists of one or more match conditions and one or\nmore actions.\nLoad balancer rules could be used by different load balancer services.\n",
      "title": "Load balancer rules"
    },
    "NodeRoutePropertiesListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/NodeRouteProperties"
              },
              "type": "array",
              "description": "Node route property results",
              "title": "Node route property results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Node network route properties list results",
      "title": "Node network route properties list results"
    },
    "BatchRequestItem": {
      "required": [
        "uri",
        "method"
      ],
      "type": "object",
      "properties": {
        "body": {
          "type": "object"
        },
        "uri": {
          "type": "string",
          "description": "relative uri (path and args), of the call including resource id (if this is a POST/DELETE), exclude hostname and port and prefix, exploded form of parameters",
          "title": "Internal uri of the call"
        },
        "method": {
          "enum": [
            "GET",
            "POST",
            "PUT",
            "DELETE",
            "PATCH"
          ],
          "type": "string",
          "description": "http method type",
          "title": "method type(POST/PUT/DELETE/UPDATE)"
        }
      }
    },
    "FooterAction": {
      "properties": {
        "url": {
          "type": "string",
          "description": "Hyperlink to the UI page that provides details of action.",
          "title": "Clickable hyperlink, if any"
        },
        "dock_to_container_footer": {
          "default": true,
          "type": "boolean",
          "description": "If true, the footer will appear in the underlying container that holds the widget.",
          "title": "Dock the footer at container"
        },
        "label": {
          "title": "Label for action",
          "description": "Label to be displayed against the footer action.",
          "$ref": "#/definitions/Label"
        }
      },
      "required": [
        "label"
      ],
      "type": "object",
      "description": "Action specified at the footer of a widget to provide additional information or to provide a clickable url for navigation. An example usage of footer action is provided under the 'example_request' section of 'CreateWidgetConfiguration' API.",
      "title": "Widget Footer Action"
    },
    "IpBlockSubnet": {
      "description": "A set of IPv4 addresses defined by a start address and a mask/prefix which will typically be associated with a layer-2 broadcast domain.",
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "block_id",
            "size"
          ],
          "type": "object",
          "properties": {
            "cidr": {
              "readOnly": true,
              "format": "ipv4-cidr-block",
              "type": "string",
              "description": "Represents network address and the prefix length which will be associated with a layer-2 broadcast domain",
              "title": "Represents network address and the prefix length which will be associated with a layer-2 broadcast domain"
            },
            "allocation_ranges": {
              "items": {
                "$ref": "#/definitions/IpPoolRange"
              },
              "readOnly": true,
              "type": "array",
              "description": "A collection of IPv4 IP ranges used for IP allocation.",
              "title": "A collection of IPv4 IP ranges used for IP allocation."
            },
            "block_id": {
              "readOnly": false,
              "type": "string",
              "description": "Block id for which the subnet is created.",
              "title": "Block id for which the subnet is created."
            },
            "size": {
              "format": "int64",
              "type": "integer",
              "description": "Represents the size or number of ip addresses in the subnet",
              "title": "Represents the size or number of ip addresses in the subnet"
            }
          }
        }
      ]
    },
    "KeyValuePair": {
      "required": [
        "value",
        "key"
      ],
      "type": "object",
      "properties": {
        "value": {
          "readOnly": false,
          "maxLength": 255,
          "type": "string",
          "description": "Value",
          "title": "Value"
        },
        "key": {
          "readOnly": false,
          "maxLength": 255,
          "type": "string",
          "description": "Key",
          "title": "Key"
        }
      }
    },
    "RouteMap": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "sequences"
          ],
          "type": "object",
          "properties": {
            "logical_router_id": {
              "readOnly": true,
              "type": "string",
              "description": "Logical router id",
              "title": "Logical router id"
            },
            "sequences": {
              "description": "Ordered list of routeMap sequences",
              "title": "Ordered list of routeMap sequences",
              "minItems": 1,
              "items": {
                "$ref": "#/definitions/RouteMapSequence"
              },
              "maxItems": 1000,
              "type": "array"
            }
          }
        }
      ]
    },
    "TransportZoneProfileListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/TransportZoneProfile"
              },
              "readOnly": true,
              "type": "array",
              "description": "Transport zone profile results",
              "title": "Transport zone profile results"
            }
          },
          "type": "object"
        }
      ],
      "description": "Transport zone profile queries result",
      "title": "Transport zone profile queries result"
    },
    "SoftwareModuleResult": {
      "properties": {
        "software_modules": {
          "items": {
            "$ref": "#/definitions/SoftwareModule"
          },
          "type": "array",
          "description": "Software module results",
          "title": "Software module results"
        }
      },
      "required": [
        "software_modules"
      ],
      "type": "object",
      "description": "Software module result",
      "title": "Software module result"
    },
    "ErrorResolverInfo": {
      "required": [
        "error_id",
        "resolver_present"
      ],
      "type": "object",
      "description": "Metadata related to a given error_id",
      "properties": {
        "error_id": {
          "format": "int64",
          "type": "integer",
          "description": "The error id for which metadata information is needed",
          "title": "The error id for which metadata information is needed"
        },
        "resolver_present": {
          "type": "boolean",
          "description": "Indicates whether there is a resolver associated with the error or not",
          "title": "Indicates whether there is a resolver associated with the error or not"
        },
        "user_metadata": {
          "title": "User supplied metadata that might be required by the resolver",
          "description": "User supplied metadata that might be required by the resolver",
          "$ref": "#/definitions/ErrorResolverUserMetadata"
        }
      }
    },
    "DneService": {
      "allOf": [
        {
          "$ref": "#/definitions/ResourceReference"
        },
        {
          "type": "object",
          "properties": {
            "service": {
              "readOnly": false,
              "title": "Network encryption Service element",
              "description": "Dne API accepts raw protocol and ports as part of NS service element\nin Dne Rule that describes traffic corresponding to an NSService.\n",
              "$ref": "#/definitions/NSServiceElement"
            }
          }
        }
      ]
    },
    "FeatureUsageListInCsvFormat": {
      "allOf": [
        {
          "$ref": "#/definitions/CsvListResult"
        },
        {
          "type": "object",
          "properties": {
            "last_update_timestamp": {
              "readOnly": true,
              "type": "integer",
              "description": "Timestamp when the data was last updated; unset if data source has\nnever updated the data.\n",
              "format": "int64"
            },
            "results": {
              "items": {
                "$ref": "#/definitions/FeatureUsageCsvRecord"
              },
              "type": "array"
            }
          }
        }
      ]
    },
    "NSServiceGroup": {
      "description": "A Networking and Security Service Group that represents a group of NSServices\n",
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "type": "object",
          "properties": {
            "default_service": {
              "readOnly": true,
              "type": "boolean",
              "description": "The default NSServiceGroups are created in the system by default. These\nNSServiceGroups can't be modified/deleted\n",
              "title": "NSServiceGroups created in the system by default"
            },
            "service_type": {
              "readOnly": true,
              "enum": [
                "ETHER",
                "NON_ETHER"
              ],
              "type": "string",
              "description": "Type of the NSServiceGroup",
              "title": "Type of the NSServiceGroup"
            },
            "members": {
              "items": {
                "$ref": "#/definitions/ResourceReference"
              },
              "type": "array",
              "description": "List of NSService or NSServiceGroup resources that can be added as members\nto an NSServiceGroup.\n",
              "maxItems": 50
            }
          }
        }
      ]
    },
    "EdgeNode": {
      "allOf": [
        {
          "$ref": "#/definitions/Node"
        },
        {
          "type": "object",
          "properties": {
            "deployment_config": {
              "title": "Config for automatic deployment of edge node virtual machine.",
              "description": "When this configuration is specified, edge fabric node of deployment_type VIRTUAL_MACHINE\nwill be deployed and registered with MP.\n",
              "$ref": "#/definitions/EdgeNodeDeploymentConfig"
            },
            "allocation_list": {
              "items": {
                "type": "string"
              },
              "readOnly": true,
              "type": "array",
              "description": "List of logical router ids to which this edge node is allocated.",
              "title": "Allocation list"
            },
            "deployment_type": {
              "description": "Supported edge deployment type.",
              "enum": [
                "VIRTUAL_MACHINE",
                "PHYSICAL_MACHINE",
                "UNKNOWN"
              ],
              "readOnly": true,
              "type": "string"
            }
          }
        }
      ]
    },
    "BasicAuthenticationScheme": {
      "allOf": [
        {
          "$ref": "#/definitions/AuthenticationScheme"
        },
        {
          "required": [
            "username",
            "scheme_name",
            "password"
          ],
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "description": "User name to authenticate with",
              "title": "User name to authenticate with"
            },
            "scheme_name": {
              "enum": [
                "basic"
              ],
              "type": "string",
              "description": "Authentication scheme name",
              "title": "Authentication scheme name"
            },
            "password": {
              "type": "string",
              "description": "Password to authenticate with",
              "title": "Password to authenticate with"
            }
          }
        }
      ]
    },
    "DhcpOptions": {
      "type": "object",
      "properties": {
        "option121": {
          "title": "option 121",
          "description": "option 121",
          "$ref": "#/definitions/DhcpOption121"
        },
        "others": {
          "minItems": 0,
          "items": {
            "$ref": "#/definitions/GenericDhcpOption"
          },
          "type": "array",
          "maxItems": 255
        }
      }
    },
    "IpfixSwitchConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/IpfixConfig"
        },
        {
          "properties": {
            "active_timeout": {
              "description": "The time in seconds after a Flow is expired even if more packets\nmatching this Flow are received by the cache.\n",
              "title": "Active timeout",
              "default": 300,
              "format": "int32",
              "maximum": 3600,
              "minimum": 60,
              "type": "integer"
            },
            "idle_timeout": {
              "description": "The time in seconds after a Flow is expired if no more packets matching\nthis Flow are received by the cache.\n",
              "title": "Idle timeout",
              "default": 300,
              "format": "int32",
              "maximum": 3600,
              "minimum": 60,
              "type": "integer"
            },
            "packet_sample_probability": {
              "description": "The probability in percentage that a packet is sampled, in range\n0-100. The probability is equal for every packet.\n",
              "title": "Packet sample probability",
              "default": 0.1,
              "exclusiveMinimum": true,
              "maximum": 100,
              "minimum": 0,
              "type": "number"
            },
            "max_flows": {
              "description": "The maximum number of flow entries in each exporter flow cache.\n",
              "title": "Max flows",
              "default": 16384,
              "format": "int64",
              "maximum": 4294967295,
              "minimum": 0,
              "type": "integer"
            }
          },
          "type": "object"
        }
      ],
      "description": "IPFIX Config for the Switching Module",
      "title": "IPFIX Config for the Switching Module"
    },
    "LbIcmpMonitor": {
      "allOf": [
        {
          "$ref": "#/definitions/LbActiveMonitor"
        },
        {
          "type": "object",
          "properties": {
            "data_length": {
              "description": "The data size(in byte) of the ICMP healthcheck packet",
              "title": "The data size(in byte) of the ICMP healthcheck packet",
              "default": 56,
              "format": "int64",
              "maximum": 65507,
              "minimum": 0,
              "type": "integer"
            }
          }
        }
      ]
    },
    "CertificateReservationParameters": {
      "required": [
        "service_type",
        "node_id"
      ],
      "type": "object",
      "properties": {
        "service_type": {
          "type": "string",
          "description": "Service type",
          "enum": [
            "MGMT_CLUSTER",
            "MGMT_PLANE",
            "API"
          ]
        },
        "node_id": {
          "type": "string",
          "description": "Node id",
          "title": "Node id"
        }
      }
    },
    "NodeNetworkInterfaceProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "physical_address": {
              "readOnly": true,
              "type": "string",
              "description": "Interface MAC address",
              "title": "Interface MAC address"
            },
            "broadcast_address": {
              "type": "string",
              "description": "Interface broadcast address",
              "title": "Interface broadcast address"
            },
            "link_status": {
              "readOnly": true,
              "enum": [
                "up",
                "down"
              ],
              "type": "string",
              "description": "Interface administration status",
              "title": "Interface administration status"
            },
            "default_gateway": {
              "type": "string",
              "description": "Interface's default gateway",
              "title": "Interface's default gateway"
            },
            "bond_primary": {
              "type": "string",
              "description": "Bond's primary device name in active-backup bond mode",
              "title": "Bond's primary device name in active-backup bond mode"
            },
            "bond_slaves": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "Bond's slave devices",
              "title": "Bond's slave devices"
            },
            "ip_addresses": {
              "items": {
                "$ref": "#/definitions/IPv4AddressProperties"
              },
              "type": "array",
              "description": "Interface IP addresses",
              "maxItems": 1,
              "title": "Interface IP addresses"
            },
            "admin_status": {
              "readOnly": true,
              "enum": [
                "up",
                "down"
              ],
              "type": "string",
              "description": "Interface administration status",
              "title": "Interface administration status"
            },
            "interface_id": {
              "readOnly": true,
              "type": "string",
              "description": "Interface ID",
              "title": "Interface ID"
            },
            "bond_mode": {
              "enum": [
                "ACTIVE_BACKUP",
                "802_3AD"
              ],
              "type": "string",
              "description": "Bond mode",
              "title": "Bond mode"
            },
            "plane": {
              "enum": [
                "mgmt",
                "debug"
              ],
              "type": "string",
              "description": "Interface plane",
              "title": "Interface plane"
            },
            "ip_configuration": {
              "enum": [
                "dhcp",
                "static",
                "not configured"
              ],
              "type": "string",
              "description": "Interface configuration",
              "title": "Interface configuration"
            },
            "mtu": {
              "format": "int64",
              "type": "integer",
              "description": "Interface MTU",
              "title": "Interface MTU"
            }
          },
          "required": [
            "ip_configuration"
          ],
          "type": "object"
        }
      ],
      "description": "Node network interface properties",
      "title": "Node network interface properties"
    },
    "NSGroupComplexExpression": {
      "allOf": [
        {
          "$ref": "#/definitions/NSGroupExpression"
        },
        {
          "properties": {
            "expressions": {
              "items": {
                "$ref": "#/definitions/NSGroupExpression"
              },
              "type": "array",
              "description": "Represents expressions which are to be logically 'AND'ed.The array cannot contain\nNSGroupComplexExpression.Only NSGroupTagExpression and NSGroupSimpleExpressions\nare accepted\n",
              "maxItems": 2,
              "title": "List of simple and tag expressions"
            }
          },
          "required": [
            "expressions"
          ],
          "type": "object"
        }
      ],
      "description": "Complex expressions to represent NSGroup membership",
      "title": "Complex expressions to represent NSGroup membership"
    },
    "LbServiceStatisticsCounter": {
      "type": "object",
      "properties": {
        "l4_total_sessions": {
          "format": "int64",
          "type": "integer",
          "description": "Number of l4 total sessions",
          "title": "Number of l4 total sessions"
        },
        "l7_current_sessions": {
          "format": "int64",
          "type": "integer",
          "description": "Number of l7 current sessions",
          "title": "Number of l7 current sessions"
        },
        "l4_max_sessions": {
          "format": "int64",
          "type": "integer",
          "description": "L4 max sessions is used to show the peak L4 max session data since\nload balancer starts to provide service.\n",
          "title": "Number of l4 maximum sessions"
        },
        "l4_current_sessions": {
          "format": "int64",
          "type": "integer",
          "description": "Number of l4 current sessions",
          "title": "Number of l4 current sessions"
        },
        "l7_total_sessions": {
          "format": "int64",
          "type": "integer",
          "description": "Number of l7 total sessions",
          "title": "Number of l7 total sessions"
        },
        "l4_current_session_rate": {
          "type": "number",
          "description": "The average number of l4 current sessions per second, the number is\naveraged over the last 5 one-second intervals.\n",
          "title": "The average number of l4 current sessions per second, the number is\naveraged over the last 5 one-second intervals.\n"
        },
        "l7_current_session_rate": {
          "type": "number",
          "description": "The average number of l7 current requests per second, the number is\naveraged over the last 5 one-second intervals.\n",
          "title": "The average number of l7 current requests per second, the number is\naveraged over the last 5 one-second intervals.\n"
        },
        "l7_max_sessions": {
          "format": "int64",
          "type": "integer",
          "description": "L7 max sessions is used to show the peak L7 max session data since\nload balancer starts to provide service.\n",
          "title": "Number of l7 maximum sessions"
        }
      }
    },
    "PnicMirrorDestination": {
      "allOf": [
        {
          "$ref": "#/definitions/MirrorDestination"
        },
        {
          "required": [
            "dest_pnics",
            "node_id"
          ],
          "type": "object",
          "properties": {
            "dest_pnics": {
              "description": "Physical NIC device names to which to send the mirrored packets",
              "title": "Physical NIC device names to which to send the mirrored packets",
              "minItems": 1,
              "items": {
                "type": "string"
              },
              "maxItems": 3,
              "type": "array"
            },
            "node_id": {
              "type": "string",
              "description": "Transport node to which to send the mirrored packets",
              "title": "Transport node to which to send the mirrored packets"
            }
          }
        }
      ]
    },
    "NodeSnmpServiceProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/NodeServiceProperties"
        },
        {
          "properties": {
            "service_properties": {
              "title": "SNMP Service properties",
              "description": "SNMP Service properties",
              "$ref": "#/definitions/SnmpServiceProperties"
            }
          },
          "required": [
            "service_properties"
          ],
          "type": "object"
        }
      ],
      "description": "Node SNMP service properties",
      "title": "Node SNMP service properties"
    },
    "RealizationStateBarrierConfig": {
      "description": "The configuration data for setting the global realization state barrier\n",
      "allOf": [
        {
          "$ref": "#/definitions/RevisionedResource"
        },
        {
          "required": [
            "interval"
          ],
          "type": "object",
          "properties": {
            "interval": {
              "description": "The interval in milliseconds used for auto incrementing the barrier number\n",
              "format": "int64",
              "title": "Interval in milliseconds",
              "readOnly": false,
              "minimum": 0,
              "type": "integer"
            }
          }
        }
      ]
    },
    "AllocationIpAddressListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/AllocationIpAddress"
              },
              "type": "array",
              "description": "Pool allocation list results",
              "title": "Pool allocation list results"
            }
          }
        }
      ]
    },
    "CertificateList": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/Certificate"
              },
              "readOnly": true,
              "type": "array",
              "description": "Certificate list"
            }
          },
          "type": "object"
        }
      ],
      "description": "Certificate queries result",
      "title": "Certificate queries result"
    },
    "LbClientSslProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/LbSslProfile"
        },
        {
          "type": "object",
          "properties": {
            "session_cache_enabled": {
              "default": true,
              "type": "boolean",
              "description": "SSL session caching allows SSL client and server to reuse previously\nnegotiated security parameters avoiding the expensive public key\noperation during handshake.\n",
              "title": "session cache enable/disable flag"
            },
            "session_cache_timeout": {
              "description": "Session cache timeout specifies how long the SSL session parameters\nare held on to and can be reused.\n",
              "title": "SSL session cache timeout value",
              "default": 300,
              "format": "int64",
              "maximum": 86400,
              "minimum": 1,
              "type": "integer"
            },
            "prefer_server_ciphers": {
              "default": false,
              "type": "boolean",
              "description": "During SSL handshake as part of the SSL client Hello client sends an\nordered list of ciphers that it can support (or prefers) and typically\nserver selects the first one from the top of that list it can also\nsupport. For Perfect Forward Secrecy(PFS), server could override the\nclient's preference.\n",
              "title": "prefer server ciphers flag"
            },
            "is_secure": {
              "readOnly": true,
              "type": "boolean",
              "description": "This flag is set to true when all the ciphers and protocols are secure.\nIt is set to false when one of the ciphers or protocols is insecure.\n",
              "title": "Secure/Insecure SSL profile flag"
            },
            "ciphers": {
              "items": {
                "enum": [
                  "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
                  "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
                  "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
                  "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
                  "TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA",
                  "TLS_ECDH_RSA_WITH_AES_256_CBC_SHA",
                  "TLS_RSA_WITH_AES_256_CBC_SHA",
                  "TLS_RSA_WITH_AES_128_CBC_SHA",
                  "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
                  "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
                  "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
                  "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384",
                  "TLS_RSA_WITH_AES_128_CBC_SHA256",
                  "TLS_RSA_WITH_AES_128_GCM_SHA256",
                  "TLS_RSA_WITH_AES_256_CBC_SHA256",
                  "TLS_RSA_WITH_AES_256_GCM_SHA384",
                  "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
                  "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
                  "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
                  "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384",
                  "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
                  "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA",
                  "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256",
                  "TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256",
                  "TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384",
                  "TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384",
                  "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA",
                  "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256",
                  "TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256",
                  "TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384",
                  "TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384"
                ],
                "type": "string",
                "description": "SSL cipher"
              },
              "type": "array",
              "description": "supported SSL cipher list to client side",
              "title": "supported SSL cipher list to client side"
            },
            "protocols": {
              "items": {
                "enum": [
                  "SSL_V2",
                  "SSL_V3",
                  "TLS_V1",
                  "TLS_V1_1",
                  "TLS_V1_2"
                ],
                "type": "string",
                "description": "SSL protocol"
              },
              "type": "array",
              "description": "SSL versions TLS1.1 and TLS1.2 are supported and enabled by default.\nSSLv2, SSLv3, and TLS1.0 are supported, but disabled by default.\n",
              "title": "supported SSL protocol list to client side"
            }
          }
        }
      ]
    },
    "NodeStatusListResult": {
      "properties": {
        "results": {
          "items": {
            "$ref": "#/definitions/NodeStatus"
          },
          "type": "array",
          "description": "Node Status list results",
          "title": "Node Status list results"
        }
      },
      "required": [
        "results"
      ],
      "type": "object",
      "description": "Node Status list result",
      "title": "Node Status list result"
    },
    "CommunicationProfileEntryListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/CommunicationProfileEntry"
              },
              "type": "array",
              "description": "CommunicationProfileEntry list results",
              "title": "CommunicationProfileEntry list results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Paged Collection of CommunicationProfileEntries",
      "title": "Paged Collection of CommunicationProfileEntries"
    },
    "DhcpIpPool": {
      "allOf": [
        {
          "$ref": "#/definitions/IpAllocationBase"
        },
        {
          "required": [
            "allocation_ranges"
          ],
          "type": "object",
          "properties": {
            "allocation_ranges": {
              "items": {
                "$ref": "#/definitions/IpPoolRange"
              },
              "type": "array",
              "description": "ip-ranges",
              "title": "ip-ranges"
            },
            "warning_threshold": {
              "description": "warning threshold, valid [50-80], default 80",
              "title": "warning threshold, valid [50-80], default 80",
              "default": 80,
              "format": "int64",
              "maximum": 80,
              "minimum": 50,
              "type": "integer"
            },
            "error_threshold": {
              "description": "error threshold, valid [80-100], default 100",
              "title": "error threshold, valid [80-100], default 100",
              "default": 100,
              "format": "int64",
              "maximum": 100,
              "minimum": 80,
              "type": "integer"
            }
          }
        }
      ]
    },
    "PolicyRealizedResource": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyResource"
        },
        {
          "properties": {
            "intent_reference": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "Desire state paths of this object",
              "title": "Desire state paths of this object"
            },
            "realization_specific_identifier": {
              "type": "string",
              "description": "Realization id of this object",
              "title": "Realization id of this object"
            },
            "state": {
              "enum": [
                "UNAVAILABLE",
                "UNREALIZED",
                "REALIZED",
                "ERROR"
              ],
              "type": "string",
              "description": "Realization state of this object",
              "title": "Realization state of this object"
            },
            "alarms": {
              "items": {
                "$ref": "#/definitions/PolicyAlarmResource"
              },
              "type": "array",
              "description": "Alarm info detail",
              "title": "Alarm info detail"
            }
          },
          "required": [
            "state"
          ],
          "type": "object"
        }
      ],
      "description": "Abstract base class for all the realized policy objects",
      "title": "Abstract base class for all the realized policy objects"
    },
    "Lag": {
      "properties": {
        "uplinks": {
          "description": "uplink names",
          "title": "uplink names",
          "items": {
            "$ref": "#/definitions/Uplink"
          },
          "readOnly": true,
          "maxItems": 32,
          "type": "array"
        },
        "name": {
          "type": "string",
          "description": "Lag name",
          "title": "Lag name"
        },
        "number_of_uplinks": {
          "description": "number of uplinks",
          "format": "int32",
          "title": "number of uplinks",
          "maximum": 32,
          "minimum": 2,
          "type": "integer"
        },
        "timeout_type": {
          "default": "SLOW",
          "enum": [
            "SLOW",
            "FAST"
          ],
          "type": "string",
          "description": "LACP timeout type",
          "title": "LACP timeout type"
        },
        "load_balance_algorithm": {
          "enum": [
            "SRCMAC",
            "DESTMAC",
            "SRCDESTMAC",
            "SRCDESTIPVLAN",
            "SRCDESTMACIPPORT"
          ],
          "type": "string",
          "description": "LACP load balance Algorithm",
          "title": "LACP load balance Algorithm"
        },
        "id": {
          "readOnly": true,
          "type": "string",
          "description": "unique id",
          "title": "unique id"
        },
        "mode": {
          "enum": [
            "ACTIVE",
            "PASSIVE"
          ],
          "type": "string",
          "description": "LACP group mode",
          "title": "LACP group mode"
        }
      },
      "required": [
        "load_balance_algorithm",
        "mode",
        "name",
        "number_of_uplinks"
      ],
      "type": "object",
      "description": "LACP group",
      "title": "LACP group"
    },
    "GlobalRestoreStatus": {
      "type": "object",
      "properties": {
        "description": {
          "readOnly": true,
          "type": "string",
          "description": "A description of the restore status",
          "title": "A description of the restore status"
        },
        "value": {
          "readOnly": true,
          "enum": [
            "NOT_AVAILABLE",
            "NOT_STARTED",
            "SUCCESS",
            "ERROR",
            "RUNNING",
            "SUSPENDING",
            "SUSPENDED",
            "ABORTED"
          ],
          "type": "string",
          "description": "Global rolled-up restore status value",
          "title": "Global rolled-up restore status value"
        }
      }
    },
    "UpgradeUnitGroupAggregateInfo": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "type"
          ],
          "type": "object",
          "properties": {
            "status": {
              "readOnly": true,
              "enum": [
                "SUCCESS",
                "FAILED",
                "IN_PROGRESS",
                "NOT_STARTED",
                "PAUSED"
              ],
              "type": "string",
              "description": "Upgrade status of upgrade unit group",
              "title": "Upgrade status of upgrade unit group"
            },
            "upgrade_unit_count": {
              "readOnly": true,
              "format": "int32",
              "type": "integer",
              "description": "Number of upgrade units in the group",
              "title": "Count of upgrade units in the group"
            },
            "failed_count": {
              "readOnly": true,
              "format": "int32",
              "type": "integer",
              "description": "Number of nodes in the upgrade unit group that failed upgrade",
              "title": "Number of nodes in the upgrade unit group that failed upgrade"
            },
            "type": {
              "readOnly": false,
              "type": "string",
              "description": "Component type",
              "title": "Component type"
            },
            "percent_complete": {
              "readOnly": true,
              "type": "number",
              "description": "Indicator of upgrade progress in percentage",
              "title": "Indicator of upgrade progress in percentage"
            },
            "enabled": {
              "default": true,
              "readOnly": false,
              "type": "boolean",
              "description": "Flag to indicate whether upgrade of this group is enabled or not",
              "title": "Flag to indicate whether upgrade of this group is enabled or not"
            },
            "upgrade_units": {
              "description": "List of upgrade units in the group",
              "title": "List of upgrade units in the group",
              "items": {
                "$ref": "#/definitions/UpgradeUnit"
              },
              "readOnly": false,
              "maxItems": 100,
              "type": "array"
            },
            "extended_configuration": {
              "description": "Extended configuration for the group",
              "title": "Extended configuration for the group",
              "items": {
                "$ref": "#/definitions/KeyValuePair"
              },
              "readOnly": false,
              "maxItems": 100,
              "type": "array"
            },
            "parallel": {
              "default": true,
              "readOnly": false,
              "type": "boolean",
              "description": "Upgrade method to specify whether the upgrade is to be performed in parallel or serially",
              "title": "Upgrade method to specify whether the upgrade is to be performed in parallel or serially"
            }
          }
        }
      ]
    },
    "NsxManagerAccountsListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/NsxManagerAccount"
              },
              "type": "array",
              "description": "NSX Manager Accounts list",
              "title": "NSX Manager Accounts list"
            }
          },
          "type": "object"
        }
      ],
      "description": "NSX Manager Accounts list",
      "title": "NSX Manager Accounts list"
    },
    "CopyFromRemoteFileProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/CopyRemoteFileProperties"
        },
        {
          "required": [
            "protocol"
          ],
          "type": "object",
          "properties": {
            "protocol": {
              "description": "Protocol to use to copy file",
              "title": "Protocol to use to copy file"
            }
          }
        }
      ]
    },
    "PolicyConfigResource": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyResource"
        },
        {
          "type": "object"
        }
      ],
      "description": "Represents an object on the desired state",
      "title": "Represents an object on the desired state"
    },
    "BridgeClusterListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "description": "BridgeCluster Results",
              "title": "BridgeCluster Results",
              "minItems": 0,
              "items": {
                "$ref": "#/definitions/BridgeCluster"
              },
              "readOnly": true,
              "type": "array"
            }
          },
          "type": "object"
        }
      ],
      "description": "Bridge cluster queries result",
      "title": "Bridge cluster queries result"
    },
    "LbFastUdpProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/LbAppProfile"
        },
        {
          "type": "object",
          "properties": {
            "idle_timeout": {
              "description": "Though UDP is a connectionless protocol, for the purposes of load\nbalancing, all UDP packets with the same flow signature (source and\ndestination IP/ports and IP protocol) received within the idle timeout\nperiod are considered to belong to the same connection and are sent to\nthe same backend server. If no packets are received for idle timeout\nperiod, the connection (association between flow signature and the\nselected server) is cleaned up.\n",
              "format": "int64",
              "default": 300,
              "title": "UDP idle timeout in seconds",
              "minimum": 1,
              "type": "integer"
            },
            "flow_mirroring_enabled": {
              "default": false,
              "type": "boolean",
              "description": "If flow mirroring is enabled, all the flows to the bounded virtual\nserver are mirrored to the standby node.\n",
              "title": "flow mirroring enabled flag"
            }
          }
        }
      ]
    },
    "ALGTypeServiceEntry": {
      "allOf": [
        {
          "$ref": "#/definitions/ServiceEntry"
        },
        {
          "properties": {
            "alg": {
              "enum": [
                "ORACLE_TNS",
                "FTP",
                "SUN_RPC_TCP",
                "SUN_RPC_UDP",
                "MS_RPC_TCP",
                "MS_RPC_UDP",
                "NBNS_BROADCAST",
                "NBDG_BROADCAST"
              ],
              "type": "string"
            },
            "destination_ports": {
              "items": {
                "format": "port-or-range",
                "type": "string",
                "description": "Examples- Single port \"8080\", Range of ports \"8090-8095\"\n"
              },
              "type": "array",
              "description": "The destination_port cannot be empty and must be a single value.",
              "maxItems": 15,
              "title": "The destination_port cannot be empty and must be a single value."
            },
            "source_ports": {
              "items": {
                "format": "port-or-range",
                "type": "string",
                "description": "Examples- Single port \"8080\", Range of ports \"8090-8095\"\n"
              },
              "type": "array",
              "maxItems": 15
            }
          },
          "required": [
            "alg"
          ],
          "type": "object"
        }
      ],
      "description": "An ServiceEntry that represents an ALG protocol",
      "title": "An ServiceEntry that represents an ALG protocol"
    },
    "RealizedFirewall": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyRealizedResource"
        },
        {
          "required": [
            "resource_type"
          ],
          "discriminator": "resource_type",
          "type": "object",
          "properties": {
            "resource_type": {
              "enum": [
                "RealizedFirewallSection"
              ],
              "type": "string"
            }
          }
        }
      ],
      "description": "Realized firewall",
      "title": "Realized firewall"
    },
    "ManagementNodeAggregateInfo": {
      "allOf": [
        {
          "$ref": "#/definitions/BaseNodeAggregateInfo"
        },
        {
          "type": "object",
          "properties": {
            "transport_nodes_connected": {
              "readOnly": true,
              "minimum": 0,
              "type": "integer",
              "format": "int64"
            },
            "role_config": {
              "readOnly": true,
              "$ref": "#/definitions/ManagementClusterRoleConfig"
            }
          }
        }
      ]
    },
    "IPProtocolNSService": {
      "allOf": [
        {
          "$ref": "#/definitions/NSServiceElement"
        },
        {
          "properties": {
            "protocol_number": {
              "type": "integer",
              "format": "int64"
            }
          },
          "required": [
            "protocol_number"
          ],
          "type": "object"
        }
      ],
      "description": "An NSService element that represents an IP protocol",
      "title": "An NSService element that represents an IP protocol"
    },
    "EffectiveMemberResourceListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "title": "effective members resource list results",
                "$ref": "#/definitions/ResourceReference"
              },
              "type": "array",
              "description": "Paged Collection of resources which are the effective members of an NSGroup.",
              "title": "Paged Collection of resources which are the effective members of an NSGroup."
            }
          }
        }
      ]
    },
    "MacLearningSpec": {
      "properties": {
        "limit": {
          "description": "The maximum number of MAC addresses that can be learned on this port",
          "title": "The maximum number of MAC addresses that can be learned on this port",
          "default": 4096,
          "format": "int32",
          "maximum": 4096,
          "readOnly": false,
          "minimum": 0,
          "type": "integer"
        },
        "aging_time": {
          "description": "Aging time in sec for learned MAC address",
          "format": "int32",
          "default": 300,
          "title": "Aging time in sec for learned MAC address",
          "readOnly": true,
          "type": "integer"
        },
        "enabled": {
          "readOnly": false,
          "type": "boolean",
          "description": "Allowing source MAC address learning",
          "title": "Allowing source MAC address learning"
        },
        "limit_policy": {
          "description": "The policy after MAC Limit is exceeded",
          "title": "The policy after MAC Limit is exceeded",
          "default": "ALLOW",
          "enum": [
            "ALLOW",
            "DROP"
          ],
          "readOnly": false,
          "type": "string"
        },
        "unicast_flooding_allowed": {
          "default": true,
          "readOnly": false,
          "type": "boolean",
          "description": "Allowing flooding for unlearned MAC for ingress traffic",
          "title": "Allowing flooding for unlearned MAC for ingress traffic"
        }
      },
      "required": [
        "enabled"
      ],
      "type": "object",
      "description": "MAC learning configuration",
      "title": "MAC learning configuration"
    },
    "AddClusterNodeSpec": {
      "type": "object",
      "properties": {
        "external_id": {
          "readOnly": false,
          "type": "string",
          "description": "Internal identifier of the node",
          "title": "Internal identifier of the node"
        },
        "controller_role_config": {
          "$ref": "#/definitions/AddControllerNodeSpec"
        },
        "display_name": {
          "type": "string",
          "description": "Display name for the node",
          "title": "Display name for the node"
        },
        "mgr_role_config": {
          "$ref": "#/definitions/AddManagementNodeSpec"
        }
      }
    },
    "FileTransferAuthenticationScheme": {
      "required": [
        "username",
        "scheme_name"
      ],
      "type": "object",
      "properties": {
        "username": {
          "type": "string",
          "description": "User name to authenticate with",
          "title": "User name to authenticate with"
        },
        "scheme_name": {
          "enum": [
            "PASSWORD"
          ],
          "type": "string",
          "description": "Authentication scheme name",
          "title": "Authentication scheme name"
        },
        "password": {
          "type": "string",
          "description": "Password to authenticate with",
          "title": "Password to authenticate with"
        }
      }
    },
    "RealizedMACSet": {
      "allOf": [
        {
          "$ref": "#/definitions/PolicyRealizedResource"
        },
        {
          "type": "object"
        }
      ],
      "description": "Realized MACSet",
      "title": "Realized MACSet"
    },
    "HostSwitchProfileTypeIdEntry": {
      "required": [
        "value"
      ],
      "type": "object",
      "properties": {
        "value": {
          "readOnly": false,
          "type": "string",
          "description": "key value"
        },
        "key": {
          "enum": [
            "UplinkHostSwitchProfile",
            "LldpHostSwitchProfile"
          ],
          "type": "string",
          "description": "Supported HostSwitch profiles."
        }
      }
    },
    "MACAddressElement": {
      "allOf": [
        {
          "$ref": "#/definitions/RevisionedResource"
        },
        {
          "properties": {
            "mac_address": {
              "pattern": "/^(([0-9A-Fa-f]{2}[:]){5}([0-9A-Fa-f]{2}))|(([0-9A-Fa-f]{2}[-]){5}([0-9A-Fa-f]{2}))$/",
              "type": "string",
              "description": "A MAC address. Must be 6 pairs of hexadecimal digits, upper or lower case,\nseparated by colons or dashes. Examples: 01:23:45:67:89:ab, 01-23-45-67-89-AB.\n"
            }
          },
          "type": "object"
        }
      ],
      "description": "MAC Address",
      "title": "MAC Address"
    },
    "LogicalRouterPortArpTable": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "logical_router_port_id"
          ],
          "type": "object",
          "properties": {
            "last_update_timestamp": {
              "readOnly": true,
              "type": "integer",
              "description": "Timestamp when the data was last updated; unset if data source has never updated the data.",
              "format": "int64"
            },
            "results": {
              "items": {
                "$ref": "#/definitions/LogicalRouterPortArpEntry"
              },
              "type": "array"
            },
            "logical_router_port_id": {
              "type": "string",
              "description": "The ID of the logical router port",
              "title": "The ID of the logical router port"
            }
          }
        }
      ]
    },
    "QosBaseRateShaper": {
      "properties": {
        "enabled": {
          "type": "boolean"
        },
        "resource_type": {
          "default": "IngressRateShaper",
          "enum": [
            "IngressRateShaper",
            "IngressBroadcastRateShaper",
            "EgressRateShaper"
          ],
          "type": "string"
        }
      },
      "required": [
        "enabled"
      ],
      "type": "object",
      "description": "A shaper configuration entry that specifies type and metrics",
      "title": "A shaper configuration entry that specifies type and metrics"
    },
    "ActionableResourceListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/ActionableResource"
              },
              "type": "array",
              "description": "List results",
              "title": "List results"
            }
          }
        }
      ]
    },
    "ServiceListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/Service"
              },
              "type": "array",
              "description": "Service list results",
              "title": "Service list results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Paged Collection of Services",
      "title": "Paged Collection of Services"
    },
    "SupportBundleFileTransferAuthenticationScheme": {
      "required": [
        "username",
        "scheme_name",
        "password"
      ],
      "type": "object",
      "properties": {
        "username": {
          "type": "string",
          "description": "User name to authenticate with",
          "title": "User name to authenticate with"
        },
        "scheme_name": {
          "enum": [
            "PASSWORD"
          ],
          "type": "string",
          "description": "Authentication scheme name",
          "title": "Authentication scheme name"
        },
        "password": {
          "type": "string",
          "description": "Password to authenticate with",
          "title": "Password to authenticate with"
        }
      }
    },
    "TaskProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/Resource"
        },
        {
          "properties": {
            "status": {
              "description": "Current status of the task",
              "enum": [
                "running",
                "error",
                "success",
                "canceling",
                "canceled",
                "killed"
              ],
              "readOnly": true,
              "type": "string"
            },
            "async_response_available": {
              "readOnly": true,
              "type": "boolean",
              "description": "True if response for asynchronous request is available",
              "title": "True if response for asynchronous request is available"
            },
            "description": {
              "readOnly": true,
              "type": "string",
              "description": "Description of the task",
              "title": "Description of the task"
            },
            "start_time": {
              "readOnly": true,
              "type": "integer",
              "description": "The start time of the task in epoch milliseconds",
              "format": "int64"
            },
            "cancelable": {
              "readOnly": true,
              "type": "boolean",
              "description": "True if this task can be canceled",
              "title": "True if this task can be canceled"
            },
            "request_method": {
              "readOnly": true,
              "type": "string",
              "description": "HTTP request method",
              "title": "HTTP request method"
            },
            "user": {
              "readOnly": true,
              "type": "string",
              "description": "Name of the user who created this task",
              "title": "Name of the user who created this task"
            },
            "progress": {
              "description": "Task progress if known, from 0 to 100",
              "title": "Task progress if known, from 0 to 100",
              "format": "int64",
              "maximum": 100,
              "readOnly": true,
              "minimum": 0,
              "type": "integer"
            },
            "message": {
              "readOnly": true,
              "type": "string",
              "description": "A message describing the disposition of the task",
              "title": "A message describing the disposition of the task"
            },
            "request_uri": {
              "readOnly": true,
              "type": "string",
              "description": "URI of the method invocation that spawned this task",
              "title": "URI of the method invocation that spawned this task"
            },
            "id": {
              "readOnly": true,
              "type": "string",
              "description": "Identifier for this task",
              "title": "Identifier for this task"
            },
            "end_time": {
              "readOnly": true,
              "type": "integer",
              "description": "The end time of the task in epoch milliseconds",
              "format": "int64"
            }
          },
          "type": "object"
        }
      ],
      "description": "Task properties",
      "title": "Task properties"
    },
    "MultiWidgetConfiguration": {
      "allOf": [
        {
          "$ref": "#/definitions/WidgetConfiguration"
        },
        {
          "properties": {
            "widgets": {
              "minItems": 1,
              "items": {
                "$ref": "#/definitions/WidgetItem"
              },
              "type": "array",
              "description": "Array of widgets that are part of the multi-widget.",
              "title": "Widgets"
            }
          },
          "required": [
            "widgets"
          ],
          "type": "object"
        }
      ],
      "description": "Combines two or more widgetconfigurations into a multi-widget",
      "title": "Multi-Widget"
    },
    "CsvListResult": {
      "type": "object",
      "description": "Base type for CSV result.",
      "properties": {
        "file_name": {
          "type": "string",
          "description": "File name set by HTTP server if API  returns CSV result as a file.",
          "title": "File name"
        }
      }
    },
    "LogicalPortMirrorSource": {
      "allOf": [
        {
          "$ref": "#/definitions/MirrorSource"
        },
        {
          "required": [
            "port_ids"
          ],
          "type": "object",
          "properties": {
            "port_ids": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "description": "Source logical port identifier list",
              "title": "Source logical port identifier list"
            }
          }
        }
      ]
    },
    "IpPoolListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/IpPool"
              },
              "type": "array",
              "description": "IP pool list results",
              "title": "IP pool list results"
            }
          }
        }
      ]
    },
    "QueryPipeRequest": {
      "properties": {
        "query": {
          "type": "string",
          "description": "Subsequent queries can specify the field values\nto be used from the output of the previous query.\nThese fields are to be specified within curly braces.\ne.g. resource_type:LogicalSwitch AND transport_zone_id:{id}.\n",
          "title": "Search query"
        }
      },
      "required": [
        "query"
      ],
      "type": "object",
      "description": "The search query",
      "title": "Query pipe request"
    },
    "IpAssignmentSpec": {
      "description": "Abstract base type for specification of IPs to be used with host switch virtual tunnel endpoints",
      "title": "Abstract base type for specification of IPs to be used with host switch virtual tunnel endpoints",
      "required": [
        "resource_type"
      ],
      "discriminator": "resource_type",
      "type": "object",
      "properties": {
        "resource_type": {
          "enum": [
            "StaticIpPoolSpec",
            "StaticIpListSpec",
            "AssignedByDhcp"
          ],
          "type": "string"
        }
      }
    },
    "LogicalRouterPortCounters": {
      "type": "object",
      "properties": {
        "dropped_packets": {
          "format": "int64",
          "type": "integer",
          "description": "The number of dropped packets",
          "title": "The number of dropped packets"
        },
        "total_bytes": {
          "format": "int64",
          "type": "integer",
          "description": "The total number of bytes",
          "title": "The total number of bytes"
        },
        "total_packets": {
          "format": "int64",
          "type": "integer",
          "description": "The total number of packets",
          "title": "The total number of packets"
        }
      }
    },
    "FabricModule": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "properties": {
            "deployment_specs": {
              "items": {
                "$ref": "#/definitions/DeploymentSpec"
              },
              "type": "array",
              "description": "List of deployment specs",
              "title": "List of deployment specs"
            },
            "current_version": {
              "type": "string",
              "description": "current version on for the host prep fabric module.",
              "title": "current version on for the host prep fabric module."
            },
            "fabric_module_name": {
              "type": "string",
              "description": "Name of the fabric module",
              "title": "Name of the fabric module"
            }
          },
          "required": [
            "deployment_specs",
            "current_version",
            "fabric_module_name"
          ],
          "type": "object"
        }
      ],
      "description": "Fabric module contains list of deployment specs and current version.\nEach deployment spec is a different version of same fabric module.\nIf fabric module have two deployment specs or say two different versions then\ncurrent version will specify which version needs to be installed.\n",
      "title": "Fabric Module contains list of deployment specs and current version."
    },
    "ClusterBackupInfoListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/ClusterBackupInfo"
              },
              "readOnly": true,
              "type": "array",
              "description": "List of timestamps of backed-up cluster files",
              "title": "List of timestamps of backed-up cluster files"
            }
          }
        }
      ]
    },
    "MacPool": {
      "description": "A collection of ranges of MAC addresses",
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "required": [
            "ranges"
          ],
          "type": "object",
          "properties": {
            "ranges": {
              "items": {
                "$ref": "#/definitions/MacRange"
              },
              "type": "array",
              "description": "Array of ranges for MAC addresses",
              "title": "Array of ranges for MAC addresses"
            }
          }
        }
      ]
    },
    "LbSslProfile": {
      "allOf": [
        {
          "$ref": "#/definitions/ManagedResource"
        },
        {
          "type": "object"
        }
      ],
      "description": "Load balancer abstract SSL profile",
      "title": "Load balancer abstract SSL profile"
    },
    "BatchResponseItem": {
      "required": [
        "code"
      ],
      "type": "object",
      "properties": {
        "body": {
          "type": "object",
          "description": "object returned by api",
          "title": "object returned by api"
        },
        "headers": {
          "type": "object",
          "description": "The headers returned by the API call",
          "title": "object returned by api"
        },
        "code": {
          "format": "int64",
          "type": "integer",
          "description": "http status code",
          "title": "object returned by api"
        }
      }
    },
    "ManagementConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/RevisionedResource"
        },
        {
          "required": [
            "publish_fqdns"
          ],
          "type": "object",
          "properties": {
            "publish_fqdns": {
              "type": "boolean",
              "description": "True if Management nodes publish their fqdns(instead of default IP addresses) across NSX for its reachability.",
              "title": "True if Management nodes publish their fqdns(instead of default IP addresses) across NSX for its reachability."
            }
          }
        }
      ]
    },
    "RoleListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "required": [
            "results"
          ],
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/Role"
              },
              "type": "array",
              "description": "List results",
              "title": "List results"
            }
          }
        }
      ]
    },
    "ReportAppResultsForVmsRequestParameters": {
      "properties": {
        "vm_ids": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Vm external Ids",
          "title": "Vm external Ids"
        }
      },
      "type": "object",
      "description": "Parameters to query results of an application discovery session. It has a list of vm ids.\n",
      "title": "Parameters to request results of an application discovery session"
    },
    "NodeNetworkInterfacePropertiesListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/NodeNetworkInterfaceProperties"
              },
              "type": "array",
              "description": "Node network interface property results",
              "title": "Node network interface property results"
            }
          },
          "required": [
            "results"
          ],
          "type": "object"
        }
      ],
      "description": "Node network interface properties list results",
      "title": "Node network interface properties list results"
    },
    "WeeklyBackupSchedule": {
      "allOf": [
        {
          "$ref": "#/definitions/BackupSchedule"
        },
        {
          "required": [
            "days_of_week",
            "minute_of_day",
            "hour_of_day"
          ],
          "type": "object",
          "properties": {
            "days_of_week": {
              "description": "Days of week when backup is taken. 0 - Sunday, 1 - Monday, 2 - Tuesday, 3 - Wednesday ...",
              "title": "Days of week when backup is taken. 0 - Sunday, 1 - Monday, 2 - Tuesday, 3 - Wednesday ...",
              "minItems": 1,
              "items": {
                "type": "integer",
                "format": "int64"
              },
              "maxItems": 7,
              "uniqueItems": true,
              "type": "array"
            },
            "minute_of_day": {
              "description": "Time of day when backup is taken",
              "format": "int64",
              "title": "Time of day when backup is taken",
              "maximum": 59,
              "minimum": 0,
              "type": "integer"
            },
            "hour_of_day": {
              "description": "Time of day when backup is taken",
              "format": "int64",
              "title": "Time of day when backup is taken",
              "maximum": 23,
              "minimum": 0,
              "type": "integer"
            }
          }
        }
      ]
    },
    "DneKeyManagerListResult": {
      "allOf": [
        {
          "$ref": "#/definitions/ListResult"
        },
        {
          "type": "object",
          "properties": {
            "results": {
              "items": {
                "$ref": "#/definitions/DneKeyManager"
              },
              "readOnly": true,
              "type": "array",
              "description": "List of DNE key managers.",
              "title": "DNE key manager list"
            }
          }
        }
      ]
    },
    "NodeAuthProviderVidmProperties": {
      "properties": {
        "host_name": {
          "type": "string",
          "description": "Fully Qualified Domain Name(FQDN) of vIDM",
          "title": "Fully Qualified Domain Name(FQDN) of vIDM"
        },
        "client_id": {
          "type": "string",
          "description": "vIDM client id",
          "title": "vIDM client id"
        },
        "thumbprint": {
          "type": "string",
          "description": "Hexadecimal SHA256 hash of the vIDM server's X.509 certificate",
          "title": "vIDM certificate thumbprint"
        },
        "client_secret": {
          "type": "string",
          "description": "vIDM client secret",
          "title": "vIDM client secret"
        },
        "node_host_name": {
          "type": "string",
          "description": "host name to use when creating the redirect URL for clients to follow after authenticating to vIDM",
          "title": "host name of the node redirected to"
        },
        "vidm_enable": {
          "type": "boolean",
          "description": "vIDM enable flag",
          "title": "vIDM enable flag"
        }
      },
      "required": [
        "node_host_name",
        "host_name",
        "client_id",
        "thumbprint"
      ],
      "type": "object",
      "description": "Node AAA provider vIDM properties",
      "title": "Node AAA provider vIDM properties"
    }
  },
  "parameters": {},
  "responses": {
    "NotExtended": {
      "description": "Not Extended",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "RequestTimeout": {
      "description": "Request Timeout",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "RequestEntityTooLarge": {
      "description": "Request Entity Too Large",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "EnhanceYourCalm": {
      "description": "Enhance Your Calm",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "NetworkAuthenticationRequired": {
      "description": "Network Authentication Required",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "Conflict": {
      "description": "Conflict",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "ExpectationFailed": {
      "description": "Expectation Failed",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "PaymentRequired": {
      "description": "Payment Required",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "PreconditionRequired": {
      "description": "Precondition Required",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "BandwidthLimitExceeded": {
      "description": "Bandwidth Limit Exceeded",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "ReservedforWebDAV": {
      "description": "Reserved for WebDAV",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "RequestedRangeNotSatisfiable": {
      "description": "Requested Range Not Satisfiable",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "InsufficientStorage": {
      "description": "Insufficient Storage",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "NotFound": {
      "description": "Not Found",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "InternalServerError": {
      "description": "Internal Server Error",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "ClientClosedRequest": {
      "description": "Client Closed Request",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "UpgradeRequired": {
      "description": "Upgrade Required",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "MethodNotAllowed": {
      "description": "Method Not Allowed",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "LengthRequired": {
      "description": "Length Required",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "UnavailableForLegalReasons": {
      "description": "Unavailable For Legal Reasons",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "Iamateapot": {
      "description": "I am a teapot",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "FailedDependency": {
      "description": "Failed Dependency",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "GatewayTimeout": {
      "description": "Gateway Timeout",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "NoResponse": {
      "description": "No Response",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "ServiceUnavailable": {
      "description": "Service Unavailable",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "UnsupportedMediaType": {
      "description": "Unsupported Media Type",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "Locked": {
      "description": "Locked",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "BadGateway": {
      "description": "Bad Gateway",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "BadRequest": {
      "description": "Bad Request",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "NotAcceptable": {
      "description": "Not Acceptable",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "HTTPVersionNotSupported": {
      "description": "HTTP Version Not Supported",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "UnprocessableEntity": {
      "description": "Unprocessable Entity",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "RetryWith": {
      "description": "Retry With",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "NotImplemented": {
      "description": "Not Implemented",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "Request-URITooLong": {
      "description": "Request-URI Too Long",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "Unauthorized": {
      "description": "Unauthorized",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "PreconditionFailed": {
      "description": "Precondition Failed",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "LoopDetected": {
      "description": "Loop Detected",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "Gone": {
      "description": "Gone",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "Forbidden": {
      "description": "Forbidden",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "TooManyRequests": {
      "description": "Too Many Requests",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "BlockedbyWindowsParentalControls": {
      "description": "Blocked by Windows Parental Controls",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "ProxyAuthenticationRequired": {
      "description": "Proxy Authentication Required",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "VariantAlsoNegotiates": {
      "description": "Variant Also Negotiates",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    },
    "RequestHeaderFieldsTooLarge": {
      "description": "Request Header Fields Too Large",
      "schema": {
        "$ref": "#/definitions/ApiError"
      }
    }
  }
}
